// Copyright (c) 2005-2017 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
// LCOV_EXCL_START
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "NeuroML_v2.2.hxx"

namespace neuroml2
{
  // NmlId
  // 


  // Nml2Quantity
  // 


  // Nml2Quantity_none
  // 


  // Nml2Quantity_voltage
  // 


  // Nml2Quantity_length
  // 


  // Nml2Quantity_resistance
  // 


  // Nml2Quantity_resistivity
  // 


  // Nml2Quantity_conductance
  // 


  // Nml2Quantity_conductanceDensity
  // 


  // Nml2Quantity_permeability
  // 


  // Nml2Quantity_time
  // 


  // Nml2Quantity_pertime
  // 


  // Nml2Quantity_capacitance
  // 


  // Nml2Quantity_specificCapacitance
  // 


  // Nml2Quantity_concentration
  // 


  // Nml2Quantity_current
  // 


  // Nml2Quantity_currentDensity
  // 


  // Nml2Quantity_temperature
  // 


  // Nml2Quantity_rhoFactor
  // 


  // Nml2Quantity_conductancePerVoltage
  // 


  // MetaId
  // 


  // NeuroLexId
  // 


  // NonNegativeInteger
  // 


  // PositiveInteger
  // 


  // DoubleGreaterThanZero
  // 


  // ZeroOrOne
  // 

  ZeroOrOne::
  ZeroOrOne (::xml_schema::double_ v): ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (v)
  {
  }

  ZeroOrOne::
  ZeroOrOne (const ZeroOrOne& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (v, f, c)
  {
  }


  // Notes
  // 


  // Property
  // 

  const Property::tag_type& Property::
  tag () const
  {
    return this->tag_.get ();
  }

  Property::tag_type& Property::
  tag ()
  {
    return this->tag_.get ();
  }

  void Property::
  tag (const tag_type& x)
  {
    this->tag_.set (x);
  }

  void Property::
  tag (::std::unique_ptr< tag_type > x)
  {
    this->tag_.set (std::move (x));
  }

  const Property::value_type& Property::
  value () const
  {
    return this->value_.get ();
  }

  Property::value_type& Property::
  value ()
  {
    return this->value_.get ();
  }

  void Property::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Property::
  value (::std::unique_ptr< value_type > x)
  {
    this->value_.set (std::move (x));
  }


  // Annotation
  // 


  // ComponentType
  // 

  const ComponentType::Property_sequence& ComponentType::
  Property () const
  {
    return this->Property_;
  }

  ComponentType::Property_sequence& ComponentType::
  Property ()
  {
    return this->Property_;
  }

  void ComponentType::
  Property (const Property_sequence& s)
  {
    this->Property_ = s;
  }

  const ComponentType::Parameter_sequence& ComponentType::
  Parameter () const
  {
    return this->Parameter_;
  }

  ComponentType::Parameter_sequence& ComponentType::
  Parameter ()
  {
    return this->Parameter_;
  }

  void ComponentType::
  Parameter (const Parameter_sequence& s)
  {
    this->Parameter_ = s;
  }

  const ComponentType::Constant_sequence& ComponentType::
  Constant () const
  {
    return this->Constant_;
  }

  ComponentType::Constant_sequence& ComponentType::
  Constant ()
  {
    return this->Constant_;
  }

  void ComponentType::
  Constant (const Constant_sequence& s)
  {
    this->Constant_ = s;
  }

  const ComponentType::Exposure_sequence& ComponentType::
  Exposure () const
  {
    return this->Exposure_;
  }

  ComponentType::Exposure_sequence& ComponentType::
  Exposure ()
  {
    return this->Exposure_;
  }

  void ComponentType::
  Exposure (const Exposure_sequence& s)
  {
    this->Exposure_ = s;
  }

  const ComponentType::Requirement_sequence& ComponentType::
  Requirement () const
  {
    return this->Requirement_;
  }

  ComponentType::Requirement_sequence& ComponentType::
  Requirement ()
  {
    return this->Requirement_;
  }

  void ComponentType::
  Requirement (const Requirement_sequence& s)
  {
    this->Requirement_ = s;
  }

  const ComponentType::InstanceRequirement_sequence& ComponentType::
  InstanceRequirement () const
  {
    return this->InstanceRequirement_;
  }

  ComponentType::InstanceRequirement_sequence& ComponentType::
  InstanceRequirement ()
  {
    return this->InstanceRequirement_;
  }

  void ComponentType::
  InstanceRequirement (const InstanceRequirement_sequence& s)
  {
    this->InstanceRequirement_ = s;
  }

  const ComponentType::Dynamics_sequence& ComponentType::
  Dynamics () const
  {
    return this->Dynamics_;
  }

  ComponentType::Dynamics_sequence& ComponentType::
  Dynamics ()
  {
    return this->Dynamics_;
  }

  void ComponentType::
  Dynamics (const Dynamics_sequence& s)
  {
    this->Dynamics_ = s;
  }

  const ComponentType::name_type& ComponentType::
  name () const
  {
    return this->name_.get ();
  }

  ComponentType::name_type& ComponentType::
  name ()
  {
    return this->name_.get ();
  }

  void ComponentType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void ComponentType::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const ComponentType::extends_optional& ComponentType::
  extends () const
  {
    return this->extends_;
  }

  ComponentType::extends_optional& ComponentType::
  extends ()
  {
    return this->extends_;
  }

  void ComponentType::
  extends (const extends_type& x)
  {
    this->extends_.set (x);
  }

  void ComponentType::
  extends (const extends_optional& x)
  {
    this->extends_ = x;
  }

  void ComponentType::
  extends (::std::unique_ptr< extends_type > x)
  {
    this->extends_.set (std::move (x));
  }

  const ComponentType::description_optional& ComponentType::
  description () const
  {
    return this->description_;
  }

  ComponentType::description_optional& ComponentType::
  description ()
  {
    return this->description_;
  }

  void ComponentType::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void ComponentType::
  description (const description_optional& x)
  {
    this->description_ = x;
  }

  void ComponentType::
  description (::std::unique_ptr< description_type > x)
  {
    this->description_.set (std::move (x));
  }


  // Constant
  // 

  const Constant::name_type& Constant::
  name () const
  {
    return this->name_.get ();
  }

  Constant::name_type& Constant::
  name ()
  {
    return this->name_.get ();
  }

  void Constant::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void Constant::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const Constant::dimension_type& Constant::
  dimension () const
  {
    return this->dimension_.get ();
  }

  Constant::dimension_type& Constant::
  dimension ()
  {
    return this->dimension_.get ();
  }

  void Constant::
  dimension (const dimension_type& x)
  {
    this->dimension_.set (x);
  }

  void Constant::
  dimension (::std::unique_ptr< dimension_type > x)
  {
    this->dimension_.set (std::move (x));
  }

  const Constant::value_type& Constant::
  value () const
  {
    return this->value_.get ();
  }

  Constant::value_type& Constant::
  value ()
  {
    return this->value_.get ();
  }

  void Constant::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Constant::
  value (::std::unique_ptr< value_type > x)
  {
    this->value_.set (std::move (x));
  }

  const Constant::description_optional& Constant::
  description () const
  {
    return this->description_;
  }

  Constant::description_optional& Constant::
  description ()
  {
    return this->description_;
  }

  void Constant::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void Constant::
  description (const description_optional& x)
  {
    this->description_ = x;
  }

  void Constant::
  description (::std::unique_ptr< description_type > x)
  {
    this->description_.set (std::move (x));
  }


  // Exposure
  // 

  const Exposure::name_type& Exposure::
  name () const
  {
    return this->name_.get ();
  }

  Exposure::name_type& Exposure::
  name ()
  {
    return this->name_.get ();
  }

  void Exposure::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void Exposure::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const Exposure::dimension_type& Exposure::
  dimension () const
  {
    return this->dimension_.get ();
  }

  Exposure::dimension_type& Exposure::
  dimension ()
  {
    return this->dimension_.get ();
  }

  void Exposure::
  dimension (const dimension_type& x)
  {
    this->dimension_.set (x);
  }

  void Exposure::
  dimension (::std::unique_ptr< dimension_type > x)
  {
    this->dimension_.set (std::move (x));
  }

  const Exposure::description_optional& Exposure::
  description () const
  {
    return this->description_;
  }

  Exposure::description_optional& Exposure::
  description ()
  {
    return this->description_;
  }

  void Exposure::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void Exposure::
  description (const description_optional& x)
  {
    this->description_ = x;
  }

  void Exposure::
  description (::std::unique_ptr< description_type > x)
  {
    this->description_.set (std::move (x));
  }


  // NamedDimensionalType
  // 

  const NamedDimensionalType::name_type& NamedDimensionalType::
  name () const
  {
    return this->name_.get ();
  }

  NamedDimensionalType::name_type& NamedDimensionalType::
  name ()
  {
    return this->name_.get ();
  }

  void NamedDimensionalType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void NamedDimensionalType::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const NamedDimensionalType::dimension_type& NamedDimensionalType::
  dimension () const
  {
    return this->dimension_.get ();
  }

  NamedDimensionalType::dimension_type& NamedDimensionalType::
  dimension ()
  {
    return this->dimension_.get ();
  }

  void NamedDimensionalType::
  dimension (const dimension_type& x)
  {
    this->dimension_.set (x);
  }

  void NamedDimensionalType::
  dimension (::std::unique_ptr< dimension_type > x)
  {
    this->dimension_.set (std::move (x));
  }

  const NamedDimensionalType::description_optional& NamedDimensionalType::
  description () const
  {
    return this->description_;
  }

  NamedDimensionalType::description_optional& NamedDimensionalType::
  description ()
  {
    return this->description_;
  }

  void NamedDimensionalType::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void NamedDimensionalType::
  description (const description_optional& x)
  {
    this->description_ = x;
  }

  void NamedDimensionalType::
  description (::std::unique_ptr< description_type > x)
  {
    this->description_.set (std::move (x));
  }


  // NamedDimensionalVariable
  // 

  const NamedDimensionalVariable::name_type& NamedDimensionalVariable::
  name () const
  {
    return this->name_.get ();
  }

  NamedDimensionalVariable::name_type& NamedDimensionalVariable::
  name ()
  {
    return this->name_.get ();
  }

  void NamedDimensionalVariable::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void NamedDimensionalVariable::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const NamedDimensionalVariable::dimension_type& NamedDimensionalVariable::
  dimension () const
  {
    return this->dimension_.get ();
  }

  NamedDimensionalVariable::dimension_type& NamedDimensionalVariable::
  dimension ()
  {
    return this->dimension_.get ();
  }

  void NamedDimensionalVariable::
  dimension (const dimension_type& x)
  {
    this->dimension_.set (x);
  }

  void NamedDimensionalVariable::
  dimension (::std::unique_ptr< dimension_type > x)
  {
    this->dimension_.set (std::move (x));
  }

  const NamedDimensionalVariable::description_optional& NamedDimensionalVariable::
  description () const
  {
    return this->description_;
  }

  NamedDimensionalVariable::description_optional& NamedDimensionalVariable::
  description ()
  {
    return this->description_;
  }

  void NamedDimensionalVariable::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void NamedDimensionalVariable::
  description (const description_optional& x)
  {
    this->description_ = x;
  }

  void NamedDimensionalVariable::
  description (::std::unique_ptr< description_type > x)
  {
    this->description_.set (std::move (x));
  }

  const NamedDimensionalVariable::exposure_optional& NamedDimensionalVariable::
  exposure () const
  {
    return this->exposure_;
  }

  NamedDimensionalVariable::exposure_optional& NamedDimensionalVariable::
  exposure ()
  {
    return this->exposure_;
  }

  void NamedDimensionalVariable::
  exposure (const exposure_type& x)
  {
    this->exposure_.set (x);
  }

  void NamedDimensionalVariable::
  exposure (const exposure_optional& x)
  {
    this->exposure_ = x;
  }

  void NamedDimensionalVariable::
  exposure (::std::unique_ptr< exposure_type > x)
  {
    this->exposure_.set (std::move (x));
  }


  // Parameter
  // 


  // LEMS_Property
  // 

  const LEMS_Property::defaultValue_optional& LEMS_Property::
  defaultValue () const
  {
    return this->defaultValue_;
  }

  LEMS_Property::defaultValue_optional& LEMS_Property::
  defaultValue ()
  {
    return this->defaultValue_;
  }

  void LEMS_Property::
  defaultValue (const defaultValue_type& x)
  {
    this->defaultValue_.set (x);
  }

  void LEMS_Property::
  defaultValue (const defaultValue_optional& x)
  {
    this->defaultValue_ = x;
  }


  // Requirement
  // 


  // InstanceRequirement
  // 

  const InstanceRequirement::name_type& InstanceRequirement::
  name () const
  {
    return this->name_.get ();
  }

  InstanceRequirement::name_type& InstanceRequirement::
  name ()
  {
    return this->name_.get ();
  }

  void InstanceRequirement::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void InstanceRequirement::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const InstanceRequirement::type_type& InstanceRequirement::
  type () const
  {
    return this->type_.get ();
  }

  InstanceRequirement::type_type& InstanceRequirement::
  type ()
  {
    return this->type_.get ();
  }

  void InstanceRequirement::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void InstanceRequirement::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }


  // Dynamics
  // 

  const Dynamics::StateVariable_sequence& Dynamics::
  StateVariable () const
  {
    return this->StateVariable_;
  }

  Dynamics::StateVariable_sequence& Dynamics::
  StateVariable ()
  {
    return this->StateVariable_;
  }

  void Dynamics::
  StateVariable (const StateVariable_sequence& s)
  {
    this->StateVariable_ = s;
  }

  const Dynamics::DerivedVariable_sequence& Dynamics::
  DerivedVariable () const
  {
    return this->DerivedVariable_;
  }

  Dynamics::DerivedVariable_sequence& Dynamics::
  DerivedVariable ()
  {
    return this->DerivedVariable_;
  }

  void Dynamics::
  DerivedVariable (const DerivedVariable_sequence& s)
  {
    this->DerivedVariable_ = s;
  }

  const Dynamics::ConditionalDerivedVariable_sequence& Dynamics::
  ConditionalDerivedVariable () const
  {
    return this->ConditionalDerivedVariable_;
  }

  Dynamics::ConditionalDerivedVariable_sequence& Dynamics::
  ConditionalDerivedVariable ()
  {
    return this->ConditionalDerivedVariable_;
  }

  void Dynamics::
  ConditionalDerivedVariable (const ConditionalDerivedVariable_sequence& s)
  {
    this->ConditionalDerivedVariable_ = s;
  }

  const Dynamics::TimeDerivative_sequence& Dynamics::
  TimeDerivative () const
  {
    return this->TimeDerivative_;
  }

  Dynamics::TimeDerivative_sequence& Dynamics::
  TimeDerivative ()
  {
    return this->TimeDerivative_;
  }

  void Dynamics::
  TimeDerivative (const TimeDerivative_sequence& s)
  {
    this->TimeDerivative_ = s;
  }


  // DerivedVariable
  // 

  const DerivedVariable::value_optional& DerivedVariable::
  value () const
  {
    return this->value_;
  }

  DerivedVariable::value_optional& DerivedVariable::
  value ()
  {
    return this->value_;
  }

  void DerivedVariable::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void DerivedVariable::
  value (const value_optional& x)
  {
    this->value_ = x;
  }

  void DerivedVariable::
  value (::std::unique_ptr< value_type > x)
  {
    this->value_.set (std::move (x));
  }

  const DerivedVariable::select_optional& DerivedVariable::
  select () const
  {
    return this->select_;
  }

  DerivedVariable::select_optional& DerivedVariable::
  select ()
  {
    return this->select_;
  }

  void DerivedVariable::
  select (const select_type& x)
  {
    this->select_.set (x);
  }

  void DerivedVariable::
  select (const select_optional& x)
  {
    this->select_ = x;
  }

  void DerivedVariable::
  select (::std::unique_ptr< select_type > x)
  {
    this->select_.set (std::move (x));
  }


  // StateVariable
  // 


  // ConditionalDerivedVariable
  // 

  const ConditionalDerivedVariable::Case_sequence& ConditionalDerivedVariable::
  Case () const
  {
    return this->Case_;
  }

  ConditionalDerivedVariable::Case_sequence& ConditionalDerivedVariable::
  Case ()
  {
    return this->Case_;
  }

  void ConditionalDerivedVariable::
  Case (const Case_sequence& s)
  {
    this->Case_ = s;
  }


  // Case
  // 

  const Case::condition_optional& Case::
  condition () const
  {
    return this->condition_;
  }

  Case::condition_optional& Case::
  condition ()
  {
    return this->condition_;
  }

  void Case::
  condition (const condition_type& x)
  {
    this->condition_.set (x);
  }

  void Case::
  condition (const condition_optional& x)
  {
    this->condition_ = x;
  }

  void Case::
  condition (::std::unique_ptr< condition_type > x)
  {
    this->condition_.set (std::move (x));
  }

  const Case::value_type& Case::
  value () const
  {
    return this->value_.get ();
  }

  Case::value_type& Case::
  value ()
  {
    return this->value_.get ();
  }

  void Case::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Case::
  value (::std::unique_ptr< value_type > x)
  {
    this->value_.set (std::move (x));
  }


  // TimeDerivative
  // 

  const TimeDerivative::variable_type& TimeDerivative::
  variable () const
  {
    return this->variable_.get ();
  }

  TimeDerivative::variable_type& TimeDerivative::
  variable ()
  {
    return this->variable_.get ();
  }

  void TimeDerivative::
  variable (const variable_type& x)
  {
    this->variable_.set (x);
  }

  void TimeDerivative::
  variable (::std::unique_ptr< variable_type > x)
  {
    this->variable_.set (std::move (x));
  }

  const TimeDerivative::value_type& TimeDerivative::
  value () const
  {
    return this->value_.get ();
  }

  TimeDerivative::value_type& TimeDerivative::
  value ()
  {
    return this->value_.get ();
  }

  void TimeDerivative::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void TimeDerivative::
  value (::std::unique_ptr< value_type > x)
  {
    this->value_.set (std::move (x));
  }


  // ZeroToOne
  // 


  // BaseWithoutId
  // 

  const BaseWithoutId::neuroLexId_optional& BaseWithoutId::
  neuroLexId () const
  {
    return this->neuroLexId_;
  }

  BaseWithoutId::neuroLexId_optional& BaseWithoutId::
  neuroLexId ()
  {
    return this->neuroLexId_;
  }

  void BaseWithoutId::
  neuroLexId (const neuroLexId_type& x)
  {
    this->neuroLexId_.set (x);
  }

  void BaseWithoutId::
  neuroLexId (const neuroLexId_optional& x)
  {
    this->neuroLexId_ = x;
  }

  void BaseWithoutId::
  neuroLexId (::std::unique_ptr< neuroLexId_type > x)
  {
    this->neuroLexId_.set (std::move (x));
  }


  // Base
  // 

  const Base::id_type& Base::
  id () const
  {
    return this->id_.get ();
  }

  Base::id_type& Base::
  id ()
  {
    return this->id_.get ();
  }

  void Base::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void Base::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // Standalone
  // 

  const Standalone::notes_optional& Standalone::
  notes () const
  {
    return this->notes_;
  }

  Standalone::notes_optional& Standalone::
  notes ()
  {
    return this->notes_;
  }

  void Standalone::
  notes (const notes_type& x)
  {
    this->notes_.set (x);
  }

  void Standalone::
  notes (const notes_optional& x)
  {
    this->notes_ = x;
  }

  void Standalone::
  notes (::std::unique_ptr< notes_type > x)
  {
    this->notes_.set (std::move (x));
  }

  const Standalone::property_sequence& Standalone::
  property () const
  {
    return this->property_;
  }

  Standalone::property_sequence& Standalone::
  property ()
  {
    return this->property_;
  }

  void Standalone::
  property (const property_sequence& s)
  {
    this->property_ = s;
  }

  const Standalone::annotation_optional& Standalone::
  annotation () const
  {
    return this->annotation_;
  }

  Standalone::annotation_optional& Standalone::
  annotation ()
  {
    return this->annotation_;
  }

  void Standalone::
  annotation (const annotation_type& x)
  {
    this->annotation_.set (x);
  }

  void Standalone::
  annotation (const annotation_optional& x)
  {
    this->annotation_ = x;
  }

  void Standalone::
  annotation (::std::unique_ptr< annotation_type > x)
  {
    this->annotation_.set (std::move (x));
  }

  const Standalone::metaid_optional& Standalone::
  metaid () const
  {
    return this->metaid_;
  }

  Standalone::metaid_optional& Standalone::
  metaid ()
  {
    return this->metaid_;
  }

  void Standalone::
  metaid (const metaid_type& x)
  {
    this->metaid_.set (x);
  }

  void Standalone::
  metaid (const metaid_optional& x)
  {
    this->metaid_ = x;
  }

  void Standalone::
  metaid (::std::unique_ptr< metaid_type > x)
  {
    this->metaid_.set (std::move (x));
  }


  // NeuroMLDocument_base
  // 

  const NeuroMLDocument_base::include_sequence& NeuroMLDocument_base::
  include () const
  {
    return this->include_;
  }

  NeuroMLDocument_base::include_sequence& NeuroMLDocument_base::
  include ()
  {
    return this->include_;
  }

  void NeuroMLDocument_base::
  include (const include_sequence& s)
  {
    this->include_ = s;
  }

  const NeuroMLDocument_base::extracellularProperties_sequence& NeuroMLDocument_base::
  extracellularProperties () const
  {
    return this->extracellularProperties_;
  }

  NeuroMLDocument_base::extracellularProperties_sequence& NeuroMLDocument_base::
  extracellularProperties ()
  {
    return this->extracellularProperties_;
  }

  void NeuroMLDocument_base::
  extracellularProperties (const extracellularProperties_sequence& s)
  {
    this->extracellularProperties_ = s;
  }

  const NeuroMLDocument_base::intracellularProperties_sequence& NeuroMLDocument_base::
  intracellularProperties () const
  {
    return this->intracellularProperties_;
  }

  NeuroMLDocument_base::intracellularProperties_sequence& NeuroMLDocument_base::
  intracellularProperties ()
  {
    return this->intracellularProperties_;
  }

  void NeuroMLDocument_base::
  intracellularProperties (const intracellularProperties_sequence& s)
  {
    this->intracellularProperties_ = s;
  }

  const NeuroMLDocument_base::morphology_sequence& NeuroMLDocument_base::
  morphology () const
  {
    return this->morphology_;
  }

  NeuroMLDocument_base::morphology_sequence& NeuroMLDocument_base::
  morphology ()
  {
    return this->morphology_;
  }

  void NeuroMLDocument_base::
  morphology (const morphology_sequence& s)
  {
    this->morphology_ = s;
  }

  const NeuroMLDocument_base::ionChannel_sequence& NeuroMLDocument_base::
  ionChannel () const
  {
    return this->ionChannel_;
  }

  NeuroMLDocument_base::ionChannel_sequence& NeuroMLDocument_base::
  ionChannel ()
  {
    return this->ionChannel_;
  }

  void NeuroMLDocument_base::
  ionChannel (const ionChannel_sequence& s)
  {
    this->ionChannel_ = s;
  }

  const NeuroMLDocument_base::ionChannelHH_sequence& NeuroMLDocument_base::
  ionChannelHH () const
  {
    return this->ionChannelHH_;
  }

  NeuroMLDocument_base::ionChannelHH_sequence& NeuroMLDocument_base::
  ionChannelHH ()
  {
    return this->ionChannelHH_;
  }

  void NeuroMLDocument_base::
  ionChannelHH (const ionChannelHH_sequence& s)
  {
    this->ionChannelHH_ = s;
  }

  const NeuroMLDocument_base::ionChannelVShift_sequence& NeuroMLDocument_base::
  ionChannelVShift () const
  {
    return this->ionChannelVShift_;
  }

  NeuroMLDocument_base::ionChannelVShift_sequence& NeuroMLDocument_base::
  ionChannelVShift ()
  {
    return this->ionChannelVShift_;
  }

  void NeuroMLDocument_base::
  ionChannelVShift (const ionChannelVShift_sequence& s)
  {
    this->ionChannelVShift_ = s;
  }

  const NeuroMLDocument_base::ionChannelKS_sequence& NeuroMLDocument_base::
  ionChannelKS () const
  {
    return this->ionChannelKS_;
  }

  NeuroMLDocument_base::ionChannelKS_sequence& NeuroMLDocument_base::
  ionChannelKS ()
  {
    return this->ionChannelKS_;
  }

  void NeuroMLDocument_base::
  ionChannelKS (const ionChannelKS_sequence& s)
  {
    this->ionChannelKS_ = s;
  }

  const NeuroMLDocument_base::decayingPoolConcentrationModel_sequence& NeuroMLDocument_base::
  decayingPoolConcentrationModel () const
  {
    return this->decayingPoolConcentrationModel_;
  }

  NeuroMLDocument_base::decayingPoolConcentrationModel_sequence& NeuroMLDocument_base::
  decayingPoolConcentrationModel ()
  {
    return this->decayingPoolConcentrationModel_;
  }

  void NeuroMLDocument_base::
  decayingPoolConcentrationModel (const decayingPoolConcentrationModel_sequence& s)
  {
    this->decayingPoolConcentrationModel_ = s;
  }

  const NeuroMLDocument_base::fixedFactorConcentrationModel_sequence& NeuroMLDocument_base::
  fixedFactorConcentrationModel () const
  {
    return this->fixedFactorConcentrationModel_;
  }

  NeuroMLDocument_base::fixedFactorConcentrationModel_sequence& NeuroMLDocument_base::
  fixedFactorConcentrationModel ()
  {
    return this->fixedFactorConcentrationModel_;
  }

  void NeuroMLDocument_base::
  fixedFactorConcentrationModel (const fixedFactorConcentrationModel_sequence& s)
  {
    this->fixedFactorConcentrationModel_ = s;
  }

  const NeuroMLDocument_base::alphaCurrentSynapse_sequence& NeuroMLDocument_base::
  alphaCurrentSynapse () const
  {
    return this->alphaCurrentSynapse_;
  }

  NeuroMLDocument_base::alphaCurrentSynapse_sequence& NeuroMLDocument_base::
  alphaCurrentSynapse ()
  {
    return this->alphaCurrentSynapse_;
  }

  void NeuroMLDocument_base::
  alphaCurrentSynapse (const alphaCurrentSynapse_sequence& s)
  {
    this->alphaCurrentSynapse_ = s;
  }

  const NeuroMLDocument_base::alphaSynapse_sequence& NeuroMLDocument_base::
  alphaSynapse () const
  {
    return this->alphaSynapse_;
  }

  NeuroMLDocument_base::alphaSynapse_sequence& NeuroMLDocument_base::
  alphaSynapse ()
  {
    return this->alphaSynapse_;
  }

  void NeuroMLDocument_base::
  alphaSynapse (const alphaSynapse_sequence& s)
  {
    this->alphaSynapse_ = s;
  }

  const NeuroMLDocument_base::expOneSynapse_sequence& NeuroMLDocument_base::
  expOneSynapse () const
  {
    return this->expOneSynapse_;
  }

  NeuroMLDocument_base::expOneSynapse_sequence& NeuroMLDocument_base::
  expOneSynapse ()
  {
    return this->expOneSynapse_;
  }

  void NeuroMLDocument_base::
  expOneSynapse (const expOneSynapse_sequence& s)
  {
    this->expOneSynapse_ = s;
  }

  const NeuroMLDocument_base::expTwoSynapse_sequence& NeuroMLDocument_base::
  expTwoSynapse () const
  {
    return this->expTwoSynapse_;
  }

  NeuroMLDocument_base::expTwoSynapse_sequence& NeuroMLDocument_base::
  expTwoSynapse ()
  {
    return this->expTwoSynapse_;
  }

  void NeuroMLDocument_base::
  expTwoSynapse (const expTwoSynapse_sequence& s)
  {
    this->expTwoSynapse_ = s;
  }

  const NeuroMLDocument_base::expThreeSynapse_sequence& NeuroMLDocument_base::
  expThreeSynapse () const
  {
    return this->expThreeSynapse_;
  }

  NeuroMLDocument_base::expThreeSynapse_sequence& NeuroMLDocument_base::
  expThreeSynapse ()
  {
    return this->expThreeSynapse_;
  }

  void NeuroMLDocument_base::
  expThreeSynapse (const expThreeSynapse_sequence& s)
  {
    this->expThreeSynapse_ = s;
  }

  const NeuroMLDocument_base::blockingPlasticSynapse_sequence& NeuroMLDocument_base::
  blockingPlasticSynapse () const
  {
    return this->blockingPlasticSynapse_;
  }

  NeuroMLDocument_base::blockingPlasticSynapse_sequence& NeuroMLDocument_base::
  blockingPlasticSynapse ()
  {
    return this->blockingPlasticSynapse_;
  }

  void NeuroMLDocument_base::
  blockingPlasticSynapse (const blockingPlasticSynapse_sequence& s)
  {
    this->blockingPlasticSynapse_ = s;
  }

  const NeuroMLDocument_base::doubleSynapse_sequence& NeuroMLDocument_base::
  doubleSynapse () const
  {
    return this->doubleSynapse_;
  }

  NeuroMLDocument_base::doubleSynapse_sequence& NeuroMLDocument_base::
  doubleSynapse ()
  {
    return this->doubleSynapse_;
  }

  void NeuroMLDocument_base::
  doubleSynapse (const doubleSynapse_sequence& s)
  {
    this->doubleSynapse_ = s;
  }

  const NeuroMLDocument_base::gapJunction_sequence& NeuroMLDocument_base::
  gapJunction () const
  {
    return this->gapJunction_;
  }

  NeuroMLDocument_base::gapJunction_sequence& NeuroMLDocument_base::
  gapJunction ()
  {
    return this->gapJunction_;
  }

  void NeuroMLDocument_base::
  gapJunction (const gapJunction_sequence& s)
  {
    this->gapJunction_ = s;
  }

  const NeuroMLDocument_base::silentSynapse_sequence& NeuroMLDocument_base::
  silentSynapse () const
  {
    return this->silentSynapse_;
  }

  NeuroMLDocument_base::silentSynapse_sequence& NeuroMLDocument_base::
  silentSynapse ()
  {
    return this->silentSynapse_;
  }

  void NeuroMLDocument_base::
  silentSynapse (const silentSynapse_sequence& s)
  {
    this->silentSynapse_ = s;
  }

  const NeuroMLDocument_base::linearGradedSynapse_sequence& NeuroMLDocument_base::
  linearGradedSynapse () const
  {
    return this->linearGradedSynapse_;
  }

  NeuroMLDocument_base::linearGradedSynapse_sequence& NeuroMLDocument_base::
  linearGradedSynapse ()
  {
    return this->linearGradedSynapse_;
  }

  void NeuroMLDocument_base::
  linearGradedSynapse (const linearGradedSynapse_sequence& s)
  {
    this->linearGradedSynapse_ = s;
  }

  const NeuroMLDocument_base::gradedSynapse_sequence& NeuroMLDocument_base::
  gradedSynapse () const
  {
    return this->gradedSynapse_;
  }

  NeuroMLDocument_base::gradedSynapse_sequence& NeuroMLDocument_base::
  gradedSynapse ()
  {
    return this->gradedSynapse_;
  }

  void NeuroMLDocument_base::
  gradedSynapse (const gradedSynapse_sequence& s)
  {
    this->gradedSynapse_ = s;
  }

  const NeuroMLDocument_base::biophysicalProperties_sequence& NeuroMLDocument_base::
  biophysicalProperties () const
  {
    return this->biophysicalProperties_;
  }

  NeuroMLDocument_base::biophysicalProperties_sequence& NeuroMLDocument_base::
  biophysicalProperties ()
  {
    return this->biophysicalProperties_;
  }

  void NeuroMLDocument_base::
  biophysicalProperties (const biophysicalProperties_sequence& s)
  {
    this->biophysicalProperties_ = s;
  }

  const NeuroMLDocument_base::cell_sequence& NeuroMLDocument_base::
  cell () const
  {
    return this->cell_;
  }

  NeuroMLDocument_base::cell_sequence& NeuroMLDocument_base::
  cell ()
  {
    return this->cell_;
  }

  void NeuroMLDocument_base::
  cell (const cell_sequence& s)
  {
    this->cell_ = s;
  }

  const NeuroMLDocument_base::cell2CaPools_sequence& NeuroMLDocument_base::
  cell2CaPools () const
  {
    return this->cell2CaPools_;
  }

  NeuroMLDocument_base::cell2CaPools_sequence& NeuroMLDocument_base::
  cell2CaPools ()
  {
    return this->cell2CaPools_;
  }

  void NeuroMLDocument_base::
  cell2CaPools (const cell2CaPools_sequence& s)
  {
    this->cell2CaPools_ = s;
  }

  const NeuroMLDocument_base::baseCell_sequence& NeuroMLDocument_base::
  baseCell () const
  {
    return this->baseCell_;
  }

  NeuroMLDocument_base::baseCell_sequence& NeuroMLDocument_base::
  baseCell ()
  {
    return this->baseCell_;
  }

  void NeuroMLDocument_base::
  baseCell (const baseCell_sequence& s)
  {
    this->baseCell_ = s;
  }

  const NeuroMLDocument_base::iafTauCell_sequence& NeuroMLDocument_base::
  iafTauCell () const
  {
    return this->iafTauCell_;
  }

  NeuroMLDocument_base::iafTauCell_sequence& NeuroMLDocument_base::
  iafTauCell ()
  {
    return this->iafTauCell_;
  }

  void NeuroMLDocument_base::
  iafTauCell (const iafTauCell_sequence& s)
  {
    this->iafTauCell_ = s;
  }

  const NeuroMLDocument_base::iafTauRefCell_sequence& NeuroMLDocument_base::
  iafTauRefCell () const
  {
    return this->iafTauRefCell_;
  }

  NeuroMLDocument_base::iafTauRefCell_sequence& NeuroMLDocument_base::
  iafTauRefCell ()
  {
    return this->iafTauRefCell_;
  }

  void NeuroMLDocument_base::
  iafTauRefCell (const iafTauRefCell_sequence& s)
  {
    this->iafTauRefCell_ = s;
  }

  const NeuroMLDocument_base::iafCell_sequence& NeuroMLDocument_base::
  iafCell () const
  {
    return this->iafCell_;
  }

  NeuroMLDocument_base::iafCell_sequence& NeuroMLDocument_base::
  iafCell ()
  {
    return this->iafCell_;
  }

  void NeuroMLDocument_base::
  iafCell (const iafCell_sequence& s)
  {
    this->iafCell_ = s;
  }

  const NeuroMLDocument_base::iafRefCell_sequence& NeuroMLDocument_base::
  iafRefCell () const
  {
    return this->iafRefCell_;
  }

  NeuroMLDocument_base::iafRefCell_sequence& NeuroMLDocument_base::
  iafRefCell ()
  {
    return this->iafRefCell_;
  }

  void NeuroMLDocument_base::
  iafRefCell (const iafRefCell_sequence& s)
  {
    this->iafRefCell_ = s;
  }

  const NeuroMLDocument_base::izhikevichCell_sequence& NeuroMLDocument_base::
  izhikevichCell () const
  {
    return this->izhikevichCell_;
  }

  NeuroMLDocument_base::izhikevichCell_sequence& NeuroMLDocument_base::
  izhikevichCell ()
  {
    return this->izhikevichCell_;
  }

  void NeuroMLDocument_base::
  izhikevichCell (const izhikevichCell_sequence& s)
  {
    this->izhikevichCell_ = s;
  }

  const NeuroMLDocument_base::izhikevich2007Cell_sequence& NeuroMLDocument_base::
  izhikevich2007Cell () const
  {
    return this->izhikevich2007Cell_;
  }

  NeuroMLDocument_base::izhikevich2007Cell_sequence& NeuroMLDocument_base::
  izhikevich2007Cell ()
  {
    return this->izhikevich2007Cell_;
  }

  void NeuroMLDocument_base::
  izhikevich2007Cell (const izhikevich2007Cell_sequence& s)
  {
    this->izhikevich2007Cell_ = s;
  }

  const NeuroMLDocument_base::adExIaFCell_sequence& NeuroMLDocument_base::
  adExIaFCell () const
  {
    return this->adExIaFCell_;
  }

  NeuroMLDocument_base::adExIaFCell_sequence& NeuroMLDocument_base::
  adExIaFCell ()
  {
    return this->adExIaFCell_;
  }

  void NeuroMLDocument_base::
  adExIaFCell (const adExIaFCell_sequence& s)
  {
    this->adExIaFCell_ = s;
  }

  const NeuroMLDocument_base::fitzHughNagumoCell_sequence& NeuroMLDocument_base::
  fitzHughNagumoCell () const
  {
    return this->fitzHughNagumoCell_;
  }

  NeuroMLDocument_base::fitzHughNagumoCell_sequence& NeuroMLDocument_base::
  fitzHughNagumoCell ()
  {
    return this->fitzHughNagumoCell_;
  }

  void NeuroMLDocument_base::
  fitzHughNagumoCell (const fitzHughNagumoCell_sequence& s)
  {
    this->fitzHughNagumoCell_ = s;
  }

  const NeuroMLDocument_base::fitzHughNagumo1969Cell_sequence& NeuroMLDocument_base::
  fitzHughNagumo1969Cell () const
  {
    return this->fitzHughNagumo1969Cell_;
  }

  NeuroMLDocument_base::fitzHughNagumo1969Cell_sequence& NeuroMLDocument_base::
  fitzHughNagumo1969Cell ()
  {
    return this->fitzHughNagumo1969Cell_;
  }

  void NeuroMLDocument_base::
  fitzHughNagumo1969Cell (const fitzHughNagumo1969Cell_sequence& s)
  {
    this->fitzHughNagumo1969Cell_ = s;
  }

  const NeuroMLDocument_base::pinskyRinzelCA3Cell_sequence& NeuroMLDocument_base::
  pinskyRinzelCA3Cell () const
  {
    return this->pinskyRinzelCA3Cell_;
  }

  NeuroMLDocument_base::pinskyRinzelCA3Cell_sequence& NeuroMLDocument_base::
  pinskyRinzelCA3Cell ()
  {
    return this->pinskyRinzelCA3Cell_;
  }

  void NeuroMLDocument_base::
  pinskyRinzelCA3Cell (const pinskyRinzelCA3Cell_sequence& s)
  {
    this->pinskyRinzelCA3Cell_ = s;
  }

  const NeuroMLDocument_base::pulseGenerator_sequence& NeuroMLDocument_base::
  pulseGenerator () const
  {
    return this->pulseGenerator_;
  }

  NeuroMLDocument_base::pulseGenerator_sequence& NeuroMLDocument_base::
  pulseGenerator ()
  {
    return this->pulseGenerator_;
  }

  void NeuroMLDocument_base::
  pulseGenerator (const pulseGenerator_sequence& s)
  {
    this->pulseGenerator_ = s;
  }

  const NeuroMLDocument_base::pulseGeneratorDL_sequence& NeuroMLDocument_base::
  pulseGeneratorDL () const
  {
    return this->pulseGeneratorDL_;
  }

  NeuroMLDocument_base::pulseGeneratorDL_sequence& NeuroMLDocument_base::
  pulseGeneratorDL ()
  {
    return this->pulseGeneratorDL_;
  }

  void NeuroMLDocument_base::
  pulseGeneratorDL (const pulseGeneratorDL_sequence& s)
  {
    this->pulseGeneratorDL_ = s;
  }

  const NeuroMLDocument_base::sineGenerator_sequence& NeuroMLDocument_base::
  sineGenerator () const
  {
    return this->sineGenerator_;
  }

  NeuroMLDocument_base::sineGenerator_sequence& NeuroMLDocument_base::
  sineGenerator ()
  {
    return this->sineGenerator_;
  }

  void NeuroMLDocument_base::
  sineGenerator (const sineGenerator_sequence& s)
  {
    this->sineGenerator_ = s;
  }

  const NeuroMLDocument_base::sineGeneratorDL_sequence& NeuroMLDocument_base::
  sineGeneratorDL () const
  {
    return this->sineGeneratorDL_;
  }

  NeuroMLDocument_base::sineGeneratorDL_sequence& NeuroMLDocument_base::
  sineGeneratorDL ()
  {
    return this->sineGeneratorDL_;
  }

  void NeuroMLDocument_base::
  sineGeneratorDL (const sineGeneratorDL_sequence& s)
  {
    this->sineGeneratorDL_ = s;
  }

  const NeuroMLDocument_base::rampGenerator_sequence& NeuroMLDocument_base::
  rampGenerator () const
  {
    return this->rampGenerator_;
  }

  NeuroMLDocument_base::rampGenerator_sequence& NeuroMLDocument_base::
  rampGenerator ()
  {
    return this->rampGenerator_;
  }

  void NeuroMLDocument_base::
  rampGenerator (const rampGenerator_sequence& s)
  {
    this->rampGenerator_ = s;
  }

  const NeuroMLDocument_base::rampGeneratorDL_sequence& NeuroMLDocument_base::
  rampGeneratorDL () const
  {
    return this->rampGeneratorDL_;
  }

  NeuroMLDocument_base::rampGeneratorDL_sequence& NeuroMLDocument_base::
  rampGeneratorDL ()
  {
    return this->rampGeneratorDL_;
  }

  void NeuroMLDocument_base::
  rampGeneratorDL (const rampGeneratorDL_sequence& s)
  {
    this->rampGeneratorDL_ = s;
  }

  const NeuroMLDocument_base::compoundInput_sequence& NeuroMLDocument_base::
  compoundInput () const
  {
    return this->compoundInput_;
  }

  NeuroMLDocument_base::compoundInput_sequence& NeuroMLDocument_base::
  compoundInput ()
  {
    return this->compoundInput_;
  }

  void NeuroMLDocument_base::
  compoundInput (const compoundInput_sequence& s)
  {
    this->compoundInput_ = s;
  }

  const NeuroMLDocument_base::compoundInputDL_sequence& NeuroMLDocument_base::
  compoundInputDL () const
  {
    return this->compoundInputDL_;
  }

  NeuroMLDocument_base::compoundInputDL_sequence& NeuroMLDocument_base::
  compoundInputDL ()
  {
    return this->compoundInputDL_;
  }

  void NeuroMLDocument_base::
  compoundInputDL (const compoundInputDL_sequence& s)
  {
    this->compoundInputDL_ = s;
  }

  const NeuroMLDocument_base::voltageClamp_sequence& NeuroMLDocument_base::
  voltageClamp () const
  {
    return this->voltageClamp_;
  }

  NeuroMLDocument_base::voltageClamp_sequence& NeuroMLDocument_base::
  voltageClamp ()
  {
    return this->voltageClamp_;
  }

  void NeuroMLDocument_base::
  voltageClamp (const voltageClamp_sequence& s)
  {
    this->voltageClamp_ = s;
  }

  const NeuroMLDocument_base::voltageClampTriple_sequence& NeuroMLDocument_base::
  voltageClampTriple () const
  {
    return this->voltageClampTriple_;
  }

  NeuroMLDocument_base::voltageClampTriple_sequence& NeuroMLDocument_base::
  voltageClampTriple ()
  {
    return this->voltageClampTriple_;
  }

  void NeuroMLDocument_base::
  voltageClampTriple (const voltageClampTriple_sequence& s)
  {
    this->voltageClampTriple_ = s;
  }

  const NeuroMLDocument_base::spikeArray_sequence& NeuroMLDocument_base::
  spikeArray () const
  {
    return this->spikeArray_;
  }

  NeuroMLDocument_base::spikeArray_sequence& NeuroMLDocument_base::
  spikeArray ()
  {
    return this->spikeArray_;
  }

  void NeuroMLDocument_base::
  spikeArray (const spikeArray_sequence& s)
  {
    this->spikeArray_ = s;
  }

  const NeuroMLDocument_base::timedSynapticInput_sequence& NeuroMLDocument_base::
  timedSynapticInput () const
  {
    return this->timedSynapticInput_;
  }

  NeuroMLDocument_base::timedSynapticInput_sequence& NeuroMLDocument_base::
  timedSynapticInput ()
  {
    return this->timedSynapticInput_;
  }

  void NeuroMLDocument_base::
  timedSynapticInput (const timedSynapticInput_sequence& s)
  {
    this->timedSynapticInput_ = s;
  }

  const NeuroMLDocument_base::spikeGenerator_sequence& NeuroMLDocument_base::
  spikeGenerator () const
  {
    return this->spikeGenerator_;
  }

  NeuroMLDocument_base::spikeGenerator_sequence& NeuroMLDocument_base::
  spikeGenerator ()
  {
    return this->spikeGenerator_;
  }

  void NeuroMLDocument_base::
  spikeGenerator (const spikeGenerator_sequence& s)
  {
    this->spikeGenerator_ = s;
  }

  const NeuroMLDocument_base::spikeGeneratorRandom_sequence& NeuroMLDocument_base::
  spikeGeneratorRandom () const
  {
    return this->spikeGeneratorRandom_;
  }

  NeuroMLDocument_base::spikeGeneratorRandom_sequence& NeuroMLDocument_base::
  spikeGeneratorRandom ()
  {
    return this->spikeGeneratorRandom_;
  }

  void NeuroMLDocument_base::
  spikeGeneratorRandom (const spikeGeneratorRandom_sequence& s)
  {
    this->spikeGeneratorRandom_ = s;
  }

  const NeuroMLDocument_base::spikeGeneratorPoisson_sequence& NeuroMLDocument_base::
  spikeGeneratorPoisson () const
  {
    return this->spikeGeneratorPoisson_;
  }

  NeuroMLDocument_base::spikeGeneratorPoisson_sequence& NeuroMLDocument_base::
  spikeGeneratorPoisson ()
  {
    return this->spikeGeneratorPoisson_;
  }

  void NeuroMLDocument_base::
  spikeGeneratorPoisson (const spikeGeneratorPoisson_sequence& s)
  {
    this->spikeGeneratorPoisson_ = s;
  }

  const NeuroMLDocument_base::spikeGeneratorRefPoisson_sequence& NeuroMLDocument_base::
  spikeGeneratorRefPoisson () const
  {
    return this->spikeGeneratorRefPoisson_;
  }

  NeuroMLDocument_base::spikeGeneratorRefPoisson_sequence& NeuroMLDocument_base::
  spikeGeneratorRefPoisson ()
  {
    return this->spikeGeneratorRefPoisson_;
  }

  void NeuroMLDocument_base::
  spikeGeneratorRefPoisson (const spikeGeneratorRefPoisson_sequence& s)
  {
    this->spikeGeneratorRefPoisson_ = s;
  }

  const NeuroMLDocument_base::poissonFiringSynapse_sequence& NeuroMLDocument_base::
  poissonFiringSynapse () const
  {
    return this->poissonFiringSynapse_;
  }

  NeuroMLDocument_base::poissonFiringSynapse_sequence& NeuroMLDocument_base::
  poissonFiringSynapse ()
  {
    return this->poissonFiringSynapse_;
  }

  void NeuroMLDocument_base::
  poissonFiringSynapse (const poissonFiringSynapse_sequence& s)
  {
    this->poissonFiringSynapse_ = s;
  }

  const NeuroMLDocument_base::transientPoissonFiringSynapse_sequence& NeuroMLDocument_base::
  transientPoissonFiringSynapse () const
  {
    return this->transientPoissonFiringSynapse_;
  }

  NeuroMLDocument_base::transientPoissonFiringSynapse_sequence& NeuroMLDocument_base::
  transientPoissonFiringSynapse ()
  {
    return this->transientPoissonFiringSynapse_;
  }

  void NeuroMLDocument_base::
  transientPoissonFiringSynapse (const transientPoissonFiringSynapse_sequence& s)
  {
    this->transientPoissonFiringSynapse_ = s;
  }

  const NeuroMLDocument_base::IF_curr_alpha_sequence& NeuroMLDocument_base::
  IF_curr_alpha () const
  {
    return this->IF_curr_alpha_;
  }

  NeuroMLDocument_base::IF_curr_alpha_sequence& NeuroMLDocument_base::
  IF_curr_alpha ()
  {
    return this->IF_curr_alpha_;
  }

  void NeuroMLDocument_base::
  IF_curr_alpha (const IF_curr_alpha_sequence& s)
  {
    this->IF_curr_alpha_ = s;
  }

  const NeuroMLDocument_base::IF_curr_exp_sequence& NeuroMLDocument_base::
  IF_curr_exp () const
  {
    return this->IF_curr_exp_;
  }

  NeuroMLDocument_base::IF_curr_exp_sequence& NeuroMLDocument_base::
  IF_curr_exp ()
  {
    return this->IF_curr_exp_;
  }

  void NeuroMLDocument_base::
  IF_curr_exp (const IF_curr_exp_sequence& s)
  {
    this->IF_curr_exp_ = s;
  }

  const NeuroMLDocument_base::IF_cond_alpha_sequence& NeuroMLDocument_base::
  IF_cond_alpha () const
  {
    return this->IF_cond_alpha_;
  }

  NeuroMLDocument_base::IF_cond_alpha_sequence& NeuroMLDocument_base::
  IF_cond_alpha ()
  {
    return this->IF_cond_alpha_;
  }

  void NeuroMLDocument_base::
  IF_cond_alpha (const IF_cond_alpha_sequence& s)
  {
    this->IF_cond_alpha_ = s;
  }

  const NeuroMLDocument_base::IF_cond_exp_sequence& NeuroMLDocument_base::
  IF_cond_exp () const
  {
    return this->IF_cond_exp_;
  }

  NeuroMLDocument_base::IF_cond_exp_sequence& NeuroMLDocument_base::
  IF_cond_exp ()
  {
    return this->IF_cond_exp_;
  }

  void NeuroMLDocument_base::
  IF_cond_exp (const IF_cond_exp_sequence& s)
  {
    this->IF_cond_exp_ = s;
  }

  const NeuroMLDocument_base::EIF_cond_exp_isfa_ista_sequence& NeuroMLDocument_base::
  EIF_cond_exp_isfa_ista () const
  {
    return this->EIF_cond_exp_isfa_ista_;
  }

  NeuroMLDocument_base::EIF_cond_exp_isfa_ista_sequence& NeuroMLDocument_base::
  EIF_cond_exp_isfa_ista ()
  {
    return this->EIF_cond_exp_isfa_ista_;
  }

  void NeuroMLDocument_base::
  EIF_cond_exp_isfa_ista (const EIF_cond_exp_isfa_ista_sequence& s)
  {
    this->EIF_cond_exp_isfa_ista_ = s;
  }

  const NeuroMLDocument_base::EIF_cond_alpha_isfa_ista_sequence& NeuroMLDocument_base::
  EIF_cond_alpha_isfa_ista () const
  {
    return this->EIF_cond_alpha_isfa_ista_;
  }

  NeuroMLDocument_base::EIF_cond_alpha_isfa_ista_sequence& NeuroMLDocument_base::
  EIF_cond_alpha_isfa_ista ()
  {
    return this->EIF_cond_alpha_isfa_ista_;
  }

  void NeuroMLDocument_base::
  EIF_cond_alpha_isfa_ista (const EIF_cond_alpha_isfa_ista_sequence& s)
  {
    this->EIF_cond_alpha_isfa_ista_ = s;
  }

  const NeuroMLDocument_base::HH_cond_exp_sequence& NeuroMLDocument_base::
  HH_cond_exp () const
  {
    return this->HH_cond_exp_;
  }

  NeuroMLDocument_base::HH_cond_exp_sequence& NeuroMLDocument_base::
  HH_cond_exp ()
  {
    return this->HH_cond_exp_;
  }

  void NeuroMLDocument_base::
  HH_cond_exp (const HH_cond_exp_sequence& s)
  {
    this->HH_cond_exp_ = s;
  }

  const NeuroMLDocument_base::expCondSynapse_sequence& NeuroMLDocument_base::
  expCondSynapse () const
  {
    return this->expCondSynapse_;
  }

  NeuroMLDocument_base::expCondSynapse_sequence& NeuroMLDocument_base::
  expCondSynapse ()
  {
    return this->expCondSynapse_;
  }

  void NeuroMLDocument_base::
  expCondSynapse (const expCondSynapse_sequence& s)
  {
    this->expCondSynapse_ = s;
  }

  const NeuroMLDocument_base::alphaCondSynapse_sequence& NeuroMLDocument_base::
  alphaCondSynapse () const
  {
    return this->alphaCondSynapse_;
  }

  NeuroMLDocument_base::alphaCondSynapse_sequence& NeuroMLDocument_base::
  alphaCondSynapse ()
  {
    return this->alphaCondSynapse_;
  }

  void NeuroMLDocument_base::
  alphaCondSynapse (const alphaCondSynapse_sequence& s)
  {
    this->alphaCondSynapse_ = s;
  }

  const NeuroMLDocument_base::expCurrSynapse_sequence& NeuroMLDocument_base::
  expCurrSynapse () const
  {
    return this->expCurrSynapse_;
  }

  NeuroMLDocument_base::expCurrSynapse_sequence& NeuroMLDocument_base::
  expCurrSynapse ()
  {
    return this->expCurrSynapse_;
  }

  void NeuroMLDocument_base::
  expCurrSynapse (const expCurrSynapse_sequence& s)
  {
    this->expCurrSynapse_ = s;
  }

  const NeuroMLDocument_base::alphaCurrSynapse_sequence& NeuroMLDocument_base::
  alphaCurrSynapse () const
  {
    return this->alphaCurrSynapse_;
  }

  NeuroMLDocument_base::alphaCurrSynapse_sequence& NeuroMLDocument_base::
  alphaCurrSynapse ()
  {
    return this->alphaCurrSynapse_;
  }

  void NeuroMLDocument_base::
  alphaCurrSynapse (const alphaCurrSynapse_sequence& s)
  {
    this->alphaCurrSynapse_ = s;
  }

  const NeuroMLDocument_base::SpikeSourcePoisson_sequence& NeuroMLDocument_base::
  SpikeSourcePoisson () const
  {
    return this->SpikeSourcePoisson_;
  }

  NeuroMLDocument_base::SpikeSourcePoisson_sequence& NeuroMLDocument_base::
  SpikeSourcePoisson ()
  {
    return this->SpikeSourcePoisson_;
  }

  void NeuroMLDocument_base::
  SpikeSourcePoisson (const SpikeSourcePoisson_sequence& s)
  {
    this->SpikeSourcePoisson_ = s;
  }

  const NeuroMLDocument_base::network_sequence& NeuroMLDocument_base::
  network () const
  {
    return this->network_;
  }

  NeuroMLDocument_base::network_sequence& NeuroMLDocument_base::
  network ()
  {
    return this->network_;
  }

  void NeuroMLDocument_base::
  network (const network_sequence& s)
  {
    this->network_ = s;
  }

  const NeuroMLDocument_base::ComponentType_sequence& NeuroMLDocument_base::
  ComponentType () const
  {
    return this->ComponentType_;
  }

  NeuroMLDocument_base::ComponentType_sequence& NeuroMLDocument_base::
  ComponentType ()
  {
    return this->ComponentType_;
  }

  void NeuroMLDocument_base::
  ComponentType (const ComponentType_sequence& s)
  {
    this->ComponentType_ = s;
  }


  // IncludeType
  // 

  const IncludeType::href_type& IncludeType::
  href () const
  {
    return this->href_.get ();
  }

  IncludeType::href_type& IncludeType::
  href ()
  {
    return this->href_.get ();
  }

  void IncludeType::
  href (const href_type& x)
  {
    this->href_.set (x);
  }

  void IncludeType::
  href (::std::unique_ptr< href_type > x)
  {
    this->href_.set (std::move (x));
  }


  // IonChannelScalable
  // 

  const IonChannelScalable::q10ConductanceScaling_sequence& IonChannelScalable::
  q10ConductanceScaling () const
  {
    return this->q10ConductanceScaling_;
  }

  IonChannelScalable::q10ConductanceScaling_sequence& IonChannelScalable::
  q10ConductanceScaling ()
  {
    return this->q10ConductanceScaling_;
  }

  void IonChannelScalable::
  q10ConductanceScaling (const q10ConductanceScaling_sequence& s)
  {
    this->q10ConductanceScaling_ = s;
  }


  // IonChannelKS
  // 

  const IonChannelKS::gateKS_sequence& IonChannelKS::
  gateKS () const
  {
    return this->gateKS_;
  }

  IonChannelKS::gateKS_sequence& IonChannelKS::
  gateKS ()
  {
    return this->gateKS_;
  }

  void IonChannelKS::
  gateKS (const gateKS_sequence& s)
  {
    this->gateKS_ = s;
  }

  const IonChannelKS::species_optional& IonChannelKS::
  species () const
  {
    return this->species_;
  }

  IonChannelKS::species_optional& IonChannelKS::
  species ()
  {
    return this->species_;
  }

  void IonChannelKS::
  species (const species_type& x)
  {
    this->species_.set (x);
  }

  void IonChannelKS::
  species (const species_optional& x)
  {
    this->species_ = x;
  }

  void IonChannelKS::
  species (::std::unique_ptr< species_type > x)
  {
    this->species_.set (std::move (x));
  }

  const IonChannelKS::conductance_optional& IonChannelKS::
  conductance () const
  {
    return this->conductance_;
  }

  IonChannelKS::conductance_optional& IonChannelKS::
  conductance ()
  {
    return this->conductance_;
  }

  void IonChannelKS::
  conductance (const conductance_type& x)
  {
    this->conductance_.set (x);
  }

  void IonChannelKS::
  conductance (const conductance_optional& x)
  {
    this->conductance_ = x;
  }

  void IonChannelKS::
  conductance (::std::unique_ptr< conductance_type > x)
  {
    this->conductance_.set (std::move (x));
  }


  // IonChannel
  // 

  const IonChannel::gate_sequence& IonChannel::
  gate () const
  {
    return this->gate_;
  }

  IonChannel::gate_sequence& IonChannel::
  gate ()
  {
    return this->gate_;
  }

  void IonChannel::
  gate (const gate_sequence& s)
  {
    this->gate_ = s;
  }

  const IonChannel::gateHHrates_sequence& IonChannel::
  gateHHrates () const
  {
    return this->gateHHrates_;
  }

  IonChannel::gateHHrates_sequence& IonChannel::
  gateHHrates ()
  {
    return this->gateHHrates_;
  }

  void IonChannel::
  gateHHrates (const gateHHrates_sequence& s)
  {
    this->gateHHrates_ = s;
  }

  const IonChannel::gateHHratesTau_sequence& IonChannel::
  gateHHratesTau () const
  {
    return this->gateHHratesTau_;
  }

  IonChannel::gateHHratesTau_sequence& IonChannel::
  gateHHratesTau ()
  {
    return this->gateHHratesTau_;
  }

  void IonChannel::
  gateHHratesTau (const gateHHratesTau_sequence& s)
  {
    this->gateHHratesTau_ = s;
  }

  const IonChannel::gateHHtauInf_sequence& IonChannel::
  gateHHtauInf () const
  {
    return this->gateHHtauInf_;
  }

  IonChannel::gateHHtauInf_sequence& IonChannel::
  gateHHtauInf ()
  {
    return this->gateHHtauInf_;
  }

  void IonChannel::
  gateHHtauInf (const gateHHtauInf_sequence& s)
  {
    this->gateHHtauInf_ = s;
  }

  const IonChannel::gateHHratesInf_sequence& IonChannel::
  gateHHratesInf () const
  {
    return this->gateHHratesInf_;
  }

  IonChannel::gateHHratesInf_sequence& IonChannel::
  gateHHratesInf ()
  {
    return this->gateHHratesInf_;
  }

  void IonChannel::
  gateHHratesInf (const gateHHratesInf_sequence& s)
  {
    this->gateHHratesInf_ = s;
  }

  const IonChannel::gateHHratesTauInf_sequence& IonChannel::
  gateHHratesTauInf () const
  {
    return this->gateHHratesTauInf_;
  }

  IonChannel::gateHHratesTauInf_sequence& IonChannel::
  gateHHratesTauInf ()
  {
    return this->gateHHratesTauInf_;
  }

  void IonChannel::
  gateHHratesTauInf (const gateHHratesTauInf_sequence& s)
  {
    this->gateHHratesTauInf_ = s;
  }

  const IonChannel::gateHHInstantaneous_sequence& IonChannel::
  gateHHInstantaneous () const
  {
    return this->gateHHInstantaneous_;
  }

  IonChannel::gateHHInstantaneous_sequence& IonChannel::
  gateHHInstantaneous ()
  {
    return this->gateHHInstantaneous_;
  }

  void IonChannel::
  gateHHInstantaneous (const gateHHInstantaneous_sequence& s)
  {
    this->gateHHInstantaneous_ = s;
  }

  const IonChannel::gateFractional_sequence& IonChannel::
  gateFractional () const
  {
    return this->gateFractional_;
  }

  IonChannel::gateFractional_sequence& IonChannel::
  gateFractional ()
  {
    return this->gateFractional_;
  }

  void IonChannel::
  gateFractional (const gateFractional_sequence& s)
  {
    this->gateFractional_ = s;
  }

  const IonChannel::species_optional& IonChannel::
  species () const
  {
    return this->species_;
  }

  IonChannel::species_optional& IonChannel::
  species ()
  {
    return this->species_;
  }

  void IonChannel::
  species (const species_type& x)
  {
    this->species_.set (x);
  }

  void IonChannel::
  species (const species_optional& x)
  {
    this->species_ = x;
  }

  void IonChannel::
  species (::std::unique_ptr< species_type > x)
  {
    this->species_.set (std::move (x));
  }

  const IonChannel::type_optional& IonChannel::
  type () const
  {
    return this->type_;
  }

  IonChannel::type_optional& IonChannel::
  type ()
  {
    return this->type_;
  }

  void IonChannel::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void IonChannel::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void IonChannel::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const IonChannel::conductance_optional& IonChannel::
  conductance () const
  {
    return this->conductance_;
  }

  IonChannel::conductance_optional& IonChannel::
  conductance ()
  {
    return this->conductance_;
  }

  void IonChannel::
  conductance (const conductance_type& x)
  {
    this->conductance_.set (x);
  }

  void IonChannel::
  conductance (const conductance_optional& x)
  {
    this->conductance_ = x;
  }

  void IonChannel::
  conductance (::std::unique_ptr< conductance_type > x)
  {
    this->conductance_.set (std::move (x));
  }


  // IonChannelHH
  // 


  // IonChannelVShift
  // 

  const IonChannelVShift::vShift_type& IonChannelVShift::
  vShift () const
  {
    return this->vShift_.get ();
  }

  IonChannelVShift::vShift_type& IonChannelVShift::
  vShift ()
  {
    return this->vShift_.get ();
  }

  void IonChannelVShift::
  vShift (const vShift_type& x)
  {
    this->vShift_.set (x);
  }

  void IonChannelVShift::
  vShift (::std::unique_ptr< vShift_type > x)
  {
    this->vShift_.set (std::move (x));
  }


  // channelTypes
  // 

  channelTypes::
  channelTypes (value v)
  : ::xml_schema::string (_xsd_channelTypes_literals_[v])
  {
  }

  channelTypes::
  channelTypes (const char* v)
  : ::xml_schema::string (v)
  {
  }

  channelTypes::
  channelTypes (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  channelTypes::
  channelTypes (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  channelTypes::
  channelTypes (const channelTypes& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  channelTypes& channelTypes::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_channelTypes_literals_[v]);

    return *this;
  }


  // Q10ConductanceScaling
  // 

  const Q10ConductanceScaling::q10Factor_type& Q10ConductanceScaling::
  q10Factor () const
  {
    return this->q10Factor_.get ();
  }

  Q10ConductanceScaling::q10Factor_type& Q10ConductanceScaling::
  q10Factor ()
  {
    return this->q10Factor_.get ();
  }

  void Q10ConductanceScaling::
  q10Factor (const q10Factor_type& x)
  {
    this->q10Factor_.set (x);
  }

  void Q10ConductanceScaling::
  q10Factor (::std::unique_ptr< q10Factor_type > x)
  {
    this->q10Factor_.set (std::move (x));
  }

  const Q10ConductanceScaling::experimentalTemp_type& Q10ConductanceScaling::
  experimentalTemp () const
  {
    return this->experimentalTemp_.get ();
  }

  Q10ConductanceScaling::experimentalTemp_type& Q10ConductanceScaling::
  experimentalTemp ()
  {
    return this->experimentalTemp_.get ();
  }

  void Q10ConductanceScaling::
  experimentalTemp (const experimentalTemp_type& x)
  {
    this->experimentalTemp_.set (x);
  }

  void Q10ConductanceScaling::
  experimentalTemp (::std::unique_ptr< experimentalTemp_type > x)
  {
    this->experimentalTemp_.set (std::move (x));
  }


  // gateTypes
  // 

  gateTypes::
  gateTypes (value v)
  : ::xml_schema::string (_xsd_gateTypes_literals_[v])
  {
  }

  gateTypes::
  gateTypes (const char* v)
  : ::xml_schema::string (v)
  {
  }

  gateTypes::
  gateTypes (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  gateTypes::
  gateTypes (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  gateTypes::
  gateTypes (const gateTypes& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  gateTypes& gateTypes::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_gateTypes_literals_[v]);

    return *this;
  }


  // ClosedState
  // 


  // OpenState
  // 


  // ForwardTransition
  // 

  const ForwardTransition::from_type& ForwardTransition::
  from () const
  {
    return this->from_.get ();
  }

  ForwardTransition::from_type& ForwardTransition::
  from ()
  {
    return this->from_.get ();
  }

  void ForwardTransition::
  from (const from_type& x)
  {
    this->from_.set (x);
  }

  void ForwardTransition::
  from (::std::unique_ptr< from_type > x)
  {
    this->from_.set (std::move (x));
  }

  const ForwardTransition::to_type& ForwardTransition::
  to () const
  {
    return this->to_.get ();
  }

  ForwardTransition::to_type& ForwardTransition::
  to ()
  {
    return this->to_.get ();
  }

  void ForwardTransition::
  to (const to_type& x)
  {
    this->to_.set (x);
  }

  void ForwardTransition::
  to (::std::unique_ptr< to_type > x)
  {
    this->to_.set (std::move (x));
  }


  // ReverseTransition
  // 

  const ReverseTransition::from_type& ReverseTransition::
  from () const
  {
    return this->from_.get ();
  }

  ReverseTransition::from_type& ReverseTransition::
  from ()
  {
    return this->from_.get ();
  }

  void ReverseTransition::
  from (const from_type& x)
  {
    this->from_.set (x);
  }

  void ReverseTransition::
  from (::std::unique_ptr< from_type > x)
  {
    this->from_.set (std::move (x));
  }

  const ReverseTransition::to_type& ReverseTransition::
  to () const
  {
    return this->to_.get ();
  }

  ReverseTransition::to_type& ReverseTransition::
  to ()
  {
    return this->to_.get ();
  }

  void ReverseTransition::
  to (const to_type& x)
  {
    this->to_.set (x);
  }

  void ReverseTransition::
  to (::std::unique_ptr< to_type > x)
  {
    this->to_.set (std::move (x));
  }


  // TauInfTransition
  // 

  const TauInfTransition::steadyState_type& TauInfTransition::
  steadyState () const
  {
    return this->steadyState_.get ();
  }

  TauInfTransition::steadyState_type& TauInfTransition::
  steadyState ()
  {
    return this->steadyState_.get ();
  }

  void TauInfTransition::
  steadyState (const steadyState_type& x)
  {
    this->steadyState_.set (x);
  }

  void TauInfTransition::
  steadyState (::std::unique_ptr< steadyState_type > x)
  {
    this->steadyState_.set (std::move (x));
  }

  const TauInfTransition::timeCourse_type& TauInfTransition::
  timeCourse () const
  {
    return this->timeCourse_.get ();
  }

  TauInfTransition::timeCourse_type& TauInfTransition::
  timeCourse ()
  {
    return this->timeCourse_.get ();
  }

  void TauInfTransition::
  timeCourse (const timeCourse_type& x)
  {
    this->timeCourse_.set (x);
  }

  void TauInfTransition::
  timeCourse (::std::unique_ptr< timeCourse_type > x)
  {
    this->timeCourse_.set (std::move (x));
  }

  const TauInfTransition::from_type& TauInfTransition::
  from () const
  {
    return this->from_.get ();
  }

  TauInfTransition::from_type& TauInfTransition::
  from ()
  {
    return this->from_.get ();
  }

  void TauInfTransition::
  from (const from_type& x)
  {
    this->from_.set (x);
  }

  void TauInfTransition::
  from (::std::unique_ptr< from_type > x)
  {
    this->from_.set (std::move (x));
  }

  const TauInfTransition::to_type& TauInfTransition::
  to () const
  {
    return this->to_.get ();
  }

  TauInfTransition::to_type& TauInfTransition::
  to ()
  {
    return this->to_.get ();
  }

  void TauInfTransition::
  to (const to_type& x)
  {
    this->to_.set (x);
  }

  void TauInfTransition::
  to (::std::unique_ptr< to_type > x)
  {
    this->to_.set (std::move (x));
  }


  // GateKS
  // 

  const GateKS::notes_optional& GateKS::
  notes () const
  {
    return this->notes_;
  }

  GateKS::notes_optional& GateKS::
  notes ()
  {
    return this->notes_;
  }

  void GateKS::
  notes (const notes_type& x)
  {
    this->notes_.set (x);
  }

  void GateKS::
  notes (const notes_optional& x)
  {
    this->notes_ = x;
  }

  void GateKS::
  notes (::std::unique_ptr< notes_type > x)
  {
    this->notes_.set (std::move (x));
  }

  const GateKS::q10Settings_optional& GateKS::
  q10Settings () const
  {
    return this->q10Settings_;
  }

  GateKS::q10Settings_optional& GateKS::
  q10Settings ()
  {
    return this->q10Settings_;
  }

  void GateKS::
  q10Settings (const q10Settings_type& x)
  {
    this->q10Settings_.set (x);
  }

  void GateKS::
  q10Settings (const q10Settings_optional& x)
  {
    this->q10Settings_ = x;
  }

  void GateKS::
  q10Settings (::std::unique_ptr< q10Settings_type > x)
  {
    this->q10Settings_.set (std::move (x));
  }

  const GateKS::closedState_sequence& GateKS::
  closedState () const
  {
    return this->closedState_;
  }

  GateKS::closedState_sequence& GateKS::
  closedState ()
  {
    return this->closedState_;
  }

  void GateKS::
  closedState (const closedState_sequence& s)
  {
    this->closedState_ = s;
  }

  const GateKS::openState_sequence& GateKS::
  openState () const
  {
    return this->openState_;
  }

  GateKS::openState_sequence& GateKS::
  openState ()
  {
    return this->openState_;
  }

  void GateKS::
  openState (const openState_sequence& s)
  {
    this->openState_ = s;
  }

  const GateKS::forwardTransition_sequence& GateKS::
  forwardTransition () const
  {
    return this->forwardTransition_;
  }

  GateKS::forwardTransition_sequence& GateKS::
  forwardTransition ()
  {
    return this->forwardTransition_;
  }

  void GateKS::
  forwardTransition (const forwardTransition_sequence& s)
  {
    this->forwardTransition_ = s;
  }

  const GateKS::reverseTransition_sequence& GateKS::
  reverseTransition () const
  {
    return this->reverseTransition_;
  }

  GateKS::reverseTransition_sequence& GateKS::
  reverseTransition ()
  {
    return this->reverseTransition_;
  }

  void GateKS::
  reverseTransition (const reverseTransition_sequence& s)
  {
    this->reverseTransition_ = s;
  }

  const GateKS::tauInfTransition_sequence& GateKS::
  tauInfTransition () const
  {
    return this->tauInfTransition_;
  }

  GateKS::tauInfTransition_sequence& GateKS::
  tauInfTransition ()
  {
    return this->tauInfTransition_;
  }

  void GateKS::
  tauInfTransition (const tauInfTransition_sequence& s)
  {
    this->tauInfTransition_ = s;
  }

  const GateKS::instances_type& GateKS::
  instances () const
  {
    return this->instances_.get ();
  }

  GateKS::instances_type& GateKS::
  instances ()
  {
    return this->instances_.get ();
  }

  void GateKS::
  instances (const instances_type& x)
  {
    this->instances_.set (x);
  }

  void GateKS::
  instances (::std::unique_ptr< instances_type > x)
  {
    this->instances_.set (std::move (x));
  }


  // GateHHUndetermined
  // 

  const GateHHUndetermined::notes_optional& GateHHUndetermined::
  notes () const
  {
    return this->notes_;
  }

  GateHHUndetermined::notes_optional& GateHHUndetermined::
  notes ()
  {
    return this->notes_;
  }

  void GateHHUndetermined::
  notes (const notes_type& x)
  {
    this->notes_.set (x);
  }

  void GateHHUndetermined::
  notes (const notes_optional& x)
  {
    this->notes_ = x;
  }

  void GateHHUndetermined::
  notes (::std::unique_ptr< notes_type > x)
  {
    this->notes_.set (std::move (x));
  }

  const GateHHUndetermined::q10Settings_optional& GateHHUndetermined::
  q10Settings () const
  {
    return this->q10Settings_;
  }

  GateHHUndetermined::q10Settings_optional& GateHHUndetermined::
  q10Settings ()
  {
    return this->q10Settings_;
  }

  void GateHHUndetermined::
  q10Settings (const q10Settings_type& x)
  {
    this->q10Settings_.set (x);
  }

  void GateHHUndetermined::
  q10Settings (const q10Settings_optional& x)
  {
    this->q10Settings_ = x;
  }

  void GateHHUndetermined::
  q10Settings (::std::unique_ptr< q10Settings_type > x)
  {
    this->q10Settings_.set (std::move (x));
  }

  const GateHHUndetermined::forwardRate_optional& GateHHUndetermined::
  forwardRate () const
  {
    return this->forwardRate_;
  }

  GateHHUndetermined::forwardRate_optional& GateHHUndetermined::
  forwardRate ()
  {
    return this->forwardRate_;
  }

  void GateHHUndetermined::
  forwardRate (const forwardRate_type& x)
  {
    this->forwardRate_.set (x);
  }

  void GateHHUndetermined::
  forwardRate (const forwardRate_optional& x)
  {
    this->forwardRate_ = x;
  }

  void GateHHUndetermined::
  forwardRate (::std::unique_ptr< forwardRate_type > x)
  {
    this->forwardRate_.set (std::move (x));
  }

  const GateHHUndetermined::reverseRate_optional& GateHHUndetermined::
  reverseRate () const
  {
    return this->reverseRate_;
  }

  GateHHUndetermined::reverseRate_optional& GateHHUndetermined::
  reverseRate ()
  {
    return this->reverseRate_;
  }

  void GateHHUndetermined::
  reverseRate (const reverseRate_type& x)
  {
    this->reverseRate_.set (x);
  }

  void GateHHUndetermined::
  reverseRate (const reverseRate_optional& x)
  {
    this->reverseRate_ = x;
  }

  void GateHHUndetermined::
  reverseRate (::std::unique_ptr< reverseRate_type > x)
  {
    this->reverseRate_.set (std::move (x));
  }

  const GateHHUndetermined::timeCourse_optional& GateHHUndetermined::
  timeCourse () const
  {
    return this->timeCourse_;
  }

  GateHHUndetermined::timeCourse_optional& GateHHUndetermined::
  timeCourse ()
  {
    return this->timeCourse_;
  }

  void GateHHUndetermined::
  timeCourse (const timeCourse_type& x)
  {
    this->timeCourse_.set (x);
  }

  void GateHHUndetermined::
  timeCourse (const timeCourse_optional& x)
  {
    this->timeCourse_ = x;
  }

  void GateHHUndetermined::
  timeCourse (::std::unique_ptr< timeCourse_type > x)
  {
    this->timeCourse_.set (std::move (x));
  }

  const GateHHUndetermined::steadyState_optional& GateHHUndetermined::
  steadyState () const
  {
    return this->steadyState_;
  }

  GateHHUndetermined::steadyState_optional& GateHHUndetermined::
  steadyState ()
  {
    return this->steadyState_;
  }

  void GateHHUndetermined::
  steadyState (const steadyState_type& x)
  {
    this->steadyState_.set (x);
  }

  void GateHHUndetermined::
  steadyState (const steadyState_optional& x)
  {
    this->steadyState_ = x;
  }

  void GateHHUndetermined::
  steadyState (::std::unique_ptr< steadyState_type > x)
  {
    this->steadyState_.set (std::move (x));
  }

  const GateHHUndetermined::subGate_sequence& GateHHUndetermined::
  subGate () const
  {
    return this->subGate_;
  }

  GateHHUndetermined::subGate_sequence& GateHHUndetermined::
  subGate ()
  {
    return this->subGate_;
  }

  void GateHHUndetermined::
  subGate (const subGate_sequence& s)
  {
    this->subGate_ = s;
  }

  const GateHHUndetermined::instances_type& GateHHUndetermined::
  instances () const
  {
    return this->instances_.get ();
  }

  GateHHUndetermined::instances_type& GateHHUndetermined::
  instances ()
  {
    return this->instances_.get ();
  }

  void GateHHUndetermined::
  instances (const instances_type& x)
  {
    this->instances_.set (x);
  }

  void GateHHUndetermined::
  instances (::std::unique_ptr< instances_type > x)
  {
    this->instances_.set (std::move (x));
  }

  const GateHHUndetermined::type_type& GateHHUndetermined::
  type () const
  {
    return this->type_.get ();
  }

  GateHHUndetermined::type_type& GateHHUndetermined::
  type ()
  {
    return this->type_.get ();
  }

  void GateHHUndetermined::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void GateHHUndetermined::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }


  // GateHHRates
  // 

  const GateHHRates::notes_optional& GateHHRates::
  notes () const
  {
    return this->notes_;
  }

  GateHHRates::notes_optional& GateHHRates::
  notes ()
  {
    return this->notes_;
  }

  void GateHHRates::
  notes (const notes_type& x)
  {
    this->notes_.set (x);
  }

  void GateHHRates::
  notes (const notes_optional& x)
  {
    this->notes_ = x;
  }

  void GateHHRates::
  notes (::std::unique_ptr< notes_type > x)
  {
    this->notes_.set (std::move (x));
  }

  const GateHHRates::q10Settings_optional& GateHHRates::
  q10Settings () const
  {
    return this->q10Settings_;
  }

  GateHHRates::q10Settings_optional& GateHHRates::
  q10Settings ()
  {
    return this->q10Settings_;
  }

  void GateHHRates::
  q10Settings (const q10Settings_type& x)
  {
    this->q10Settings_.set (x);
  }

  void GateHHRates::
  q10Settings (const q10Settings_optional& x)
  {
    this->q10Settings_ = x;
  }

  void GateHHRates::
  q10Settings (::std::unique_ptr< q10Settings_type > x)
  {
    this->q10Settings_.set (std::move (x));
  }

  const GateHHRates::forwardRate_type& GateHHRates::
  forwardRate () const
  {
    return this->forwardRate_.get ();
  }

  GateHHRates::forwardRate_type& GateHHRates::
  forwardRate ()
  {
    return this->forwardRate_.get ();
  }

  void GateHHRates::
  forwardRate (const forwardRate_type& x)
  {
    this->forwardRate_.set (x);
  }

  void GateHHRates::
  forwardRate (::std::unique_ptr< forwardRate_type > x)
  {
    this->forwardRate_.set (std::move (x));
  }

  const GateHHRates::reverseRate_type& GateHHRates::
  reverseRate () const
  {
    return this->reverseRate_.get ();
  }

  GateHHRates::reverseRate_type& GateHHRates::
  reverseRate ()
  {
    return this->reverseRate_.get ();
  }

  void GateHHRates::
  reverseRate (const reverseRate_type& x)
  {
    this->reverseRate_.set (x);
  }

  void GateHHRates::
  reverseRate (::std::unique_ptr< reverseRate_type > x)
  {
    this->reverseRate_.set (std::move (x));
  }

  const GateHHRates::instances_type& GateHHRates::
  instances () const
  {
    return this->instances_.get ();
  }

  GateHHRates::instances_type& GateHHRates::
  instances ()
  {
    return this->instances_.get ();
  }

  void GateHHRates::
  instances (const instances_type& x)
  {
    this->instances_.set (x);
  }

  void GateHHRates::
  instances (::std::unique_ptr< instances_type > x)
  {
    this->instances_.set (std::move (x));
  }


  // GateHHTauInf
  // 

  const GateHHTauInf::notes_optional& GateHHTauInf::
  notes () const
  {
    return this->notes_;
  }

  GateHHTauInf::notes_optional& GateHHTauInf::
  notes ()
  {
    return this->notes_;
  }

  void GateHHTauInf::
  notes (const notes_type& x)
  {
    this->notes_.set (x);
  }

  void GateHHTauInf::
  notes (const notes_optional& x)
  {
    this->notes_ = x;
  }

  void GateHHTauInf::
  notes (::std::unique_ptr< notes_type > x)
  {
    this->notes_.set (std::move (x));
  }

  const GateHHTauInf::q10Settings_optional& GateHHTauInf::
  q10Settings () const
  {
    return this->q10Settings_;
  }

  GateHHTauInf::q10Settings_optional& GateHHTauInf::
  q10Settings ()
  {
    return this->q10Settings_;
  }

  void GateHHTauInf::
  q10Settings (const q10Settings_type& x)
  {
    this->q10Settings_.set (x);
  }

  void GateHHTauInf::
  q10Settings (const q10Settings_optional& x)
  {
    this->q10Settings_ = x;
  }

  void GateHHTauInf::
  q10Settings (::std::unique_ptr< q10Settings_type > x)
  {
    this->q10Settings_.set (std::move (x));
  }

  const GateHHTauInf::timeCourse_type& GateHHTauInf::
  timeCourse () const
  {
    return this->timeCourse_.get ();
  }

  GateHHTauInf::timeCourse_type& GateHHTauInf::
  timeCourse ()
  {
    return this->timeCourse_.get ();
  }

  void GateHHTauInf::
  timeCourse (const timeCourse_type& x)
  {
    this->timeCourse_.set (x);
  }

  void GateHHTauInf::
  timeCourse (::std::unique_ptr< timeCourse_type > x)
  {
    this->timeCourse_.set (std::move (x));
  }

  const GateHHTauInf::steadyState_type& GateHHTauInf::
  steadyState () const
  {
    return this->steadyState_.get ();
  }

  GateHHTauInf::steadyState_type& GateHHTauInf::
  steadyState ()
  {
    return this->steadyState_.get ();
  }

  void GateHHTauInf::
  steadyState (const steadyState_type& x)
  {
    this->steadyState_.set (x);
  }

  void GateHHTauInf::
  steadyState (::std::unique_ptr< steadyState_type > x)
  {
    this->steadyState_.set (std::move (x));
  }

  const GateHHTauInf::instances_type& GateHHTauInf::
  instances () const
  {
    return this->instances_.get ();
  }

  GateHHTauInf::instances_type& GateHHTauInf::
  instances ()
  {
    return this->instances_.get ();
  }

  void GateHHTauInf::
  instances (const instances_type& x)
  {
    this->instances_.set (x);
  }

  void GateHHTauInf::
  instances (::std::unique_ptr< instances_type > x)
  {
    this->instances_.set (std::move (x));
  }


  // GateHHRatesTauInf
  // 

  const GateHHRatesTauInf::notes_optional& GateHHRatesTauInf::
  notes () const
  {
    return this->notes_;
  }

  GateHHRatesTauInf::notes_optional& GateHHRatesTauInf::
  notes ()
  {
    return this->notes_;
  }

  void GateHHRatesTauInf::
  notes (const notes_type& x)
  {
    this->notes_.set (x);
  }

  void GateHHRatesTauInf::
  notes (const notes_optional& x)
  {
    this->notes_ = x;
  }

  void GateHHRatesTauInf::
  notes (::std::unique_ptr< notes_type > x)
  {
    this->notes_.set (std::move (x));
  }

  const GateHHRatesTauInf::q10Settings_optional& GateHHRatesTauInf::
  q10Settings () const
  {
    return this->q10Settings_;
  }

  GateHHRatesTauInf::q10Settings_optional& GateHHRatesTauInf::
  q10Settings ()
  {
    return this->q10Settings_;
  }

  void GateHHRatesTauInf::
  q10Settings (const q10Settings_type& x)
  {
    this->q10Settings_.set (x);
  }

  void GateHHRatesTauInf::
  q10Settings (const q10Settings_optional& x)
  {
    this->q10Settings_ = x;
  }

  void GateHHRatesTauInf::
  q10Settings (::std::unique_ptr< q10Settings_type > x)
  {
    this->q10Settings_.set (std::move (x));
  }

  const GateHHRatesTauInf::forwardRate_type& GateHHRatesTauInf::
  forwardRate () const
  {
    return this->forwardRate_.get ();
  }

  GateHHRatesTauInf::forwardRate_type& GateHHRatesTauInf::
  forwardRate ()
  {
    return this->forwardRate_.get ();
  }

  void GateHHRatesTauInf::
  forwardRate (const forwardRate_type& x)
  {
    this->forwardRate_.set (x);
  }

  void GateHHRatesTauInf::
  forwardRate (::std::unique_ptr< forwardRate_type > x)
  {
    this->forwardRate_.set (std::move (x));
  }

  const GateHHRatesTauInf::reverseRate_type& GateHHRatesTauInf::
  reverseRate () const
  {
    return this->reverseRate_.get ();
  }

  GateHHRatesTauInf::reverseRate_type& GateHHRatesTauInf::
  reverseRate ()
  {
    return this->reverseRate_.get ();
  }

  void GateHHRatesTauInf::
  reverseRate (const reverseRate_type& x)
  {
    this->reverseRate_.set (x);
  }

  void GateHHRatesTauInf::
  reverseRate (::std::unique_ptr< reverseRate_type > x)
  {
    this->reverseRate_.set (std::move (x));
  }

  const GateHHRatesTauInf::timeCourse_type& GateHHRatesTauInf::
  timeCourse () const
  {
    return this->timeCourse_.get ();
  }

  GateHHRatesTauInf::timeCourse_type& GateHHRatesTauInf::
  timeCourse ()
  {
    return this->timeCourse_.get ();
  }

  void GateHHRatesTauInf::
  timeCourse (const timeCourse_type& x)
  {
    this->timeCourse_.set (x);
  }

  void GateHHRatesTauInf::
  timeCourse (::std::unique_ptr< timeCourse_type > x)
  {
    this->timeCourse_.set (std::move (x));
  }

  const GateHHRatesTauInf::steadyState_type& GateHHRatesTauInf::
  steadyState () const
  {
    return this->steadyState_.get ();
  }

  GateHHRatesTauInf::steadyState_type& GateHHRatesTauInf::
  steadyState ()
  {
    return this->steadyState_.get ();
  }

  void GateHHRatesTauInf::
  steadyState (const steadyState_type& x)
  {
    this->steadyState_.set (x);
  }

  void GateHHRatesTauInf::
  steadyState (::std::unique_ptr< steadyState_type > x)
  {
    this->steadyState_.set (std::move (x));
  }

  const GateHHRatesTauInf::instances_type& GateHHRatesTauInf::
  instances () const
  {
    return this->instances_.get ();
  }

  GateHHRatesTauInf::instances_type& GateHHRatesTauInf::
  instances ()
  {
    return this->instances_.get ();
  }

  void GateHHRatesTauInf::
  instances (const instances_type& x)
  {
    this->instances_.set (x);
  }

  void GateHHRatesTauInf::
  instances (::std::unique_ptr< instances_type > x)
  {
    this->instances_.set (std::move (x));
  }


  // GateHHRatesTau
  // 

  const GateHHRatesTau::notes_optional& GateHHRatesTau::
  notes () const
  {
    return this->notes_;
  }

  GateHHRatesTau::notes_optional& GateHHRatesTau::
  notes ()
  {
    return this->notes_;
  }

  void GateHHRatesTau::
  notes (const notes_type& x)
  {
    this->notes_.set (x);
  }

  void GateHHRatesTau::
  notes (const notes_optional& x)
  {
    this->notes_ = x;
  }

  void GateHHRatesTau::
  notes (::std::unique_ptr< notes_type > x)
  {
    this->notes_.set (std::move (x));
  }

  const GateHHRatesTau::q10Settings_optional& GateHHRatesTau::
  q10Settings () const
  {
    return this->q10Settings_;
  }

  GateHHRatesTau::q10Settings_optional& GateHHRatesTau::
  q10Settings ()
  {
    return this->q10Settings_;
  }

  void GateHHRatesTau::
  q10Settings (const q10Settings_type& x)
  {
    this->q10Settings_.set (x);
  }

  void GateHHRatesTau::
  q10Settings (const q10Settings_optional& x)
  {
    this->q10Settings_ = x;
  }

  void GateHHRatesTau::
  q10Settings (::std::unique_ptr< q10Settings_type > x)
  {
    this->q10Settings_.set (std::move (x));
  }

  const GateHHRatesTau::forwardRate_type& GateHHRatesTau::
  forwardRate () const
  {
    return this->forwardRate_.get ();
  }

  GateHHRatesTau::forwardRate_type& GateHHRatesTau::
  forwardRate ()
  {
    return this->forwardRate_.get ();
  }

  void GateHHRatesTau::
  forwardRate (const forwardRate_type& x)
  {
    this->forwardRate_.set (x);
  }

  void GateHHRatesTau::
  forwardRate (::std::unique_ptr< forwardRate_type > x)
  {
    this->forwardRate_.set (std::move (x));
  }

  const GateHHRatesTau::reverseRate_type& GateHHRatesTau::
  reverseRate () const
  {
    return this->reverseRate_.get ();
  }

  GateHHRatesTau::reverseRate_type& GateHHRatesTau::
  reverseRate ()
  {
    return this->reverseRate_.get ();
  }

  void GateHHRatesTau::
  reverseRate (const reverseRate_type& x)
  {
    this->reverseRate_.set (x);
  }

  void GateHHRatesTau::
  reverseRate (::std::unique_ptr< reverseRate_type > x)
  {
    this->reverseRate_.set (std::move (x));
  }

  const GateHHRatesTau::timeCourse_type& GateHHRatesTau::
  timeCourse () const
  {
    return this->timeCourse_.get ();
  }

  GateHHRatesTau::timeCourse_type& GateHHRatesTau::
  timeCourse ()
  {
    return this->timeCourse_.get ();
  }

  void GateHHRatesTau::
  timeCourse (const timeCourse_type& x)
  {
    this->timeCourse_.set (x);
  }

  void GateHHRatesTau::
  timeCourse (::std::unique_ptr< timeCourse_type > x)
  {
    this->timeCourse_.set (std::move (x));
  }

  const GateHHRatesTau::instances_type& GateHHRatesTau::
  instances () const
  {
    return this->instances_.get ();
  }

  GateHHRatesTau::instances_type& GateHHRatesTau::
  instances ()
  {
    return this->instances_.get ();
  }

  void GateHHRatesTau::
  instances (const instances_type& x)
  {
    this->instances_.set (x);
  }

  void GateHHRatesTau::
  instances (::std::unique_ptr< instances_type > x)
  {
    this->instances_.set (std::move (x));
  }


  // GateHHRatesInf
  // 

  const GateHHRatesInf::notes_optional& GateHHRatesInf::
  notes () const
  {
    return this->notes_;
  }

  GateHHRatesInf::notes_optional& GateHHRatesInf::
  notes ()
  {
    return this->notes_;
  }

  void GateHHRatesInf::
  notes (const notes_type& x)
  {
    this->notes_.set (x);
  }

  void GateHHRatesInf::
  notes (const notes_optional& x)
  {
    this->notes_ = x;
  }

  void GateHHRatesInf::
  notes (::std::unique_ptr< notes_type > x)
  {
    this->notes_.set (std::move (x));
  }

  const GateHHRatesInf::q10Settings_optional& GateHHRatesInf::
  q10Settings () const
  {
    return this->q10Settings_;
  }

  GateHHRatesInf::q10Settings_optional& GateHHRatesInf::
  q10Settings ()
  {
    return this->q10Settings_;
  }

  void GateHHRatesInf::
  q10Settings (const q10Settings_type& x)
  {
    this->q10Settings_.set (x);
  }

  void GateHHRatesInf::
  q10Settings (const q10Settings_optional& x)
  {
    this->q10Settings_ = x;
  }

  void GateHHRatesInf::
  q10Settings (::std::unique_ptr< q10Settings_type > x)
  {
    this->q10Settings_.set (std::move (x));
  }

  const GateHHRatesInf::forwardRate_type& GateHHRatesInf::
  forwardRate () const
  {
    return this->forwardRate_.get ();
  }

  GateHHRatesInf::forwardRate_type& GateHHRatesInf::
  forwardRate ()
  {
    return this->forwardRate_.get ();
  }

  void GateHHRatesInf::
  forwardRate (const forwardRate_type& x)
  {
    this->forwardRate_.set (x);
  }

  void GateHHRatesInf::
  forwardRate (::std::unique_ptr< forwardRate_type > x)
  {
    this->forwardRate_.set (std::move (x));
  }

  const GateHHRatesInf::reverseRate_type& GateHHRatesInf::
  reverseRate () const
  {
    return this->reverseRate_.get ();
  }

  GateHHRatesInf::reverseRate_type& GateHHRatesInf::
  reverseRate ()
  {
    return this->reverseRate_.get ();
  }

  void GateHHRatesInf::
  reverseRate (const reverseRate_type& x)
  {
    this->reverseRate_.set (x);
  }

  void GateHHRatesInf::
  reverseRate (::std::unique_ptr< reverseRate_type > x)
  {
    this->reverseRate_.set (std::move (x));
  }

  const GateHHRatesInf::steadyState_type& GateHHRatesInf::
  steadyState () const
  {
    return this->steadyState_.get ();
  }

  GateHHRatesInf::steadyState_type& GateHHRatesInf::
  steadyState ()
  {
    return this->steadyState_.get ();
  }

  void GateHHRatesInf::
  steadyState (const steadyState_type& x)
  {
    this->steadyState_.set (x);
  }

  void GateHHRatesInf::
  steadyState (::std::unique_ptr< steadyState_type > x)
  {
    this->steadyState_.set (std::move (x));
  }

  const GateHHRatesInf::instances_type& GateHHRatesInf::
  instances () const
  {
    return this->instances_.get ();
  }

  GateHHRatesInf::instances_type& GateHHRatesInf::
  instances ()
  {
    return this->instances_.get ();
  }

  void GateHHRatesInf::
  instances (const instances_type& x)
  {
    this->instances_.set (x);
  }

  void GateHHRatesInf::
  instances (::std::unique_ptr< instances_type > x)
  {
    this->instances_.set (std::move (x));
  }


  // GateHHInstantaneous
  // 

  const GateHHInstantaneous::notes_optional& GateHHInstantaneous::
  notes () const
  {
    return this->notes_;
  }

  GateHHInstantaneous::notes_optional& GateHHInstantaneous::
  notes ()
  {
    return this->notes_;
  }

  void GateHHInstantaneous::
  notes (const notes_type& x)
  {
    this->notes_.set (x);
  }

  void GateHHInstantaneous::
  notes (const notes_optional& x)
  {
    this->notes_ = x;
  }

  void GateHHInstantaneous::
  notes (::std::unique_ptr< notes_type > x)
  {
    this->notes_.set (std::move (x));
  }

  const GateHHInstantaneous::steadyState_type& GateHHInstantaneous::
  steadyState () const
  {
    return this->steadyState_.get ();
  }

  GateHHInstantaneous::steadyState_type& GateHHInstantaneous::
  steadyState ()
  {
    return this->steadyState_.get ();
  }

  void GateHHInstantaneous::
  steadyState (const steadyState_type& x)
  {
    this->steadyState_.set (x);
  }

  void GateHHInstantaneous::
  steadyState (::std::unique_ptr< steadyState_type > x)
  {
    this->steadyState_.set (std::move (x));
  }

  const GateHHInstantaneous::instances_type& GateHHInstantaneous::
  instances () const
  {
    return this->instances_.get ();
  }

  GateHHInstantaneous::instances_type& GateHHInstantaneous::
  instances ()
  {
    return this->instances_.get ();
  }

  void GateHHInstantaneous::
  instances (const instances_type& x)
  {
    this->instances_.set (x);
  }

  void GateHHInstantaneous::
  instances (::std::unique_ptr< instances_type > x)
  {
    this->instances_.set (std::move (x));
  }


  // GateFractional
  // 

  const GateFractional::notes_optional& GateFractional::
  notes () const
  {
    return this->notes_;
  }

  GateFractional::notes_optional& GateFractional::
  notes ()
  {
    return this->notes_;
  }

  void GateFractional::
  notes (const notes_type& x)
  {
    this->notes_.set (x);
  }

  void GateFractional::
  notes (const notes_optional& x)
  {
    this->notes_ = x;
  }

  void GateFractional::
  notes (::std::unique_ptr< notes_type > x)
  {
    this->notes_.set (std::move (x));
  }

  const GateFractional::q10Settings_optional& GateFractional::
  q10Settings () const
  {
    return this->q10Settings_;
  }

  GateFractional::q10Settings_optional& GateFractional::
  q10Settings ()
  {
    return this->q10Settings_;
  }

  void GateFractional::
  q10Settings (const q10Settings_type& x)
  {
    this->q10Settings_.set (x);
  }

  void GateFractional::
  q10Settings (const q10Settings_optional& x)
  {
    this->q10Settings_ = x;
  }

  void GateFractional::
  q10Settings (::std::unique_ptr< q10Settings_type > x)
  {
    this->q10Settings_.set (std::move (x));
  }

  const GateFractional::subGate_sequence& GateFractional::
  subGate () const
  {
    return this->subGate_;
  }

  GateFractional::subGate_sequence& GateFractional::
  subGate ()
  {
    return this->subGate_;
  }

  void GateFractional::
  subGate (const subGate_sequence& s)
  {
    this->subGate_ = s;
  }

  const GateFractional::instances_type& GateFractional::
  instances () const
  {
    return this->instances_.get ();
  }

  GateFractional::instances_type& GateFractional::
  instances ()
  {
    return this->instances_.get ();
  }

  void GateFractional::
  instances (const instances_type& x)
  {
    this->instances_.set (x);
  }

  void GateFractional::
  instances (::std::unique_ptr< instances_type > x)
  {
    this->instances_.set (std::move (x));
  }


  // GateFractionalSubgate
  // 

  const GateFractionalSubgate::notes_optional& GateFractionalSubgate::
  notes () const
  {
    return this->notes_;
  }

  GateFractionalSubgate::notes_optional& GateFractionalSubgate::
  notes ()
  {
    return this->notes_;
  }

  void GateFractionalSubgate::
  notes (const notes_type& x)
  {
    this->notes_.set (x);
  }

  void GateFractionalSubgate::
  notes (const notes_optional& x)
  {
    this->notes_ = x;
  }

  void GateFractionalSubgate::
  notes (::std::unique_ptr< notes_type > x)
  {
    this->notes_.set (std::move (x));
  }

  const GateFractionalSubgate::q10Settings_optional& GateFractionalSubgate::
  q10Settings () const
  {
    return this->q10Settings_;
  }

  GateFractionalSubgate::q10Settings_optional& GateFractionalSubgate::
  q10Settings ()
  {
    return this->q10Settings_;
  }

  void GateFractionalSubgate::
  q10Settings (const q10Settings_type& x)
  {
    this->q10Settings_.set (x);
  }

  void GateFractionalSubgate::
  q10Settings (const q10Settings_optional& x)
  {
    this->q10Settings_ = x;
  }

  void GateFractionalSubgate::
  q10Settings (::std::unique_ptr< q10Settings_type > x)
  {
    this->q10Settings_.set (std::move (x));
  }

  const GateFractionalSubgate::steadyState_type& GateFractionalSubgate::
  steadyState () const
  {
    return this->steadyState_.get ();
  }

  GateFractionalSubgate::steadyState_type& GateFractionalSubgate::
  steadyState ()
  {
    return this->steadyState_.get ();
  }

  void GateFractionalSubgate::
  steadyState (const steadyState_type& x)
  {
    this->steadyState_.set (x);
  }

  void GateFractionalSubgate::
  steadyState (::std::unique_ptr< steadyState_type > x)
  {
    this->steadyState_.set (std::move (x));
  }

  const GateFractionalSubgate::timeCourse_type& GateFractionalSubgate::
  timeCourse () const
  {
    return this->timeCourse_.get ();
  }

  GateFractionalSubgate::timeCourse_type& GateFractionalSubgate::
  timeCourse ()
  {
    return this->timeCourse_.get ();
  }

  void GateFractionalSubgate::
  timeCourse (const timeCourse_type& x)
  {
    this->timeCourse_.set (x);
  }

  void GateFractionalSubgate::
  timeCourse (::std::unique_ptr< timeCourse_type > x)
  {
    this->timeCourse_.set (std::move (x));
  }

  const GateFractionalSubgate::fractionalConductance_type& GateFractionalSubgate::
  fractionalConductance () const
  {
    return this->fractionalConductance_.get ();
  }

  GateFractionalSubgate::fractionalConductance_type& GateFractionalSubgate::
  fractionalConductance ()
  {
    return this->fractionalConductance_.get ();
  }

  void GateFractionalSubgate::
  fractionalConductance (const fractionalConductance_type& x)
  {
    this->fractionalConductance_.set (x);
  }

  void GateFractionalSubgate::
  fractionalConductance (::std::unique_ptr< fractionalConductance_type > x)
  {
    this->fractionalConductance_.set (std::move (x));
  }


  // Q10Settings
  // 

  const Q10Settings::type_type& Q10Settings::
  type () const
  {
    return this->type_.get ();
  }

  Q10Settings::type_type& Q10Settings::
  type ()
  {
    return this->type_.get ();
  }

  void Q10Settings::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void Q10Settings::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const Q10Settings::fixedQ10_optional& Q10Settings::
  fixedQ10 () const
  {
    return this->fixedQ10_;
  }

  Q10Settings::fixedQ10_optional& Q10Settings::
  fixedQ10 ()
  {
    return this->fixedQ10_;
  }

  void Q10Settings::
  fixedQ10 (const fixedQ10_type& x)
  {
    this->fixedQ10_.set (x);
  }

  void Q10Settings::
  fixedQ10 (const fixedQ10_optional& x)
  {
    this->fixedQ10_ = x;
  }

  void Q10Settings::
  fixedQ10 (::std::unique_ptr< fixedQ10_type > x)
  {
    this->fixedQ10_.set (std::move (x));
  }

  const Q10Settings::q10Factor_optional& Q10Settings::
  q10Factor () const
  {
    return this->q10Factor_;
  }

  Q10Settings::q10Factor_optional& Q10Settings::
  q10Factor ()
  {
    return this->q10Factor_;
  }

  void Q10Settings::
  q10Factor (const q10Factor_type& x)
  {
    this->q10Factor_.set (x);
  }

  void Q10Settings::
  q10Factor (const q10Factor_optional& x)
  {
    this->q10Factor_ = x;
  }

  void Q10Settings::
  q10Factor (::std::unique_ptr< q10Factor_type > x)
  {
    this->q10Factor_.set (std::move (x));
  }

  const Q10Settings::experimentalTemp_optional& Q10Settings::
  experimentalTemp () const
  {
    return this->experimentalTemp_;
  }

  Q10Settings::experimentalTemp_optional& Q10Settings::
  experimentalTemp ()
  {
    return this->experimentalTemp_;
  }

  void Q10Settings::
  experimentalTemp (const experimentalTemp_type& x)
  {
    this->experimentalTemp_.set (x);
  }

  void Q10Settings::
  experimentalTemp (const experimentalTemp_optional& x)
  {
    this->experimentalTemp_ = x;
  }

  void Q10Settings::
  experimentalTemp (::std::unique_ptr< experimentalTemp_type > x)
  {
    this->experimentalTemp_.set (std::move (x));
  }


  // HHRate
  // 

  const HHRate::type_type& HHRate::
  type () const
  {
    return this->type_.get ();
  }

  HHRate::type_type& HHRate::
  type ()
  {
    return this->type_.get ();
  }

  void HHRate::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void HHRate::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const HHRate::rate_optional& HHRate::
  rate () const
  {
    return this->rate_;
  }

  HHRate::rate_optional& HHRate::
  rate ()
  {
    return this->rate_;
  }

  void HHRate::
  rate (const rate_type& x)
  {
    this->rate_.set (x);
  }

  void HHRate::
  rate (const rate_optional& x)
  {
    this->rate_ = x;
  }

  void HHRate::
  rate (::std::unique_ptr< rate_type > x)
  {
    this->rate_.set (std::move (x));
  }

  const HHRate::midpoint_optional& HHRate::
  midpoint () const
  {
    return this->midpoint_;
  }

  HHRate::midpoint_optional& HHRate::
  midpoint ()
  {
    return this->midpoint_;
  }

  void HHRate::
  midpoint (const midpoint_type& x)
  {
    this->midpoint_.set (x);
  }

  void HHRate::
  midpoint (const midpoint_optional& x)
  {
    this->midpoint_ = x;
  }

  void HHRate::
  midpoint (::std::unique_ptr< midpoint_type > x)
  {
    this->midpoint_.set (std::move (x));
  }

  const HHRate::scale_optional& HHRate::
  scale () const
  {
    return this->scale_;
  }

  HHRate::scale_optional& HHRate::
  scale ()
  {
    return this->scale_;
  }

  void HHRate::
  scale (const scale_type& x)
  {
    this->scale_.set (x);
  }

  void HHRate::
  scale (const scale_optional& x)
  {
    this->scale_ = x;
  }

  void HHRate::
  scale (::std::unique_ptr< scale_type > x)
  {
    this->scale_.set (std::move (x));
  }


  // HHVariable
  // 

  const HHVariable::type_type& HHVariable::
  type () const
  {
    return this->type_.get ();
  }

  HHVariable::type_type& HHVariable::
  type ()
  {
    return this->type_.get ();
  }

  void HHVariable::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void HHVariable::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const HHVariable::rate_optional& HHVariable::
  rate () const
  {
    return this->rate_;
  }

  HHVariable::rate_optional& HHVariable::
  rate ()
  {
    return this->rate_;
  }

  void HHVariable::
  rate (const rate_type& x)
  {
    this->rate_.set (x);
  }

  void HHVariable::
  rate (const rate_optional& x)
  {
    this->rate_ = x;
  }

  const HHVariable::midpoint_optional& HHVariable::
  midpoint () const
  {
    return this->midpoint_;
  }

  HHVariable::midpoint_optional& HHVariable::
  midpoint ()
  {
    return this->midpoint_;
  }

  void HHVariable::
  midpoint (const midpoint_type& x)
  {
    this->midpoint_.set (x);
  }

  void HHVariable::
  midpoint (const midpoint_optional& x)
  {
    this->midpoint_ = x;
  }

  void HHVariable::
  midpoint (::std::unique_ptr< midpoint_type > x)
  {
    this->midpoint_.set (std::move (x));
  }

  const HHVariable::scale_optional& HHVariable::
  scale () const
  {
    return this->scale_;
  }

  HHVariable::scale_optional& HHVariable::
  scale ()
  {
    return this->scale_;
  }

  void HHVariable::
  scale (const scale_type& x)
  {
    this->scale_.set (x);
  }

  void HHVariable::
  scale (const scale_optional& x)
  {
    this->scale_ = x;
  }

  void HHVariable::
  scale (::std::unique_ptr< scale_type > x)
  {
    this->scale_.set (std::move (x));
  }


  // HHTime
  // 

  const HHTime::type_type& HHTime::
  type () const
  {
    return this->type_.get ();
  }

  HHTime::type_type& HHTime::
  type ()
  {
    return this->type_.get ();
  }

  void HHTime::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void HHTime::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const HHTime::rate_optional& HHTime::
  rate () const
  {
    return this->rate_;
  }

  HHTime::rate_optional& HHTime::
  rate ()
  {
    return this->rate_;
  }

  void HHTime::
  rate (const rate_type& x)
  {
    this->rate_.set (x);
  }

  void HHTime::
  rate (const rate_optional& x)
  {
    this->rate_ = x;
  }

  void HHTime::
  rate (::std::unique_ptr< rate_type > x)
  {
    this->rate_.set (std::move (x));
  }

  const HHTime::midpoint_optional& HHTime::
  midpoint () const
  {
    return this->midpoint_;
  }

  HHTime::midpoint_optional& HHTime::
  midpoint ()
  {
    return this->midpoint_;
  }

  void HHTime::
  midpoint (const midpoint_type& x)
  {
    this->midpoint_.set (x);
  }

  void HHTime::
  midpoint (const midpoint_optional& x)
  {
    this->midpoint_ = x;
  }

  void HHTime::
  midpoint (::std::unique_ptr< midpoint_type > x)
  {
    this->midpoint_.set (std::move (x));
  }

  const HHTime::scale_optional& HHTime::
  scale () const
  {
    return this->scale_;
  }

  HHTime::scale_optional& HHTime::
  scale ()
  {
    return this->scale_;
  }

  void HHTime::
  scale (const scale_type& x)
  {
    this->scale_.set (x);
  }

  void HHTime::
  scale (const scale_optional& x)
  {
    this->scale_ = x;
  }

  void HHTime::
  scale (::std::unique_ptr< scale_type > x)
  {
    this->scale_.set (std::move (x));
  }

  const HHTime::tau_optional& HHTime::
  tau () const
  {
    return this->tau_;
  }

  HHTime::tau_optional& HHTime::
  tau ()
  {
    return this->tau_;
  }

  void HHTime::
  tau (const tau_type& x)
  {
    this->tau_.set (x);
  }

  void HHTime::
  tau (const tau_optional& x)
  {
    this->tau_ = x;
  }

  void HHTime::
  tau (::std::unique_ptr< tau_type > x)
  {
    this->tau_.set (std::move (x));
  }


  // DecayingPoolConcentrationModel
  // 

  const DecayingPoolConcentrationModel::ion_type& DecayingPoolConcentrationModel::
  ion () const
  {
    return this->ion_.get ();
  }

  DecayingPoolConcentrationModel::ion_type& DecayingPoolConcentrationModel::
  ion ()
  {
    return this->ion_.get ();
  }

  void DecayingPoolConcentrationModel::
  ion (const ion_type& x)
  {
    this->ion_.set (x);
  }

  void DecayingPoolConcentrationModel::
  ion (::std::unique_ptr< ion_type > x)
  {
    this->ion_.set (std::move (x));
  }

  const DecayingPoolConcentrationModel::restingConc_type& DecayingPoolConcentrationModel::
  restingConc () const
  {
    return this->restingConc_.get ();
  }

  DecayingPoolConcentrationModel::restingConc_type& DecayingPoolConcentrationModel::
  restingConc ()
  {
    return this->restingConc_.get ();
  }

  void DecayingPoolConcentrationModel::
  restingConc (const restingConc_type& x)
  {
    this->restingConc_.set (x);
  }

  void DecayingPoolConcentrationModel::
  restingConc (::std::unique_ptr< restingConc_type > x)
  {
    this->restingConc_.set (std::move (x));
  }

  const DecayingPoolConcentrationModel::decayConstant_type& DecayingPoolConcentrationModel::
  decayConstant () const
  {
    return this->decayConstant_.get ();
  }

  DecayingPoolConcentrationModel::decayConstant_type& DecayingPoolConcentrationModel::
  decayConstant ()
  {
    return this->decayConstant_.get ();
  }

  void DecayingPoolConcentrationModel::
  decayConstant (const decayConstant_type& x)
  {
    this->decayConstant_.set (x);
  }

  void DecayingPoolConcentrationModel::
  decayConstant (::std::unique_ptr< decayConstant_type > x)
  {
    this->decayConstant_.set (std::move (x));
  }

  const DecayingPoolConcentrationModel::shellThickness_type& DecayingPoolConcentrationModel::
  shellThickness () const
  {
    return this->shellThickness_.get ();
  }

  DecayingPoolConcentrationModel::shellThickness_type& DecayingPoolConcentrationModel::
  shellThickness ()
  {
    return this->shellThickness_.get ();
  }

  void DecayingPoolConcentrationModel::
  shellThickness (const shellThickness_type& x)
  {
    this->shellThickness_.set (x);
  }

  void DecayingPoolConcentrationModel::
  shellThickness (::std::unique_ptr< shellThickness_type > x)
  {
    this->shellThickness_.set (std::move (x));
  }


  // FixedFactorConcentrationModel
  // 

  const FixedFactorConcentrationModel::ion_type& FixedFactorConcentrationModel::
  ion () const
  {
    return this->ion_.get ();
  }

  FixedFactorConcentrationModel::ion_type& FixedFactorConcentrationModel::
  ion ()
  {
    return this->ion_.get ();
  }

  void FixedFactorConcentrationModel::
  ion (const ion_type& x)
  {
    this->ion_.set (x);
  }

  void FixedFactorConcentrationModel::
  ion (::std::unique_ptr< ion_type > x)
  {
    this->ion_.set (std::move (x));
  }

  const FixedFactorConcentrationModel::restingConc_type& FixedFactorConcentrationModel::
  restingConc () const
  {
    return this->restingConc_.get ();
  }

  FixedFactorConcentrationModel::restingConc_type& FixedFactorConcentrationModel::
  restingConc ()
  {
    return this->restingConc_.get ();
  }

  void FixedFactorConcentrationModel::
  restingConc (const restingConc_type& x)
  {
    this->restingConc_.set (x);
  }

  void FixedFactorConcentrationModel::
  restingConc (::std::unique_ptr< restingConc_type > x)
  {
    this->restingConc_.set (std::move (x));
  }

  const FixedFactorConcentrationModel::decayConstant_type& FixedFactorConcentrationModel::
  decayConstant () const
  {
    return this->decayConstant_.get ();
  }

  FixedFactorConcentrationModel::decayConstant_type& FixedFactorConcentrationModel::
  decayConstant ()
  {
    return this->decayConstant_.get ();
  }

  void FixedFactorConcentrationModel::
  decayConstant (const decayConstant_type& x)
  {
    this->decayConstant_.set (x);
  }

  void FixedFactorConcentrationModel::
  decayConstant (::std::unique_ptr< decayConstant_type > x)
  {
    this->decayConstant_.set (std::move (x));
  }

  const FixedFactorConcentrationModel::rho_type& FixedFactorConcentrationModel::
  rho () const
  {
    return this->rho_.get ();
  }

  FixedFactorConcentrationModel::rho_type& FixedFactorConcentrationModel::
  rho ()
  {
    return this->rho_.get ();
  }

  void FixedFactorConcentrationModel::
  rho (const rho_type& x)
  {
    this->rho_.set (x);
  }

  void FixedFactorConcentrationModel::
  rho (::std::unique_ptr< rho_type > x)
  {
    this->rho_.set (std::move (x));
  }


  // BaseSynapse
  // 


  // BaseVoltageDepSynapse
  // 


  // BaseCurrentBasedSynapse
  // 


  // BaseConductanceBasedSynapse
  // 

  const BaseConductanceBasedSynapse::gbase_type& BaseConductanceBasedSynapse::
  gbase () const
  {
    return this->gbase_.get ();
  }

  BaseConductanceBasedSynapse::gbase_type& BaseConductanceBasedSynapse::
  gbase ()
  {
    return this->gbase_.get ();
  }

  void BaseConductanceBasedSynapse::
  gbase (const gbase_type& x)
  {
    this->gbase_.set (x);
  }

  void BaseConductanceBasedSynapse::
  gbase (::std::unique_ptr< gbase_type > x)
  {
    this->gbase_.set (std::move (x));
  }

  const BaseConductanceBasedSynapse::erev_type& BaseConductanceBasedSynapse::
  erev () const
  {
    return this->erev_.get ();
  }

  BaseConductanceBasedSynapse::erev_type& BaseConductanceBasedSynapse::
  erev ()
  {
    return this->erev_.get ();
  }

  void BaseConductanceBasedSynapse::
  erev (const erev_type& x)
  {
    this->erev_.set (x);
  }

  void BaseConductanceBasedSynapse::
  erev (::std::unique_ptr< erev_type > x)
  {
    this->erev_.set (std::move (x));
  }


  // BaseConductanceBasedSynapseTwo
  // 

  const BaseConductanceBasedSynapseTwo::gbase1_type& BaseConductanceBasedSynapseTwo::
  gbase1 () const
  {
    return this->gbase1_.get ();
  }

  BaseConductanceBasedSynapseTwo::gbase1_type& BaseConductanceBasedSynapseTwo::
  gbase1 ()
  {
    return this->gbase1_.get ();
  }

  void BaseConductanceBasedSynapseTwo::
  gbase1 (const gbase1_type& x)
  {
    this->gbase1_.set (x);
  }

  void BaseConductanceBasedSynapseTwo::
  gbase1 (::std::unique_ptr< gbase1_type > x)
  {
    this->gbase1_.set (std::move (x));
  }

  const BaseConductanceBasedSynapseTwo::gbase2_type& BaseConductanceBasedSynapseTwo::
  gbase2 () const
  {
    return this->gbase2_.get ();
  }

  BaseConductanceBasedSynapseTwo::gbase2_type& BaseConductanceBasedSynapseTwo::
  gbase2 ()
  {
    return this->gbase2_.get ();
  }

  void BaseConductanceBasedSynapseTwo::
  gbase2 (const gbase2_type& x)
  {
    this->gbase2_.set (x);
  }

  void BaseConductanceBasedSynapseTwo::
  gbase2 (::std::unique_ptr< gbase2_type > x)
  {
    this->gbase2_.set (std::move (x));
  }

  const BaseConductanceBasedSynapseTwo::erev_type& BaseConductanceBasedSynapseTwo::
  erev () const
  {
    return this->erev_.get ();
  }

  BaseConductanceBasedSynapseTwo::erev_type& BaseConductanceBasedSynapseTwo::
  erev ()
  {
    return this->erev_.get ();
  }

  void BaseConductanceBasedSynapseTwo::
  erev (const erev_type& x)
  {
    this->erev_.set (x);
  }

  void BaseConductanceBasedSynapseTwo::
  erev (::std::unique_ptr< erev_type > x)
  {
    this->erev_.set (std::move (x));
  }


  // GapJunction
  // 

  const GapJunction::conductance_type& GapJunction::
  conductance () const
  {
    return this->conductance_.get ();
  }

  GapJunction::conductance_type& GapJunction::
  conductance ()
  {
    return this->conductance_.get ();
  }

  void GapJunction::
  conductance (const conductance_type& x)
  {
    this->conductance_.set (x);
  }

  void GapJunction::
  conductance (::std::unique_ptr< conductance_type > x)
  {
    this->conductance_.set (std::move (x));
  }


  // SilentSynapse
  // 


  // LinearGradedSynapse
  // 

  const LinearGradedSynapse::conductance_type& LinearGradedSynapse::
  conductance () const
  {
    return this->conductance_.get ();
  }

  LinearGradedSynapse::conductance_type& LinearGradedSynapse::
  conductance ()
  {
    return this->conductance_.get ();
  }

  void LinearGradedSynapse::
  conductance (const conductance_type& x)
  {
    this->conductance_.set (x);
  }

  void LinearGradedSynapse::
  conductance (::std::unique_ptr< conductance_type > x)
  {
    this->conductance_.set (std::move (x));
  }


  // GradedSynapse
  // 

  const GradedSynapse::conductance_type& GradedSynapse::
  conductance () const
  {
    return this->conductance_.get ();
  }

  GradedSynapse::conductance_type& GradedSynapse::
  conductance ()
  {
    return this->conductance_.get ();
  }

  void GradedSynapse::
  conductance (const conductance_type& x)
  {
    this->conductance_.set (x);
  }

  void GradedSynapse::
  conductance (::std::unique_ptr< conductance_type > x)
  {
    this->conductance_.set (std::move (x));
  }

  const GradedSynapse::delta_type& GradedSynapse::
  delta () const
  {
    return this->delta_.get ();
  }

  GradedSynapse::delta_type& GradedSynapse::
  delta ()
  {
    return this->delta_.get ();
  }

  void GradedSynapse::
  delta (const delta_type& x)
  {
    this->delta_.set (x);
  }

  void GradedSynapse::
  delta (::std::unique_ptr< delta_type > x)
  {
    this->delta_.set (std::move (x));
  }

  const GradedSynapse::Vth_type& GradedSynapse::
  Vth () const
  {
    return this->Vth_.get ();
  }

  GradedSynapse::Vth_type& GradedSynapse::
  Vth ()
  {
    return this->Vth_.get ();
  }

  void GradedSynapse::
  Vth (const Vth_type& x)
  {
    this->Vth_.set (x);
  }

  void GradedSynapse::
  Vth (::std::unique_ptr< Vth_type > x)
  {
    this->Vth_.set (std::move (x));
  }

  const GradedSynapse::k_type& GradedSynapse::
  k () const
  {
    return this->k_.get ();
  }

  GradedSynapse::k_type& GradedSynapse::
  k ()
  {
    return this->k_.get ();
  }

  void GradedSynapse::
  k (const k_type& x)
  {
    this->k_.set (x);
  }

  void GradedSynapse::
  k (::std::unique_ptr< k_type > x)
  {
    this->k_.set (std::move (x));
  }

  const GradedSynapse::erev_type& GradedSynapse::
  erev () const
  {
    return this->erev_.get ();
  }

  GradedSynapse::erev_type& GradedSynapse::
  erev ()
  {
    return this->erev_.get ();
  }

  void GradedSynapse::
  erev (const erev_type& x)
  {
    this->erev_.set (x);
  }

  void GradedSynapse::
  erev (::std::unique_ptr< erev_type > x)
  {
    this->erev_.set (std::move (x));
  }


  // AlphaCurrentSynapse
  // 

  const AlphaCurrentSynapse::tau_type& AlphaCurrentSynapse::
  tau () const
  {
    return this->tau_.get ();
  }

  AlphaCurrentSynapse::tau_type& AlphaCurrentSynapse::
  tau ()
  {
    return this->tau_.get ();
  }

  void AlphaCurrentSynapse::
  tau (const tau_type& x)
  {
    this->tau_.set (x);
  }

  void AlphaCurrentSynapse::
  tau (::std::unique_ptr< tau_type > x)
  {
    this->tau_.set (std::move (x));
  }

  const AlphaCurrentSynapse::ibase_type& AlphaCurrentSynapse::
  ibase () const
  {
    return this->ibase_.get ();
  }

  AlphaCurrentSynapse::ibase_type& AlphaCurrentSynapse::
  ibase ()
  {
    return this->ibase_.get ();
  }

  void AlphaCurrentSynapse::
  ibase (const ibase_type& x)
  {
    this->ibase_.set (x);
  }

  void AlphaCurrentSynapse::
  ibase (::std::unique_ptr< ibase_type > x)
  {
    this->ibase_.set (std::move (x));
  }


  // AlphaSynapse
  // 

  const AlphaSynapse::tau_type& AlphaSynapse::
  tau () const
  {
    return this->tau_.get ();
  }

  AlphaSynapse::tau_type& AlphaSynapse::
  tau ()
  {
    return this->tau_.get ();
  }

  void AlphaSynapse::
  tau (const tau_type& x)
  {
    this->tau_.set (x);
  }

  void AlphaSynapse::
  tau (::std::unique_ptr< tau_type > x)
  {
    this->tau_.set (std::move (x));
  }


  // ExpOneSynapse
  // 

  const ExpOneSynapse::tauDecay_type& ExpOneSynapse::
  tauDecay () const
  {
    return this->tauDecay_.get ();
  }

  ExpOneSynapse::tauDecay_type& ExpOneSynapse::
  tauDecay ()
  {
    return this->tauDecay_.get ();
  }

  void ExpOneSynapse::
  tauDecay (const tauDecay_type& x)
  {
    this->tauDecay_.set (x);
  }

  void ExpOneSynapse::
  tauDecay (::std::unique_ptr< tauDecay_type > x)
  {
    this->tauDecay_.set (std::move (x));
  }


  // ExpTwoSynapse
  // 

  const ExpTwoSynapse::tauDecay_type& ExpTwoSynapse::
  tauDecay () const
  {
    return this->tauDecay_.get ();
  }

  ExpTwoSynapse::tauDecay_type& ExpTwoSynapse::
  tauDecay ()
  {
    return this->tauDecay_.get ();
  }

  void ExpTwoSynapse::
  tauDecay (const tauDecay_type& x)
  {
    this->tauDecay_.set (x);
  }

  void ExpTwoSynapse::
  tauDecay (::std::unique_ptr< tauDecay_type > x)
  {
    this->tauDecay_.set (std::move (x));
  }

  const ExpTwoSynapse::tauRise_type& ExpTwoSynapse::
  tauRise () const
  {
    return this->tauRise_.get ();
  }

  ExpTwoSynapse::tauRise_type& ExpTwoSynapse::
  tauRise ()
  {
    return this->tauRise_.get ();
  }

  void ExpTwoSynapse::
  tauRise (const tauRise_type& x)
  {
    this->tauRise_.set (x);
  }

  void ExpTwoSynapse::
  tauRise (::std::unique_ptr< tauRise_type > x)
  {
    this->tauRise_.set (std::move (x));
  }


  // ExpThreeSynapse
  // 

  const ExpThreeSynapse::tauDecay1_type& ExpThreeSynapse::
  tauDecay1 () const
  {
    return this->tauDecay1_.get ();
  }

  ExpThreeSynapse::tauDecay1_type& ExpThreeSynapse::
  tauDecay1 ()
  {
    return this->tauDecay1_.get ();
  }

  void ExpThreeSynapse::
  tauDecay1 (const tauDecay1_type& x)
  {
    this->tauDecay1_.set (x);
  }

  void ExpThreeSynapse::
  tauDecay1 (::std::unique_ptr< tauDecay1_type > x)
  {
    this->tauDecay1_.set (std::move (x));
  }

  const ExpThreeSynapse::tauDecay2_type& ExpThreeSynapse::
  tauDecay2 () const
  {
    return this->tauDecay2_.get ();
  }

  ExpThreeSynapse::tauDecay2_type& ExpThreeSynapse::
  tauDecay2 ()
  {
    return this->tauDecay2_.get ();
  }

  void ExpThreeSynapse::
  tauDecay2 (const tauDecay2_type& x)
  {
    this->tauDecay2_.set (x);
  }

  void ExpThreeSynapse::
  tauDecay2 (::std::unique_ptr< tauDecay2_type > x)
  {
    this->tauDecay2_.set (std::move (x));
  }

  const ExpThreeSynapse::tauRise_type& ExpThreeSynapse::
  tauRise () const
  {
    return this->tauRise_.get ();
  }

  ExpThreeSynapse::tauRise_type& ExpThreeSynapse::
  tauRise ()
  {
    return this->tauRise_.get ();
  }

  void ExpThreeSynapse::
  tauRise (const tauRise_type& x)
  {
    this->tauRise_.set (x);
  }

  void ExpThreeSynapse::
  tauRise (::std::unique_ptr< tauRise_type > x)
  {
    this->tauRise_.set (std::move (x));
  }


  // DoubleSynapse
  // 

  const DoubleSynapse::synapse1_type& DoubleSynapse::
  synapse1 () const
  {
    return this->synapse1_.get ();
  }

  DoubleSynapse::synapse1_type& DoubleSynapse::
  synapse1 ()
  {
    return this->synapse1_.get ();
  }

  void DoubleSynapse::
  synapse1 (const synapse1_type& x)
  {
    this->synapse1_.set (x);
  }

  void DoubleSynapse::
  synapse1 (::std::unique_ptr< synapse1_type > x)
  {
    this->synapse1_.set (std::move (x));
  }

  const DoubleSynapse::synapse2_type& DoubleSynapse::
  synapse2 () const
  {
    return this->synapse2_.get ();
  }

  DoubleSynapse::synapse2_type& DoubleSynapse::
  synapse2 ()
  {
    return this->synapse2_.get ();
  }

  void DoubleSynapse::
  synapse2 (const synapse2_type& x)
  {
    this->synapse2_.set (x);
  }

  void DoubleSynapse::
  synapse2 (::std::unique_ptr< synapse2_type > x)
  {
    this->synapse2_.set (std::move (x));
  }

  const DoubleSynapse::synapse1Path_type& DoubleSynapse::
  synapse1Path () const
  {
    return this->synapse1Path_.get ();
  }

  DoubleSynapse::synapse1Path_type& DoubleSynapse::
  synapse1Path ()
  {
    return this->synapse1Path_.get ();
  }

  void DoubleSynapse::
  synapse1Path (const synapse1Path_type& x)
  {
    this->synapse1Path_.set (x);
  }

  void DoubleSynapse::
  synapse1Path (::std::unique_ptr< synapse1Path_type > x)
  {
    this->synapse1Path_.set (std::move (x));
  }

  const DoubleSynapse::synapse2Path_type& DoubleSynapse::
  synapse2Path () const
  {
    return this->synapse2Path_.get ();
  }

  DoubleSynapse::synapse2Path_type& DoubleSynapse::
  synapse2Path ()
  {
    return this->synapse2Path_.get ();
  }

  void DoubleSynapse::
  synapse2Path (const synapse2Path_type& x)
  {
    this->synapse2Path_.set (x);
  }

  void DoubleSynapse::
  synapse2Path (::std::unique_ptr< synapse2Path_type > x)
  {
    this->synapse2Path_.set (std::move (x));
  }


  // BlockingPlasticSynapse
  // 

  const BlockingPlasticSynapse::plasticityMechanism_optional& BlockingPlasticSynapse::
  plasticityMechanism () const
  {
    return this->plasticityMechanism_;
  }

  BlockingPlasticSynapse::plasticityMechanism_optional& BlockingPlasticSynapse::
  plasticityMechanism ()
  {
    return this->plasticityMechanism_;
  }

  void BlockingPlasticSynapse::
  plasticityMechanism (const plasticityMechanism_type& x)
  {
    this->plasticityMechanism_.set (x);
  }

  void BlockingPlasticSynapse::
  plasticityMechanism (const plasticityMechanism_optional& x)
  {
    this->plasticityMechanism_ = x;
  }

  void BlockingPlasticSynapse::
  plasticityMechanism (::std::unique_ptr< plasticityMechanism_type > x)
  {
    this->plasticityMechanism_.set (std::move (x));
  }

  const BlockingPlasticSynapse::blockMechanism_optional& BlockingPlasticSynapse::
  blockMechanism () const
  {
    return this->blockMechanism_;
  }

  BlockingPlasticSynapse::blockMechanism_optional& BlockingPlasticSynapse::
  blockMechanism ()
  {
    return this->blockMechanism_;
  }

  void BlockingPlasticSynapse::
  blockMechanism (const blockMechanism_type& x)
  {
    this->blockMechanism_.set (x);
  }

  void BlockingPlasticSynapse::
  blockMechanism (const blockMechanism_optional& x)
  {
    this->blockMechanism_ = x;
  }

  void BlockingPlasticSynapse::
  blockMechanism (::std::unique_ptr< blockMechanism_type > x)
  {
    this->blockMechanism_.set (std::move (x));
  }


  // BlockTypes
  // 

  BlockTypes::
  BlockTypes (value v)
  : ::xml_schema::string (_xsd_BlockTypes_literals_[v])
  {
  }

  BlockTypes::
  BlockTypes (const char* v)
  : ::xml_schema::string (v)
  {
  }

  BlockTypes::
  BlockTypes (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  BlockTypes::
  BlockTypes (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  BlockTypes::
  BlockTypes (const BlockTypes& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  BlockTypes& BlockTypes::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_BlockTypes_literals_[v]);

    return *this;
  }


  // BlockMechanism
  // 

  const BlockMechanism::type_type& BlockMechanism::
  type () const
  {
    return this->type_.get ();
  }

  BlockMechanism::type_type& BlockMechanism::
  type ()
  {
    return this->type_.get ();
  }

  void BlockMechanism::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void BlockMechanism::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const BlockMechanism::species_type& BlockMechanism::
  species () const
  {
    return this->species_.get ();
  }

  BlockMechanism::species_type& BlockMechanism::
  species ()
  {
    return this->species_.get ();
  }

  void BlockMechanism::
  species (const species_type& x)
  {
    this->species_.set (x);
  }

  void BlockMechanism::
  species (::std::unique_ptr< species_type > x)
  {
    this->species_.set (std::move (x));
  }

  const BlockMechanism::blockConcentration_type& BlockMechanism::
  blockConcentration () const
  {
    return this->blockConcentration_.get ();
  }

  BlockMechanism::blockConcentration_type& BlockMechanism::
  blockConcentration ()
  {
    return this->blockConcentration_.get ();
  }

  void BlockMechanism::
  blockConcentration (const blockConcentration_type& x)
  {
    this->blockConcentration_.set (x);
  }

  void BlockMechanism::
  blockConcentration (::std::unique_ptr< blockConcentration_type > x)
  {
    this->blockConcentration_.set (std::move (x));
  }

  const BlockMechanism::scalingConc_type& BlockMechanism::
  scalingConc () const
  {
    return this->scalingConc_.get ();
  }

  BlockMechanism::scalingConc_type& BlockMechanism::
  scalingConc ()
  {
    return this->scalingConc_.get ();
  }

  void BlockMechanism::
  scalingConc (const scalingConc_type& x)
  {
    this->scalingConc_.set (x);
  }

  void BlockMechanism::
  scalingConc (::std::unique_ptr< scalingConc_type > x)
  {
    this->scalingConc_.set (std::move (x));
  }

  const BlockMechanism::scalingVolt_type& BlockMechanism::
  scalingVolt () const
  {
    return this->scalingVolt_.get ();
  }

  BlockMechanism::scalingVolt_type& BlockMechanism::
  scalingVolt ()
  {
    return this->scalingVolt_.get ();
  }

  void BlockMechanism::
  scalingVolt (const scalingVolt_type& x)
  {
    this->scalingVolt_.set (x);
  }

  void BlockMechanism::
  scalingVolt (::std::unique_ptr< scalingVolt_type > x)
  {
    this->scalingVolt_.set (std::move (x));
  }


  // PlasticityTypes
  // 

  PlasticityTypes::
  PlasticityTypes (value v)
  : ::xml_schema::string (_xsd_PlasticityTypes_literals_[v])
  {
  }

  PlasticityTypes::
  PlasticityTypes (const char* v)
  : ::xml_schema::string (v)
  {
  }

  PlasticityTypes::
  PlasticityTypes (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  PlasticityTypes::
  PlasticityTypes (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  PlasticityTypes::
  PlasticityTypes (const PlasticityTypes& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  PlasticityTypes& PlasticityTypes::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_PlasticityTypes_literals_[v]);

    return *this;
  }


  // PlasticityMechanism
  // 

  const PlasticityMechanism::type_type& PlasticityMechanism::
  type () const
  {
    return this->type_.get ();
  }

  PlasticityMechanism::type_type& PlasticityMechanism::
  type ()
  {
    return this->type_.get ();
  }

  void PlasticityMechanism::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void PlasticityMechanism::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const PlasticityMechanism::initReleaseProb_type& PlasticityMechanism::
  initReleaseProb () const
  {
    return this->initReleaseProb_.get ();
  }

  PlasticityMechanism::initReleaseProb_type& PlasticityMechanism::
  initReleaseProb ()
  {
    return this->initReleaseProb_.get ();
  }

  void PlasticityMechanism::
  initReleaseProb (const initReleaseProb_type& x)
  {
    this->initReleaseProb_.set (x);
  }

  void PlasticityMechanism::
  initReleaseProb (::std::unique_ptr< initReleaseProb_type > x)
  {
    this->initReleaseProb_.set (std::move (x));
  }

  const PlasticityMechanism::tauRec_type& PlasticityMechanism::
  tauRec () const
  {
    return this->tauRec_.get ();
  }

  PlasticityMechanism::tauRec_type& PlasticityMechanism::
  tauRec ()
  {
    return this->tauRec_.get ();
  }

  void PlasticityMechanism::
  tauRec (const tauRec_type& x)
  {
    this->tauRec_.set (x);
  }

  void PlasticityMechanism::
  tauRec (::std::unique_ptr< tauRec_type > x)
  {
    this->tauRec_.set (std::move (x));
  }

  const PlasticityMechanism::tauFac_optional& PlasticityMechanism::
  tauFac () const
  {
    return this->tauFac_;
  }

  PlasticityMechanism::tauFac_optional& PlasticityMechanism::
  tauFac ()
  {
    return this->tauFac_;
  }

  void PlasticityMechanism::
  tauFac (const tauFac_type& x)
  {
    this->tauFac_.set (x);
  }

  void PlasticityMechanism::
  tauFac (const tauFac_optional& x)
  {
    this->tauFac_ = x;
  }

  void PlasticityMechanism::
  tauFac (::std::unique_ptr< tauFac_type > x)
  {
    this->tauFac_.set (std::move (x));
  }


  // BaseCell
  // 


  // IafTauCell
  // 

  const IafTauCell::leakReversal_type& IafTauCell::
  leakReversal () const
  {
    return this->leakReversal_.get ();
  }

  IafTauCell::leakReversal_type& IafTauCell::
  leakReversal ()
  {
    return this->leakReversal_.get ();
  }

  void IafTauCell::
  leakReversal (const leakReversal_type& x)
  {
    this->leakReversal_.set (x);
  }

  void IafTauCell::
  leakReversal (::std::unique_ptr< leakReversal_type > x)
  {
    this->leakReversal_.set (std::move (x));
  }

  const IafTauCell::thresh_type& IafTauCell::
  thresh () const
  {
    return this->thresh_.get ();
  }

  IafTauCell::thresh_type& IafTauCell::
  thresh ()
  {
    return this->thresh_.get ();
  }

  void IafTauCell::
  thresh (const thresh_type& x)
  {
    this->thresh_.set (x);
  }

  void IafTauCell::
  thresh (::std::unique_ptr< thresh_type > x)
  {
    this->thresh_.set (std::move (x));
  }

  const IafTauCell::reset_type& IafTauCell::
  reset () const
  {
    return this->reset_.get ();
  }

  IafTauCell::reset_type& IafTauCell::
  reset ()
  {
    return this->reset_.get ();
  }

  void IafTauCell::
  reset (const reset_type& x)
  {
    this->reset_.set (x);
  }

  void IafTauCell::
  reset (::std::unique_ptr< reset_type > x)
  {
    this->reset_.set (std::move (x));
  }

  const IafTauCell::tau_type& IafTauCell::
  tau () const
  {
    return this->tau_.get ();
  }

  IafTauCell::tau_type& IafTauCell::
  tau ()
  {
    return this->tau_.get ();
  }

  void IafTauCell::
  tau (const tau_type& x)
  {
    this->tau_.set (x);
  }

  void IafTauCell::
  tau (::std::unique_ptr< tau_type > x)
  {
    this->tau_.set (std::move (x));
  }


  // IafTauRefCell
  // 

  const IafTauRefCell::refract_type& IafTauRefCell::
  refract () const
  {
    return this->refract_.get ();
  }

  IafTauRefCell::refract_type& IafTauRefCell::
  refract ()
  {
    return this->refract_.get ();
  }

  void IafTauRefCell::
  refract (const refract_type& x)
  {
    this->refract_.set (x);
  }

  void IafTauRefCell::
  refract (::std::unique_ptr< refract_type > x)
  {
    this->refract_.set (std::move (x));
  }


  // IafCell
  // 

  const IafCell::leakReversal_type& IafCell::
  leakReversal () const
  {
    return this->leakReversal_.get ();
  }

  IafCell::leakReversal_type& IafCell::
  leakReversal ()
  {
    return this->leakReversal_.get ();
  }

  void IafCell::
  leakReversal (const leakReversal_type& x)
  {
    this->leakReversal_.set (x);
  }

  void IafCell::
  leakReversal (::std::unique_ptr< leakReversal_type > x)
  {
    this->leakReversal_.set (std::move (x));
  }

  const IafCell::thresh_type& IafCell::
  thresh () const
  {
    return this->thresh_.get ();
  }

  IafCell::thresh_type& IafCell::
  thresh ()
  {
    return this->thresh_.get ();
  }

  void IafCell::
  thresh (const thresh_type& x)
  {
    this->thresh_.set (x);
  }

  void IafCell::
  thresh (::std::unique_ptr< thresh_type > x)
  {
    this->thresh_.set (std::move (x));
  }

  const IafCell::reset_type& IafCell::
  reset () const
  {
    return this->reset_.get ();
  }

  IafCell::reset_type& IafCell::
  reset ()
  {
    return this->reset_.get ();
  }

  void IafCell::
  reset (const reset_type& x)
  {
    this->reset_.set (x);
  }

  void IafCell::
  reset (::std::unique_ptr< reset_type > x)
  {
    this->reset_.set (std::move (x));
  }

  const IafCell::C_type& IafCell::
  C () const
  {
    return this->C_.get ();
  }

  IafCell::C_type& IafCell::
  C ()
  {
    return this->C_.get ();
  }

  void IafCell::
  C (const C_type& x)
  {
    this->C_.set (x);
  }

  void IafCell::
  C (::std::unique_ptr< C_type > x)
  {
    this->C_.set (std::move (x));
  }

  const IafCell::leakConductance_type& IafCell::
  leakConductance () const
  {
    return this->leakConductance_.get ();
  }

  IafCell::leakConductance_type& IafCell::
  leakConductance ()
  {
    return this->leakConductance_.get ();
  }

  void IafCell::
  leakConductance (const leakConductance_type& x)
  {
    this->leakConductance_.set (x);
  }

  void IafCell::
  leakConductance (::std::unique_ptr< leakConductance_type > x)
  {
    this->leakConductance_.set (std::move (x));
  }


  // IafRefCell
  // 

  const IafRefCell::refract_type& IafRefCell::
  refract () const
  {
    return this->refract_.get ();
  }

  IafRefCell::refract_type& IafRefCell::
  refract ()
  {
    return this->refract_.get ();
  }

  void IafRefCell::
  refract (const refract_type& x)
  {
    this->refract_.set (x);
  }

  void IafRefCell::
  refract (::std::unique_ptr< refract_type > x)
  {
    this->refract_.set (std::move (x));
  }


  // IzhikevichCell
  // 

  const IzhikevichCell::v0_type& IzhikevichCell::
  v0 () const
  {
    return this->v0_.get ();
  }

  IzhikevichCell::v0_type& IzhikevichCell::
  v0 ()
  {
    return this->v0_.get ();
  }

  void IzhikevichCell::
  v0 (const v0_type& x)
  {
    this->v0_.set (x);
  }

  void IzhikevichCell::
  v0 (::std::unique_ptr< v0_type > x)
  {
    this->v0_.set (std::move (x));
  }

  const IzhikevichCell::thresh_type& IzhikevichCell::
  thresh () const
  {
    return this->thresh_.get ();
  }

  IzhikevichCell::thresh_type& IzhikevichCell::
  thresh ()
  {
    return this->thresh_.get ();
  }

  void IzhikevichCell::
  thresh (const thresh_type& x)
  {
    this->thresh_.set (x);
  }

  void IzhikevichCell::
  thresh (::std::unique_ptr< thresh_type > x)
  {
    this->thresh_.set (std::move (x));
  }

  const IzhikevichCell::a_type& IzhikevichCell::
  a () const
  {
    return this->a_.get ();
  }

  IzhikevichCell::a_type& IzhikevichCell::
  a ()
  {
    return this->a_.get ();
  }

  void IzhikevichCell::
  a (const a_type& x)
  {
    this->a_.set (x);
  }

  void IzhikevichCell::
  a (::std::unique_ptr< a_type > x)
  {
    this->a_.set (std::move (x));
  }

  const IzhikevichCell::b_type& IzhikevichCell::
  b () const
  {
    return this->b_.get ();
  }

  IzhikevichCell::b_type& IzhikevichCell::
  b ()
  {
    return this->b_.get ();
  }

  void IzhikevichCell::
  b (const b_type& x)
  {
    this->b_.set (x);
  }

  void IzhikevichCell::
  b (::std::unique_ptr< b_type > x)
  {
    this->b_.set (std::move (x));
  }

  const IzhikevichCell::c_type& IzhikevichCell::
  c () const
  {
    return this->c_.get ();
  }

  IzhikevichCell::c_type& IzhikevichCell::
  c ()
  {
    return this->c_.get ();
  }

  void IzhikevichCell::
  c (const c_type& x)
  {
    this->c_.set (x);
  }

  void IzhikevichCell::
  c (::std::unique_ptr< c_type > x)
  {
    this->c_.set (std::move (x));
  }

  const IzhikevichCell::d_type& IzhikevichCell::
  d () const
  {
    return this->d_.get ();
  }

  IzhikevichCell::d_type& IzhikevichCell::
  d ()
  {
    return this->d_.get ();
  }

  void IzhikevichCell::
  d (const d_type& x)
  {
    this->d_.set (x);
  }

  void IzhikevichCell::
  d (::std::unique_ptr< d_type > x)
  {
    this->d_.set (std::move (x));
  }


  // BaseCellMembPotCap
  // 

  const BaseCellMembPotCap::C_type& BaseCellMembPotCap::
  C () const
  {
    return this->C_.get ();
  }

  BaseCellMembPotCap::C_type& BaseCellMembPotCap::
  C ()
  {
    return this->C_.get ();
  }

  void BaseCellMembPotCap::
  C (const C_type& x)
  {
    this->C_.set (x);
  }

  void BaseCellMembPotCap::
  C (::std::unique_ptr< C_type > x)
  {
    this->C_.set (std::move (x));
  }


  // Izhikevich2007Cell
  // 

  const Izhikevich2007Cell::v0_type& Izhikevich2007Cell::
  v0 () const
  {
    return this->v0_.get ();
  }

  Izhikevich2007Cell::v0_type& Izhikevich2007Cell::
  v0 ()
  {
    return this->v0_.get ();
  }

  void Izhikevich2007Cell::
  v0 (const v0_type& x)
  {
    this->v0_.set (x);
  }

  void Izhikevich2007Cell::
  v0 (::std::unique_ptr< v0_type > x)
  {
    this->v0_.set (std::move (x));
  }

  const Izhikevich2007Cell::k_type& Izhikevich2007Cell::
  k () const
  {
    return this->k_.get ();
  }

  Izhikevich2007Cell::k_type& Izhikevich2007Cell::
  k ()
  {
    return this->k_.get ();
  }

  void Izhikevich2007Cell::
  k (const k_type& x)
  {
    this->k_.set (x);
  }

  void Izhikevich2007Cell::
  k (::std::unique_ptr< k_type > x)
  {
    this->k_.set (std::move (x));
  }

  const Izhikevich2007Cell::vr_type& Izhikevich2007Cell::
  vr () const
  {
    return this->vr_.get ();
  }

  Izhikevich2007Cell::vr_type& Izhikevich2007Cell::
  vr ()
  {
    return this->vr_.get ();
  }

  void Izhikevich2007Cell::
  vr (const vr_type& x)
  {
    this->vr_.set (x);
  }

  void Izhikevich2007Cell::
  vr (::std::unique_ptr< vr_type > x)
  {
    this->vr_.set (std::move (x));
  }

  const Izhikevich2007Cell::vt_type& Izhikevich2007Cell::
  vt () const
  {
    return this->vt_.get ();
  }

  Izhikevich2007Cell::vt_type& Izhikevich2007Cell::
  vt ()
  {
    return this->vt_.get ();
  }

  void Izhikevich2007Cell::
  vt (const vt_type& x)
  {
    this->vt_.set (x);
  }

  void Izhikevich2007Cell::
  vt (::std::unique_ptr< vt_type > x)
  {
    this->vt_.set (std::move (x));
  }

  const Izhikevich2007Cell::vpeak_type& Izhikevich2007Cell::
  vpeak () const
  {
    return this->vpeak_.get ();
  }

  Izhikevich2007Cell::vpeak_type& Izhikevich2007Cell::
  vpeak ()
  {
    return this->vpeak_.get ();
  }

  void Izhikevich2007Cell::
  vpeak (const vpeak_type& x)
  {
    this->vpeak_.set (x);
  }

  void Izhikevich2007Cell::
  vpeak (::std::unique_ptr< vpeak_type > x)
  {
    this->vpeak_.set (std::move (x));
  }

  const Izhikevich2007Cell::a_type& Izhikevich2007Cell::
  a () const
  {
    return this->a_.get ();
  }

  Izhikevich2007Cell::a_type& Izhikevich2007Cell::
  a ()
  {
    return this->a_.get ();
  }

  void Izhikevich2007Cell::
  a (const a_type& x)
  {
    this->a_.set (x);
  }

  void Izhikevich2007Cell::
  a (::std::unique_ptr< a_type > x)
  {
    this->a_.set (std::move (x));
  }

  const Izhikevich2007Cell::b_type& Izhikevich2007Cell::
  b () const
  {
    return this->b_.get ();
  }

  Izhikevich2007Cell::b_type& Izhikevich2007Cell::
  b ()
  {
    return this->b_.get ();
  }

  void Izhikevich2007Cell::
  b (const b_type& x)
  {
    this->b_.set (x);
  }

  void Izhikevich2007Cell::
  b (::std::unique_ptr< b_type > x)
  {
    this->b_.set (std::move (x));
  }

  const Izhikevich2007Cell::c_type& Izhikevich2007Cell::
  c () const
  {
    return this->c_.get ();
  }

  Izhikevich2007Cell::c_type& Izhikevich2007Cell::
  c ()
  {
    return this->c_.get ();
  }

  void Izhikevich2007Cell::
  c (const c_type& x)
  {
    this->c_.set (x);
  }

  void Izhikevich2007Cell::
  c (::std::unique_ptr< c_type > x)
  {
    this->c_.set (std::move (x));
  }

  const Izhikevich2007Cell::d_type& Izhikevich2007Cell::
  d () const
  {
    return this->d_.get ();
  }

  Izhikevich2007Cell::d_type& Izhikevich2007Cell::
  d ()
  {
    return this->d_.get ();
  }

  void Izhikevich2007Cell::
  d (const d_type& x)
  {
    this->d_.set (x);
  }

  void Izhikevich2007Cell::
  d (::std::unique_ptr< d_type > x)
  {
    this->d_.set (std::move (x));
  }


  // AdExIaFCell
  // 

  const AdExIaFCell::gL_type& AdExIaFCell::
  gL () const
  {
    return this->gL_.get ();
  }

  AdExIaFCell::gL_type& AdExIaFCell::
  gL ()
  {
    return this->gL_.get ();
  }

  void AdExIaFCell::
  gL (const gL_type& x)
  {
    this->gL_.set (x);
  }

  void AdExIaFCell::
  gL (::std::unique_ptr< gL_type > x)
  {
    this->gL_.set (std::move (x));
  }

  const AdExIaFCell::EL_type& AdExIaFCell::
  EL () const
  {
    return this->EL_.get ();
  }

  AdExIaFCell::EL_type& AdExIaFCell::
  EL ()
  {
    return this->EL_.get ();
  }

  void AdExIaFCell::
  EL (const EL_type& x)
  {
    this->EL_.set (x);
  }

  void AdExIaFCell::
  EL (::std::unique_ptr< EL_type > x)
  {
    this->EL_.set (std::move (x));
  }

  const AdExIaFCell::reset_type& AdExIaFCell::
  reset () const
  {
    return this->reset_.get ();
  }

  AdExIaFCell::reset_type& AdExIaFCell::
  reset ()
  {
    return this->reset_.get ();
  }

  void AdExIaFCell::
  reset (const reset_type& x)
  {
    this->reset_.set (x);
  }

  void AdExIaFCell::
  reset (::std::unique_ptr< reset_type > x)
  {
    this->reset_.set (std::move (x));
  }

  const AdExIaFCell::VT_type& AdExIaFCell::
  VT () const
  {
    return this->VT_.get ();
  }

  AdExIaFCell::VT_type& AdExIaFCell::
  VT ()
  {
    return this->VT_.get ();
  }

  void AdExIaFCell::
  VT (const VT_type& x)
  {
    this->VT_.set (x);
  }

  void AdExIaFCell::
  VT (::std::unique_ptr< VT_type > x)
  {
    this->VT_.set (std::move (x));
  }

  const AdExIaFCell::thresh_type& AdExIaFCell::
  thresh () const
  {
    return this->thresh_.get ();
  }

  AdExIaFCell::thresh_type& AdExIaFCell::
  thresh ()
  {
    return this->thresh_.get ();
  }

  void AdExIaFCell::
  thresh (const thresh_type& x)
  {
    this->thresh_.set (x);
  }

  void AdExIaFCell::
  thresh (::std::unique_ptr< thresh_type > x)
  {
    this->thresh_.set (std::move (x));
  }

  const AdExIaFCell::delT_type& AdExIaFCell::
  delT () const
  {
    return this->delT_.get ();
  }

  AdExIaFCell::delT_type& AdExIaFCell::
  delT ()
  {
    return this->delT_.get ();
  }

  void AdExIaFCell::
  delT (const delT_type& x)
  {
    this->delT_.set (x);
  }

  void AdExIaFCell::
  delT (::std::unique_ptr< delT_type > x)
  {
    this->delT_.set (std::move (x));
  }

  const AdExIaFCell::tauw_type& AdExIaFCell::
  tauw () const
  {
    return this->tauw_.get ();
  }

  AdExIaFCell::tauw_type& AdExIaFCell::
  tauw ()
  {
    return this->tauw_.get ();
  }

  void AdExIaFCell::
  tauw (const tauw_type& x)
  {
    this->tauw_.set (x);
  }

  void AdExIaFCell::
  tauw (::std::unique_ptr< tauw_type > x)
  {
    this->tauw_.set (std::move (x));
  }

  const AdExIaFCell::refract_type& AdExIaFCell::
  refract () const
  {
    return this->refract_.get ();
  }

  AdExIaFCell::refract_type& AdExIaFCell::
  refract ()
  {
    return this->refract_.get ();
  }

  void AdExIaFCell::
  refract (const refract_type& x)
  {
    this->refract_.set (x);
  }

  void AdExIaFCell::
  refract (::std::unique_ptr< refract_type > x)
  {
    this->refract_.set (std::move (x));
  }

  const AdExIaFCell::a_type& AdExIaFCell::
  a () const
  {
    return this->a_.get ();
  }

  AdExIaFCell::a_type& AdExIaFCell::
  a ()
  {
    return this->a_.get ();
  }

  void AdExIaFCell::
  a (const a_type& x)
  {
    this->a_.set (x);
  }

  void AdExIaFCell::
  a (::std::unique_ptr< a_type > x)
  {
    this->a_.set (std::move (x));
  }

  const AdExIaFCell::b_type& AdExIaFCell::
  b () const
  {
    return this->b_.get ();
  }

  AdExIaFCell::b_type& AdExIaFCell::
  b ()
  {
    return this->b_.get ();
  }

  void AdExIaFCell::
  b (const b_type& x)
  {
    this->b_.set (x);
  }

  void AdExIaFCell::
  b (::std::unique_ptr< b_type > x)
  {
    this->b_.set (std::move (x));
  }


  // FitzHughNagumoCell
  // 

  const FitzHughNagumoCell::I_type& FitzHughNagumoCell::
  I () const
  {
    return this->I_.get ();
  }

  FitzHughNagumoCell::I_type& FitzHughNagumoCell::
  I ()
  {
    return this->I_.get ();
  }

  void FitzHughNagumoCell::
  I (const I_type& x)
  {
    this->I_.set (x);
  }

  void FitzHughNagumoCell::
  I (::std::unique_ptr< I_type > x)
  {
    this->I_.set (std::move (x));
  }


  // FitzHughNagumo1969Cell
  // 

  const FitzHughNagumo1969Cell::a_type& FitzHughNagumo1969Cell::
  a () const
  {
    return this->a_.get ();
  }

  FitzHughNagumo1969Cell::a_type& FitzHughNagumo1969Cell::
  a ()
  {
    return this->a_.get ();
  }

  void FitzHughNagumo1969Cell::
  a (const a_type& x)
  {
    this->a_.set (x);
  }

  void FitzHughNagumo1969Cell::
  a (::std::unique_ptr< a_type > x)
  {
    this->a_.set (std::move (x));
  }

  const FitzHughNagumo1969Cell::b_type& FitzHughNagumo1969Cell::
  b () const
  {
    return this->b_.get ();
  }

  FitzHughNagumo1969Cell::b_type& FitzHughNagumo1969Cell::
  b ()
  {
    return this->b_.get ();
  }

  void FitzHughNagumo1969Cell::
  b (const b_type& x)
  {
    this->b_.set (x);
  }

  void FitzHughNagumo1969Cell::
  b (::std::unique_ptr< b_type > x)
  {
    this->b_.set (std::move (x));
  }

  const FitzHughNagumo1969Cell::I_type& FitzHughNagumo1969Cell::
  I () const
  {
    return this->I_.get ();
  }

  FitzHughNagumo1969Cell::I_type& FitzHughNagumo1969Cell::
  I ()
  {
    return this->I_.get ();
  }

  void FitzHughNagumo1969Cell::
  I (const I_type& x)
  {
    this->I_.set (x);
  }

  void FitzHughNagumo1969Cell::
  I (::std::unique_ptr< I_type > x)
  {
    this->I_.set (std::move (x));
  }

  const FitzHughNagumo1969Cell::phi_type& FitzHughNagumo1969Cell::
  phi () const
  {
    return this->phi_.get ();
  }

  FitzHughNagumo1969Cell::phi_type& FitzHughNagumo1969Cell::
  phi ()
  {
    return this->phi_.get ();
  }

  void FitzHughNagumo1969Cell::
  phi (const phi_type& x)
  {
    this->phi_.set (x);
  }

  void FitzHughNagumo1969Cell::
  phi (::std::unique_ptr< phi_type > x)
  {
    this->phi_.set (std::move (x));
  }

  const FitzHughNagumo1969Cell::V0_type& FitzHughNagumo1969Cell::
  V0 () const
  {
    return this->V0_.get ();
  }

  FitzHughNagumo1969Cell::V0_type& FitzHughNagumo1969Cell::
  V0 ()
  {
    return this->V0_.get ();
  }

  void FitzHughNagumo1969Cell::
  V0 (const V0_type& x)
  {
    this->V0_.set (x);
  }

  void FitzHughNagumo1969Cell::
  V0 (::std::unique_ptr< V0_type > x)
  {
    this->V0_.set (std::move (x));
  }

  const FitzHughNagumo1969Cell::W0_type& FitzHughNagumo1969Cell::
  W0 () const
  {
    return this->W0_.get ();
  }

  FitzHughNagumo1969Cell::W0_type& FitzHughNagumo1969Cell::
  W0 ()
  {
    return this->W0_.get ();
  }

  void FitzHughNagumo1969Cell::
  W0 (const W0_type& x)
  {
    this->W0_.set (x);
  }

  void FitzHughNagumo1969Cell::
  W0 (::std::unique_ptr< W0_type > x)
  {
    this->W0_.set (std::move (x));
  }


  // PinskyRinzelCA3Cell
  // 

  const PinskyRinzelCA3Cell::iSoma_type& PinskyRinzelCA3Cell::
  iSoma () const
  {
    return this->iSoma_.get ();
  }

  PinskyRinzelCA3Cell::iSoma_type& PinskyRinzelCA3Cell::
  iSoma ()
  {
    return this->iSoma_.get ();
  }

  void PinskyRinzelCA3Cell::
  iSoma (const iSoma_type& x)
  {
    this->iSoma_.set (x);
  }

  void PinskyRinzelCA3Cell::
  iSoma (::std::unique_ptr< iSoma_type > x)
  {
    this->iSoma_.set (std::move (x));
  }

  const PinskyRinzelCA3Cell::iDend_type& PinskyRinzelCA3Cell::
  iDend () const
  {
    return this->iDend_.get ();
  }

  PinskyRinzelCA3Cell::iDend_type& PinskyRinzelCA3Cell::
  iDend ()
  {
    return this->iDend_.get ();
  }

  void PinskyRinzelCA3Cell::
  iDend (const iDend_type& x)
  {
    this->iDend_.set (x);
  }

  void PinskyRinzelCA3Cell::
  iDend (::std::unique_ptr< iDend_type > x)
  {
    this->iDend_.set (std::move (x));
  }

  const PinskyRinzelCA3Cell::gc_type& PinskyRinzelCA3Cell::
  gc () const
  {
    return this->gc_.get ();
  }

  PinskyRinzelCA3Cell::gc_type& PinskyRinzelCA3Cell::
  gc ()
  {
    return this->gc_.get ();
  }

  void PinskyRinzelCA3Cell::
  gc (const gc_type& x)
  {
    this->gc_.set (x);
  }

  void PinskyRinzelCA3Cell::
  gc (::std::unique_ptr< gc_type > x)
  {
    this->gc_.set (std::move (x));
  }

  const PinskyRinzelCA3Cell::gLs_type& PinskyRinzelCA3Cell::
  gLs () const
  {
    return this->gLs_.get ();
  }

  PinskyRinzelCA3Cell::gLs_type& PinskyRinzelCA3Cell::
  gLs ()
  {
    return this->gLs_.get ();
  }

  void PinskyRinzelCA3Cell::
  gLs (const gLs_type& x)
  {
    this->gLs_.set (x);
  }

  void PinskyRinzelCA3Cell::
  gLs (::std::unique_ptr< gLs_type > x)
  {
    this->gLs_.set (std::move (x));
  }

  const PinskyRinzelCA3Cell::gLd_type& PinskyRinzelCA3Cell::
  gLd () const
  {
    return this->gLd_.get ();
  }

  PinskyRinzelCA3Cell::gLd_type& PinskyRinzelCA3Cell::
  gLd ()
  {
    return this->gLd_.get ();
  }

  void PinskyRinzelCA3Cell::
  gLd (const gLd_type& x)
  {
    this->gLd_.set (x);
  }

  void PinskyRinzelCA3Cell::
  gLd (::std::unique_ptr< gLd_type > x)
  {
    this->gLd_.set (std::move (x));
  }

  const PinskyRinzelCA3Cell::gNa_type& PinskyRinzelCA3Cell::
  gNa () const
  {
    return this->gNa_.get ();
  }

  PinskyRinzelCA3Cell::gNa_type& PinskyRinzelCA3Cell::
  gNa ()
  {
    return this->gNa_.get ();
  }

  void PinskyRinzelCA3Cell::
  gNa (const gNa_type& x)
  {
    this->gNa_.set (x);
  }

  void PinskyRinzelCA3Cell::
  gNa (::std::unique_ptr< gNa_type > x)
  {
    this->gNa_.set (std::move (x));
  }

  const PinskyRinzelCA3Cell::gKdr_type& PinskyRinzelCA3Cell::
  gKdr () const
  {
    return this->gKdr_.get ();
  }

  PinskyRinzelCA3Cell::gKdr_type& PinskyRinzelCA3Cell::
  gKdr ()
  {
    return this->gKdr_.get ();
  }

  void PinskyRinzelCA3Cell::
  gKdr (const gKdr_type& x)
  {
    this->gKdr_.set (x);
  }

  void PinskyRinzelCA3Cell::
  gKdr (::std::unique_ptr< gKdr_type > x)
  {
    this->gKdr_.set (std::move (x));
  }

  const PinskyRinzelCA3Cell::gCa_type& PinskyRinzelCA3Cell::
  gCa () const
  {
    return this->gCa_.get ();
  }

  PinskyRinzelCA3Cell::gCa_type& PinskyRinzelCA3Cell::
  gCa ()
  {
    return this->gCa_.get ();
  }

  void PinskyRinzelCA3Cell::
  gCa (const gCa_type& x)
  {
    this->gCa_.set (x);
  }

  void PinskyRinzelCA3Cell::
  gCa (::std::unique_ptr< gCa_type > x)
  {
    this->gCa_.set (std::move (x));
  }

  const PinskyRinzelCA3Cell::gKahp_type& PinskyRinzelCA3Cell::
  gKahp () const
  {
    return this->gKahp_.get ();
  }

  PinskyRinzelCA3Cell::gKahp_type& PinskyRinzelCA3Cell::
  gKahp ()
  {
    return this->gKahp_.get ();
  }

  void PinskyRinzelCA3Cell::
  gKahp (const gKahp_type& x)
  {
    this->gKahp_.set (x);
  }

  void PinskyRinzelCA3Cell::
  gKahp (::std::unique_ptr< gKahp_type > x)
  {
    this->gKahp_.set (std::move (x));
  }

  const PinskyRinzelCA3Cell::gKC_type& PinskyRinzelCA3Cell::
  gKC () const
  {
    return this->gKC_.get ();
  }

  PinskyRinzelCA3Cell::gKC_type& PinskyRinzelCA3Cell::
  gKC ()
  {
    return this->gKC_.get ();
  }

  void PinskyRinzelCA3Cell::
  gKC (const gKC_type& x)
  {
    this->gKC_.set (x);
  }

  void PinskyRinzelCA3Cell::
  gKC (::std::unique_ptr< gKC_type > x)
  {
    this->gKC_.set (std::move (x));
  }

  const PinskyRinzelCA3Cell::gNmda_type& PinskyRinzelCA3Cell::
  gNmda () const
  {
    return this->gNmda_.get ();
  }

  PinskyRinzelCA3Cell::gNmda_type& PinskyRinzelCA3Cell::
  gNmda ()
  {
    return this->gNmda_.get ();
  }

  void PinskyRinzelCA3Cell::
  gNmda (const gNmda_type& x)
  {
    this->gNmda_.set (x);
  }

  void PinskyRinzelCA3Cell::
  gNmda (::std::unique_ptr< gNmda_type > x)
  {
    this->gNmda_.set (std::move (x));
  }

  const PinskyRinzelCA3Cell::gAmpa_type& PinskyRinzelCA3Cell::
  gAmpa () const
  {
    return this->gAmpa_.get ();
  }

  PinskyRinzelCA3Cell::gAmpa_type& PinskyRinzelCA3Cell::
  gAmpa ()
  {
    return this->gAmpa_.get ();
  }

  void PinskyRinzelCA3Cell::
  gAmpa (const gAmpa_type& x)
  {
    this->gAmpa_.set (x);
  }

  void PinskyRinzelCA3Cell::
  gAmpa (::std::unique_ptr< gAmpa_type > x)
  {
    this->gAmpa_.set (std::move (x));
  }

  const PinskyRinzelCA3Cell::eNa_type& PinskyRinzelCA3Cell::
  eNa () const
  {
    return this->eNa_.get ();
  }

  PinskyRinzelCA3Cell::eNa_type& PinskyRinzelCA3Cell::
  eNa ()
  {
    return this->eNa_.get ();
  }

  void PinskyRinzelCA3Cell::
  eNa (const eNa_type& x)
  {
    this->eNa_.set (x);
  }

  void PinskyRinzelCA3Cell::
  eNa (::std::unique_ptr< eNa_type > x)
  {
    this->eNa_.set (std::move (x));
  }

  const PinskyRinzelCA3Cell::eCa_type& PinskyRinzelCA3Cell::
  eCa () const
  {
    return this->eCa_.get ();
  }

  PinskyRinzelCA3Cell::eCa_type& PinskyRinzelCA3Cell::
  eCa ()
  {
    return this->eCa_.get ();
  }

  void PinskyRinzelCA3Cell::
  eCa (const eCa_type& x)
  {
    this->eCa_.set (x);
  }

  void PinskyRinzelCA3Cell::
  eCa (::std::unique_ptr< eCa_type > x)
  {
    this->eCa_.set (std::move (x));
  }

  const PinskyRinzelCA3Cell::eK_type& PinskyRinzelCA3Cell::
  eK () const
  {
    return this->eK_.get ();
  }

  PinskyRinzelCA3Cell::eK_type& PinskyRinzelCA3Cell::
  eK ()
  {
    return this->eK_.get ();
  }

  void PinskyRinzelCA3Cell::
  eK (const eK_type& x)
  {
    this->eK_.set (x);
  }

  void PinskyRinzelCA3Cell::
  eK (::std::unique_ptr< eK_type > x)
  {
    this->eK_.set (std::move (x));
  }

  const PinskyRinzelCA3Cell::eL_type& PinskyRinzelCA3Cell::
  eL () const
  {
    return this->eL_.get ();
  }

  PinskyRinzelCA3Cell::eL_type& PinskyRinzelCA3Cell::
  eL ()
  {
    return this->eL_.get ();
  }

  void PinskyRinzelCA3Cell::
  eL (const eL_type& x)
  {
    this->eL_.set (x);
  }

  void PinskyRinzelCA3Cell::
  eL (::std::unique_ptr< eL_type > x)
  {
    this->eL_.set (std::move (x));
  }

  const PinskyRinzelCA3Cell::qd0_type& PinskyRinzelCA3Cell::
  qd0 () const
  {
    return this->qd0_.get ();
  }

  PinskyRinzelCA3Cell::qd0_type& PinskyRinzelCA3Cell::
  qd0 ()
  {
    return this->qd0_.get ();
  }

  void PinskyRinzelCA3Cell::
  qd0 (const qd0_type& x)
  {
    this->qd0_.set (x);
  }

  void PinskyRinzelCA3Cell::
  qd0 (::std::unique_ptr< qd0_type > x)
  {
    this->qd0_.set (std::move (x));
  }

  const PinskyRinzelCA3Cell::pp_type& PinskyRinzelCA3Cell::
  pp () const
  {
    return this->pp_.get ();
  }

  PinskyRinzelCA3Cell::pp_type& PinskyRinzelCA3Cell::
  pp ()
  {
    return this->pp_.get ();
  }

  void PinskyRinzelCA3Cell::
  pp (const pp_type& x)
  {
    this->pp_.set (x);
  }

  void PinskyRinzelCA3Cell::
  pp (::std::unique_ptr< pp_type > x)
  {
    this->pp_.set (std::move (x));
  }

  const PinskyRinzelCA3Cell::alphac_type& PinskyRinzelCA3Cell::
  alphac () const
  {
    return this->alphac_.get ();
  }

  PinskyRinzelCA3Cell::alphac_type& PinskyRinzelCA3Cell::
  alphac ()
  {
    return this->alphac_.get ();
  }

  void PinskyRinzelCA3Cell::
  alphac (const alphac_type& x)
  {
    this->alphac_.set (x);
  }

  void PinskyRinzelCA3Cell::
  alphac (::std::unique_ptr< alphac_type > x)
  {
    this->alphac_.set (std::move (x));
  }

  const PinskyRinzelCA3Cell::betac_type& PinskyRinzelCA3Cell::
  betac () const
  {
    return this->betac_.get ();
  }

  PinskyRinzelCA3Cell::betac_type& PinskyRinzelCA3Cell::
  betac ()
  {
    return this->betac_.get ();
  }

  void PinskyRinzelCA3Cell::
  betac (const betac_type& x)
  {
    this->betac_.set (x);
  }

  void PinskyRinzelCA3Cell::
  betac (::std::unique_ptr< betac_type > x)
  {
    this->betac_.set (std::move (x));
  }

  const PinskyRinzelCA3Cell::cm_type& PinskyRinzelCA3Cell::
  cm () const
  {
    return this->cm_.get ();
  }

  PinskyRinzelCA3Cell::cm_type& PinskyRinzelCA3Cell::
  cm ()
  {
    return this->cm_.get ();
  }

  void PinskyRinzelCA3Cell::
  cm (const cm_type& x)
  {
    this->cm_.set (x);
  }

  void PinskyRinzelCA3Cell::
  cm (::std::unique_ptr< cm_type > x)
  {
    this->cm_.set (std::move (x));
  }


  // Cell
  // 

  const Cell::morphology_optional& Cell::
  morphology () const
  {
    return this->morphology_;
  }

  Cell::morphology_optional& Cell::
  morphology ()
  {
    return this->morphology_;
  }

  void Cell::
  morphology (const morphology_type& x)
  {
    this->morphology_.set (x);
  }

  void Cell::
  morphology (const morphology_optional& x)
  {
    this->morphology_ = x;
  }

  void Cell::
  morphology (::std::unique_ptr< morphology_type > x)
  {
    this->morphology_.set (std::move (x));
  }

  const Cell::biophysicalProperties_optional& Cell::
  biophysicalProperties () const
  {
    return this->biophysicalProperties_;
  }

  Cell::biophysicalProperties_optional& Cell::
  biophysicalProperties ()
  {
    return this->biophysicalProperties_;
  }

  void Cell::
  biophysicalProperties (const biophysicalProperties_type& x)
  {
    this->biophysicalProperties_.set (x);
  }

  void Cell::
  biophysicalProperties (const biophysicalProperties_optional& x)
  {
    this->biophysicalProperties_ = x;
  }

  void Cell::
  biophysicalProperties (::std::unique_ptr< biophysicalProperties_type > x)
  {
    this->biophysicalProperties_.set (std::move (x));
  }

  const Cell::morphology1_optional& Cell::
  morphology1 () const
  {
    return this->morphology1_;
  }

  Cell::morphology1_optional& Cell::
  morphology1 ()
  {
    return this->morphology1_;
  }

  void Cell::
  morphology1 (const morphology1_type& x)
  {
    this->morphology1_.set (x);
  }

  void Cell::
  morphology1 (const morphology1_optional& x)
  {
    this->morphology1_ = x;
  }

  void Cell::
  morphology1 (::std::unique_ptr< morphology1_type > x)
  {
    this->morphology1_.set (std::move (x));
  }

  const Cell::biophysicalProperties1_optional& Cell::
  biophysicalProperties1 () const
  {
    return this->biophysicalProperties1_;
  }

  Cell::biophysicalProperties1_optional& Cell::
  biophysicalProperties1 ()
  {
    return this->biophysicalProperties1_;
  }

  void Cell::
  biophysicalProperties1 (const biophysicalProperties1_type& x)
  {
    this->biophysicalProperties1_.set (x);
  }

  void Cell::
  biophysicalProperties1 (const biophysicalProperties1_optional& x)
  {
    this->biophysicalProperties1_ = x;
  }

  void Cell::
  biophysicalProperties1 (::std::unique_ptr< biophysicalProperties1_type > x)
  {
    this->biophysicalProperties1_.set (std::move (x));
  }


  // Cell2CaPools
  // 

  const Cell2CaPools::biophysicalProperties2CaPools_optional& Cell2CaPools::
  biophysicalProperties2CaPools () const
  {
    return this->biophysicalProperties2CaPools_;
  }

  Cell2CaPools::biophysicalProperties2CaPools_optional& Cell2CaPools::
  biophysicalProperties2CaPools ()
  {
    return this->biophysicalProperties2CaPools_;
  }

  void Cell2CaPools::
  biophysicalProperties2CaPools (const biophysicalProperties2CaPools_type& x)
  {
    this->biophysicalProperties2CaPools_.set (x);
  }

  void Cell2CaPools::
  biophysicalProperties2CaPools (const biophysicalProperties2CaPools_optional& x)
  {
    this->biophysicalProperties2CaPools_ = x;
  }

  void Cell2CaPools::
  biophysicalProperties2CaPools (::std::unique_ptr< biophysicalProperties2CaPools_type > x)
  {
    this->biophysicalProperties2CaPools_.set (std::move (x));
  }


  // Morphology_base
  // 

  const Morphology_base::segment_sequence& Morphology_base::
  segment () const
  {
    return this->segment_;
  }

  Morphology_base::segment_sequence& Morphology_base::
  segment ()
  {
    return this->segment_;
  }

  void Morphology_base::
  segment (const segment_sequence& s)
  {
    this->segment_ = s;
  }

  const Morphology_base::segmentGroup_sequence& Morphology_base::
  segmentGroup () const
  {
    return this->segmentGroup_;
  }

  Morphology_base::segmentGroup_sequence& Morphology_base::
  segmentGroup ()
  {
    return this->segmentGroup_;
  }

  void Morphology_base::
  segmentGroup (const segmentGroup_sequence& s)
  {
    this->segmentGroup_ = s;
  }


  // BaseNonNegativeIntegerId
  // 

  const BaseNonNegativeIntegerId::id_type& BaseNonNegativeIntegerId::
  id () const
  {
    return this->id_.get ();
  }

  BaseNonNegativeIntegerId::id_type& BaseNonNegativeIntegerId::
  id ()
  {
    return this->id_.get ();
  }

  void BaseNonNegativeIntegerId::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void BaseNonNegativeIntegerId::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // Segment_base
  // 

  const Segment_base::parent_optional& Segment_base::
  parent () const
  {
    return this->parent_;
  }

  Segment_base::parent_optional& Segment_base::
  parent ()
  {
    return this->parent_;
  }

  void Segment_base::
  parent (const parent_type& x)
  {
    this->parent_.set (x);
  }

  void Segment_base::
  parent (const parent_optional& x)
  {
    this->parent_ = x;
  }

  void Segment_base::
  parent (::std::unique_ptr< parent_type > x)
  {
    this->parent_.set (std::move (x));
  }

  const Segment_base::proximal_optional& Segment_base::
  proximal () const
  {
    return this->proximal_;
  }

  Segment_base::proximal_optional& Segment_base::
  proximal ()
  {
    return this->proximal_;
  }

  void Segment_base::
  proximal (const proximal_type& x)
  {
    this->proximal_.set (x);
  }

  void Segment_base::
  proximal (const proximal_optional& x)
  {
    this->proximal_ = x;
  }

  void Segment_base::
  proximal (::std::unique_ptr< proximal_type > x)
  {
    this->proximal_.set (std::move (x));
  }

  const Segment_base::distal_type& Segment_base::
  distal () const
  {
    return this->distal_.get ();
  }

  Segment_base::distal_type& Segment_base::
  distal ()
  {
    return this->distal_.get ();
  }

  void Segment_base::
  distal (const distal_type& x)
  {
    this->distal_.set (x);
  }

  void Segment_base::
  distal (::std::unique_ptr< distal_type > x)
  {
    this->distal_.set (std::move (x));
  }

  const Segment_base::name_optional& Segment_base::
  name () const
  {
    return this->name_;
  }

  Segment_base::name_optional& Segment_base::
  name ()
  {
    return this->name_;
  }

  void Segment_base::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void Segment_base::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void Segment_base::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }


  // SegmentParent
  // 

  const SegmentParent::segment_type& SegmentParent::
  segment () const
  {
    return this->segment_.get ();
  }

  SegmentParent::segment_type& SegmentParent::
  segment ()
  {
    return this->segment_.get ();
  }

  void SegmentParent::
  segment (const segment_type& x)
  {
    this->segment_.set (x);
  }

  void SegmentParent::
  segment (::std::unique_ptr< segment_type > x)
  {
    this->segment_.set (std::move (x));
  }

  const SegmentParent::fractionAlong_type& SegmentParent::
  fractionAlong () const
  {
    return this->fractionAlong_.get ();
  }

  SegmentParent::fractionAlong_type& SegmentParent::
  fractionAlong ()
  {
    return this->fractionAlong_.get ();
  }

  void SegmentParent::
  fractionAlong (const fractionAlong_type& x)
  {
    this->fractionAlong_.set (x);
  }

  void SegmentParent::
  fractionAlong (::std::unique_ptr< fractionAlong_type > x)
  {
    this->fractionAlong_.set (std::move (x));
  }

  SegmentParent::fractionAlong_type SegmentParent::
  fractionAlong_default_value ()
  {
    return fractionAlong_type (1.0F);
  }


  // Point3DWithDiam
  // 

  const Point3DWithDiam::x_type& Point3DWithDiam::
  x () const
  {
    return this->x_.get ();
  }

  Point3DWithDiam::x_type& Point3DWithDiam::
  x ()
  {
    return this->x_.get ();
  }

  void Point3DWithDiam::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  const Point3DWithDiam::y_type& Point3DWithDiam::
  y () const
  {
    return this->y_.get ();
  }

  Point3DWithDiam::y_type& Point3DWithDiam::
  y ()
  {
    return this->y_.get ();
  }

  void Point3DWithDiam::
  y (const y_type& x)
  {
    this->y_.set (x);
  }

  const Point3DWithDiam::z_type& Point3DWithDiam::
  z () const
  {
    return this->z_.get ();
  }

  Point3DWithDiam::z_type& Point3DWithDiam::
  z ()
  {
    return this->z_.get ();
  }

  void Point3DWithDiam::
  z (const z_type& x)
  {
    this->z_.set (x);
  }

  const Point3DWithDiam::diameter_type& Point3DWithDiam::
  diameter () const
  {
    return this->diameter_.get ();
  }

  Point3DWithDiam::diameter_type& Point3DWithDiam::
  diameter ()
  {
    return this->diameter_.get ();
  }

  void Point3DWithDiam::
  diameter (const diameter_type& x)
  {
    this->diameter_.set (x);
  }

  void Point3DWithDiam::
  diameter (::std::unique_ptr< diameter_type > x)
  {
    this->diameter_.set (std::move (x));
  }


  // SegmentGroup
  // 

  const SegmentGroup::notes_optional& SegmentGroup::
  notes () const
  {
    return this->notes_;
  }

  SegmentGroup::notes_optional& SegmentGroup::
  notes ()
  {
    return this->notes_;
  }

  void SegmentGroup::
  notes (const notes_type& x)
  {
    this->notes_.set (x);
  }

  void SegmentGroup::
  notes (const notes_optional& x)
  {
    this->notes_ = x;
  }

  void SegmentGroup::
  notes (::std::unique_ptr< notes_type > x)
  {
    this->notes_.set (std::move (x));
  }

  const SegmentGroup::property_sequence& SegmentGroup::
  property () const
  {
    return this->property_;
  }

  SegmentGroup::property_sequence& SegmentGroup::
  property ()
  {
    return this->property_;
  }

  void SegmentGroup::
  property (const property_sequence& s)
  {
    this->property_ = s;
  }

  const SegmentGroup::annotation_optional& SegmentGroup::
  annotation () const
  {
    return this->annotation_;
  }

  SegmentGroup::annotation_optional& SegmentGroup::
  annotation ()
  {
    return this->annotation_;
  }

  void SegmentGroup::
  annotation (const annotation_type& x)
  {
    this->annotation_.set (x);
  }

  void SegmentGroup::
  annotation (const annotation_optional& x)
  {
    this->annotation_ = x;
  }

  void SegmentGroup::
  annotation (::std::unique_ptr< annotation_type > x)
  {
    this->annotation_.set (std::move (x));
  }

  const SegmentGroup::member_sequence& SegmentGroup::
  member () const
  {
    return this->member_;
  }

  SegmentGroup::member_sequence& SegmentGroup::
  member ()
  {
    return this->member_;
  }

  void SegmentGroup::
  member (const member_sequence& s)
  {
    this->member_ = s;
  }

  const SegmentGroup::include_sequence& SegmentGroup::
  include () const
  {
    return this->include_;
  }

  SegmentGroup::include_sequence& SegmentGroup::
  include ()
  {
    return this->include_;
  }

  void SegmentGroup::
  include (const include_sequence& s)
  {
    this->include_ = s;
  }

  const SegmentGroup::path_sequence& SegmentGroup::
  path () const
  {
    return this->path_;
  }

  SegmentGroup::path_sequence& SegmentGroup::
  path ()
  {
    return this->path_;
  }

  void SegmentGroup::
  path (const path_sequence& s)
  {
    this->path_ = s;
  }

  const SegmentGroup::subTree_sequence& SegmentGroup::
  subTree () const
  {
    return this->subTree_;
  }

  SegmentGroup::subTree_sequence& SegmentGroup::
  subTree ()
  {
    return this->subTree_;
  }

  void SegmentGroup::
  subTree (const subTree_sequence& s)
  {
    this->subTree_ = s;
  }

  const SegmentGroup::inhomogeneousParameter_sequence& SegmentGroup::
  inhomogeneousParameter () const
  {
    return this->inhomogeneousParameter_;
  }

  SegmentGroup::inhomogeneousParameter_sequence& SegmentGroup::
  inhomogeneousParameter ()
  {
    return this->inhomogeneousParameter_;
  }

  void SegmentGroup::
  inhomogeneousParameter (const inhomogeneousParameter_sequence& s)
  {
    this->inhomogeneousParameter_ = s;
  }


  // InhomogeneousParameter
  // 

  const InhomogeneousParameter::proximal_optional& InhomogeneousParameter::
  proximal () const
  {
    return this->proximal_;
  }

  InhomogeneousParameter::proximal_optional& InhomogeneousParameter::
  proximal ()
  {
    return this->proximal_;
  }

  void InhomogeneousParameter::
  proximal (const proximal_type& x)
  {
    this->proximal_.set (x);
  }

  void InhomogeneousParameter::
  proximal (const proximal_optional& x)
  {
    this->proximal_ = x;
  }

  void InhomogeneousParameter::
  proximal (::std::unique_ptr< proximal_type > x)
  {
    this->proximal_.set (std::move (x));
  }

  const InhomogeneousParameter::distal_optional& InhomogeneousParameter::
  distal () const
  {
    return this->distal_;
  }

  InhomogeneousParameter::distal_optional& InhomogeneousParameter::
  distal ()
  {
    return this->distal_;
  }

  void InhomogeneousParameter::
  distal (const distal_type& x)
  {
    this->distal_.set (x);
  }

  void InhomogeneousParameter::
  distal (const distal_optional& x)
  {
    this->distal_ = x;
  }

  void InhomogeneousParameter::
  distal (::std::unique_ptr< distal_type > x)
  {
    this->distal_.set (std::move (x));
  }

  const InhomogeneousParameter::variable_type& InhomogeneousParameter::
  variable () const
  {
    return this->variable_.get ();
  }

  InhomogeneousParameter::variable_type& InhomogeneousParameter::
  variable ()
  {
    return this->variable_.get ();
  }

  void InhomogeneousParameter::
  variable (const variable_type& x)
  {
    this->variable_.set (x);
  }

  void InhomogeneousParameter::
  variable (::std::unique_ptr< variable_type > x)
  {
    this->variable_.set (std::move (x));
  }

  const InhomogeneousParameter::metric_type& InhomogeneousParameter::
  metric () const
  {
    return this->metric_.get ();
  }

  InhomogeneousParameter::metric_type& InhomogeneousParameter::
  metric ()
  {
    return this->metric_.get ();
  }

  void InhomogeneousParameter::
  metric (const metric_type& x)
  {
    this->metric_.set (x);
  }

  void InhomogeneousParameter::
  metric (::std::unique_ptr< metric_type > x)
  {
    this->metric_.set (std::move (x));
  }


  // Metric
  // 

  Metric::
  Metric (value v)
  : ::xml_schema::string (_xsd_Metric_literals_[v])
  {
  }

  Metric::
  Metric (const char* v)
  : ::xml_schema::string (v)
  {
  }

  Metric::
  Metric (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  Metric::
  Metric (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  Metric::
  Metric (const Metric& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  Metric& Metric::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_Metric_literals_[v]);

    return *this;
  }


  // ProximalDetails
  // 

  const ProximalDetails::translationStart_type& ProximalDetails::
  translationStart () const
  {
    return this->translationStart_.get ();
  }

  ProximalDetails::translationStart_type& ProximalDetails::
  translationStart ()
  {
    return this->translationStart_.get ();
  }

  void ProximalDetails::
  translationStart (const translationStart_type& x)
  {
    this->translationStart_.set (x);
  }


  // DistalDetails
  // 

  const DistalDetails::normalizationEnd_type& DistalDetails::
  normalizationEnd () const
  {
    return this->normalizationEnd_.get ();
  }

  DistalDetails::normalizationEnd_type& DistalDetails::
  normalizationEnd ()
  {
    return this->normalizationEnd_.get ();
  }

  void DistalDetails::
  normalizationEnd (const normalizationEnd_type& x)
  {
    this->normalizationEnd_.set (x);
  }


  // Member
  // 

  const Member::segment_type& Member::
  segment () const
  {
    return this->segment_.get ();
  }

  Member::segment_type& Member::
  segment ()
  {
    return this->segment_.get ();
  }

  void Member::
  segment (const segment_type& x)
  {
    this->segment_.set (x);
  }

  void Member::
  segment (::std::unique_ptr< segment_type > x)
  {
    this->segment_.set (std::move (x));
  }


  // Include
  // 

  const Include::segmentGroup_type& Include::
  segmentGroup () const
  {
    return this->segmentGroup_.get ();
  }

  Include::segmentGroup_type& Include::
  segmentGroup ()
  {
    return this->segmentGroup_.get ();
  }

  void Include::
  segmentGroup (const segmentGroup_type& x)
  {
    this->segmentGroup_.set (x);
  }

  void Include::
  segmentGroup (::std::unique_ptr< segmentGroup_type > x)
  {
    this->segmentGroup_.set (std::move (x));
  }


  // Path
  // 

  const Path::from_optional& Path::
  from () const
  {
    return this->from_;
  }

  Path::from_optional& Path::
  from ()
  {
    return this->from_;
  }

  void Path::
  from (const from_type& x)
  {
    this->from_.set (x);
  }

  void Path::
  from (const from_optional& x)
  {
    this->from_ = x;
  }

  void Path::
  from (::std::unique_ptr< from_type > x)
  {
    this->from_.set (std::move (x));
  }

  const Path::to_optional& Path::
  to () const
  {
    return this->to_;
  }

  Path::to_optional& Path::
  to ()
  {
    return this->to_;
  }

  void Path::
  to (const to_type& x)
  {
    this->to_.set (x);
  }

  void Path::
  to (const to_optional& x)
  {
    this->to_ = x;
  }

  void Path::
  to (::std::unique_ptr< to_type > x)
  {
    this->to_.set (std::move (x));
  }


  // SubTree
  // 

  const SubTree::from_optional& SubTree::
  from () const
  {
    return this->from_;
  }

  SubTree::from_optional& SubTree::
  from ()
  {
    return this->from_;
  }

  void SubTree::
  from (const from_type& x)
  {
    this->from_.set (x);
  }

  void SubTree::
  from (const from_optional& x)
  {
    this->from_ = x;
  }

  void SubTree::
  from (::std::unique_ptr< from_type > x)
  {
    this->from_.set (std::move (x));
  }

  const SubTree::to_optional& SubTree::
  to () const
  {
    return this->to_;
  }

  SubTree::to_optional& SubTree::
  to ()
  {
    return this->to_;
  }

  void SubTree::
  to (const to_type& x)
  {
    this->to_.set (x);
  }

  void SubTree::
  to (const to_optional& x)
  {
    this->to_ = x;
  }

  void SubTree::
  to (::std::unique_ptr< to_type > x)
  {
    this->to_.set (std::move (x));
  }


  // SegmentEndPoint
  // 

  const SegmentEndPoint::segment_type& SegmentEndPoint::
  segment () const
  {
    return this->segment_.get ();
  }

  SegmentEndPoint::segment_type& SegmentEndPoint::
  segment ()
  {
    return this->segment_.get ();
  }

  void SegmentEndPoint::
  segment (const segment_type& x)
  {
    this->segment_.set (x);
  }

  void SegmentEndPoint::
  segment (::std::unique_ptr< segment_type > x)
  {
    this->segment_.set (std::move (x));
  }


  // BiophysicalProperties
  // 

  const BiophysicalProperties::membraneProperties_type& BiophysicalProperties::
  membraneProperties () const
  {
    return this->membraneProperties_.get ();
  }

  BiophysicalProperties::membraneProperties_type& BiophysicalProperties::
  membraneProperties ()
  {
    return this->membraneProperties_.get ();
  }

  void BiophysicalProperties::
  membraneProperties (const membraneProperties_type& x)
  {
    this->membraneProperties_.set (x);
  }

  void BiophysicalProperties::
  membraneProperties (::std::unique_ptr< membraneProperties_type > x)
  {
    this->membraneProperties_.set (std::move (x));
  }

  const BiophysicalProperties::intracellularProperties_optional& BiophysicalProperties::
  intracellularProperties () const
  {
    return this->intracellularProperties_;
  }

  BiophysicalProperties::intracellularProperties_optional& BiophysicalProperties::
  intracellularProperties ()
  {
    return this->intracellularProperties_;
  }

  void BiophysicalProperties::
  intracellularProperties (const intracellularProperties_type& x)
  {
    this->intracellularProperties_.set (x);
  }

  void BiophysicalProperties::
  intracellularProperties (const intracellularProperties_optional& x)
  {
    this->intracellularProperties_ = x;
  }

  void BiophysicalProperties::
  intracellularProperties (::std::unique_ptr< intracellularProperties_type > x)
  {
    this->intracellularProperties_.set (std::move (x));
  }

  const BiophysicalProperties::extracellularProperties_optional& BiophysicalProperties::
  extracellularProperties () const
  {
    return this->extracellularProperties_;
  }

  BiophysicalProperties::extracellularProperties_optional& BiophysicalProperties::
  extracellularProperties ()
  {
    return this->extracellularProperties_;
  }

  void BiophysicalProperties::
  extracellularProperties (const extracellularProperties_type& x)
  {
    this->extracellularProperties_.set (x);
  }

  void BiophysicalProperties::
  extracellularProperties (const extracellularProperties_optional& x)
  {
    this->extracellularProperties_ = x;
  }

  void BiophysicalProperties::
  extracellularProperties (::std::unique_ptr< extracellularProperties_type > x)
  {
    this->extracellularProperties_.set (std::move (x));
  }


  // BiophysicalProperties2CaPools
  // 

  const BiophysicalProperties2CaPools::membraneProperties2CaPools_type& BiophysicalProperties2CaPools::
  membraneProperties2CaPools () const
  {
    return this->membraneProperties2CaPools_.get ();
  }

  BiophysicalProperties2CaPools::membraneProperties2CaPools_type& BiophysicalProperties2CaPools::
  membraneProperties2CaPools ()
  {
    return this->membraneProperties2CaPools_.get ();
  }

  void BiophysicalProperties2CaPools::
  membraneProperties2CaPools (const membraneProperties2CaPools_type& x)
  {
    this->membraneProperties2CaPools_.set (x);
  }

  void BiophysicalProperties2CaPools::
  membraneProperties2CaPools (::std::unique_ptr< membraneProperties2CaPools_type > x)
  {
    this->membraneProperties2CaPools_.set (std::move (x));
  }

  const BiophysicalProperties2CaPools::intracellularProperties2CaPools_optional& BiophysicalProperties2CaPools::
  intracellularProperties2CaPools () const
  {
    return this->intracellularProperties2CaPools_;
  }

  BiophysicalProperties2CaPools::intracellularProperties2CaPools_optional& BiophysicalProperties2CaPools::
  intracellularProperties2CaPools ()
  {
    return this->intracellularProperties2CaPools_;
  }

  void BiophysicalProperties2CaPools::
  intracellularProperties2CaPools (const intracellularProperties2CaPools_type& x)
  {
    this->intracellularProperties2CaPools_.set (x);
  }

  void BiophysicalProperties2CaPools::
  intracellularProperties2CaPools (const intracellularProperties2CaPools_optional& x)
  {
    this->intracellularProperties2CaPools_ = x;
  }

  void BiophysicalProperties2CaPools::
  intracellularProperties2CaPools (::std::unique_ptr< intracellularProperties2CaPools_type > x)
  {
    this->intracellularProperties2CaPools_.set (std::move (x));
  }

  const BiophysicalProperties2CaPools::extracellularProperties_optional& BiophysicalProperties2CaPools::
  extracellularProperties () const
  {
    return this->extracellularProperties_;
  }

  BiophysicalProperties2CaPools::extracellularProperties_optional& BiophysicalProperties2CaPools::
  extracellularProperties ()
  {
    return this->extracellularProperties_;
  }

  void BiophysicalProperties2CaPools::
  extracellularProperties (const extracellularProperties_type& x)
  {
    this->extracellularProperties_.set (x);
  }

  void BiophysicalProperties2CaPools::
  extracellularProperties (const extracellularProperties_optional& x)
  {
    this->extracellularProperties_ = x;
  }

  void BiophysicalProperties2CaPools::
  extracellularProperties (::std::unique_ptr< extracellularProperties_type > x)
  {
    this->extracellularProperties_.set (std::move (x));
  }


  // MembraneProperties
  // 

  const MembraneProperties::channelPopulation_sequence& MembraneProperties::
  channelPopulation () const
  {
    return this->channelPopulation_;
  }

  MembraneProperties::channelPopulation_sequence& MembraneProperties::
  channelPopulation ()
  {
    return this->channelPopulation_;
  }

  void MembraneProperties::
  channelPopulation (const channelPopulation_sequence& s)
  {
    this->channelPopulation_ = s;
  }

  const MembraneProperties::channelDensity_sequence& MembraneProperties::
  channelDensity () const
  {
    return this->channelDensity_;
  }

  MembraneProperties::channelDensity_sequence& MembraneProperties::
  channelDensity ()
  {
    return this->channelDensity_;
  }

  void MembraneProperties::
  channelDensity (const channelDensity_sequence& s)
  {
    this->channelDensity_ = s;
  }

  const MembraneProperties::channelDensityVShift_sequence& MembraneProperties::
  channelDensityVShift () const
  {
    return this->channelDensityVShift_;
  }

  MembraneProperties::channelDensityVShift_sequence& MembraneProperties::
  channelDensityVShift ()
  {
    return this->channelDensityVShift_;
  }

  void MembraneProperties::
  channelDensityVShift (const channelDensityVShift_sequence& s)
  {
    this->channelDensityVShift_ = s;
  }

  const MembraneProperties::channelDensityNernst_sequence& MembraneProperties::
  channelDensityNernst () const
  {
    return this->channelDensityNernst_;
  }

  MembraneProperties::channelDensityNernst_sequence& MembraneProperties::
  channelDensityNernst ()
  {
    return this->channelDensityNernst_;
  }

  void MembraneProperties::
  channelDensityNernst (const channelDensityNernst_sequence& s)
  {
    this->channelDensityNernst_ = s;
  }

  const MembraneProperties::channelDensityGHK_sequence& MembraneProperties::
  channelDensityGHK () const
  {
    return this->channelDensityGHK_;
  }

  MembraneProperties::channelDensityGHK_sequence& MembraneProperties::
  channelDensityGHK ()
  {
    return this->channelDensityGHK_;
  }

  void MembraneProperties::
  channelDensityGHK (const channelDensityGHK_sequence& s)
  {
    this->channelDensityGHK_ = s;
  }

  const MembraneProperties::channelDensityGHK2_sequence& MembraneProperties::
  channelDensityGHK2 () const
  {
    return this->channelDensityGHK2_;
  }

  MembraneProperties::channelDensityGHK2_sequence& MembraneProperties::
  channelDensityGHK2 ()
  {
    return this->channelDensityGHK2_;
  }

  void MembraneProperties::
  channelDensityGHK2 (const channelDensityGHK2_sequence& s)
  {
    this->channelDensityGHK2_ = s;
  }

  const MembraneProperties::channelDensityNonUniform_sequence& MembraneProperties::
  channelDensityNonUniform () const
  {
    return this->channelDensityNonUniform_;
  }

  MembraneProperties::channelDensityNonUniform_sequence& MembraneProperties::
  channelDensityNonUniform ()
  {
    return this->channelDensityNonUniform_;
  }

  void MembraneProperties::
  channelDensityNonUniform (const channelDensityNonUniform_sequence& s)
  {
    this->channelDensityNonUniform_ = s;
  }

  const MembraneProperties::channelDensityNonUniformNernst_sequence& MembraneProperties::
  channelDensityNonUniformNernst () const
  {
    return this->channelDensityNonUniformNernst_;
  }

  MembraneProperties::channelDensityNonUniformNernst_sequence& MembraneProperties::
  channelDensityNonUniformNernst ()
  {
    return this->channelDensityNonUniformNernst_;
  }

  void MembraneProperties::
  channelDensityNonUniformNernst (const channelDensityNonUniformNernst_sequence& s)
  {
    this->channelDensityNonUniformNernst_ = s;
  }

  const MembraneProperties::channelDensityNonUniformGHK_sequence& MembraneProperties::
  channelDensityNonUniformGHK () const
  {
    return this->channelDensityNonUniformGHK_;
  }

  MembraneProperties::channelDensityNonUniformGHK_sequence& MembraneProperties::
  channelDensityNonUniformGHK ()
  {
    return this->channelDensityNonUniformGHK_;
  }

  void MembraneProperties::
  channelDensityNonUniformGHK (const channelDensityNonUniformGHK_sequence& s)
  {
    this->channelDensityNonUniformGHK_ = s;
  }

  const MembraneProperties::spikeThresh_sequence& MembraneProperties::
  spikeThresh () const
  {
    return this->spikeThresh_;
  }

  MembraneProperties::spikeThresh_sequence& MembraneProperties::
  spikeThresh ()
  {
    return this->spikeThresh_;
  }

  void MembraneProperties::
  spikeThresh (const spikeThresh_sequence& s)
  {
    this->spikeThresh_ = s;
  }

  const MembraneProperties::specificCapacitance_sequence& MembraneProperties::
  specificCapacitance () const
  {
    return this->specificCapacitance_;
  }

  MembraneProperties::specificCapacitance_sequence& MembraneProperties::
  specificCapacitance ()
  {
    return this->specificCapacitance_;
  }

  void MembraneProperties::
  specificCapacitance (const specificCapacitance_sequence& s)
  {
    this->specificCapacitance_ = s;
  }

  const MembraneProperties::initMembPotential_sequence& MembraneProperties::
  initMembPotential () const
  {
    return this->initMembPotential_;
  }

  MembraneProperties::initMembPotential_sequence& MembraneProperties::
  initMembPotential ()
  {
    return this->initMembPotential_;
  }

  void MembraneProperties::
  initMembPotential (const initMembPotential_sequence& s)
  {
    this->initMembPotential_ = s;
  }


  // MembraneProperties2CaPools
  // 

  const MembraneProperties2CaPools::channelDensityNernstCa2_sequence& MembraneProperties2CaPools::
  channelDensityNernstCa2 () const
  {
    return this->channelDensityNernstCa2_;
  }

  MembraneProperties2CaPools::channelDensityNernstCa2_sequence& MembraneProperties2CaPools::
  channelDensityNernstCa2 ()
  {
    return this->channelDensityNernstCa2_;
  }

  void MembraneProperties2CaPools::
  channelDensityNernstCa2 (const channelDensityNernstCa2_sequence& s)
  {
    this->channelDensityNernstCa2_ = s;
  }


  // SpikeThresh
  // 

  const SpikeThresh::value_type& SpikeThresh::
  value () const
  {
    return this->value_.get ();
  }

  SpikeThresh::value_type& SpikeThresh::
  value ()
  {
    return this->value_.get ();
  }

  void SpikeThresh::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void SpikeThresh::
  value (::std::unique_ptr< value_type > x)
  {
    this->value_.set (std::move (x));
  }

  const SpikeThresh::segmentGroup_type& SpikeThresh::
  segmentGroup () const
  {
    return this->segmentGroup_.get ();
  }

  SpikeThresh::segmentGroup_type& SpikeThresh::
  segmentGroup ()
  {
    return this->segmentGroup_.get ();
  }

  void SpikeThresh::
  segmentGroup (const segmentGroup_type& x)
  {
    this->segmentGroup_.set (x);
  }

  void SpikeThresh::
  segmentGroup (::std::unique_ptr< segmentGroup_type > x)
  {
    this->segmentGroup_.set (std::move (x));
  }

  const SpikeThresh::segmentGroup_type& SpikeThresh::
  segmentGroup_default_value ()
  {
    return segmentGroup_default_value_;
  }


  // SpecificCapacitance
  // 

  const SpecificCapacitance::value_type& SpecificCapacitance::
  value () const
  {
    return this->value_.get ();
  }

  SpecificCapacitance::value_type& SpecificCapacitance::
  value ()
  {
    return this->value_.get ();
  }

  void SpecificCapacitance::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void SpecificCapacitance::
  value (::std::unique_ptr< value_type > x)
  {
    this->value_.set (std::move (x));
  }

  const SpecificCapacitance::segmentGroup_type& SpecificCapacitance::
  segmentGroup () const
  {
    return this->segmentGroup_.get ();
  }

  SpecificCapacitance::segmentGroup_type& SpecificCapacitance::
  segmentGroup ()
  {
    return this->segmentGroup_.get ();
  }

  void SpecificCapacitance::
  segmentGroup (const segmentGroup_type& x)
  {
    this->segmentGroup_.set (x);
  }

  void SpecificCapacitance::
  segmentGroup (::std::unique_ptr< segmentGroup_type > x)
  {
    this->segmentGroup_.set (std::move (x));
  }

  const SpecificCapacitance::segmentGroup_type& SpecificCapacitance::
  segmentGroup_default_value ()
  {
    return segmentGroup_default_value_;
  }


  // InitMembPotential
  // 

  const InitMembPotential::value_type& InitMembPotential::
  value () const
  {
    return this->value_.get ();
  }

  InitMembPotential::value_type& InitMembPotential::
  value ()
  {
    return this->value_.get ();
  }

  void InitMembPotential::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void InitMembPotential::
  value (::std::unique_ptr< value_type > x)
  {
    this->value_.set (std::move (x));
  }

  const InitMembPotential::segmentGroup_type& InitMembPotential::
  segmentGroup () const
  {
    return this->segmentGroup_.get ();
  }

  InitMembPotential::segmentGroup_type& InitMembPotential::
  segmentGroup ()
  {
    return this->segmentGroup_.get ();
  }

  void InitMembPotential::
  segmentGroup (const segmentGroup_type& x)
  {
    this->segmentGroup_.set (x);
  }

  void InitMembPotential::
  segmentGroup (::std::unique_ptr< segmentGroup_type > x)
  {
    this->segmentGroup_.set (std::move (x));
  }

  const InitMembPotential::segmentGroup_type& InitMembPotential::
  segmentGroup_default_value ()
  {
    return segmentGroup_default_value_;
  }


  // Resistivity
  // 

  const Resistivity::value_type& Resistivity::
  value () const
  {
    return this->value_.get ();
  }

  Resistivity::value_type& Resistivity::
  value ()
  {
    return this->value_.get ();
  }

  void Resistivity::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Resistivity::
  value (::std::unique_ptr< value_type > x)
  {
    this->value_.set (std::move (x));
  }

  const Resistivity::segmentGroup_type& Resistivity::
  segmentGroup () const
  {
    return this->segmentGroup_.get ();
  }

  Resistivity::segmentGroup_type& Resistivity::
  segmentGroup ()
  {
    return this->segmentGroup_.get ();
  }

  void Resistivity::
  segmentGroup (const segmentGroup_type& x)
  {
    this->segmentGroup_.set (x);
  }

  void Resistivity::
  segmentGroup (::std::unique_ptr< segmentGroup_type > x)
  {
    this->segmentGroup_.set (std::move (x));
  }

  const Resistivity::segmentGroup_type& Resistivity::
  segmentGroup_default_value ()
  {
    return segmentGroup_default_value_;
  }


  // ChannelPopulation
  // 

  const ChannelPopulation::variableParameter_sequence& ChannelPopulation::
  variableParameter () const
  {
    return this->variableParameter_;
  }

  ChannelPopulation::variableParameter_sequence& ChannelPopulation::
  variableParameter ()
  {
    return this->variableParameter_;
  }

  void ChannelPopulation::
  variableParameter (const variableParameter_sequence& s)
  {
    this->variableParameter_ = s;
  }

  const ChannelPopulation::ionChannel_type& ChannelPopulation::
  ionChannel () const
  {
    return this->ionChannel_.get ();
  }

  ChannelPopulation::ionChannel_type& ChannelPopulation::
  ionChannel ()
  {
    return this->ionChannel_.get ();
  }

  void ChannelPopulation::
  ionChannel (const ionChannel_type& x)
  {
    this->ionChannel_.set (x);
  }

  void ChannelPopulation::
  ionChannel (::std::unique_ptr< ionChannel_type > x)
  {
    this->ionChannel_.set (std::move (x));
  }

  const ChannelPopulation::number_type& ChannelPopulation::
  number () const
  {
    return this->number_.get ();
  }

  ChannelPopulation::number_type& ChannelPopulation::
  number ()
  {
    return this->number_.get ();
  }

  void ChannelPopulation::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void ChannelPopulation::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const ChannelPopulation::erev_type& ChannelPopulation::
  erev () const
  {
    return this->erev_.get ();
  }

  ChannelPopulation::erev_type& ChannelPopulation::
  erev ()
  {
    return this->erev_.get ();
  }

  void ChannelPopulation::
  erev (const erev_type& x)
  {
    this->erev_.set (x);
  }

  void ChannelPopulation::
  erev (::std::unique_ptr< erev_type > x)
  {
    this->erev_.set (std::move (x));
  }

  const ChannelPopulation::segmentGroup_type& ChannelPopulation::
  segmentGroup () const
  {
    return this->segmentGroup_.get ();
  }

  ChannelPopulation::segmentGroup_type& ChannelPopulation::
  segmentGroup ()
  {
    return this->segmentGroup_.get ();
  }

  void ChannelPopulation::
  segmentGroup (const segmentGroup_type& x)
  {
    this->segmentGroup_.set (x);
  }

  void ChannelPopulation::
  segmentGroup (::std::unique_ptr< segmentGroup_type > x)
  {
    this->segmentGroup_.set (std::move (x));
  }

  const ChannelPopulation::segmentGroup_type& ChannelPopulation::
  segmentGroup_default_value ()
  {
    return segmentGroup_default_value_;
  }

  const ChannelPopulation::segment_optional& ChannelPopulation::
  segment () const
  {
    return this->segment_;
  }

  ChannelPopulation::segment_optional& ChannelPopulation::
  segment ()
  {
    return this->segment_;
  }

  void ChannelPopulation::
  segment (const segment_type& x)
  {
    this->segment_.set (x);
  }

  void ChannelPopulation::
  segment (const segment_optional& x)
  {
    this->segment_ = x;
  }

  void ChannelPopulation::
  segment (::std::unique_ptr< segment_type > x)
  {
    this->segment_.set (std::move (x));
  }

  const ChannelPopulation::ion_type& ChannelPopulation::
  ion () const
  {
    return this->ion_.get ();
  }

  ChannelPopulation::ion_type& ChannelPopulation::
  ion ()
  {
    return this->ion_.get ();
  }

  void ChannelPopulation::
  ion (const ion_type& x)
  {
    this->ion_.set (x);
  }

  void ChannelPopulation::
  ion (::std::unique_ptr< ion_type > x)
  {
    this->ion_.set (std::move (x));
  }


  // ChannelDensityNonUniform
  // 

  const ChannelDensityNonUniform::variableParameter_sequence& ChannelDensityNonUniform::
  variableParameter () const
  {
    return this->variableParameter_;
  }

  ChannelDensityNonUniform::variableParameter_sequence& ChannelDensityNonUniform::
  variableParameter ()
  {
    return this->variableParameter_;
  }

  void ChannelDensityNonUniform::
  variableParameter (const variableParameter_sequence& s)
  {
    this->variableParameter_ = s;
  }

  const ChannelDensityNonUniform::ionChannel_type& ChannelDensityNonUniform::
  ionChannel () const
  {
    return this->ionChannel_.get ();
  }

  ChannelDensityNonUniform::ionChannel_type& ChannelDensityNonUniform::
  ionChannel ()
  {
    return this->ionChannel_.get ();
  }

  void ChannelDensityNonUniform::
  ionChannel (const ionChannel_type& x)
  {
    this->ionChannel_.set (x);
  }

  void ChannelDensityNonUniform::
  ionChannel (::std::unique_ptr< ionChannel_type > x)
  {
    this->ionChannel_.set (std::move (x));
  }

  const ChannelDensityNonUniform::erev_type& ChannelDensityNonUniform::
  erev () const
  {
    return this->erev_.get ();
  }

  ChannelDensityNonUniform::erev_type& ChannelDensityNonUniform::
  erev ()
  {
    return this->erev_.get ();
  }

  void ChannelDensityNonUniform::
  erev (const erev_type& x)
  {
    this->erev_.set (x);
  }

  void ChannelDensityNonUniform::
  erev (::std::unique_ptr< erev_type > x)
  {
    this->erev_.set (std::move (x));
  }

  const ChannelDensityNonUniform::ion_type& ChannelDensityNonUniform::
  ion () const
  {
    return this->ion_.get ();
  }

  ChannelDensityNonUniform::ion_type& ChannelDensityNonUniform::
  ion ()
  {
    return this->ion_.get ();
  }

  void ChannelDensityNonUniform::
  ion (const ion_type& x)
  {
    this->ion_.set (x);
  }

  void ChannelDensityNonUniform::
  ion (::std::unique_ptr< ion_type > x)
  {
    this->ion_.set (std::move (x));
  }


  // ChannelDensityNonUniformNernst
  // 

  const ChannelDensityNonUniformNernst::variableParameter_sequence& ChannelDensityNonUniformNernst::
  variableParameter () const
  {
    return this->variableParameter_;
  }

  ChannelDensityNonUniformNernst::variableParameter_sequence& ChannelDensityNonUniformNernst::
  variableParameter ()
  {
    return this->variableParameter_;
  }

  void ChannelDensityNonUniformNernst::
  variableParameter (const variableParameter_sequence& s)
  {
    this->variableParameter_ = s;
  }

  const ChannelDensityNonUniformNernst::ionChannel_type& ChannelDensityNonUniformNernst::
  ionChannel () const
  {
    return this->ionChannel_.get ();
  }

  ChannelDensityNonUniformNernst::ionChannel_type& ChannelDensityNonUniformNernst::
  ionChannel ()
  {
    return this->ionChannel_.get ();
  }

  void ChannelDensityNonUniformNernst::
  ionChannel (const ionChannel_type& x)
  {
    this->ionChannel_.set (x);
  }

  void ChannelDensityNonUniformNernst::
  ionChannel (::std::unique_ptr< ionChannel_type > x)
  {
    this->ionChannel_.set (std::move (x));
  }

  const ChannelDensityNonUniformNernst::ion_type& ChannelDensityNonUniformNernst::
  ion () const
  {
    return this->ion_.get ();
  }

  ChannelDensityNonUniformNernst::ion_type& ChannelDensityNonUniformNernst::
  ion ()
  {
    return this->ion_.get ();
  }

  void ChannelDensityNonUniformNernst::
  ion (const ion_type& x)
  {
    this->ion_.set (x);
  }

  void ChannelDensityNonUniformNernst::
  ion (::std::unique_ptr< ion_type > x)
  {
    this->ion_.set (std::move (x));
  }


  // ChannelDensityNonUniformGHK
  // 

  const ChannelDensityNonUniformGHK::variableParameter_sequence& ChannelDensityNonUniformGHK::
  variableParameter () const
  {
    return this->variableParameter_;
  }

  ChannelDensityNonUniformGHK::variableParameter_sequence& ChannelDensityNonUniformGHK::
  variableParameter ()
  {
    return this->variableParameter_;
  }

  void ChannelDensityNonUniformGHK::
  variableParameter (const variableParameter_sequence& s)
  {
    this->variableParameter_ = s;
  }

  const ChannelDensityNonUniformGHK::ionChannel_type& ChannelDensityNonUniformGHK::
  ionChannel () const
  {
    return this->ionChannel_.get ();
  }

  ChannelDensityNonUniformGHK::ionChannel_type& ChannelDensityNonUniformGHK::
  ionChannel ()
  {
    return this->ionChannel_.get ();
  }

  void ChannelDensityNonUniformGHK::
  ionChannel (const ionChannel_type& x)
  {
    this->ionChannel_.set (x);
  }

  void ChannelDensityNonUniformGHK::
  ionChannel (::std::unique_ptr< ionChannel_type > x)
  {
    this->ionChannel_.set (std::move (x));
  }

  const ChannelDensityNonUniformGHK::ion_type& ChannelDensityNonUniformGHK::
  ion () const
  {
    return this->ion_.get ();
  }

  ChannelDensityNonUniformGHK::ion_type& ChannelDensityNonUniformGHK::
  ion ()
  {
    return this->ion_.get ();
  }

  void ChannelDensityNonUniformGHK::
  ion (const ion_type& x)
  {
    this->ion_.set (x);
  }

  void ChannelDensityNonUniformGHK::
  ion (::std::unique_ptr< ion_type > x)
  {
    this->ion_.set (std::move (x));
  }


  // ChannelDensity
  // 

  const ChannelDensity::variableParameter_sequence& ChannelDensity::
  variableParameter () const
  {
    return this->variableParameter_;
  }

  ChannelDensity::variableParameter_sequence& ChannelDensity::
  variableParameter ()
  {
    return this->variableParameter_;
  }

  void ChannelDensity::
  variableParameter (const variableParameter_sequence& s)
  {
    this->variableParameter_ = s;
  }

  const ChannelDensity::ionChannel_type& ChannelDensity::
  ionChannel () const
  {
    return this->ionChannel_.get ();
  }

  ChannelDensity::ionChannel_type& ChannelDensity::
  ionChannel ()
  {
    return this->ionChannel_.get ();
  }

  void ChannelDensity::
  ionChannel (const ionChannel_type& x)
  {
    this->ionChannel_.set (x);
  }

  void ChannelDensity::
  ionChannel (::std::unique_ptr< ionChannel_type > x)
  {
    this->ionChannel_.set (std::move (x));
  }

  const ChannelDensity::condDensity_optional& ChannelDensity::
  condDensity () const
  {
    return this->condDensity_;
  }

  ChannelDensity::condDensity_optional& ChannelDensity::
  condDensity ()
  {
    return this->condDensity_;
  }

  void ChannelDensity::
  condDensity (const condDensity_type& x)
  {
    this->condDensity_.set (x);
  }

  void ChannelDensity::
  condDensity (const condDensity_optional& x)
  {
    this->condDensity_ = x;
  }

  void ChannelDensity::
  condDensity (::std::unique_ptr< condDensity_type > x)
  {
    this->condDensity_.set (std::move (x));
  }

  const ChannelDensity::erev_type& ChannelDensity::
  erev () const
  {
    return this->erev_.get ();
  }

  ChannelDensity::erev_type& ChannelDensity::
  erev ()
  {
    return this->erev_.get ();
  }

  void ChannelDensity::
  erev (const erev_type& x)
  {
    this->erev_.set (x);
  }

  void ChannelDensity::
  erev (::std::unique_ptr< erev_type > x)
  {
    this->erev_.set (std::move (x));
  }

  const ChannelDensity::segmentGroup_type& ChannelDensity::
  segmentGroup () const
  {
    return this->segmentGroup_.get ();
  }

  ChannelDensity::segmentGroup_type& ChannelDensity::
  segmentGroup ()
  {
    return this->segmentGroup_.get ();
  }

  void ChannelDensity::
  segmentGroup (const segmentGroup_type& x)
  {
    this->segmentGroup_.set (x);
  }

  void ChannelDensity::
  segmentGroup (::std::unique_ptr< segmentGroup_type > x)
  {
    this->segmentGroup_.set (std::move (x));
  }

  const ChannelDensity::segmentGroup_type& ChannelDensity::
  segmentGroup_default_value ()
  {
    return segmentGroup_default_value_;
  }

  const ChannelDensity::segment_optional& ChannelDensity::
  segment () const
  {
    return this->segment_;
  }

  ChannelDensity::segment_optional& ChannelDensity::
  segment ()
  {
    return this->segment_;
  }

  void ChannelDensity::
  segment (const segment_type& x)
  {
    this->segment_.set (x);
  }

  void ChannelDensity::
  segment (const segment_optional& x)
  {
    this->segment_ = x;
  }

  void ChannelDensity::
  segment (::std::unique_ptr< segment_type > x)
  {
    this->segment_.set (std::move (x));
  }

  const ChannelDensity::ion_type& ChannelDensity::
  ion () const
  {
    return this->ion_.get ();
  }

  ChannelDensity::ion_type& ChannelDensity::
  ion ()
  {
    return this->ion_.get ();
  }

  void ChannelDensity::
  ion (const ion_type& x)
  {
    this->ion_.set (x);
  }

  void ChannelDensity::
  ion (::std::unique_ptr< ion_type > x)
  {
    this->ion_.set (std::move (x));
  }


  // ChannelDensityVShift
  // 

  const ChannelDensityVShift::vShift_type& ChannelDensityVShift::
  vShift () const
  {
    return this->vShift_.get ();
  }

  ChannelDensityVShift::vShift_type& ChannelDensityVShift::
  vShift ()
  {
    return this->vShift_.get ();
  }

  void ChannelDensityVShift::
  vShift (const vShift_type& x)
  {
    this->vShift_.set (x);
  }

  void ChannelDensityVShift::
  vShift (::std::unique_ptr< vShift_type > x)
  {
    this->vShift_.set (std::move (x));
  }


  // ChannelDensityNernst
  // 

  const ChannelDensityNernst::variableParameter_sequence& ChannelDensityNernst::
  variableParameter () const
  {
    return this->variableParameter_;
  }

  ChannelDensityNernst::variableParameter_sequence& ChannelDensityNernst::
  variableParameter ()
  {
    return this->variableParameter_;
  }

  void ChannelDensityNernst::
  variableParameter (const variableParameter_sequence& s)
  {
    this->variableParameter_ = s;
  }

  const ChannelDensityNernst::ionChannel_type& ChannelDensityNernst::
  ionChannel () const
  {
    return this->ionChannel_.get ();
  }

  ChannelDensityNernst::ionChannel_type& ChannelDensityNernst::
  ionChannel ()
  {
    return this->ionChannel_.get ();
  }

  void ChannelDensityNernst::
  ionChannel (const ionChannel_type& x)
  {
    this->ionChannel_.set (x);
  }

  void ChannelDensityNernst::
  ionChannel (::std::unique_ptr< ionChannel_type > x)
  {
    this->ionChannel_.set (std::move (x));
  }

  const ChannelDensityNernst::condDensity_optional& ChannelDensityNernst::
  condDensity () const
  {
    return this->condDensity_;
  }

  ChannelDensityNernst::condDensity_optional& ChannelDensityNernst::
  condDensity ()
  {
    return this->condDensity_;
  }

  void ChannelDensityNernst::
  condDensity (const condDensity_type& x)
  {
    this->condDensity_.set (x);
  }

  void ChannelDensityNernst::
  condDensity (const condDensity_optional& x)
  {
    this->condDensity_ = x;
  }

  void ChannelDensityNernst::
  condDensity (::std::unique_ptr< condDensity_type > x)
  {
    this->condDensity_.set (std::move (x));
  }

  const ChannelDensityNernst::segmentGroup_type& ChannelDensityNernst::
  segmentGroup () const
  {
    return this->segmentGroup_.get ();
  }

  ChannelDensityNernst::segmentGroup_type& ChannelDensityNernst::
  segmentGroup ()
  {
    return this->segmentGroup_.get ();
  }

  void ChannelDensityNernst::
  segmentGroup (const segmentGroup_type& x)
  {
    this->segmentGroup_.set (x);
  }

  void ChannelDensityNernst::
  segmentGroup (::std::unique_ptr< segmentGroup_type > x)
  {
    this->segmentGroup_.set (std::move (x));
  }

  const ChannelDensityNernst::segmentGroup_type& ChannelDensityNernst::
  segmentGroup_default_value ()
  {
    return segmentGroup_default_value_;
  }

  const ChannelDensityNernst::segment_optional& ChannelDensityNernst::
  segment () const
  {
    return this->segment_;
  }

  ChannelDensityNernst::segment_optional& ChannelDensityNernst::
  segment ()
  {
    return this->segment_;
  }

  void ChannelDensityNernst::
  segment (const segment_type& x)
  {
    this->segment_.set (x);
  }

  void ChannelDensityNernst::
  segment (const segment_optional& x)
  {
    this->segment_ = x;
  }

  void ChannelDensityNernst::
  segment (::std::unique_ptr< segment_type > x)
  {
    this->segment_.set (std::move (x));
  }

  const ChannelDensityNernst::ion_type& ChannelDensityNernst::
  ion () const
  {
    return this->ion_.get ();
  }

  ChannelDensityNernst::ion_type& ChannelDensityNernst::
  ion ()
  {
    return this->ion_.get ();
  }

  void ChannelDensityNernst::
  ion (const ion_type& x)
  {
    this->ion_.set (x);
  }

  void ChannelDensityNernst::
  ion (::std::unique_ptr< ion_type > x)
  {
    this->ion_.set (std::move (x));
  }


  // ChannelDensityNernstCa2
  // 


  // ChannelDensityGHK
  // 

  const ChannelDensityGHK::ionChannel_type& ChannelDensityGHK::
  ionChannel () const
  {
    return this->ionChannel_.get ();
  }

  ChannelDensityGHK::ionChannel_type& ChannelDensityGHK::
  ionChannel ()
  {
    return this->ionChannel_.get ();
  }

  void ChannelDensityGHK::
  ionChannel (const ionChannel_type& x)
  {
    this->ionChannel_.set (x);
  }

  void ChannelDensityGHK::
  ionChannel (::std::unique_ptr< ionChannel_type > x)
  {
    this->ionChannel_.set (std::move (x));
  }

  const ChannelDensityGHK::permeability_type& ChannelDensityGHK::
  permeability () const
  {
    return this->permeability_.get ();
  }

  ChannelDensityGHK::permeability_type& ChannelDensityGHK::
  permeability ()
  {
    return this->permeability_.get ();
  }

  void ChannelDensityGHK::
  permeability (const permeability_type& x)
  {
    this->permeability_.set (x);
  }

  void ChannelDensityGHK::
  permeability (::std::unique_ptr< permeability_type > x)
  {
    this->permeability_.set (std::move (x));
  }

  const ChannelDensityGHK::segmentGroup_type& ChannelDensityGHK::
  segmentGroup () const
  {
    return this->segmentGroup_.get ();
  }

  ChannelDensityGHK::segmentGroup_type& ChannelDensityGHK::
  segmentGroup ()
  {
    return this->segmentGroup_.get ();
  }

  void ChannelDensityGHK::
  segmentGroup (const segmentGroup_type& x)
  {
    this->segmentGroup_.set (x);
  }

  void ChannelDensityGHK::
  segmentGroup (::std::unique_ptr< segmentGroup_type > x)
  {
    this->segmentGroup_.set (std::move (x));
  }

  const ChannelDensityGHK::segmentGroup_type& ChannelDensityGHK::
  segmentGroup_default_value ()
  {
    return segmentGroup_default_value_;
  }

  const ChannelDensityGHK::segment_optional& ChannelDensityGHK::
  segment () const
  {
    return this->segment_;
  }

  ChannelDensityGHK::segment_optional& ChannelDensityGHK::
  segment ()
  {
    return this->segment_;
  }

  void ChannelDensityGHK::
  segment (const segment_type& x)
  {
    this->segment_.set (x);
  }

  void ChannelDensityGHK::
  segment (const segment_optional& x)
  {
    this->segment_ = x;
  }

  void ChannelDensityGHK::
  segment (::std::unique_ptr< segment_type > x)
  {
    this->segment_.set (std::move (x));
  }

  const ChannelDensityGHK::ion_type& ChannelDensityGHK::
  ion () const
  {
    return this->ion_.get ();
  }

  ChannelDensityGHK::ion_type& ChannelDensityGHK::
  ion ()
  {
    return this->ion_.get ();
  }

  void ChannelDensityGHK::
  ion (const ion_type& x)
  {
    this->ion_.set (x);
  }

  void ChannelDensityGHK::
  ion (::std::unique_ptr< ion_type > x)
  {
    this->ion_.set (std::move (x));
  }


  // ChannelDensityGHK2
  // 

  const ChannelDensityGHK2::ionChannel_type& ChannelDensityGHK2::
  ionChannel () const
  {
    return this->ionChannel_.get ();
  }

  ChannelDensityGHK2::ionChannel_type& ChannelDensityGHK2::
  ionChannel ()
  {
    return this->ionChannel_.get ();
  }

  void ChannelDensityGHK2::
  ionChannel (const ionChannel_type& x)
  {
    this->ionChannel_.set (x);
  }

  void ChannelDensityGHK2::
  ionChannel (::std::unique_ptr< ionChannel_type > x)
  {
    this->ionChannel_.set (std::move (x));
  }

  const ChannelDensityGHK2::condDensity_optional& ChannelDensityGHK2::
  condDensity () const
  {
    return this->condDensity_;
  }

  ChannelDensityGHK2::condDensity_optional& ChannelDensityGHK2::
  condDensity ()
  {
    return this->condDensity_;
  }

  void ChannelDensityGHK2::
  condDensity (const condDensity_type& x)
  {
    this->condDensity_.set (x);
  }

  void ChannelDensityGHK2::
  condDensity (const condDensity_optional& x)
  {
    this->condDensity_ = x;
  }

  void ChannelDensityGHK2::
  condDensity (::std::unique_ptr< condDensity_type > x)
  {
    this->condDensity_.set (std::move (x));
  }

  const ChannelDensityGHK2::segmentGroup_type& ChannelDensityGHK2::
  segmentGroup () const
  {
    return this->segmentGroup_.get ();
  }

  ChannelDensityGHK2::segmentGroup_type& ChannelDensityGHK2::
  segmentGroup ()
  {
    return this->segmentGroup_.get ();
  }

  void ChannelDensityGHK2::
  segmentGroup (const segmentGroup_type& x)
  {
    this->segmentGroup_.set (x);
  }

  void ChannelDensityGHK2::
  segmentGroup (::std::unique_ptr< segmentGroup_type > x)
  {
    this->segmentGroup_.set (std::move (x));
  }

  const ChannelDensityGHK2::segmentGroup_type& ChannelDensityGHK2::
  segmentGroup_default_value ()
  {
    return segmentGroup_default_value_;
  }

  const ChannelDensityGHK2::segment_optional& ChannelDensityGHK2::
  segment () const
  {
    return this->segment_;
  }

  ChannelDensityGHK2::segment_optional& ChannelDensityGHK2::
  segment ()
  {
    return this->segment_;
  }

  void ChannelDensityGHK2::
  segment (const segment_type& x)
  {
    this->segment_.set (x);
  }

  void ChannelDensityGHK2::
  segment (const segment_optional& x)
  {
    this->segment_ = x;
  }

  void ChannelDensityGHK2::
  segment (::std::unique_ptr< segment_type > x)
  {
    this->segment_.set (std::move (x));
  }

  const ChannelDensityGHK2::ion_type& ChannelDensityGHK2::
  ion () const
  {
    return this->ion_.get ();
  }

  ChannelDensityGHK2::ion_type& ChannelDensityGHK2::
  ion ()
  {
    return this->ion_.get ();
  }

  void ChannelDensityGHK2::
  ion (const ion_type& x)
  {
    this->ion_.set (x);
  }

  void ChannelDensityGHK2::
  ion (::std::unique_ptr< ion_type > x)
  {
    this->ion_.set (std::move (x));
  }


  // VariableParameter
  // 

  const VariableParameter::inhomogeneousValue_optional& VariableParameter::
  inhomogeneousValue () const
  {
    return this->inhomogeneousValue_;
  }

  VariableParameter::inhomogeneousValue_optional& VariableParameter::
  inhomogeneousValue ()
  {
    return this->inhomogeneousValue_;
  }

  void VariableParameter::
  inhomogeneousValue (const inhomogeneousValue_type& x)
  {
    this->inhomogeneousValue_.set (x);
  }

  void VariableParameter::
  inhomogeneousValue (const inhomogeneousValue_optional& x)
  {
    this->inhomogeneousValue_ = x;
  }

  void VariableParameter::
  inhomogeneousValue (::std::unique_ptr< inhomogeneousValue_type > x)
  {
    this->inhomogeneousValue_.set (std::move (x));
  }

  const VariableParameter::parameter_type& VariableParameter::
  parameter () const
  {
    return this->parameter_.get ();
  }

  VariableParameter::parameter_type& VariableParameter::
  parameter ()
  {
    return this->parameter_.get ();
  }

  void VariableParameter::
  parameter (const parameter_type& x)
  {
    this->parameter_.set (x);
  }

  void VariableParameter::
  parameter (::std::unique_ptr< parameter_type > x)
  {
    this->parameter_.set (std::move (x));
  }

  const VariableParameter::segmentGroup_type& VariableParameter::
  segmentGroup () const
  {
    return this->segmentGroup_.get ();
  }

  VariableParameter::segmentGroup_type& VariableParameter::
  segmentGroup ()
  {
    return this->segmentGroup_.get ();
  }

  void VariableParameter::
  segmentGroup (const segmentGroup_type& x)
  {
    this->segmentGroup_.set (x);
  }

  void VariableParameter::
  segmentGroup (::std::unique_ptr< segmentGroup_type > x)
  {
    this->segmentGroup_.set (std::move (x));
  }


  // InhomogeneousValue
  // 

  const InhomogeneousValue::inhomogeneousParameter_type& InhomogeneousValue::
  inhomogeneousParameter () const
  {
    return this->inhomogeneousParameter_.get ();
  }

  InhomogeneousValue::inhomogeneousParameter_type& InhomogeneousValue::
  inhomogeneousParameter ()
  {
    return this->inhomogeneousParameter_.get ();
  }

  void InhomogeneousValue::
  inhomogeneousParameter (const inhomogeneousParameter_type& x)
  {
    this->inhomogeneousParameter_.set (x);
  }

  void InhomogeneousValue::
  inhomogeneousParameter (::std::unique_ptr< inhomogeneousParameter_type > x)
  {
    this->inhomogeneousParameter_.set (std::move (x));
  }

  const InhomogeneousValue::value_type& InhomogeneousValue::
  value () const
  {
    return this->value_.get ();
  }

  InhomogeneousValue::value_type& InhomogeneousValue::
  value ()
  {
    return this->value_.get ();
  }

  void InhomogeneousValue::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void InhomogeneousValue::
  value (::std::unique_ptr< value_type > x)
  {
    this->value_.set (std::move (x));
  }


  // Species
  // 

  const Species::id_type& Species::
  id () const
  {
    return this->id_.get ();
  }

  Species::id_type& Species::
  id ()
  {
    return this->id_.get ();
  }

  void Species::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void Species::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const Species::concentrationModel_type& Species::
  concentrationModel () const
  {
    return this->concentrationModel_.get ();
  }

  Species::concentrationModel_type& Species::
  concentrationModel ()
  {
    return this->concentrationModel_.get ();
  }

  void Species::
  concentrationModel (const concentrationModel_type& x)
  {
    this->concentrationModel_.set (x);
  }

  void Species::
  concentrationModel (::std::unique_ptr< concentrationModel_type > x)
  {
    this->concentrationModel_.set (std::move (x));
  }

  const Species::ion_optional& Species::
  ion () const
  {
    return this->ion_;
  }

  Species::ion_optional& Species::
  ion ()
  {
    return this->ion_;
  }

  void Species::
  ion (const ion_type& x)
  {
    this->ion_.set (x);
  }

  void Species::
  ion (const ion_optional& x)
  {
    this->ion_ = x;
  }

  void Species::
  ion (::std::unique_ptr< ion_type > x)
  {
    this->ion_.set (std::move (x));
  }

  const Species::initialConcentration_type& Species::
  initialConcentration () const
  {
    return this->initialConcentration_.get ();
  }

  Species::initialConcentration_type& Species::
  initialConcentration ()
  {
    return this->initialConcentration_.get ();
  }

  void Species::
  initialConcentration (const initialConcentration_type& x)
  {
    this->initialConcentration_.set (x);
  }

  void Species::
  initialConcentration (::std::unique_ptr< initialConcentration_type > x)
  {
    this->initialConcentration_.set (std::move (x));
  }

  const Species::initialExtConcentration_type& Species::
  initialExtConcentration () const
  {
    return this->initialExtConcentration_.get ();
  }

  Species::initialExtConcentration_type& Species::
  initialExtConcentration ()
  {
    return this->initialExtConcentration_.get ();
  }

  void Species::
  initialExtConcentration (const initialExtConcentration_type& x)
  {
    this->initialExtConcentration_.set (x);
  }

  void Species::
  initialExtConcentration (::std::unique_ptr< initialExtConcentration_type > x)
  {
    this->initialExtConcentration_.set (std::move (x));
  }

  const Species::segmentGroup_type& Species::
  segmentGroup () const
  {
    return this->segmentGroup_.get ();
  }

  Species::segmentGroup_type& Species::
  segmentGroup ()
  {
    return this->segmentGroup_.get ();
  }

  void Species::
  segmentGroup (const segmentGroup_type& x)
  {
    this->segmentGroup_.set (x);
  }

  void Species::
  segmentGroup (::std::unique_ptr< segmentGroup_type > x)
  {
    this->segmentGroup_.set (std::move (x));
  }

  const Species::segmentGroup_type& Species::
  segmentGroup_default_value ()
  {
    return segmentGroup_default_value_;
  }


  // ConcentrationModel_D
  // 

  const ConcentrationModel_D::type_type& ConcentrationModel_D::
  type () const
  {
    return this->type_.get ();
  }

  const ConcentrationModel_D::type_type& ConcentrationModel_D::
  type_default_value ()
  {
    return type_default_value_;
  }


  // IntracellularProperties
  // 

  const IntracellularProperties::species_sequence& IntracellularProperties::
  species () const
  {
    return this->species_;
  }

  IntracellularProperties::species_sequence& IntracellularProperties::
  species ()
  {
    return this->species_;
  }

  void IntracellularProperties::
  species (const species_sequence& s)
  {
    this->species_ = s;
  }

  const IntracellularProperties::resistivity_sequence& IntracellularProperties::
  resistivity () const
  {
    return this->resistivity_;
  }

  IntracellularProperties::resistivity_sequence& IntracellularProperties::
  resistivity ()
  {
    return this->resistivity_;
  }

  void IntracellularProperties::
  resistivity (const resistivity_sequence& s)
  {
    this->resistivity_ = s;
  }


  // IntracellularProperties2CaPools
  // 


  // ExtracellularProperties
  // 

  const ExtracellularProperties::species_sequence& ExtracellularProperties::
  species () const
  {
    return this->species_;
  }

  ExtracellularProperties::species_sequence& ExtracellularProperties::
  species ()
  {
    return this->species_;
  }

  void ExtracellularProperties::
  species (const species_sequence& s)
  {
    this->species_ = s;
  }


  // ExtracellularPropertiesLocal
  // 

  const ExtracellularPropertiesLocal::species_sequence& ExtracellularPropertiesLocal::
  species () const
  {
    return this->species_;
  }

  ExtracellularPropertiesLocal::species_sequence& ExtracellularPropertiesLocal::
  species ()
  {
    return this->species_;
  }

  void ExtracellularPropertiesLocal::
  species (const species_sequence& s)
  {
    this->species_ = s;
  }


  // ReactionScheme
  // 

  const ReactionScheme::source_type& ReactionScheme::
  source () const
  {
    return this->source_.get ();
  }

  ReactionScheme::source_type& ReactionScheme::
  source ()
  {
    return this->source_.get ();
  }

  void ReactionScheme::
  source (const source_type& x)
  {
    this->source_.set (x);
  }

  void ReactionScheme::
  source (::std::unique_ptr< source_type > x)
  {
    this->source_.set (std::move (x));
  }

  const ReactionScheme::type_type& ReactionScheme::
  type () const
  {
    return this->type_.get ();
  }

  ReactionScheme::type_type& ReactionScheme::
  type ()
  {
    return this->type_.get ();
  }

  void ReactionScheme::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void ReactionScheme::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }


  // PulseGenerator
  // 

  const PulseGenerator::delay_type& PulseGenerator::
  delay () const
  {
    return this->delay_.get ();
  }

  PulseGenerator::delay_type& PulseGenerator::
  delay ()
  {
    return this->delay_.get ();
  }

  void PulseGenerator::
  delay (const delay_type& x)
  {
    this->delay_.set (x);
  }

  void PulseGenerator::
  delay (::std::unique_ptr< delay_type > x)
  {
    this->delay_.set (std::move (x));
  }

  const PulseGenerator::duration_type& PulseGenerator::
  duration () const
  {
    return this->duration_.get ();
  }

  PulseGenerator::duration_type& PulseGenerator::
  duration ()
  {
    return this->duration_.get ();
  }

  void PulseGenerator::
  duration (const duration_type& x)
  {
    this->duration_.set (x);
  }

  void PulseGenerator::
  duration (::std::unique_ptr< duration_type > x)
  {
    this->duration_.set (std::move (x));
  }

  const PulseGenerator::amplitude_type& PulseGenerator::
  amplitude () const
  {
    return this->amplitude_.get ();
  }

  PulseGenerator::amplitude_type& PulseGenerator::
  amplitude ()
  {
    return this->amplitude_.get ();
  }

  void PulseGenerator::
  amplitude (const amplitude_type& x)
  {
    this->amplitude_.set (x);
  }

  void PulseGenerator::
  amplitude (::std::unique_ptr< amplitude_type > x)
  {
    this->amplitude_.set (std::move (x));
  }


  // PulseGeneratorDL
  // 

  const PulseGeneratorDL::delay_type& PulseGeneratorDL::
  delay () const
  {
    return this->delay_.get ();
  }

  PulseGeneratorDL::delay_type& PulseGeneratorDL::
  delay ()
  {
    return this->delay_.get ();
  }

  void PulseGeneratorDL::
  delay (const delay_type& x)
  {
    this->delay_.set (x);
  }

  void PulseGeneratorDL::
  delay (::std::unique_ptr< delay_type > x)
  {
    this->delay_.set (std::move (x));
  }

  const PulseGeneratorDL::duration_type& PulseGeneratorDL::
  duration () const
  {
    return this->duration_.get ();
  }

  PulseGeneratorDL::duration_type& PulseGeneratorDL::
  duration ()
  {
    return this->duration_.get ();
  }

  void PulseGeneratorDL::
  duration (const duration_type& x)
  {
    this->duration_.set (x);
  }

  void PulseGeneratorDL::
  duration (::std::unique_ptr< duration_type > x)
  {
    this->duration_.set (std::move (x));
  }

  const PulseGeneratorDL::amplitude_type& PulseGeneratorDL::
  amplitude () const
  {
    return this->amplitude_.get ();
  }

  PulseGeneratorDL::amplitude_type& PulseGeneratorDL::
  amplitude ()
  {
    return this->amplitude_.get ();
  }

  void PulseGeneratorDL::
  amplitude (const amplitude_type& x)
  {
    this->amplitude_.set (x);
  }

  void PulseGeneratorDL::
  amplitude (::std::unique_ptr< amplitude_type > x)
  {
    this->amplitude_.set (std::move (x));
  }


  // SineGenerator
  // 

  const SineGenerator::delay_type& SineGenerator::
  delay () const
  {
    return this->delay_.get ();
  }

  SineGenerator::delay_type& SineGenerator::
  delay ()
  {
    return this->delay_.get ();
  }

  void SineGenerator::
  delay (const delay_type& x)
  {
    this->delay_.set (x);
  }

  void SineGenerator::
  delay (::std::unique_ptr< delay_type > x)
  {
    this->delay_.set (std::move (x));
  }

  const SineGenerator::phase_type& SineGenerator::
  phase () const
  {
    return this->phase_.get ();
  }

  SineGenerator::phase_type& SineGenerator::
  phase ()
  {
    return this->phase_.get ();
  }

  void SineGenerator::
  phase (const phase_type& x)
  {
    this->phase_.set (x);
  }

  void SineGenerator::
  phase (::std::unique_ptr< phase_type > x)
  {
    this->phase_.set (std::move (x));
  }

  const SineGenerator::duration_type& SineGenerator::
  duration () const
  {
    return this->duration_.get ();
  }

  SineGenerator::duration_type& SineGenerator::
  duration ()
  {
    return this->duration_.get ();
  }

  void SineGenerator::
  duration (const duration_type& x)
  {
    this->duration_.set (x);
  }

  void SineGenerator::
  duration (::std::unique_ptr< duration_type > x)
  {
    this->duration_.set (std::move (x));
  }

  const SineGenerator::amplitude_type& SineGenerator::
  amplitude () const
  {
    return this->amplitude_.get ();
  }

  SineGenerator::amplitude_type& SineGenerator::
  amplitude ()
  {
    return this->amplitude_.get ();
  }

  void SineGenerator::
  amplitude (const amplitude_type& x)
  {
    this->amplitude_.set (x);
  }

  void SineGenerator::
  amplitude (::std::unique_ptr< amplitude_type > x)
  {
    this->amplitude_.set (std::move (x));
  }

  const SineGenerator::period_type& SineGenerator::
  period () const
  {
    return this->period_.get ();
  }

  SineGenerator::period_type& SineGenerator::
  period ()
  {
    return this->period_.get ();
  }

  void SineGenerator::
  period (const period_type& x)
  {
    this->period_.set (x);
  }

  void SineGenerator::
  period (::std::unique_ptr< period_type > x)
  {
    this->period_.set (std::move (x));
  }


  // SineGeneratorDL
  // 

  const SineGeneratorDL::delay_type& SineGeneratorDL::
  delay () const
  {
    return this->delay_.get ();
  }

  SineGeneratorDL::delay_type& SineGeneratorDL::
  delay ()
  {
    return this->delay_.get ();
  }

  void SineGeneratorDL::
  delay (const delay_type& x)
  {
    this->delay_.set (x);
  }

  void SineGeneratorDL::
  delay (::std::unique_ptr< delay_type > x)
  {
    this->delay_.set (std::move (x));
  }

  const SineGeneratorDL::phase_type& SineGeneratorDL::
  phase () const
  {
    return this->phase_.get ();
  }

  SineGeneratorDL::phase_type& SineGeneratorDL::
  phase ()
  {
    return this->phase_.get ();
  }

  void SineGeneratorDL::
  phase (const phase_type& x)
  {
    this->phase_.set (x);
  }

  void SineGeneratorDL::
  phase (::std::unique_ptr< phase_type > x)
  {
    this->phase_.set (std::move (x));
  }

  const SineGeneratorDL::duration_type& SineGeneratorDL::
  duration () const
  {
    return this->duration_.get ();
  }

  SineGeneratorDL::duration_type& SineGeneratorDL::
  duration ()
  {
    return this->duration_.get ();
  }

  void SineGeneratorDL::
  duration (const duration_type& x)
  {
    this->duration_.set (x);
  }

  void SineGeneratorDL::
  duration (::std::unique_ptr< duration_type > x)
  {
    this->duration_.set (std::move (x));
  }

  const SineGeneratorDL::amplitude_type& SineGeneratorDL::
  amplitude () const
  {
    return this->amplitude_.get ();
  }

  SineGeneratorDL::amplitude_type& SineGeneratorDL::
  amplitude ()
  {
    return this->amplitude_.get ();
  }

  void SineGeneratorDL::
  amplitude (const amplitude_type& x)
  {
    this->amplitude_.set (x);
  }

  void SineGeneratorDL::
  amplitude (::std::unique_ptr< amplitude_type > x)
  {
    this->amplitude_.set (std::move (x));
  }

  const SineGeneratorDL::period_type& SineGeneratorDL::
  period () const
  {
    return this->period_.get ();
  }

  SineGeneratorDL::period_type& SineGeneratorDL::
  period ()
  {
    return this->period_.get ();
  }

  void SineGeneratorDL::
  period (const period_type& x)
  {
    this->period_.set (x);
  }

  void SineGeneratorDL::
  period (::std::unique_ptr< period_type > x)
  {
    this->period_.set (std::move (x));
  }


  // RampGenerator
  // 

  const RampGenerator::delay_type& RampGenerator::
  delay () const
  {
    return this->delay_.get ();
  }

  RampGenerator::delay_type& RampGenerator::
  delay ()
  {
    return this->delay_.get ();
  }

  void RampGenerator::
  delay (const delay_type& x)
  {
    this->delay_.set (x);
  }

  void RampGenerator::
  delay (::std::unique_ptr< delay_type > x)
  {
    this->delay_.set (std::move (x));
  }

  const RampGenerator::duration_type& RampGenerator::
  duration () const
  {
    return this->duration_.get ();
  }

  RampGenerator::duration_type& RampGenerator::
  duration ()
  {
    return this->duration_.get ();
  }

  void RampGenerator::
  duration (const duration_type& x)
  {
    this->duration_.set (x);
  }

  void RampGenerator::
  duration (::std::unique_ptr< duration_type > x)
  {
    this->duration_.set (std::move (x));
  }

  const RampGenerator::startAmplitude_type& RampGenerator::
  startAmplitude () const
  {
    return this->startAmplitude_.get ();
  }

  RampGenerator::startAmplitude_type& RampGenerator::
  startAmplitude ()
  {
    return this->startAmplitude_.get ();
  }

  void RampGenerator::
  startAmplitude (const startAmplitude_type& x)
  {
    this->startAmplitude_.set (x);
  }

  void RampGenerator::
  startAmplitude (::std::unique_ptr< startAmplitude_type > x)
  {
    this->startAmplitude_.set (std::move (x));
  }

  const RampGenerator::finishAmplitude_type& RampGenerator::
  finishAmplitude () const
  {
    return this->finishAmplitude_.get ();
  }

  RampGenerator::finishAmplitude_type& RampGenerator::
  finishAmplitude ()
  {
    return this->finishAmplitude_.get ();
  }

  void RampGenerator::
  finishAmplitude (const finishAmplitude_type& x)
  {
    this->finishAmplitude_.set (x);
  }

  void RampGenerator::
  finishAmplitude (::std::unique_ptr< finishAmplitude_type > x)
  {
    this->finishAmplitude_.set (std::move (x));
  }

  const RampGenerator::baselineAmplitude_type& RampGenerator::
  baselineAmplitude () const
  {
    return this->baselineAmplitude_.get ();
  }

  RampGenerator::baselineAmplitude_type& RampGenerator::
  baselineAmplitude ()
  {
    return this->baselineAmplitude_.get ();
  }

  void RampGenerator::
  baselineAmplitude (const baselineAmplitude_type& x)
  {
    this->baselineAmplitude_.set (x);
  }

  void RampGenerator::
  baselineAmplitude (::std::unique_ptr< baselineAmplitude_type > x)
  {
    this->baselineAmplitude_.set (std::move (x));
  }


  // RampGeneratorDL
  // 

  const RampGeneratorDL::delay_type& RampGeneratorDL::
  delay () const
  {
    return this->delay_.get ();
  }

  RampGeneratorDL::delay_type& RampGeneratorDL::
  delay ()
  {
    return this->delay_.get ();
  }

  void RampGeneratorDL::
  delay (const delay_type& x)
  {
    this->delay_.set (x);
  }

  void RampGeneratorDL::
  delay (::std::unique_ptr< delay_type > x)
  {
    this->delay_.set (std::move (x));
  }

  const RampGeneratorDL::duration_type& RampGeneratorDL::
  duration () const
  {
    return this->duration_.get ();
  }

  RampGeneratorDL::duration_type& RampGeneratorDL::
  duration ()
  {
    return this->duration_.get ();
  }

  void RampGeneratorDL::
  duration (const duration_type& x)
  {
    this->duration_.set (x);
  }

  void RampGeneratorDL::
  duration (::std::unique_ptr< duration_type > x)
  {
    this->duration_.set (std::move (x));
  }

  const RampGeneratorDL::startAmplitude_type& RampGeneratorDL::
  startAmplitude () const
  {
    return this->startAmplitude_.get ();
  }

  RampGeneratorDL::startAmplitude_type& RampGeneratorDL::
  startAmplitude ()
  {
    return this->startAmplitude_.get ();
  }

  void RampGeneratorDL::
  startAmplitude (const startAmplitude_type& x)
  {
    this->startAmplitude_.set (x);
  }

  void RampGeneratorDL::
  startAmplitude (::std::unique_ptr< startAmplitude_type > x)
  {
    this->startAmplitude_.set (std::move (x));
  }

  const RampGeneratorDL::finishAmplitude_type& RampGeneratorDL::
  finishAmplitude () const
  {
    return this->finishAmplitude_.get ();
  }

  RampGeneratorDL::finishAmplitude_type& RampGeneratorDL::
  finishAmplitude ()
  {
    return this->finishAmplitude_.get ();
  }

  void RampGeneratorDL::
  finishAmplitude (const finishAmplitude_type& x)
  {
    this->finishAmplitude_.set (x);
  }

  void RampGeneratorDL::
  finishAmplitude (::std::unique_ptr< finishAmplitude_type > x)
  {
    this->finishAmplitude_.set (std::move (x));
  }

  const RampGeneratorDL::baselineAmplitude_type& RampGeneratorDL::
  baselineAmplitude () const
  {
    return this->baselineAmplitude_.get ();
  }

  RampGeneratorDL::baselineAmplitude_type& RampGeneratorDL::
  baselineAmplitude ()
  {
    return this->baselineAmplitude_.get ();
  }

  void RampGeneratorDL::
  baselineAmplitude (const baselineAmplitude_type& x)
  {
    this->baselineAmplitude_.set (x);
  }

  void RampGeneratorDL::
  baselineAmplitude (::std::unique_ptr< baselineAmplitude_type > x)
  {
    this->baselineAmplitude_.set (std::move (x));
  }


  // CompoundInput
  // 

  const CompoundInput::pulseGenerator_sequence& CompoundInput::
  pulseGenerator () const
  {
    return this->pulseGenerator_;
  }

  CompoundInput::pulseGenerator_sequence& CompoundInput::
  pulseGenerator ()
  {
    return this->pulseGenerator_;
  }

  void CompoundInput::
  pulseGenerator (const pulseGenerator_sequence& s)
  {
    this->pulseGenerator_ = s;
  }

  const CompoundInput::sineGenerator_sequence& CompoundInput::
  sineGenerator () const
  {
    return this->sineGenerator_;
  }

  CompoundInput::sineGenerator_sequence& CompoundInput::
  sineGenerator ()
  {
    return this->sineGenerator_;
  }

  void CompoundInput::
  sineGenerator (const sineGenerator_sequence& s)
  {
    this->sineGenerator_ = s;
  }

  const CompoundInput::rampGenerator_sequence& CompoundInput::
  rampGenerator () const
  {
    return this->rampGenerator_;
  }

  CompoundInput::rampGenerator_sequence& CompoundInput::
  rampGenerator ()
  {
    return this->rampGenerator_;
  }

  void CompoundInput::
  rampGenerator (const rampGenerator_sequence& s)
  {
    this->rampGenerator_ = s;
  }


  // CompoundInputDL
  // 

  const CompoundInputDL::pulseGeneratorDL_sequence& CompoundInputDL::
  pulseGeneratorDL () const
  {
    return this->pulseGeneratorDL_;
  }

  CompoundInputDL::pulseGeneratorDL_sequence& CompoundInputDL::
  pulseGeneratorDL ()
  {
    return this->pulseGeneratorDL_;
  }

  void CompoundInputDL::
  pulseGeneratorDL (const pulseGeneratorDL_sequence& s)
  {
    this->pulseGeneratorDL_ = s;
  }

  const CompoundInputDL::sineGeneratorDL_sequence& CompoundInputDL::
  sineGeneratorDL () const
  {
    return this->sineGeneratorDL_;
  }

  CompoundInputDL::sineGeneratorDL_sequence& CompoundInputDL::
  sineGeneratorDL ()
  {
    return this->sineGeneratorDL_;
  }

  void CompoundInputDL::
  sineGeneratorDL (const sineGeneratorDL_sequence& s)
  {
    this->sineGeneratorDL_ = s;
  }

  const CompoundInputDL::rampGeneratorDL_sequence& CompoundInputDL::
  rampGeneratorDL () const
  {
    return this->rampGeneratorDL_;
  }

  CompoundInputDL::rampGeneratorDL_sequence& CompoundInputDL::
  rampGeneratorDL ()
  {
    return this->rampGeneratorDL_;
  }

  void CompoundInputDL::
  rampGeneratorDL (const rampGeneratorDL_sequence& s)
  {
    this->rampGeneratorDL_ = s;
  }


  // VoltageClamp
  // 

  const VoltageClamp::delay_type& VoltageClamp::
  delay () const
  {
    return this->delay_.get ();
  }

  VoltageClamp::delay_type& VoltageClamp::
  delay ()
  {
    return this->delay_.get ();
  }

  void VoltageClamp::
  delay (const delay_type& x)
  {
    this->delay_.set (x);
  }

  void VoltageClamp::
  delay (::std::unique_ptr< delay_type > x)
  {
    this->delay_.set (std::move (x));
  }

  const VoltageClamp::duration_type& VoltageClamp::
  duration () const
  {
    return this->duration_.get ();
  }

  VoltageClamp::duration_type& VoltageClamp::
  duration ()
  {
    return this->duration_.get ();
  }

  void VoltageClamp::
  duration (const duration_type& x)
  {
    this->duration_.set (x);
  }

  void VoltageClamp::
  duration (::std::unique_ptr< duration_type > x)
  {
    this->duration_.set (std::move (x));
  }

  const VoltageClamp::targetVoltage_type& VoltageClamp::
  targetVoltage () const
  {
    return this->targetVoltage_.get ();
  }

  VoltageClamp::targetVoltage_type& VoltageClamp::
  targetVoltage ()
  {
    return this->targetVoltage_.get ();
  }

  void VoltageClamp::
  targetVoltage (const targetVoltage_type& x)
  {
    this->targetVoltage_.set (x);
  }

  void VoltageClamp::
  targetVoltage (::std::unique_ptr< targetVoltage_type > x)
  {
    this->targetVoltage_.set (std::move (x));
  }

  const VoltageClamp::simpleSeriesResistance_type& VoltageClamp::
  simpleSeriesResistance () const
  {
    return this->simpleSeriesResistance_.get ();
  }

  VoltageClamp::simpleSeriesResistance_type& VoltageClamp::
  simpleSeriesResistance ()
  {
    return this->simpleSeriesResistance_.get ();
  }

  void VoltageClamp::
  simpleSeriesResistance (const simpleSeriesResistance_type& x)
  {
    this->simpleSeriesResistance_.set (x);
  }

  void VoltageClamp::
  simpleSeriesResistance (::std::unique_ptr< simpleSeriesResistance_type > x)
  {
    this->simpleSeriesResistance_.set (std::move (x));
  }


  // VoltageClampTriple
  // 

  const VoltageClampTriple::active_type& VoltageClampTriple::
  active () const
  {
    return this->active_.get ();
  }

  VoltageClampTriple::active_type& VoltageClampTriple::
  active ()
  {
    return this->active_.get ();
  }

  void VoltageClampTriple::
  active (const active_type& x)
  {
    this->active_.set (x);
  }

  void VoltageClampTriple::
  active (::std::unique_ptr< active_type > x)
  {
    this->active_.set (std::move (x));
  }

  const VoltageClampTriple::delay_type& VoltageClampTriple::
  delay () const
  {
    return this->delay_.get ();
  }

  VoltageClampTriple::delay_type& VoltageClampTriple::
  delay ()
  {
    return this->delay_.get ();
  }

  void VoltageClampTriple::
  delay (const delay_type& x)
  {
    this->delay_.set (x);
  }

  void VoltageClampTriple::
  delay (::std::unique_ptr< delay_type > x)
  {
    this->delay_.set (std::move (x));
  }

  const VoltageClampTriple::duration_type& VoltageClampTriple::
  duration () const
  {
    return this->duration_.get ();
  }

  VoltageClampTriple::duration_type& VoltageClampTriple::
  duration ()
  {
    return this->duration_.get ();
  }

  void VoltageClampTriple::
  duration (const duration_type& x)
  {
    this->duration_.set (x);
  }

  void VoltageClampTriple::
  duration (::std::unique_ptr< duration_type > x)
  {
    this->duration_.set (std::move (x));
  }

  const VoltageClampTriple::conditioningVoltage_type& VoltageClampTriple::
  conditioningVoltage () const
  {
    return this->conditioningVoltage_.get ();
  }

  VoltageClampTriple::conditioningVoltage_type& VoltageClampTriple::
  conditioningVoltage ()
  {
    return this->conditioningVoltage_.get ();
  }

  void VoltageClampTriple::
  conditioningVoltage (const conditioningVoltage_type& x)
  {
    this->conditioningVoltage_.set (x);
  }

  void VoltageClampTriple::
  conditioningVoltage (::std::unique_ptr< conditioningVoltage_type > x)
  {
    this->conditioningVoltage_.set (std::move (x));
  }

  const VoltageClampTriple::testingVoltage_type& VoltageClampTriple::
  testingVoltage () const
  {
    return this->testingVoltage_.get ();
  }

  VoltageClampTriple::testingVoltage_type& VoltageClampTriple::
  testingVoltage ()
  {
    return this->testingVoltage_.get ();
  }

  void VoltageClampTriple::
  testingVoltage (const testingVoltage_type& x)
  {
    this->testingVoltage_.set (x);
  }

  void VoltageClampTriple::
  testingVoltage (::std::unique_ptr< testingVoltage_type > x)
  {
    this->testingVoltage_.set (std::move (x));
  }

  const VoltageClampTriple::returnVoltage_type& VoltageClampTriple::
  returnVoltage () const
  {
    return this->returnVoltage_.get ();
  }

  VoltageClampTriple::returnVoltage_type& VoltageClampTriple::
  returnVoltage ()
  {
    return this->returnVoltage_.get ();
  }

  void VoltageClampTriple::
  returnVoltage (const returnVoltage_type& x)
  {
    this->returnVoltage_.set (x);
  }

  void VoltageClampTriple::
  returnVoltage (::std::unique_ptr< returnVoltage_type > x)
  {
    this->returnVoltage_.set (std::move (x));
  }

  const VoltageClampTriple::simpleSeriesResistance_type& VoltageClampTriple::
  simpleSeriesResistance () const
  {
    return this->simpleSeriesResistance_.get ();
  }

  VoltageClampTriple::simpleSeriesResistance_type& VoltageClampTriple::
  simpleSeriesResistance ()
  {
    return this->simpleSeriesResistance_.get ();
  }

  void VoltageClampTriple::
  simpleSeriesResistance (const simpleSeriesResistance_type& x)
  {
    this->simpleSeriesResistance_.set (x);
  }

  void VoltageClampTriple::
  simpleSeriesResistance (::std::unique_ptr< simpleSeriesResistance_type > x)
  {
    this->simpleSeriesResistance_.set (std::move (x));
  }


  // Spike
  // 

  const Spike::time_type& Spike::
  time () const
  {
    return this->time_.get ();
  }

  Spike::time_type& Spike::
  time ()
  {
    return this->time_.get ();
  }

  void Spike::
  time (const time_type& x)
  {
    this->time_.set (x);
  }

  void Spike::
  time (::std::unique_ptr< time_type > x)
  {
    this->time_.set (std::move (x));
  }


  // SpikeArray
  // 

  const SpikeArray::spike_sequence& SpikeArray::
  spike () const
  {
    return this->spike_;
  }

  SpikeArray::spike_sequence& SpikeArray::
  spike ()
  {
    return this->spike_;
  }

  void SpikeArray::
  spike (const spike_sequence& s)
  {
    this->spike_ = s;
  }


  // TimedSynapticInput
  // 

  const TimedSynapticInput::spike_sequence& TimedSynapticInput::
  spike () const
  {
    return this->spike_;
  }

  TimedSynapticInput::spike_sequence& TimedSynapticInput::
  spike ()
  {
    return this->spike_;
  }

  void TimedSynapticInput::
  spike (const spike_sequence& s)
  {
    this->spike_ = s;
  }

  const TimedSynapticInput::synapse_type& TimedSynapticInput::
  synapse () const
  {
    return this->synapse_.get ();
  }

  TimedSynapticInput::synapse_type& TimedSynapticInput::
  synapse ()
  {
    return this->synapse_.get ();
  }

  void TimedSynapticInput::
  synapse (const synapse_type& x)
  {
    this->synapse_.set (x);
  }

  void TimedSynapticInput::
  synapse (::std::unique_ptr< synapse_type > x)
  {
    this->synapse_.set (std::move (x));
  }

  const TimedSynapticInput::spikeTarget_type& TimedSynapticInput::
  spikeTarget () const
  {
    return this->spikeTarget_.get ();
  }

  TimedSynapticInput::spikeTarget_type& TimedSynapticInput::
  spikeTarget ()
  {
    return this->spikeTarget_.get ();
  }

  void TimedSynapticInput::
  spikeTarget (const spikeTarget_type& x)
  {
    this->spikeTarget_.set (x);
  }

  void TimedSynapticInput::
  spikeTarget (::std::unique_ptr< spikeTarget_type > x)
  {
    this->spikeTarget_.set (std::move (x));
  }


  // SpikeGenerator
  // 

  const SpikeGenerator::period_type& SpikeGenerator::
  period () const
  {
    return this->period_.get ();
  }

  SpikeGenerator::period_type& SpikeGenerator::
  period ()
  {
    return this->period_.get ();
  }

  void SpikeGenerator::
  period (const period_type& x)
  {
    this->period_.set (x);
  }

  void SpikeGenerator::
  period (::std::unique_ptr< period_type > x)
  {
    this->period_.set (std::move (x));
  }


  // SpikeGeneratorRandom
  // 

  const SpikeGeneratorRandom::maxISI_type& SpikeGeneratorRandom::
  maxISI () const
  {
    return this->maxISI_.get ();
  }

  SpikeGeneratorRandom::maxISI_type& SpikeGeneratorRandom::
  maxISI ()
  {
    return this->maxISI_.get ();
  }

  void SpikeGeneratorRandom::
  maxISI (const maxISI_type& x)
  {
    this->maxISI_.set (x);
  }

  void SpikeGeneratorRandom::
  maxISI (::std::unique_ptr< maxISI_type > x)
  {
    this->maxISI_.set (std::move (x));
  }

  const SpikeGeneratorRandom::minISI_type& SpikeGeneratorRandom::
  minISI () const
  {
    return this->minISI_.get ();
  }

  SpikeGeneratorRandom::minISI_type& SpikeGeneratorRandom::
  minISI ()
  {
    return this->minISI_.get ();
  }

  void SpikeGeneratorRandom::
  minISI (const minISI_type& x)
  {
    this->minISI_.set (x);
  }

  void SpikeGeneratorRandom::
  minISI (::std::unique_ptr< minISI_type > x)
  {
    this->minISI_.set (std::move (x));
  }


  // SpikeGeneratorPoisson
  // 

  const SpikeGeneratorPoisson::averageRate_type& SpikeGeneratorPoisson::
  averageRate () const
  {
    return this->averageRate_.get ();
  }

  SpikeGeneratorPoisson::averageRate_type& SpikeGeneratorPoisson::
  averageRate ()
  {
    return this->averageRate_.get ();
  }

  void SpikeGeneratorPoisson::
  averageRate (const averageRate_type& x)
  {
    this->averageRate_.set (x);
  }

  void SpikeGeneratorPoisson::
  averageRate (::std::unique_ptr< averageRate_type > x)
  {
    this->averageRate_.set (std::move (x));
  }


  // SpikeGeneratorRefPoisson
  // 

  const SpikeGeneratorRefPoisson::minimumISI_type& SpikeGeneratorRefPoisson::
  minimumISI () const
  {
    return this->minimumISI_.get ();
  }

  SpikeGeneratorRefPoisson::minimumISI_type& SpikeGeneratorRefPoisson::
  minimumISI ()
  {
    return this->minimumISI_.get ();
  }

  void SpikeGeneratorRefPoisson::
  minimumISI (const minimumISI_type& x)
  {
    this->minimumISI_.set (x);
  }

  void SpikeGeneratorRefPoisson::
  minimumISI (::std::unique_ptr< minimumISI_type > x)
  {
    this->minimumISI_.set (std::move (x));
  }


  // PoissonFiringSynapse
  // 

  const PoissonFiringSynapse::averageRate_type& PoissonFiringSynapse::
  averageRate () const
  {
    return this->averageRate_.get ();
  }

  PoissonFiringSynapse::averageRate_type& PoissonFiringSynapse::
  averageRate ()
  {
    return this->averageRate_.get ();
  }

  void PoissonFiringSynapse::
  averageRate (const averageRate_type& x)
  {
    this->averageRate_.set (x);
  }

  void PoissonFiringSynapse::
  averageRate (::std::unique_ptr< averageRate_type > x)
  {
    this->averageRate_.set (std::move (x));
  }

  const PoissonFiringSynapse::synapse_type& PoissonFiringSynapse::
  synapse () const
  {
    return this->synapse_.get ();
  }

  PoissonFiringSynapse::synapse_type& PoissonFiringSynapse::
  synapse ()
  {
    return this->synapse_.get ();
  }

  void PoissonFiringSynapse::
  synapse (const synapse_type& x)
  {
    this->synapse_.set (x);
  }

  void PoissonFiringSynapse::
  synapse (::std::unique_ptr< synapse_type > x)
  {
    this->synapse_.set (std::move (x));
  }

  const PoissonFiringSynapse::spikeTarget_type& PoissonFiringSynapse::
  spikeTarget () const
  {
    return this->spikeTarget_.get ();
  }

  PoissonFiringSynapse::spikeTarget_type& PoissonFiringSynapse::
  spikeTarget ()
  {
    return this->spikeTarget_.get ();
  }

  void PoissonFiringSynapse::
  spikeTarget (const spikeTarget_type& x)
  {
    this->spikeTarget_.set (x);
  }

  void PoissonFiringSynapse::
  spikeTarget (::std::unique_ptr< spikeTarget_type > x)
  {
    this->spikeTarget_.set (std::move (x));
  }


  // TransientPoissonFiringSynapse
  // 

  const TransientPoissonFiringSynapse::averageRate_type& TransientPoissonFiringSynapse::
  averageRate () const
  {
    return this->averageRate_.get ();
  }

  TransientPoissonFiringSynapse::averageRate_type& TransientPoissonFiringSynapse::
  averageRate ()
  {
    return this->averageRate_.get ();
  }

  void TransientPoissonFiringSynapse::
  averageRate (const averageRate_type& x)
  {
    this->averageRate_.set (x);
  }

  void TransientPoissonFiringSynapse::
  averageRate (::std::unique_ptr< averageRate_type > x)
  {
    this->averageRate_.set (std::move (x));
  }

  const TransientPoissonFiringSynapse::delay_type& TransientPoissonFiringSynapse::
  delay () const
  {
    return this->delay_.get ();
  }

  TransientPoissonFiringSynapse::delay_type& TransientPoissonFiringSynapse::
  delay ()
  {
    return this->delay_.get ();
  }

  void TransientPoissonFiringSynapse::
  delay (const delay_type& x)
  {
    this->delay_.set (x);
  }

  void TransientPoissonFiringSynapse::
  delay (::std::unique_ptr< delay_type > x)
  {
    this->delay_.set (std::move (x));
  }

  const TransientPoissonFiringSynapse::duration_type& TransientPoissonFiringSynapse::
  duration () const
  {
    return this->duration_.get ();
  }

  TransientPoissonFiringSynapse::duration_type& TransientPoissonFiringSynapse::
  duration ()
  {
    return this->duration_.get ();
  }

  void TransientPoissonFiringSynapse::
  duration (const duration_type& x)
  {
    this->duration_.set (x);
  }

  void TransientPoissonFiringSynapse::
  duration (::std::unique_ptr< duration_type > x)
  {
    this->duration_.set (std::move (x));
  }

  const TransientPoissonFiringSynapse::synapse_type& TransientPoissonFiringSynapse::
  synapse () const
  {
    return this->synapse_.get ();
  }

  TransientPoissonFiringSynapse::synapse_type& TransientPoissonFiringSynapse::
  synapse ()
  {
    return this->synapse_.get ();
  }

  void TransientPoissonFiringSynapse::
  synapse (const synapse_type& x)
  {
    this->synapse_.set (x);
  }

  void TransientPoissonFiringSynapse::
  synapse (::std::unique_ptr< synapse_type > x)
  {
    this->synapse_.set (std::move (x));
  }

  const TransientPoissonFiringSynapse::spikeTarget_type& TransientPoissonFiringSynapse::
  spikeTarget () const
  {
    return this->spikeTarget_.get ();
  }

  TransientPoissonFiringSynapse::spikeTarget_type& TransientPoissonFiringSynapse::
  spikeTarget ()
  {
    return this->spikeTarget_.get ();
  }

  void TransientPoissonFiringSynapse::
  spikeTarget (const spikeTarget_type& x)
  {
    this->spikeTarget_.set (x);
  }

  void TransientPoissonFiringSynapse::
  spikeTarget (::std::unique_ptr< spikeTarget_type > x)
  {
    this->spikeTarget_.set (std::move (x));
  }


  // Network
  // 

  const Network::space_sequence& Network::
  space () const
  {
    return this->space_;
  }

  Network::space_sequence& Network::
  space ()
  {
    return this->space_;
  }

  void Network::
  space (const space_sequence& s)
  {
    this->space_ = s;
  }

  const Network::region_sequence& Network::
  region () const
  {
    return this->region_;
  }

  Network::region_sequence& Network::
  region ()
  {
    return this->region_;
  }

  void Network::
  region (const region_sequence& s)
  {
    this->region_ = s;
  }

  const Network::extracellularProperties_sequence& Network::
  extracellularProperties () const
  {
    return this->extracellularProperties_;
  }

  Network::extracellularProperties_sequence& Network::
  extracellularProperties ()
  {
    return this->extracellularProperties_;
  }

  void Network::
  extracellularProperties (const extracellularProperties_sequence& s)
  {
    this->extracellularProperties_ = s;
  }

  const Network::population_sequence& Network::
  population () const
  {
    return this->population_;
  }

  Network::population_sequence& Network::
  population ()
  {
    return this->population_;
  }

  void Network::
  population (const population_sequence& s)
  {
    this->population_ = s;
  }

  const Network::cellSet_sequence& Network::
  cellSet () const
  {
    return this->cellSet_;
  }

  Network::cellSet_sequence& Network::
  cellSet ()
  {
    return this->cellSet_;
  }

  void Network::
  cellSet (const cellSet_sequence& s)
  {
    this->cellSet_ = s;
  }

  const Network::synapticConnection_sequence& Network::
  synapticConnection () const
  {
    return this->synapticConnection_;
  }

  Network::synapticConnection_sequence& Network::
  synapticConnection ()
  {
    return this->synapticConnection_;
  }

  void Network::
  synapticConnection (const synapticConnection_sequence& s)
  {
    this->synapticConnection_ = s;
  }

  const Network::projection_sequence& Network::
  projection () const
  {
    return this->projection_;
  }

  Network::projection_sequence& Network::
  projection ()
  {
    return this->projection_;
  }

  void Network::
  projection (const projection_sequence& s)
  {
    this->projection_ = s;
  }

  const Network::electricalProjection_sequence& Network::
  electricalProjection () const
  {
    return this->electricalProjection_;
  }

  Network::electricalProjection_sequence& Network::
  electricalProjection ()
  {
    return this->electricalProjection_;
  }

  void Network::
  electricalProjection (const electricalProjection_sequence& s)
  {
    this->electricalProjection_ = s;
  }

  const Network::continuousProjection_sequence& Network::
  continuousProjection () const
  {
    return this->continuousProjection_;
  }

  Network::continuousProjection_sequence& Network::
  continuousProjection ()
  {
    return this->continuousProjection_;
  }

  void Network::
  continuousProjection (const continuousProjection_sequence& s)
  {
    this->continuousProjection_ = s;
  }

  const Network::explicitInput_sequence& Network::
  explicitInput () const
  {
    return this->explicitInput_;
  }

  Network::explicitInput_sequence& Network::
  explicitInput ()
  {
    return this->explicitInput_;
  }

  void Network::
  explicitInput (const explicitInput_sequence& s)
  {
    this->explicitInput_ = s;
  }

  const Network::inputList_sequence& Network::
  inputList () const
  {
    return this->inputList_;
  }

  Network::inputList_sequence& Network::
  inputList ()
  {
    return this->inputList_;
  }

  void Network::
  inputList (const inputList_sequence& s)
  {
    this->inputList_ = s;
  }

  const Network::type_optional& Network::
  type () const
  {
    return this->type_;
  }

  Network::type_optional& Network::
  type ()
  {
    return this->type_;
  }

  void Network::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void Network::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void Network::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const Network::temperature_optional& Network::
  temperature () const
  {
    return this->temperature_;
  }

  Network::temperature_optional& Network::
  temperature ()
  {
    return this->temperature_;
  }

  void Network::
  temperature (const temperature_type& x)
  {
    this->temperature_.set (x);
  }

  void Network::
  temperature (const temperature_optional& x)
  {
    this->temperature_ = x;
  }

  void Network::
  temperature (::std::unique_ptr< temperature_type > x)
  {
    this->temperature_.set (std::move (x));
  }


  // networkTypes
  // 

  networkTypes::
  networkTypes (value v)
  : ::xml_schema::string (_xsd_networkTypes_literals_[v])
  {
  }

  networkTypes::
  networkTypes (const char* v)
  : ::xml_schema::string (v)
  {
  }

  networkTypes::
  networkTypes (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  networkTypes::
  networkTypes (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  networkTypes::
  networkTypes (const networkTypes& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  networkTypes& networkTypes::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_networkTypes_literals_[v]);

    return *this;
  }


  // Space
  // 

  const Space::structure_optional& Space::
  structure () const
  {
    return this->structure_;
  }

  Space::structure_optional& Space::
  structure ()
  {
    return this->structure_;
  }

  void Space::
  structure (const structure_type& x)
  {
    this->structure_.set (x);
  }

  void Space::
  structure (const structure_optional& x)
  {
    this->structure_ = x;
  }

  void Space::
  structure (::std::unique_ptr< structure_type > x)
  {
    this->structure_.set (std::move (x));
  }

  const Space::basedOn_optional& Space::
  basedOn () const
  {
    return this->basedOn_;
  }

  Space::basedOn_optional& Space::
  basedOn ()
  {
    return this->basedOn_;
  }

  void Space::
  basedOn (const basedOn_type& x)
  {
    this->basedOn_.set (x);
  }

  void Space::
  basedOn (const basedOn_optional& x)
  {
    this->basedOn_ = x;
  }

  void Space::
  basedOn (::std::unique_ptr< basedOn_type > x)
  {
    this->basedOn_.set (std::move (x));
  }


  // SpaceStructure
  // 

  const SpaceStructure::xSpacing_optional& SpaceStructure::
  xSpacing () const
  {
    return this->xSpacing_;
  }

  SpaceStructure::xSpacing_optional& SpaceStructure::
  xSpacing ()
  {
    return this->xSpacing_;
  }

  void SpaceStructure::
  xSpacing (const xSpacing_type& x)
  {
    this->xSpacing_.set (x);
  }

  void SpaceStructure::
  xSpacing (const xSpacing_optional& x)
  {
    this->xSpacing_ = x;
  }

  const SpaceStructure::ySpacing_optional& SpaceStructure::
  ySpacing () const
  {
    return this->ySpacing_;
  }

  SpaceStructure::ySpacing_optional& SpaceStructure::
  ySpacing ()
  {
    return this->ySpacing_;
  }

  void SpaceStructure::
  ySpacing (const ySpacing_type& x)
  {
    this->ySpacing_.set (x);
  }

  void SpaceStructure::
  ySpacing (const ySpacing_optional& x)
  {
    this->ySpacing_ = x;
  }

  const SpaceStructure::zSpacing_optional& SpaceStructure::
  zSpacing () const
  {
    return this->zSpacing_;
  }

  SpaceStructure::zSpacing_optional& SpaceStructure::
  zSpacing ()
  {
    return this->zSpacing_;
  }

  void SpaceStructure::
  zSpacing (const zSpacing_type& x)
  {
    this->zSpacing_.set (x);
  }

  void SpaceStructure::
  zSpacing (const zSpacing_optional& x)
  {
    this->zSpacing_ = x;
  }

  const SpaceStructure::xStart_type& SpaceStructure::
  xStart () const
  {
    return this->xStart_.get ();
  }

  SpaceStructure::xStart_type& SpaceStructure::
  xStart ()
  {
    return this->xStart_.get ();
  }

  void SpaceStructure::
  xStart (const xStart_type& x)
  {
    this->xStart_.set (x);
  }

  SpaceStructure::xStart_type SpaceStructure::
  xStart_default_value ()
  {
    return xStart_type (0.0F);
  }

  const SpaceStructure::yStart_type& SpaceStructure::
  yStart () const
  {
    return this->yStart_.get ();
  }

  SpaceStructure::yStart_type& SpaceStructure::
  yStart ()
  {
    return this->yStart_.get ();
  }

  void SpaceStructure::
  yStart (const yStart_type& x)
  {
    this->yStart_.set (x);
  }

  SpaceStructure::yStart_type SpaceStructure::
  yStart_default_value ()
  {
    return yStart_type (0.0F);
  }

  const SpaceStructure::zStart_type& SpaceStructure::
  zStart () const
  {
    return this->zStart_.get ();
  }

  SpaceStructure::zStart_type& SpaceStructure::
  zStart ()
  {
    return this->zStart_.get ();
  }

  void SpaceStructure::
  zStart (const zStart_type& x)
  {
    this->zStart_.set (x);
  }

  SpaceStructure::zStart_type SpaceStructure::
  zStart_default_value ()
  {
    return zStart_type (0.0F);
  }


  // allowedSpaces
  // 

  allowedSpaces::
  allowedSpaces (value v)
  : ::xml_schema::string (_xsd_allowedSpaces_literals_[v])
  {
  }

  allowedSpaces::
  allowedSpaces (const char* v)
  : ::xml_schema::string (v)
  {
  }

  allowedSpaces::
  allowedSpaces (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  allowedSpaces::
  allowedSpaces (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  allowedSpaces::
  allowedSpaces (const allowedSpaces& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  allowedSpaces& allowedSpaces::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_allowedSpaces_literals_[v]);

    return *this;
  }


  // Region
  // 

  const Region::space_optional& Region::
  space () const
  {
    return this->space_;
  }

  Region::space_optional& Region::
  space ()
  {
    return this->space_;
  }

  void Region::
  space (const space_type& x)
  {
    this->space_.set (x);
  }

  void Region::
  space (const space_optional& x)
  {
    this->space_ = x;
  }

  void Region::
  space (::std::unique_ptr< space_type > x)
  {
    this->space_.set (std::move (x));
  }


  // Population
  // 

  const Population::layout_optional& Population::
  layout () const
  {
    return this->layout_;
  }

  Population::layout_optional& Population::
  layout ()
  {
    return this->layout_;
  }

  void Population::
  layout (const layout_type& x)
  {
    this->layout_.set (x);
  }

  void Population::
  layout (const layout_optional& x)
  {
    this->layout_ = x;
  }

  void Population::
  layout (::std::unique_ptr< layout_type > x)
  {
    this->layout_.set (std::move (x));
  }

  const Population::instance_sequence& Population::
  instance () const
  {
    return this->instance_;
  }

  Population::instance_sequence& Population::
  instance ()
  {
    return this->instance_;
  }

  void Population::
  instance (const instance_sequence& s)
  {
    this->instance_ = s;
  }

  const Population::component_type& Population::
  component () const
  {
    return this->component_.get ();
  }

  Population::component_type& Population::
  component ()
  {
    return this->component_.get ();
  }

  void Population::
  component (const component_type& x)
  {
    this->component_.set (x);
  }

  void Population::
  component (::std::unique_ptr< component_type > x)
  {
    this->component_.set (std::move (x));
  }

  const Population::size_optional& Population::
  size () const
  {
    return this->size_;
  }

  Population::size_optional& Population::
  size ()
  {
    return this->size_;
  }

  void Population::
  size (const size_type& x)
  {
    this->size_.set (x);
  }

  void Population::
  size (const size_optional& x)
  {
    this->size_ = x;
  }

  void Population::
  size (::std::unique_ptr< size_type > x)
  {
    this->size_.set (std::move (x));
  }

  const Population::type_optional& Population::
  type () const
  {
    return this->type_;
  }

  Population::type_optional& Population::
  type ()
  {
    return this->type_;
  }

  void Population::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void Population::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void Population::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const Population::extracellularProperties_optional& Population::
  extracellularProperties () const
  {
    return this->extracellularProperties_;
  }

  Population::extracellularProperties_optional& Population::
  extracellularProperties ()
  {
    return this->extracellularProperties_;
  }

  void Population::
  extracellularProperties (const extracellularProperties_type& x)
  {
    this->extracellularProperties_.set (x);
  }

  void Population::
  extracellularProperties (const extracellularProperties_optional& x)
  {
    this->extracellularProperties_ = x;
  }

  void Population::
  extracellularProperties (::std::unique_ptr< extracellularProperties_type > x)
  {
    this->extracellularProperties_.set (std::move (x));
  }


  // populationTypes
  // 

  populationTypes::
  populationTypes (value v)
  : ::xml_schema::string (_xsd_populationTypes_literals_[v])
  {
  }

  populationTypes::
  populationTypes (const char* v)
  : ::xml_schema::string (v)
  {
  }

  populationTypes::
  populationTypes (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  populationTypes::
  populationTypes (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  populationTypes::
  populationTypes (const populationTypes& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  populationTypes& populationTypes::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_populationTypes_literals_[v]);

    return *this;
  }


  // Layout
  // 

  const Layout::random_optional& Layout::
  random () const
  {
    return this->random_;
  }

  Layout::random_optional& Layout::
  random ()
  {
    return this->random_;
  }

  void Layout::
  random (const random_type& x)
  {
    this->random_.set (x);
  }

  void Layout::
  random (const random_optional& x)
  {
    this->random_ = x;
  }

  void Layout::
  random (::std::unique_ptr< random_type > x)
  {
    this->random_.set (std::move (x));
  }

  const Layout::grid_optional& Layout::
  grid () const
  {
    return this->grid_;
  }

  Layout::grid_optional& Layout::
  grid ()
  {
    return this->grid_;
  }

  void Layout::
  grid (const grid_type& x)
  {
    this->grid_.set (x);
  }

  void Layout::
  grid (const grid_optional& x)
  {
    this->grid_ = x;
  }

  void Layout::
  grid (::std::unique_ptr< grid_type > x)
  {
    this->grid_.set (std::move (x));
  }

  const Layout::unstructured_optional& Layout::
  unstructured () const
  {
    return this->unstructured_;
  }

  Layout::unstructured_optional& Layout::
  unstructured ()
  {
    return this->unstructured_;
  }

  void Layout::
  unstructured (const unstructured_type& x)
  {
    this->unstructured_.set (x);
  }

  void Layout::
  unstructured (const unstructured_optional& x)
  {
    this->unstructured_ = x;
  }

  void Layout::
  unstructured (::std::unique_ptr< unstructured_type > x)
  {
    this->unstructured_.set (std::move (x));
  }

  const Layout::space_optional& Layout::
  space () const
  {
    return this->space_;
  }

  Layout::space_optional& Layout::
  space ()
  {
    return this->space_;
  }

  void Layout::
  space (const space_type& x)
  {
    this->space_.set (x);
  }

  void Layout::
  space (const space_optional& x)
  {
    this->space_ = x;
  }

  void Layout::
  space (::std::unique_ptr< space_type > x)
  {
    this->space_.set (std::move (x));
  }


  // UnstructuredLayout
  // 

  const UnstructuredLayout::number_optional& UnstructuredLayout::
  number () const
  {
    return this->number_;
  }

  UnstructuredLayout::number_optional& UnstructuredLayout::
  number ()
  {
    return this->number_;
  }

  void UnstructuredLayout::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void UnstructuredLayout::
  number (const number_optional& x)
  {
    this->number_ = x;
  }


  // RandomLayout
  // 

  const RandomLayout::number_optional& RandomLayout::
  number () const
  {
    return this->number_;
  }

  RandomLayout::number_optional& RandomLayout::
  number ()
  {
    return this->number_;
  }

  void RandomLayout::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void RandomLayout::
  number (const number_optional& x)
  {
    this->number_ = x;
  }

  const RandomLayout::region_optional& RandomLayout::
  region () const
  {
    return this->region_;
  }

  RandomLayout::region_optional& RandomLayout::
  region ()
  {
    return this->region_;
  }

  void RandomLayout::
  region (const region_type& x)
  {
    this->region_.set (x);
  }

  void RandomLayout::
  region (const region_optional& x)
  {
    this->region_ = x;
  }

  void RandomLayout::
  region (::std::unique_ptr< region_type > x)
  {
    this->region_.set (std::move (x));
  }


  // GridLayout
  // 

  const GridLayout::xSize_optional& GridLayout::
  xSize () const
  {
    return this->xSize_;
  }

  GridLayout::xSize_optional& GridLayout::
  xSize ()
  {
    return this->xSize_;
  }

  void GridLayout::
  xSize (const xSize_type& x)
  {
    this->xSize_.set (x);
  }

  void GridLayout::
  xSize (const xSize_optional& x)
  {
    this->xSize_ = x;
  }

  const GridLayout::ySize_optional& GridLayout::
  ySize () const
  {
    return this->ySize_;
  }

  GridLayout::ySize_optional& GridLayout::
  ySize ()
  {
    return this->ySize_;
  }

  void GridLayout::
  ySize (const ySize_type& x)
  {
    this->ySize_.set (x);
  }

  void GridLayout::
  ySize (const ySize_optional& x)
  {
    this->ySize_ = x;
  }

  const GridLayout::zSize_optional& GridLayout::
  zSize () const
  {
    return this->zSize_;
  }

  GridLayout::zSize_optional& GridLayout::
  zSize ()
  {
    return this->zSize_;
  }

  void GridLayout::
  zSize (const zSize_type& x)
  {
    this->zSize_.set (x);
  }

  void GridLayout::
  zSize (const zSize_optional& x)
  {
    this->zSize_ = x;
  }


  // Instance
  // 

  const Instance::location_type& Instance::
  location () const
  {
    return this->location_.get ();
  }

  Instance::location_type& Instance::
  location ()
  {
    return this->location_.get ();
  }

  void Instance::
  location (const location_type& x)
  {
    this->location_.set (x);
  }

  void Instance::
  location (::std::unique_ptr< location_type > x)
  {
    this->location_.set (std::move (x));
  }

  const Instance::id_optional& Instance::
  id () const
  {
    return this->id_;
  }

  Instance::id_optional& Instance::
  id ()
  {
    return this->id_;
  }

  void Instance::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void Instance::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  const Instance::i_optional& Instance::
  i () const
  {
    return this->i_;
  }

  Instance::i_optional& Instance::
  i ()
  {
    return this->i_;
  }

  void Instance::
  i (const i_type& x)
  {
    this->i_.set (x);
  }

  void Instance::
  i (const i_optional& x)
  {
    this->i_ = x;
  }

  const Instance::j_optional& Instance::
  j () const
  {
    return this->j_;
  }

  Instance::j_optional& Instance::
  j ()
  {
    return this->j_;
  }

  void Instance::
  j (const j_type& x)
  {
    this->j_.set (x);
  }

  void Instance::
  j (const j_optional& x)
  {
    this->j_ = x;
  }

  const Instance::k_optional& Instance::
  k () const
  {
    return this->k_;
  }

  Instance::k_optional& Instance::
  k ()
  {
    return this->k_;
  }

  void Instance::
  k (const k_type& x)
  {
    this->k_.set (x);
  }

  void Instance::
  k (const k_optional& x)
  {
    this->k_ = x;
  }


  // Location
  // 

  const Location::x_type& Location::
  x () const
  {
    return this->x_.get ();
  }

  Location::x_type& Location::
  x ()
  {
    return this->x_.get ();
  }

  void Location::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  const Location::y_type& Location::
  y () const
  {
    return this->y_.get ();
  }

  Location::y_type& Location::
  y ()
  {
    return this->y_.get ();
  }

  void Location::
  y (const y_type& x)
  {
    this->y_.set (x);
  }

  const Location::z_type& Location::
  z () const
  {
    return this->z_.get ();
  }

  Location::z_type& Location::
  z ()
  {
    return this->z_.get ();
  }

  void Location::
  z (const z_type& x)
  {
    this->z_.set (x);
  }


  // CellSet
  // 

  const CellSet::select_type& CellSet::
  select () const
  {
    return this->select_.get ();
  }

  CellSet::select_type& CellSet::
  select ()
  {
    return this->select_.get ();
  }

  void CellSet::
  select (const select_type& x)
  {
    this->select_.set (x);
  }

  void CellSet::
  select (::std::unique_ptr< select_type > x)
  {
    this->select_.set (std::move (x));
  }


  // SynapticConnection
  // 

  const SynapticConnection::from_type& SynapticConnection::
  from () const
  {
    return this->from_.get ();
  }

  SynapticConnection::from_type& SynapticConnection::
  from ()
  {
    return this->from_.get ();
  }

  void SynapticConnection::
  from (const from_type& x)
  {
    this->from_.set (x);
  }

  void SynapticConnection::
  from (::std::unique_ptr< from_type > x)
  {
    this->from_.set (std::move (x));
  }

  const SynapticConnection::to_type& SynapticConnection::
  to () const
  {
    return this->to_.get ();
  }

  SynapticConnection::to_type& SynapticConnection::
  to ()
  {
    return this->to_.get ();
  }

  void SynapticConnection::
  to (const to_type& x)
  {
    this->to_.set (x);
  }

  void SynapticConnection::
  to (::std::unique_ptr< to_type > x)
  {
    this->to_.set (std::move (x));
  }

  const SynapticConnection::synapse_type& SynapticConnection::
  synapse () const
  {
    return this->synapse_.get ();
  }

  SynapticConnection::synapse_type& SynapticConnection::
  synapse ()
  {
    return this->synapse_.get ();
  }

  void SynapticConnection::
  synapse (const synapse_type& x)
  {
    this->synapse_.set (x);
  }

  void SynapticConnection::
  synapse (::std::unique_ptr< synapse_type > x)
  {
    this->synapse_.set (std::move (x));
  }

  const SynapticConnection::destination_optional& SynapticConnection::
  destination () const
  {
    return this->destination_;
  }

  SynapticConnection::destination_optional& SynapticConnection::
  destination ()
  {
    return this->destination_;
  }

  void SynapticConnection::
  destination (const destination_type& x)
  {
    this->destination_.set (x);
  }

  void SynapticConnection::
  destination (const destination_optional& x)
  {
    this->destination_ = x;
  }

  void SynapticConnection::
  destination (::std::unique_ptr< destination_type > x)
  {
    this->destination_.set (std::move (x));
  }


  // BaseProjection
  // 

  const BaseProjection::presynapticPopulation_type& BaseProjection::
  presynapticPopulation () const
  {
    return this->presynapticPopulation_.get ();
  }

  BaseProjection::presynapticPopulation_type& BaseProjection::
  presynapticPopulation ()
  {
    return this->presynapticPopulation_.get ();
  }

  void BaseProjection::
  presynapticPopulation (const presynapticPopulation_type& x)
  {
    this->presynapticPopulation_.set (x);
  }

  void BaseProjection::
  presynapticPopulation (::std::unique_ptr< presynapticPopulation_type > x)
  {
    this->presynapticPopulation_.set (std::move (x));
  }

  const BaseProjection::postsynapticPopulation_type& BaseProjection::
  postsynapticPopulation () const
  {
    return this->postsynapticPopulation_.get ();
  }

  BaseProjection::postsynapticPopulation_type& BaseProjection::
  postsynapticPopulation ()
  {
    return this->postsynapticPopulation_.get ();
  }

  void BaseProjection::
  postsynapticPopulation (const postsynapticPopulation_type& x)
  {
    this->postsynapticPopulation_.set (x);
  }

  void BaseProjection::
  postsynapticPopulation (::std::unique_ptr< postsynapticPopulation_type > x)
  {
    this->postsynapticPopulation_.set (std::move (x));
  }


  // Projection
  // 

  const Projection::connection_sequence& Projection::
  connection () const
  {
    return this->connection_;
  }

  Projection::connection_sequence& Projection::
  connection ()
  {
    return this->connection_;
  }

  void Projection::
  connection (const connection_sequence& s)
  {
    this->connection_ = s;
  }

  const Projection::connectionWD_sequence& Projection::
  connectionWD () const
  {
    return this->connectionWD_;
  }

  Projection::connectionWD_sequence& Projection::
  connectionWD ()
  {
    return this->connectionWD_;
  }

  void Projection::
  connectionWD (const connectionWD_sequence& s)
  {
    this->connectionWD_ = s;
  }

  const Projection::synapse_type& Projection::
  synapse () const
  {
    return this->synapse_.get ();
  }

  Projection::synapse_type& Projection::
  synapse ()
  {
    return this->synapse_.get ();
  }

  void Projection::
  synapse (const synapse_type& x)
  {
    this->synapse_.set (x);
  }

  void Projection::
  synapse (::std::unique_ptr< synapse_type > x)
  {
    this->synapse_.set (std::move (x));
  }


  // BaseConnection
  // 


  // BaseConnectionOldFormat
  // 

  const BaseConnectionOldFormat::preCellId_type& BaseConnectionOldFormat::
  preCellId () const
  {
    return this->preCellId_.get ();
  }

  BaseConnectionOldFormat::preCellId_type& BaseConnectionOldFormat::
  preCellId ()
  {
    return this->preCellId_.get ();
  }

  void BaseConnectionOldFormat::
  preCellId (const preCellId_type& x)
  {
    this->preCellId_.set (x);
  }

  void BaseConnectionOldFormat::
  preCellId (::std::unique_ptr< preCellId_type > x)
  {
    this->preCellId_.set (std::move (x));
  }

  const BaseConnectionOldFormat::preSegmentId_type& BaseConnectionOldFormat::
  preSegmentId () const
  {
    return this->preSegmentId_.get ();
  }

  BaseConnectionOldFormat::preSegmentId_type& BaseConnectionOldFormat::
  preSegmentId ()
  {
    return this->preSegmentId_.get ();
  }

  void BaseConnectionOldFormat::
  preSegmentId (const preSegmentId_type& x)
  {
    this->preSegmentId_.set (x);
  }

  void BaseConnectionOldFormat::
  preSegmentId (::std::unique_ptr< preSegmentId_type > x)
  {
    this->preSegmentId_.set (std::move (x));
  }

  BaseConnectionOldFormat::preSegmentId_type BaseConnectionOldFormat::
  preSegmentId_default_value ()
  {
    return preSegmentId_type (0ULL);
  }

  const BaseConnectionOldFormat::preFractionAlong_type& BaseConnectionOldFormat::
  preFractionAlong () const
  {
    return this->preFractionAlong_.get ();
  }

  BaseConnectionOldFormat::preFractionAlong_type& BaseConnectionOldFormat::
  preFractionAlong ()
  {
    return this->preFractionAlong_.get ();
  }

  void BaseConnectionOldFormat::
  preFractionAlong (const preFractionAlong_type& x)
  {
    this->preFractionAlong_.set (x);
  }

  void BaseConnectionOldFormat::
  preFractionAlong (::std::unique_ptr< preFractionAlong_type > x)
  {
    this->preFractionAlong_.set (std::move (x));
  }

  BaseConnectionOldFormat::preFractionAlong_type BaseConnectionOldFormat::
  preFractionAlong_default_value ()
  {
    return preFractionAlong_type (.5F);
  }

  const BaseConnectionOldFormat::postCellId_type& BaseConnectionOldFormat::
  postCellId () const
  {
    return this->postCellId_.get ();
  }

  BaseConnectionOldFormat::postCellId_type& BaseConnectionOldFormat::
  postCellId ()
  {
    return this->postCellId_.get ();
  }

  void BaseConnectionOldFormat::
  postCellId (const postCellId_type& x)
  {
    this->postCellId_.set (x);
  }

  void BaseConnectionOldFormat::
  postCellId (::std::unique_ptr< postCellId_type > x)
  {
    this->postCellId_.set (std::move (x));
  }

  const BaseConnectionOldFormat::postSegmentId_type& BaseConnectionOldFormat::
  postSegmentId () const
  {
    return this->postSegmentId_.get ();
  }

  BaseConnectionOldFormat::postSegmentId_type& BaseConnectionOldFormat::
  postSegmentId ()
  {
    return this->postSegmentId_.get ();
  }

  void BaseConnectionOldFormat::
  postSegmentId (const postSegmentId_type& x)
  {
    this->postSegmentId_.set (x);
  }

  void BaseConnectionOldFormat::
  postSegmentId (::std::unique_ptr< postSegmentId_type > x)
  {
    this->postSegmentId_.set (std::move (x));
  }

  BaseConnectionOldFormat::postSegmentId_type BaseConnectionOldFormat::
  postSegmentId_default_value ()
  {
    return postSegmentId_type (0ULL);
  }

  const BaseConnectionOldFormat::postFractionAlong_type& BaseConnectionOldFormat::
  postFractionAlong () const
  {
    return this->postFractionAlong_.get ();
  }

  BaseConnectionOldFormat::postFractionAlong_type& BaseConnectionOldFormat::
  postFractionAlong ()
  {
    return this->postFractionAlong_.get ();
  }

  void BaseConnectionOldFormat::
  postFractionAlong (const postFractionAlong_type& x)
  {
    this->postFractionAlong_.set (x);
  }

  void BaseConnectionOldFormat::
  postFractionAlong (::std::unique_ptr< postFractionAlong_type > x)
  {
    this->postFractionAlong_.set (std::move (x));
  }

  BaseConnectionOldFormat::postFractionAlong_type BaseConnectionOldFormat::
  postFractionAlong_default_value ()
  {
    return postFractionAlong_type (.5F);
  }


  // BaseConnectionNewFormat
  // 

  const BaseConnectionNewFormat::preCell_type& BaseConnectionNewFormat::
  preCell () const
  {
    return this->preCell_.get ();
  }

  BaseConnectionNewFormat::preCell_type& BaseConnectionNewFormat::
  preCell ()
  {
    return this->preCell_.get ();
  }

  void BaseConnectionNewFormat::
  preCell (const preCell_type& x)
  {
    this->preCell_.set (x);
  }

  void BaseConnectionNewFormat::
  preCell (::std::unique_ptr< preCell_type > x)
  {
    this->preCell_.set (std::move (x));
  }

  const BaseConnectionNewFormat::preSegment_type& BaseConnectionNewFormat::
  preSegment () const
  {
    return this->preSegment_.get ();
  }

  BaseConnectionNewFormat::preSegment_type& BaseConnectionNewFormat::
  preSegment ()
  {
    return this->preSegment_.get ();
  }

  void BaseConnectionNewFormat::
  preSegment (const preSegment_type& x)
  {
    this->preSegment_.set (x);
  }

  void BaseConnectionNewFormat::
  preSegment (::std::unique_ptr< preSegment_type > x)
  {
    this->preSegment_.set (std::move (x));
  }

  BaseConnectionNewFormat::preSegment_type BaseConnectionNewFormat::
  preSegment_default_value ()
  {
    return preSegment_type (0ULL);
  }

  const BaseConnectionNewFormat::preFractionAlong_type& BaseConnectionNewFormat::
  preFractionAlong () const
  {
    return this->preFractionAlong_.get ();
  }

  BaseConnectionNewFormat::preFractionAlong_type& BaseConnectionNewFormat::
  preFractionAlong ()
  {
    return this->preFractionAlong_.get ();
  }

  void BaseConnectionNewFormat::
  preFractionAlong (const preFractionAlong_type& x)
  {
    this->preFractionAlong_.set (x);
  }

  void BaseConnectionNewFormat::
  preFractionAlong (::std::unique_ptr< preFractionAlong_type > x)
  {
    this->preFractionAlong_.set (std::move (x));
  }

  BaseConnectionNewFormat::preFractionAlong_type BaseConnectionNewFormat::
  preFractionAlong_default_value ()
  {
    return preFractionAlong_type (.5F);
  }

  const BaseConnectionNewFormat::postCell_type& BaseConnectionNewFormat::
  postCell () const
  {
    return this->postCell_.get ();
  }

  BaseConnectionNewFormat::postCell_type& BaseConnectionNewFormat::
  postCell ()
  {
    return this->postCell_.get ();
  }

  void BaseConnectionNewFormat::
  postCell (const postCell_type& x)
  {
    this->postCell_.set (x);
  }

  void BaseConnectionNewFormat::
  postCell (::std::unique_ptr< postCell_type > x)
  {
    this->postCell_.set (std::move (x));
  }

  const BaseConnectionNewFormat::postSegment_type& BaseConnectionNewFormat::
  postSegment () const
  {
    return this->postSegment_.get ();
  }

  BaseConnectionNewFormat::postSegment_type& BaseConnectionNewFormat::
  postSegment ()
  {
    return this->postSegment_.get ();
  }

  void BaseConnectionNewFormat::
  postSegment (const postSegment_type& x)
  {
    this->postSegment_.set (x);
  }

  void BaseConnectionNewFormat::
  postSegment (::std::unique_ptr< postSegment_type > x)
  {
    this->postSegment_.set (std::move (x));
  }

  BaseConnectionNewFormat::postSegment_type BaseConnectionNewFormat::
  postSegment_default_value ()
  {
    return postSegment_type (0ULL);
  }

  const BaseConnectionNewFormat::postFractionAlong_type& BaseConnectionNewFormat::
  postFractionAlong () const
  {
    return this->postFractionAlong_.get ();
  }

  BaseConnectionNewFormat::postFractionAlong_type& BaseConnectionNewFormat::
  postFractionAlong ()
  {
    return this->postFractionAlong_.get ();
  }

  void BaseConnectionNewFormat::
  postFractionAlong (const postFractionAlong_type& x)
  {
    this->postFractionAlong_.set (x);
  }

  void BaseConnectionNewFormat::
  postFractionAlong (::std::unique_ptr< postFractionAlong_type > x)
  {
    this->postFractionAlong_.set (std::move (x));
  }

  BaseConnectionNewFormat::postFractionAlong_type BaseConnectionNewFormat::
  postFractionAlong_default_value ()
  {
    return postFractionAlong_type (.5F);
  }


  // Connection_base
  // 


  // ConnectionWD
  // 

  const ConnectionWD::weight_type& ConnectionWD::
  weight () const
  {
    return this->weight_.get ();
  }

  ConnectionWD::weight_type& ConnectionWD::
  weight ()
  {
    return this->weight_.get ();
  }

  void ConnectionWD::
  weight (const weight_type& x)
  {
    this->weight_.set (x);
  }

  const ConnectionWD::delay_type& ConnectionWD::
  delay () const
  {
    return this->delay_.get ();
  }

  ConnectionWD::delay_type& ConnectionWD::
  delay ()
  {
    return this->delay_.get ();
  }

  void ConnectionWD::
  delay (const delay_type& x)
  {
    this->delay_.set (x);
  }

  void ConnectionWD::
  delay (::std::unique_ptr< delay_type > x)
  {
    this->delay_.set (std::move (x));
  }


  // ElectricalProjection
  // 

  const ElectricalProjection::electricalConnection_sequence& ElectricalProjection::
  electricalConnection () const
  {
    return this->electricalConnection_;
  }

  ElectricalProjection::electricalConnection_sequence& ElectricalProjection::
  electricalConnection ()
  {
    return this->electricalConnection_;
  }

  void ElectricalProjection::
  electricalConnection (const electricalConnection_sequence& s)
  {
    this->electricalConnection_ = s;
  }

  const ElectricalProjection::electricalConnectionInstance_sequence& ElectricalProjection::
  electricalConnectionInstance () const
  {
    return this->electricalConnectionInstance_;
  }

  ElectricalProjection::electricalConnectionInstance_sequence& ElectricalProjection::
  electricalConnectionInstance ()
  {
    return this->electricalConnectionInstance_;
  }

  void ElectricalProjection::
  electricalConnectionInstance (const electricalConnectionInstance_sequence& s)
  {
    this->electricalConnectionInstance_ = s;
  }

  const ElectricalProjection::electricalConnectionInstanceW_sequence& ElectricalProjection::
  electricalConnectionInstanceW () const
  {
    return this->electricalConnectionInstanceW_;
  }

  ElectricalProjection::electricalConnectionInstanceW_sequence& ElectricalProjection::
  electricalConnectionInstanceW ()
  {
    return this->electricalConnectionInstanceW_;
  }

  void ElectricalProjection::
  electricalConnectionInstanceW (const electricalConnectionInstanceW_sequence& s)
  {
    this->electricalConnectionInstanceW_ = s;
  }


  // ElectricalConnection
  // 

  const ElectricalConnection::synapse_type& ElectricalConnection::
  synapse () const
  {
    return this->synapse_.get ();
  }

  ElectricalConnection::synapse_type& ElectricalConnection::
  synapse ()
  {
    return this->synapse_.get ();
  }

  void ElectricalConnection::
  synapse (const synapse_type& x)
  {
    this->synapse_.set (x);
  }

  void ElectricalConnection::
  synapse (::std::unique_ptr< synapse_type > x)
  {
    this->synapse_.set (std::move (x));
  }


  // ElectricalConnectionInstance
  // 


  // ElectricalConnectionInstanceW
  // 

  const ElectricalConnectionInstanceW::weight_type& ElectricalConnectionInstanceW::
  weight () const
  {
    return this->weight_.get ();
  }

  ElectricalConnectionInstanceW::weight_type& ElectricalConnectionInstanceW::
  weight ()
  {
    return this->weight_.get ();
  }

  void ElectricalConnectionInstanceW::
  weight (const weight_type& x)
  {
    this->weight_.set (x);
  }


  // ContinuousProjection
  // 

  const ContinuousProjection::continuousConnection_sequence& ContinuousProjection::
  continuousConnection () const
  {
    return this->continuousConnection_;
  }

  ContinuousProjection::continuousConnection_sequence& ContinuousProjection::
  continuousConnection ()
  {
    return this->continuousConnection_;
  }

  void ContinuousProjection::
  continuousConnection (const continuousConnection_sequence& s)
  {
    this->continuousConnection_ = s;
  }

  const ContinuousProjection::continuousConnectionInstance_sequence& ContinuousProjection::
  continuousConnectionInstance () const
  {
    return this->continuousConnectionInstance_;
  }

  ContinuousProjection::continuousConnectionInstance_sequence& ContinuousProjection::
  continuousConnectionInstance ()
  {
    return this->continuousConnectionInstance_;
  }

  void ContinuousProjection::
  continuousConnectionInstance (const continuousConnectionInstance_sequence& s)
  {
    this->continuousConnectionInstance_ = s;
  }

  const ContinuousProjection::continuousConnectionInstanceW_sequence& ContinuousProjection::
  continuousConnectionInstanceW () const
  {
    return this->continuousConnectionInstanceW_;
  }

  ContinuousProjection::continuousConnectionInstanceW_sequence& ContinuousProjection::
  continuousConnectionInstanceW ()
  {
    return this->continuousConnectionInstanceW_;
  }

  void ContinuousProjection::
  continuousConnectionInstanceW (const continuousConnectionInstanceW_sequence& s)
  {
    this->continuousConnectionInstanceW_ = s;
  }


  // ContinuousConnection
  // 

  const ContinuousConnection::preComponent_type& ContinuousConnection::
  preComponent () const
  {
    return this->preComponent_.get ();
  }

  ContinuousConnection::preComponent_type& ContinuousConnection::
  preComponent ()
  {
    return this->preComponent_.get ();
  }

  void ContinuousConnection::
  preComponent (const preComponent_type& x)
  {
    this->preComponent_.set (x);
  }

  void ContinuousConnection::
  preComponent (::std::unique_ptr< preComponent_type > x)
  {
    this->preComponent_.set (std::move (x));
  }

  const ContinuousConnection::postComponent_type& ContinuousConnection::
  postComponent () const
  {
    return this->postComponent_.get ();
  }

  ContinuousConnection::postComponent_type& ContinuousConnection::
  postComponent ()
  {
    return this->postComponent_.get ();
  }

  void ContinuousConnection::
  postComponent (const postComponent_type& x)
  {
    this->postComponent_.set (x);
  }

  void ContinuousConnection::
  postComponent (::std::unique_ptr< postComponent_type > x)
  {
    this->postComponent_.set (std::move (x));
  }


  // ContinuousConnectionInstance
  // 


  // ContinuousConnectionInstanceW
  // 

  const ContinuousConnectionInstanceW::weight_type& ContinuousConnectionInstanceW::
  weight () const
  {
    return this->weight_.get ();
  }

  ContinuousConnectionInstanceW::weight_type& ContinuousConnectionInstanceW::
  weight ()
  {
    return this->weight_.get ();
  }

  void ContinuousConnectionInstanceW::
  weight (const weight_type& x)
  {
    this->weight_.set (x);
  }


  // ExplicitInput
  // 

  const ExplicitInput::target_type& ExplicitInput::
  target () const
  {
    return this->target_.get ();
  }

  ExplicitInput::target_type& ExplicitInput::
  target ()
  {
    return this->target_.get ();
  }

  void ExplicitInput::
  target (const target_type& x)
  {
    this->target_.set (x);
  }

  void ExplicitInput::
  target (::std::unique_ptr< target_type > x)
  {
    this->target_.set (std::move (x));
  }

  const ExplicitInput::input_type& ExplicitInput::
  input () const
  {
    return this->input_.get ();
  }

  ExplicitInput::input_type& ExplicitInput::
  input ()
  {
    return this->input_.get ();
  }

  void ExplicitInput::
  input (const input_type& x)
  {
    this->input_.set (x);
  }

  void ExplicitInput::
  input (::std::unique_ptr< input_type > x)
  {
    this->input_.set (std::move (x));
  }

  const ExplicitInput::destination_optional& ExplicitInput::
  destination () const
  {
    return this->destination_;
  }

  ExplicitInput::destination_optional& ExplicitInput::
  destination ()
  {
    return this->destination_;
  }

  void ExplicitInput::
  destination (const destination_type& x)
  {
    this->destination_.set (x);
  }

  void ExplicitInput::
  destination (const destination_optional& x)
  {
    this->destination_ = x;
  }

  void ExplicitInput::
  destination (::std::unique_ptr< destination_type > x)
  {
    this->destination_.set (std::move (x));
  }


  // InputList
  // 

  const InputList::input_sequence& InputList::
  input () const
  {
    return this->input_;
  }

  InputList::input_sequence& InputList::
  input ()
  {
    return this->input_;
  }

  void InputList::
  input (const input_sequence& s)
  {
    this->input_ = s;
  }

  const InputList::inputW_sequence& InputList::
  inputW () const
  {
    return this->inputW_;
  }

  InputList::inputW_sequence& InputList::
  inputW ()
  {
    return this->inputW_;
  }

  void InputList::
  inputW (const inputW_sequence& s)
  {
    this->inputW_ = s;
  }

  const InputList::population_type& InputList::
  population () const
  {
    return this->population_.get ();
  }

  InputList::population_type& InputList::
  population ()
  {
    return this->population_.get ();
  }

  void InputList::
  population (const population_type& x)
  {
    this->population_.set (x);
  }

  void InputList::
  population (::std::unique_ptr< population_type > x)
  {
    this->population_.set (std::move (x));
  }

  const InputList::component_type& InputList::
  component () const
  {
    return this->component_.get ();
  }

  InputList::component_type& InputList::
  component ()
  {
    return this->component_.get ();
  }

  void InputList::
  component (const component_type& x)
  {
    this->component_.set (x);
  }

  void InputList::
  component (::std::unique_ptr< component_type > x)
  {
    this->component_.set (std::move (x));
  }


  // Input
  // 

  const Input::id_type& Input::
  id () const
  {
    return this->id_.get ();
  }

  Input::id_type& Input::
  id ()
  {
    return this->id_.get ();
  }

  void Input::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void Input::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const Input::target_type& Input::
  target () const
  {
    return this->target_.get ();
  }

  Input::target_type& Input::
  target ()
  {
    return this->target_.get ();
  }

  void Input::
  target (const target_type& x)
  {
    this->target_.set (x);
  }

  void Input::
  target (::std::unique_ptr< target_type > x)
  {
    this->target_.set (std::move (x));
  }

  const Input::destination_type& Input::
  destination () const
  {
    return this->destination_.get ();
  }

  Input::destination_type& Input::
  destination ()
  {
    return this->destination_.get ();
  }

  void Input::
  destination (const destination_type& x)
  {
    this->destination_.set (x);
  }

  void Input::
  destination (::std::unique_ptr< destination_type > x)
  {
    this->destination_.set (std::move (x));
  }

  const Input::segmentId_optional& Input::
  segmentId () const
  {
    return this->segmentId_;
  }

  Input::segmentId_optional& Input::
  segmentId ()
  {
    return this->segmentId_;
  }

  void Input::
  segmentId (const segmentId_type& x)
  {
    this->segmentId_.set (x);
  }

  void Input::
  segmentId (const segmentId_optional& x)
  {
    this->segmentId_ = x;
  }

  void Input::
  segmentId (::std::unique_ptr< segmentId_type > x)
  {
    this->segmentId_.set (std::move (x));
  }

  const Input::fractionAlong_optional& Input::
  fractionAlong () const
  {
    return this->fractionAlong_;
  }

  Input::fractionAlong_optional& Input::
  fractionAlong ()
  {
    return this->fractionAlong_;
  }

  void Input::
  fractionAlong (const fractionAlong_type& x)
  {
    this->fractionAlong_.set (x);
  }

  void Input::
  fractionAlong (const fractionAlong_optional& x)
  {
    this->fractionAlong_ = x;
  }

  void Input::
  fractionAlong (::std::unique_ptr< fractionAlong_type > x)
  {
    this->fractionAlong_.set (std::move (x));
  }


  // InputW
  // 

  const InputW::weight_type& InputW::
  weight () const
  {
    return this->weight_.get ();
  }

  InputW::weight_type& InputW::
  weight ()
  {
    return this->weight_.get ();
  }

  void InputW::
  weight (const weight_type& x)
  {
    this->weight_.set (x);
  }


  // basePyNNCell
  // 

  const basePyNNCell::cm_type& basePyNNCell::
  cm () const
  {
    return this->cm_.get ();
  }

  basePyNNCell::cm_type& basePyNNCell::
  cm ()
  {
    return this->cm_.get ();
  }

  void basePyNNCell::
  cm (const cm_type& x)
  {
    this->cm_.set (x);
  }

  const basePyNNCell::i_offset_type& basePyNNCell::
  i_offset () const
  {
    return this->i_offset_.get ();
  }

  basePyNNCell::i_offset_type& basePyNNCell::
  i_offset ()
  {
    return this->i_offset_.get ();
  }

  void basePyNNCell::
  i_offset (const i_offset_type& x)
  {
    this->i_offset_.set (x);
  }

  const basePyNNCell::tau_syn_E_type& basePyNNCell::
  tau_syn_E () const
  {
    return this->tau_syn_E_.get ();
  }

  basePyNNCell::tau_syn_E_type& basePyNNCell::
  tau_syn_E ()
  {
    return this->tau_syn_E_.get ();
  }

  void basePyNNCell::
  tau_syn_E (const tau_syn_E_type& x)
  {
    this->tau_syn_E_.set (x);
  }

  const basePyNNCell::tau_syn_I_type& basePyNNCell::
  tau_syn_I () const
  {
    return this->tau_syn_I_.get ();
  }

  basePyNNCell::tau_syn_I_type& basePyNNCell::
  tau_syn_I ()
  {
    return this->tau_syn_I_.get ();
  }

  void basePyNNCell::
  tau_syn_I (const tau_syn_I_type& x)
  {
    this->tau_syn_I_.set (x);
  }

  const basePyNNCell::v_init_type& basePyNNCell::
  v_init () const
  {
    return this->v_init_.get ();
  }

  basePyNNCell::v_init_type& basePyNNCell::
  v_init ()
  {
    return this->v_init_.get ();
  }

  void basePyNNCell::
  v_init (const v_init_type& x)
  {
    this->v_init_.set (x);
  }


  // basePyNNIaFCell
  // 

  const basePyNNIaFCell::tau_m_type& basePyNNIaFCell::
  tau_m () const
  {
    return this->tau_m_.get ();
  }

  basePyNNIaFCell::tau_m_type& basePyNNIaFCell::
  tau_m ()
  {
    return this->tau_m_.get ();
  }

  void basePyNNIaFCell::
  tau_m (const tau_m_type& x)
  {
    this->tau_m_.set (x);
  }

  const basePyNNIaFCell::tau_refrac_type& basePyNNIaFCell::
  tau_refrac () const
  {
    return this->tau_refrac_.get ();
  }

  basePyNNIaFCell::tau_refrac_type& basePyNNIaFCell::
  tau_refrac ()
  {
    return this->tau_refrac_.get ();
  }

  void basePyNNIaFCell::
  tau_refrac (const tau_refrac_type& x)
  {
    this->tau_refrac_.set (x);
  }

  const basePyNNIaFCell::v_reset_type& basePyNNIaFCell::
  v_reset () const
  {
    return this->v_reset_.get ();
  }

  basePyNNIaFCell::v_reset_type& basePyNNIaFCell::
  v_reset ()
  {
    return this->v_reset_.get ();
  }

  void basePyNNIaFCell::
  v_reset (const v_reset_type& x)
  {
    this->v_reset_.set (x);
  }

  const basePyNNIaFCell::v_rest_type& basePyNNIaFCell::
  v_rest () const
  {
    return this->v_rest_.get ();
  }

  basePyNNIaFCell::v_rest_type& basePyNNIaFCell::
  v_rest ()
  {
    return this->v_rest_.get ();
  }

  void basePyNNIaFCell::
  v_rest (const v_rest_type& x)
  {
    this->v_rest_.set (x);
  }

  const basePyNNIaFCell::v_thresh_type& basePyNNIaFCell::
  v_thresh () const
  {
    return this->v_thresh_.get ();
  }

  basePyNNIaFCell::v_thresh_type& basePyNNIaFCell::
  v_thresh ()
  {
    return this->v_thresh_.get ();
  }

  void basePyNNIaFCell::
  v_thresh (const v_thresh_type& x)
  {
    this->v_thresh_.set (x);
  }


  // basePyNNIaFCondCell
  // 

  const basePyNNIaFCondCell::e_rev_E_type& basePyNNIaFCondCell::
  e_rev_E () const
  {
    return this->e_rev_E_.get ();
  }

  basePyNNIaFCondCell::e_rev_E_type& basePyNNIaFCondCell::
  e_rev_E ()
  {
    return this->e_rev_E_.get ();
  }

  void basePyNNIaFCondCell::
  e_rev_E (const e_rev_E_type& x)
  {
    this->e_rev_E_.set (x);
  }

  const basePyNNIaFCondCell::e_rev_I_type& basePyNNIaFCondCell::
  e_rev_I () const
  {
    return this->e_rev_I_.get ();
  }

  basePyNNIaFCondCell::e_rev_I_type& basePyNNIaFCondCell::
  e_rev_I ()
  {
    return this->e_rev_I_.get ();
  }

  void basePyNNIaFCondCell::
  e_rev_I (const e_rev_I_type& x)
  {
    this->e_rev_I_.set (x);
  }


  // IF_curr_alpha
  // 


  // IF_curr_exp
  // 


  // IF_cond_alpha
  // 


  // IF_cond_exp
  // 


  // EIF_cond_exp_isfa_ista
  // 

  const EIF_cond_exp_isfa_ista::a_type& EIF_cond_exp_isfa_ista::
  a () const
  {
    return this->a_.get ();
  }

  EIF_cond_exp_isfa_ista::a_type& EIF_cond_exp_isfa_ista::
  a ()
  {
    return this->a_.get ();
  }

  void EIF_cond_exp_isfa_ista::
  a (const a_type& x)
  {
    this->a_.set (x);
  }

  const EIF_cond_exp_isfa_ista::b_type& EIF_cond_exp_isfa_ista::
  b () const
  {
    return this->b_.get ();
  }

  EIF_cond_exp_isfa_ista::b_type& EIF_cond_exp_isfa_ista::
  b ()
  {
    return this->b_.get ();
  }

  void EIF_cond_exp_isfa_ista::
  b (const b_type& x)
  {
    this->b_.set (x);
  }

  const EIF_cond_exp_isfa_ista::delta_T_type& EIF_cond_exp_isfa_ista::
  delta_T () const
  {
    return this->delta_T_.get ();
  }

  EIF_cond_exp_isfa_ista::delta_T_type& EIF_cond_exp_isfa_ista::
  delta_T ()
  {
    return this->delta_T_.get ();
  }

  void EIF_cond_exp_isfa_ista::
  delta_T (const delta_T_type& x)
  {
    this->delta_T_.set (x);
  }

  const EIF_cond_exp_isfa_ista::tau_w_type& EIF_cond_exp_isfa_ista::
  tau_w () const
  {
    return this->tau_w_.get ();
  }

  EIF_cond_exp_isfa_ista::tau_w_type& EIF_cond_exp_isfa_ista::
  tau_w ()
  {
    return this->tau_w_.get ();
  }

  void EIF_cond_exp_isfa_ista::
  tau_w (const tau_w_type& x)
  {
    this->tau_w_.set (x);
  }

  const EIF_cond_exp_isfa_ista::v_spike_type& EIF_cond_exp_isfa_ista::
  v_spike () const
  {
    return this->v_spike_.get ();
  }

  EIF_cond_exp_isfa_ista::v_spike_type& EIF_cond_exp_isfa_ista::
  v_spike ()
  {
    return this->v_spike_.get ();
  }

  void EIF_cond_exp_isfa_ista::
  v_spike (const v_spike_type& x)
  {
    this->v_spike_.set (x);
  }


  // EIF_cond_alpha_isfa_ista
  // 


  // HH_cond_exp
  // 

  const HH_cond_exp::v_offset_type& HH_cond_exp::
  v_offset () const
  {
    return this->v_offset_.get ();
  }

  HH_cond_exp::v_offset_type& HH_cond_exp::
  v_offset ()
  {
    return this->v_offset_.get ();
  }

  void HH_cond_exp::
  v_offset (const v_offset_type& x)
  {
    this->v_offset_.set (x);
  }

  const HH_cond_exp::e_rev_E_type& HH_cond_exp::
  e_rev_E () const
  {
    return this->e_rev_E_.get ();
  }

  HH_cond_exp::e_rev_E_type& HH_cond_exp::
  e_rev_E ()
  {
    return this->e_rev_E_.get ();
  }

  void HH_cond_exp::
  e_rev_E (const e_rev_E_type& x)
  {
    this->e_rev_E_.set (x);
  }

  const HH_cond_exp::e_rev_I_type& HH_cond_exp::
  e_rev_I () const
  {
    return this->e_rev_I_.get ();
  }

  HH_cond_exp::e_rev_I_type& HH_cond_exp::
  e_rev_I ()
  {
    return this->e_rev_I_.get ();
  }

  void HH_cond_exp::
  e_rev_I (const e_rev_I_type& x)
  {
    this->e_rev_I_.set (x);
  }

  const HH_cond_exp::e_rev_K_type& HH_cond_exp::
  e_rev_K () const
  {
    return this->e_rev_K_.get ();
  }

  HH_cond_exp::e_rev_K_type& HH_cond_exp::
  e_rev_K ()
  {
    return this->e_rev_K_.get ();
  }

  void HH_cond_exp::
  e_rev_K (const e_rev_K_type& x)
  {
    this->e_rev_K_.set (x);
  }

  const HH_cond_exp::e_rev_Na_type& HH_cond_exp::
  e_rev_Na () const
  {
    return this->e_rev_Na_.get ();
  }

  HH_cond_exp::e_rev_Na_type& HH_cond_exp::
  e_rev_Na ()
  {
    return this->e_rev_Na_.get ();
  }

  void HH_cond_exp::
  e_rev_Na (const e_rev_Na_type& x)
  {
    this->e_rev_Na_.set (x);
  }

  const HH_cond_exp::e_rev_leak_type& HH_cond_exp::
  e_rev_leak () const
  {
    return this->e_rev_leak_.get ();
  }

  HH_cond_exp::e_rev_leak_type& HH_cond_exp::
  e_rev_leak ()
  {
    return this->e_rev_leak_.get ();
  }

  void HH_cond_exp::
  e_rev_leak (const e_rev_leak_type& x)
  {
    this->e_rev_leak_.set (x);
  }

  const HH_cond_exp::g_leak_type& HH_cond_exp::
  g_leak () const
  {
    return this->g_leak_.get ();
  }

  HH_cond_exp::g_leak_type& HH_cond_exp::
  g_leak ()
  {
    return this->g_leak_.get ();
  }

  void HH_cond_exp::
  g_leak (const g_leak_type& x)
  {
    this->g_leak_.set (x);
  }

  const HH_cond_exp::gbar_K_type& HH_cond_exp::
  gbar_K () const
  {
    return this->gbar_K_.get ();
  }

  HH_cond_exp::gbar_K_type& HH_cond_exp::
  gbar_K ()
  {
    return this->gbar_K_.get ();
  }

  void HH_cond_exp::
  gbar_K (const gbar_K_type& x)
  {
    this->gbar_K_.set (x);
  }

  const HH_cond_exp::gbar_Na_type& HH_cond_exp::
  gbar_Na () const
  {
    return this->gbar_Na_.get ();
  }

  HH_cond_exp::gbar_Na_type& HH_cond_exp::
  gbar_Na ()
  {
    return this->gbar_Na_.get ();
  }

  void HH_cond_exp::
  gbar_Na (const gbar_Na_type& x)
  {
    this->gbar_Na_.set (x);
  }


  // BasePynnSynapse
  // 

  const BasePynnSynapse::tau_syn_type& BasePynnSynapse::
  tau_syn () const
  {
    return this->tau_syn_.get ();
  }

  BasePynnSynapse::tau_syn_type& BasePynnSynapse::
  tau_syn ()
  {
    return this->tau_syn_.get ();
  }

  void BasePynnSynapse::
  tau_syn (const tau_syn_type& x)
  {
    this->tau_syn_.set (x);
  }


  // ExpCondSynapse
  // 

  const ExpCondSynapse::e_rev_type& ExpCondSynapse::
  e_rev () const
  {
    return this->e_rev_.get ();
  }

  ExpCondSynapse::e_rev_type& ExpCondSynapse::
  e_rev ()
  {
    return this->e_rev_.get ();
  }

  void ExpCondSynapse::
  e_rev (const e_rev_type& x)
  {
    this->e_rev_.set (x);
  }


  // AlphaCondSynapse
  // 

  const AlphaCondSynapse::e_rev_type& AlphaCondSynapse::
  e_rev () const
  {
    return this->e_rev_.get ();
  }

  AlphaCondSynapse::e_rev_type& AlphaCondSynapse::
  e_rev ()
  {
    return this->e_rev_.get ();
  }

  void AlphaCondSynapse::
  e_rev (const e_rev_type& x)
  {
    this->e_rev_.set (x);
  }


  // ExpCurrSynapse
  // 


  // AlphaCurrSynapse
  // 


  // SpikeSourcePoisson
  // 

  const SpikeSourcePoisson::start_type& SpikeSourcePoisson::
  start () const
  {
    return this->start_.get ();
  }

  SpikeSourcePoisson::start_type& SpikeSourcePoisson::
  start ()
  {
    return this->start_.get ();
  }

  void SpikeSourcePoisson::
  start (const start_type& x)
  {
    this->start_.set (x);
  }

  void SpikeSourcePoisson::
  start (::std::unique_ptr< start_type > x)
  {
    this->start_.set (std::move (x));
  }

  const SpikeSourcePoisson::duration_type& SpikeSourcePoisson::
  duration () const
  {
    return this->duration_.get ();
  }

  SpikeSourcePoisson::duration_type& SpikeSourcePoisson::
  duration ()
  {
    return this->duration_.get ();
  }

  void SpikeSourcePoisson::
  duration (const duration_type& x)
  {
    this->duration_.set (x);
  }

  void SpikeSourcePoisson::
  duration (::std::unique_ptr< duration_type > x)
  {
    this->duration_.set (std::move (x));
  }

  const SpikeSourcePoisson::rate_type& SpikeSourcePoisson::
  rate () const
  {
    return this->rate_.get ();
  }

  SpikeSourcePoisson::rate_type& SpikeSourcePoisson::
  rate ()
  {
    return this->rate_.get ();
  }

  void SpikeSourcePoisson::
  rate (const rate_type& x)
  {
    this->rate_.set (x);
  }

  void SpikeSourcePoisson::
  rate (::std::unique_ptr< rate_type > x)
  {
    this->rate_.set (std::move (x));
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace neuroml2
{
  // NmlId
  //

  NmlId::
  NmlId ()
  : ::xml_schema::string ()
  {
  }

  NmlId::
  NmlId (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  NmlId::
  NmlId (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  NmlId::
  NmlId (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  NmlId::
  NmlId (const NmlId& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  NmlId::
  NmlId (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  NmlId::
  NmlId (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  NmlId::
  NmlId (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  NmlId* NmlId::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class NmlId (*this, f, c);
  }

  NmlId::
  ~NmlId ()
  {
  }

  // Nml2Quantity
  //

  Nml2Quantity::
  Nml2Quantity ()
  : ::xml_schema::string ()
  {
  }

  Nml2Quantity::
  Nml2Quantity (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity::
  Nml2Quantity (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity::
  Nml2Quantity (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity::
  Nml2Quantity (const Nml2Quantity& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Nml2Quantity::
  Nml2Quantity (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Nml2Quantity::
  Nml2Quantity (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Nml2Quantity::
  Nml2Quantity (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Nml2Quantity* Nml2Quantity::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Nml2Quantity (*this, f, c);
  }

  Nml2Quantity::
  ~Nml2Quantity ()
  {
  }

  // Nml2Quantity_none
  //

  Nml2Quantity_none::
  Nml2Quantity_none ()
  : ::xml_schema::string ()
  {
  }

  Nml2Quantity_none::
  Nml2Quantity_none (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_none::
  Nml2Quantity_none (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_none::
  Nml2Quantity_none (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_none::
  Nml2Quantity_none (const Nml2Quantity_none& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Nml2Quantity_none::
  Nml2Quantity_none (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Nml2Quantity_none::
  Nml2Quantity_none (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Nml2Quantity_none::
  Nml2Quantity_none (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Nml2Quantity_none* Nml2Quantity_none::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Nml2Quantity_none (*this, f, c);
  }

  Nml2Quantity_none::
  ~Nml2Quantity_none ()
  {
  }

  // Nml2Quantity_voltage
  //

  Nml2Quantity_voltage::
  Nml2Quantity_voltage ()
  : ::xml_schema::string ()
  {
  }

  Nml2Quantity_voltage::
  Nml2Quantity_voltage (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_voltage::
  Nml2Quantity_voltage (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_voltage::
  Nml2Quantity_voltage (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_voltage::
  Nml2Quantity_voltage (const Nml2Quantity_voltage& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Nml2Quantity_voltage::
  Nml2Quantity_voltage (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Nml2Quantity_voltage::
  Nml2Quantity_voltage (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Nml2Quantity_voltage::
  Nml2Quantity_voltage (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Nml2Quantity_voltage* Nml2Quantity_voltage::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Nml2Quantity_voltage (*this, f, c);
  }

  Nml2Quantity_voltage::
  ~Nml2Quantity_voltage ()
  {
  }

  // Nml2Quantity_length
  //

  Nml2Quantity_length::
  Nml2Quantity_length ()
  : ::xml_schema::string ()
  {
  }

  Nml2Quantity_length::
  Nml2Quantity_length (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_length::
  Nml2Quantity_length (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_length::
  Nml2Quantity_length (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_length::
  Nml2Quantity_length (const Nml2Quantity_length& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Nml2Quantity_length::
  Nml2Quantity_length (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Nml2Quantity_length::
  Nml2Quantity_length (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Nml2Quantity_length::
  Nml2Quantity_length (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Nml2Quantity_length* Nml2Quantity_length::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Nml2Quantity_length (*this, f, c);
  }

  Nml2Quantity_length::
  ~Nml2Quantity_length ()
  {
  }

  // Nml2Quantity_resistance
  //

  Nml2Quantity_resistance::
  Nml2Quantity_resistance ()
  : ::xml_schema::string ()
  {
  }

  Nml2Quantity_resistance::
  Nml2Quantity_resistance (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_resistance::
  Nml2Quantity_resistance (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_resistance::
  Nml2Quantity_resistance (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_resistance::
  Nml2Quantity_resistance (const Nml2Quantity_resistance& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Nml2Quantity_resistance::
  Nml2Quantity_resistance (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Nml2Quantity_resistance::
  Nml2Quantity_resistance (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Nml2Quantity_resistance::
  Nml2Quantity_resistance (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Nml2Quantity_resistance* Nml2Quantity_resistance::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Nml2Quantity_resistance (*this, f, c);
  }

  Nml2Quantity_resistance::
  ~Nml2Quantity_resistance ()
  {
  }

  // Nml2Quantity_resistivity
  //

  Nml2Quantity_resistivity::
  Nml2Quantity_resistivity ()
  : ::xml_schema::string ()
  {
  }

  Nml2Quantity_resistivity::
  Nml2Quantity_resistivity (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_resistivity::
  Nml2Quantity_resistivity (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_resistivity::
  Nml2Quantity_resistivity (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_resistivity::
  Nml2Quantity_resistivity (const Nml2Quantity_resistivity& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Nml2Quantity_resistivity::
  Nml2Quantity_resistivity (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Nml2Quantity_resistivity::
  Nml2Quantity_resistivity (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Nml2Quantity_resistivity::
  Nml2Quantity_resistivity (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Nml2Quantity_resistivity* Nml2Quantity_resistivity::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Nml2Quantity_resistivity (*this, f, c);
  }

  Nml2Quantity_resistivity::
  ~Nml2Quantity_resistivity ()
  {
  }

  // Nml2Quantity_conductance
  //

  Nml2Quantity_conductance::
  Nml2Quantity_conductance ()
  : ::xml_schema::string ()
  {
  }

  Nml2Quantity_conductance::
  Nml2Quantity_conductance (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_conductance::
  Nml2Quantity_conductance (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_conductance::
  Nml2Quantity_conductance (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_conductance::
  Nml2Quantity_conductance (const Nml2Quantity_conductance& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Nml2Quantity_conductance::
  Nml2Quantity_conductance (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Nml2Quantity_conductance::
  Nml2Quantity_conductance (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Nml2Quantity_conductance::
  Nml2Quantity_conductance (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Nml2Quantity_conductance* Nml2Quantity_conductance::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Nml2Quantity_conductance (*this, f, c);
  }

  Nml2Quantity_conductance::
  ~Nml2Quantity_conductance ()
  {
  }

  // Nml2Quantity_conductanceDensity
  //

  Nml2Quantity_conductanceDensity::
  Nml2Quantity_conductanceDensity ()
  : ::xml_schema::string ()
  {
  }

  Nml2Quantity_conductanceDensity::
  Nml2Quantity_conductanceDensity (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_conductanceDensity::
  Nml2Quantity_conductanceDensity (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_conductanceDensity::
  Nml2Quantity_conductanceDensity (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_conductanceDensity::
  Nml2Quantity_conductanceDensity (const Nml2Quantity_conductanceDensity& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Nml2Quantity_conductanceDensity::
  Nml2Quantity_conductanceDensity (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Nml2Quantity_conductanceDensity::
  Nml2Quantity_conductanceDensity (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Nml2Quantity_conductanceDensity::
  Nml2Quantity_conductanceDensity (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Nml2Quantity_conductanceDensity* Nml2Quantity_conductanceDensity::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Nml2Quantity_conductanceDensity (*this, f, c);
  }

  Nml2Quantity_conductanceDensity::
  ~Nml2Quantity_conductanceDensity ()
  {
  }

  // Nml2Quantity_permeability
  //

  Nml2Quantity_permeability::
  Nml2Quantity_permeability ()
  : ::xml_schema::string ()
  {
  }

  Nml2Quantity_permeability::
  Nml2Quantity_permeability (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_permeability::
  Nml2Quantity_permeability (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_permeability::
  Nml2Quantity_permeability (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_permeability::
  Nml2Quantity_permeability (const Nml2Quantity_permeability& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Nml2Quantity_permeability::
  Nml2Quantity_permeability (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Nml2Quantity_permeability::
  Nml2Quantity_permeability (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Nml2Quantity_permeability::
  Nml2Quantity_permeability (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Nml2Quantity_permeability* Nml2Quantity_permeability::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Nml2Quantity_permeability (*this, f, c);
  }

  Nml2Quantity_permeability::
  ~Nml2Quantity_permeability ()
  {
  }

  // Nml2Quantity_time
  //

  Nml2Quantity_time::
  Nml2Quantity_time ()
  : ::xml_schema::string ()
  {
  }

  Nml2Quantity_time::
  Nml2Quantity_time (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_time::
  Nml2Quantity_time (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_time::
  Nml2Quantity_time (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_time::
  Nml2Quantity_time (const Nml2Quantity_time& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Nml2Quantity_time::
  Nml2Quantity_time (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Nml2Quantity_time::
  Nml2Quantity_time (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Nml2Quantity_time::
  Nml2Quantity_time (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Nml2Quantity_time* Nml2Quantity_time::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Nml2Quantity_time (*this, f, c);
  }

  Nml2Quantity_time::
  ~Nml2Quantity_time ()
  {
  }

  // Nml2Quantity_pertime
  //

  Nml2Quantity_pertime::
  Nml2Quantity_pertime ()
  : ::xml_schema::string ()
  {
  }

  Nml2Quantity_pertime::
  Nml2Quantity_pertime (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_pertime::
  Nml2Quantity_pertime (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_pertime::
  Nml2Quantity_pertime (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_pertime::
  Nml2Quantity_pertime (const Nml2Quantity_pertime& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Nml2Quantity_pertime::
  Nml2Quantity_pertime (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Nml2Quantity_pertime::
  Nml2Quantity_pertime (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Nml2Quantity_pertime::
  Nml2Quantity_pertime (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Nml2Quantity_pertime* Nml2Quantity_pertime::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Nml2Quantity_pertime (*this, f, c);
  }

  Nml2Quantity_pertime::
  ~Nml2Quantity_pertime ()
  {
  }

  // Nml2Quantity_capacitance
  //

  Nml2Quantity_capacitance::
  Nml2Quantity_capacitance ()
  : ::xml_schema::string ()
  {
  }

  Nml2Quantity_capacitance::
  Nml2Quantity_capacitance (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_capacitance::
  Nml2Quantity_capacitance (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_capacitance::
  Nml2Quantity_capacitance (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_capacitance::
  Nml2Quantity_capacitance (const Nml2Quantity_capacitance& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Nml2Quantity_capacitance::
  Nml2Quantity_capacitance (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Nml2Quantity_capacitance::
  Nml2Quantity_capacitance (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Nml2Quantity_capacitance::
  Nml2Quantity_capacitance (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Nml2Quantity_capacitance* Nml2Quantity_capacitance::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Nml2Quantity_capacitance (*this, f, c);
  }

  Nml2Quantity_capacitance::
  ~Nml2Quantity_capacitance ()
  {
  }

  // Nml2Quantity_specificCapacitance
  //

  Nml2Quantity_specificCapacitance::
  Nml2Quantity_specificCapacitance ()
  : ::xml_schema::string ()
  {
  }

  Nml2Quantity_specificCapacitance::
  Nml2Quantity_specificCapacitance (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_specificCapacitance::
  Nml2Quantity_specificCapacitance (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_specificCapacitance::
  Nml2Quantity_specificCapacitance (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_specificCapacitance::
  Nml2Quantity_specificCapacitance (const Nml2Quantity_specificCapacitance& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Nml2Quantity_specificCapacitance::
  Nml2Quantity_specificCapacitance (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Nml2Quantity_specificCapacitance::
  Nml2Quantity_specificCapacitance (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Nml2Quantity_specificCapacitance::
  Nml2Quantity_specificCapacitance (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Nml2Quantity_specificCapacitance* Nml2Quantity_specificCapacitance::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Nml2Quantity_specificCapacitance (*this, f, c);
  }

  Nml2Quantity_specificCapacitance::
  ~Nml2Quantity_specificCapacitance ()
  {
  }

  // Nml2Quantity_concentration
  //

  Nml2Quantity_concentration::
  Nml2Quantity_concentration ()
  : ::xml_schema::string ()
  {
  }

  Nml2Quantity_concentration::
  Nml2Quantity_concentration (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_concentration::
  Nml2Quantity_concentration (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_concentration::
  Nml2Quantity_concentration (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_concentration::
  Nml2Quantity_concentration (const Nml2Quantity_concentration& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Nml2Quantity_concentration::
  Nml2Quantity_concentration (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Nml2Quantity_concentration::
  Nml2Quantity_concentration (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Nml2Quantity_concentration::
  Nml2Quantity_concentration (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Nml2Quantity_concentration* Nml2Quantity_concentration::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Nml2Quantity_concentration (*this, f, c);
  }

  Nml2Quantity_concentration::
  ~Nml2Quantity_concentration ()
  {
  }

  // Nml2Quantity_current
  //

  Nml2Quantity_current::
  Nml2Quantity_current ()
  : ::xml_schema::string ()
  {
  }

  Nml2Quantity_current::
  Nml2Quantity_current (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_current::
  Nml2Quantity_current (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_current::
  Nml2Quantity_current (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_current::
  Nml2Quantity_current (const Nml2Quantity_current& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Nml2Quantity_current::
  Nml2Quantity_current (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Nml2Quantity_current::
  Nml2Quantity_current (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Nml2Quantity_current::
  Nml2Quantity_current (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Nml2Quantity_current* Nml2Quantity_current::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Nml2Quantity_current (*this, f, c);
  }

  Nml2Quantity_current::
  ~Nml2Quantity_current ()
  {
  }

  // Nml2Quantity_currentDensity
  //

  Nml2Quantity_currentDensity::
  Nml2Quantity_currentDensity ()
  : ::xml_schema::string ()
  {
  }

  Nml2Quantity_currentDensity::
  Nml2Quantity_currentDensity (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_currentDensity::
  Nml2Quantity_currentDensity (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_currentDensity::
  Nml2Quantity_currentDensity (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_currentDensity::
  Nml2Quantity_currentDensity (const Nml2Quantity_currentDensity& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Nml2Quantity_currentDensity::
  Nml2Quantity_currentDensity (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Nml2Quantity_currentDensity::
  Nml2Quantity_currentDensity (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Nml2Quantity_currentDensity::
  Nml2Quantity_currentDensity (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Nml2Quantity_currentDensity* Nml2Quantity_currentDensity::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Nml2Quantity_currentDensity (*this, f, c);
  }

  Nml2Quantity_currentDensity::
  ~Nml2Quantity_currentDensity ()
  {
  }

  // Nml2Quantity_temperature
  //

  Nml2Quantity_temperature::
  Nml2Quantity_temperature ()
  : ::xml_schema::string ()
  {
  }

  Nml2Quantity_temperature::
  Nml2Quantity_temperature (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_temperature::
  Nml2Quantity_temperature (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_temperature::
  Nml2Quantity_temperature (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_temperature::
  Nml2Quantity_temperature (const Nml2Quantity_temperature& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Nml2Quantity_temperature::
  Nml2Quantity_temperature (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Nml2Quantity_temperature::
  Nml2Quantity_temperature (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Nml2Quantity_temperature::
  Nml2Quantity_temperature (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Nml2Quantity_temperature* Nml2Quantity_temperature::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Nml2Quantity_temperature (*this, f, c);
  }

  Nml2Quantity_temperature::
  ~Nml2Quantity_temperature ()
  {
  }

  // Nml2Quantity_rhoFactor
  //

  Nml2Quantity_rhoFactor::
  Nml2Quantity_rhoFactor ()
  : ::xml_schema::string ()
  {
  }

  Nml2Quantity_rhoFactor::
  Nml2Quantity_rhoFactor (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_rhoFactor::
  Nml2Quantity_rhoFactor (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_rhoFactor::
  Nml2Quantity_rhoFactor (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_rhoFactor::
  Nml2Quantity_rhoFactor (const Nml2Quantity_rhoFactor& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Nml2Quantity_rhoFactor::
  Nml2Quantity_rhoFactor (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Nml2Quantity_rhoFactor::
  Nml2Quantity_rhoFactor (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Nml2Quantity_rhoFactor::
  Nml2Quantity_rhoFactor (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Nml2Quantity_rhoFactor* Nml2Quantity_rhoFactor::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Nml2Quantity_rhoFactor (*this, f, c);
  }

  Nml2Quantity_rhoFactor::
  ~Nml2Quantity_rhoFactor ()
  {
  }

  // Nml2Quantity_conductancePerVoltage
  //

  Nml2Quantity_conductancePerVoltage::
  Nml2Quantity_conductancePerVoltage ()
  : ::xml_schema::string ()
  {
  }

  Nml2Quantity_conductancePerVoltage::
  Nml2Quantity_conductancePerVoltage (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_conductancePerVoltage::
  Nml2Quantity_conductancePerVoltage (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_conductancePerVoltage::
  Nml2Quantity_conductancePerVoltage (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nml2Quantity_conductancePerVoltage::
  Nml2Quantity_conductancePerVoltage (const Nml2Quantity_conductancePerVoltage& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Nml2Quantity_conductancePerVoltage::
  Nml2Quantity_conductancePerVoltage (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Nml2Quantity_conductancePerVoltage::
  Nml2Quantity_conductancePerVoltage (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Nml2Quantity_conductancePerVoltage::
  Nml2Quantity_conductancePerVoltage (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Nml2Quantity_conductancePerVoltage* Nml2Quantity_conductancePerVoltage::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Nml2Quantity_conductancePerVoltage (*this, f, c);
  }

  Nml2Quantity_conductancePerVoltage::
  ~Nml2Quantity_conductancePerVoltage ()
  {
  }

  // MetaId
  //

  MetaId::
  MetaId ()
  : ::xml_schema::string ()
  {
  }

  MetaId::
  MetaId (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  MetaId::
  MetaId (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  MetaId::
  MetaId (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  MetaId::
  MetaId (const MetaId& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  MetaId::
  MetaId (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  MetaId::
  MetaId (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  MetaId::
  MetaId (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  MetaId* MetaId::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MetaId (*this, f, c);
  }

  MetaId::
  ~MetaId ()
  {
  }

  // NeuroLexId
  //

  NeuroLexId::
  NeuroLexId ()
  : ::xml_schema::string ()
  {
  }

  NeuroLexId::
  NeuroLexId (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  NeuroLexId::
  NeuroLexId (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  NeuroLexId::
  NeuroLexId (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  NeuroLexId::
  NeuroLexId (const NeuroLexId& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  NeuroLexId::
  NeuroLexId (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  NeuroLexId::
  NeuroLexId (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  NeuroLexId::
  NeuroLexId (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  NeuroLexId* NeuroLexId::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class NeuroLexId (*this, f, c);
  }

  NeuroLexId::
  ~NeuroLexId ()
  {
  }

  // NonNegativeInteger
  //

  NonNegativeInteger::
  NonNegativeInteger (const ::xml_schema::non_negative_integer& _xsd_non_negative_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (_xsd_non_negative_integer_base)
  {
  }

  NonNegativeInteger::
  NonNegativeInteger (const NonNegativeInteger& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  NonNegativeInteger::
  NonNegativeInteger (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  NonNegativeInteger::
  NonNegativeInteger (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  NonNegativeInteger::
  NonNegativeInteger (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  NonNegativeInteger* NonNegativeInteger::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class NonNegativeInteger (*this, f, c);
  }

  NonNegativeInteger::
  ~NonNegativeInteger ()
  {
  }

  // PositiveInteger
  //

  PositiveInteger::
  PositiveInteger (const ::xml_schema::positive_integer& _xsd_positive_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base)
  {
  }

  PositiveInteger::
  PositiveInteger (const PositiveInteger& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  PositiveInteger::
  PositiveInteger (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  PositiveInteger::
  PositiveInteger (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  PositiveInteger::
  PositiveInteger (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  PositiveInteger* PositiveInteger::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PositiveInteger (*this, f, c);
  }

  PositiveInteger::
  ~PositiveInteger ()
  {
  }

  // DoubleGreaterThanZero
  //

  DoubleGreaterThanZero::
  DoubleGreaterThanZero (const ::xml_schema::double_& _xsd_double__base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
  {
  }

  DoubleGreaterThanZero::
  DoubleGreaterThanZero (const DoubleGreaterThanZero& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
  {
  }

  DoubleGreaterThanZero::
  DoubleGreaterThanZero (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
  {
  }

  DoubleGreaterThanZero::
  DoubleGreaterThanZero (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
  {
  }

  DoubleGreaterThanZero::
  DoubleGreaterThanZero (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
  {
  }

  DoubleGreaterThanZero* DoubleGreaterThanZero::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DoubleGreaterThanZero (*this, f, c);
  }

  DoubleGreaterThanZero::
  ~DoubleGreaterThanZero ()
  {
  }

  // ZeroOrOne
  //

  ZeroOrOne::
  ZeroOrOne (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
  {
  }

  ZeroOrOne::
  ZeroOrOne (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
  {
  }

  ZeroOrOne::
  ZeroOrOne (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
  {
  }

  ZeroOrOne* ZeroOrOne::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ZeroOrOne (*this, f, c);
  }

  // Notes
  //

  Notes::
  Notes ()
  : ::xml_schema::string ()
  {
  }

  Notes::
  Notes (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Notes::
  Notes (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Notes::
  Notes (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Notes::
  Notes (const Notes& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Notes::
  Notes (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Notes::
  Notes (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Notes::
  Notes (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Notes* Notes::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Notes (*this, f, c);
  }

  Notes::
  ~Notes ()
  {
  }

  // Property
  //

  Property::
  Property (const tag_type& tag,
            const value_type& value)
  : ::xml_schema::type (),
    tag_ (tag, this),
    value_ (value, this)
  {
  }

  Property::
  Property (const Property& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    tag_ (x.tag_, f, this),
    value_ (x.value_, f, this)
  {
  }

  Property::
  Property (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    tag_ (this),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Property::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "tag" && n.namespace_ ().empty ())
      {
        this->tag_.set (tag_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!tag_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "tag",
        "");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Property* Property::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Property (*this, f, c);
  }

  Property& Property::
  operator= (const Property& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->tag_ = x.tag_;
      this->value_ = x.value_;
    }

    return *this;
  }

  Property::
  ~Property ()
  {
  }

  bool
  operator== (const Property& x, const Property& y)
  {
    if (!(x.tag () == y.tag ()))
      return false;

    if (!(x.value () == y.value ()))
      return false;

    return true;
  }

  bool
  operator!= (const Property& x, const Property& y)
  {
    return !(x == y);
  }

  // Annotation
  //

  Annotation::
  Annotation ()
  : ::xml_schema::type ()
  {
  }

  Annotation::
  Annotation (const Annotation& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  Annotation::
  Annotation (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Annotation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      break;
    }
  }

  Annotation* Annotation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Annotation (*this, f, c);
  }

  Annotation::
  ~Annotation ()
  {
  }

  bool
  operator== (const Annotation&, const Annotation&)
  {
    return true;
  }

  bool
  operator!= (const Annotation& x, const Annotation& y)
  {
    return !(x == y);
  }

  // ComponentType
  //

  ComponentType::
  ComponentType (const name_type& name)
  : ::xml_schema::type (),
    Property_ (this),
    Parameter_ (this),
    Constant_ (this),
    Exposure_ (this),
    Requirement_ (this),
    InstanceRequirement_ (this),
    Dynamics_ (this),
    name_ (name, this),
    extends_ (this),
    description_ (this)
  {
  }

  ComponentType::
  ComponentType (const ComponentType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Property_ (x.Property_, f, this),
    Parameter_ (x.Parameter_, f, this),
    Constant_ (x.Constant_, f, this),
    Exposure_ (x.Exposure_, f, this),
    Requirement_ (x.Requirement_, f, this),
    InstanceRequirement_ (x.InstanceRequirement_, f, this),
    Dynamics_ (x.Dynamics_, f, this),
    name_ (x.name_, f, this),
    extends_ (x.extends_, f, this),
    description_ (x.description_, f, this)
  {
  }

  ComponentType::
  ComponentType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Property_ (this),
    Parameter_ (this),
    Constant_ (this),
    Exposure_ (this),
    Requirement_ (this),
    InstanceRequirement_ (this),
    Dynamics_ (this),
    name_ (this),
    extends_ (this),
    description_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ComponentType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Property
      //
      if (n.name () == "Property" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< Property_type > r (
          Property_traits::create (i, f, this));

        this->Property_.push_back (::std::move (r));
        continue;
      }

      // Parameter
      //
      if (n.name () == "Parameter" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< Parameter_type > r (
          Parameter_traits::create (i, f, this));

        this->Parameter_.push_back (::std::move (r));
        continue;
      }

      // Constant
      //
      if (n.name () == "Constant" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< Constant_type > r (
          Constant_traits::create (i, f, this));

        this->Constant_.push_back (::std::move (r));
        continue;
      }

      // Exposure
      //
      if (n.name () == "Exposure" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< Exposure_type > r (
          Exposure_traits::create (i, f, this));

        this->Exposure_.push_back (::std::move (r));
        continue;
      }

      // Requirement
      //
      if (n.name () == "Requirement" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< Requirement_type > r (
          Requirement_traits::create (i, f, this));

        this->Requirement_.push_back (::std::move (r));
        continue;
      }

      // InstanceRequirement
      //
      if (n.name () == "InstanceRequirement" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< InstanceRequirement_type > r (
          InstanceRequirement_traits::create (i, f, this));

        this->InstanceRequirement_.push_back (::std::move (r));
        continue;
      }

      // Dynamics
      //
      if (n.name () == "Dynamics" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< Dynamics_type > r (
          Dynamics_traits::create (i, f, this));

        this->Dynamics_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "extends" && n.namespace_ ().empty ())
      {
        this->extends_.set (extends_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "description" && n.namespace_ ().empty ())
      {
        this->description_.set (description_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  ComponentType* ComponentType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ComponentType (*this, f, c);
  }

  ComponentType& ComponentType::
  operator= (const ComponentType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Property_ = x.Property_;
      this->Parameter_ = x.Parameter_;
      this->Constant_ = x.Constant_;
      this->Exposure_ = x.Exposure_;
      this->Requirement_ = x.Requirement_;
      this->InstanceRequirement_ = x.InstanceRequirement_;
      this->Dynamics_ = x.Dynamics_;
      this->name_ = x.name_;
      this->extends_ = x.extends_;
      this->description_ = x.description_;
    }

    return *this;
  }

  ComponentType::
  ~ComponentType ()
  {
  }

  bool
  operator== (const ComponentType& x, const ComponentType& y)
  {
    if (!(x.Property () == y.Property ()))
      return false;

    if (!(x.Parameter () == y.Parameter ()))
      return false;

    if (!(x.Constant () == y.Constant ()))
      return false;

    if (!(x.Exposure () == y.Exposure ()))
      return false;

    if (!(x.Requirement () == y.Requirement ()))
      return false;

    if (!(x.InstanceRequirement () == y.InstanceRequirement ()))
      return false;

    if (!(x.Dynamics () == y.Dynamics ()))
      return false;

    if (!(x.name () == y.name ()))
      return false;

    if (!(x.extends () == y.extends ()))
      return false;

    if (!(x.description () == y.description ()))
      return false;

    return true;
  }

  bool
  operator!= (const ComponentType& x, const ComponentType& y)
  {
    return !(x == y);
  }

  // Constant
  //

  Constant::
  Constant (const name_type& name,
            const dimension_type& dimension,
            const value_type& value)
  : ::xml_schema::type (),
    name_ (name, this),
    dimension_ (dimension, this),
    value_ (value, this),
    description_ (this)
  {
  }

  Constant::
  Constant (const Constant& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    dimension_ (x.dimension_, f, this),
    value_ (x.value_, f, this),
    description_ (x.description_, f, this)
  {
  }

  Constant::
  Constant (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    dimension_ (this),
    value_ (this),
    description_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Constant::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dimension" && n.namespace_ ().empty ())
      {
        this->dimension_.set (dimension_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "description" && n.namespace_ ().empty ())
      {
        this->description_.set (description_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!dimension_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "dimension",
        "");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Constant* Constant::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Constant (*this, f, c);
  }

  Constant& Constant::
  operator= (const Constant& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->name_ = x.name_;
      this->dimension_ = x.dimension_;
      this->value_ = x.value_;
      this->description_ = x.description_;
    }

    return *this;
  }

  Constant::
  ~Constant ()
  {
  }

  bool
  operator== (const Constant& x, const Constant& y)
  {
    if (!(x.name () == y.name ()))
      return false;

    if (!(x.dimension () == y.dimension ()))
      return false;

    if (!(x.value () == y.value ()))
      return false;

    if (!(x.description () == y.description ()))
      return false;

    return true;
  }

  bool
  operator!= (const Constant& x, const Constant& y)
  {
    return !(x == y);
  }

  // Exposure
  //

  Exposure::
  Exposure (const name_type& name,
            const dimension_type& dimension)
  : ::xml_schema::type (),
    name_ (name, this),
    dimension_ (dimension, this),
    description_ (this)
  {
  }

  Exposure::
  Exposure (const Exposure& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    dimension_ (x.dimension_, f, this),
    description_ (x.description_, f, this)
  {
  }

  Exposure::
  Exposure (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    dimension_ (this),
    description_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Exposure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dimension" && n.namespace_ ().empty ())
      {
        this->dimension_.set (dimension_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "description" && n.namespace_ ().empty ())
      {
        this->description_.set (description_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!dimension_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "dimension",
        "");
    }
  }

  Exposure* Exposure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Exposure (*this, f, c);
  }

  Exposure& Exposure::
  operator= (const Exposure& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->name_ = x.name_;
      this->dimension_ = x.dimension_;
      this->description_ = x.description_;
    }

    return *this;
  }

  Exposure::
  ~Exposure ()
  {
  }

  bool
  operator== (const Exposure& x, const Exposure& y)
  {
    if (!(x.name () == y.name ()))
      return false;

    if (!(x.dimension () == y.dimension ()))
      return false;

    if (!(x.description () == y.description ()))
      return false;

    return true;
  }

  bool
  operator!= (const Exposure& x, const Exposure& y)
  {
    return !(x == y);
  }

  // NamedDimensionalType
  //

  NamedDimensionalType::
  NamedDimensionalType (const name_type& name,
                        const dimension_type& dimension)
  : ::xml_schema::type (),
    name_ (name, this),
    dimension_ (dimension, this),
    description_ (this)
  {
  }

  NamedDimensionalType::
  NamedDimensionalType (const NamedDimensionalType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    dimension_ (x.dimension_, f, this),
    description_ (x.description_, f, this)
  {
  }

  NamedDimensionalType::
  NamedDimensionalType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    dimension_ (this),
    description_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void NamedDimensionalType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dimension" && n.namespace_ ().empty ())
      {
        this->dimension_.set (dimension_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "description" && n.namespace_ ().empty ())
      {
        this->description_.set (description_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!dimension_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "dimension",
        "");
    }
  }

  NamedDimensionalType* NamedDimensionalType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class NamedDimensionalType (*this, f, c);
  }

  NamedDimensionalType& NamedDimensionalType::
  operator= (const NamedDimensionalType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->name_ = x.name_;
      this->dimension_ = x.dimension_;
      this->description_ = x.description_;
    }

    return *this;
  }

  NamedDimensionalType::
  ~NamedDimensionalType ()
  {
  }

  bool
  operator== (const NamedDimensionalType& x, const NamedDimensionalType& y)
  {
    if (!(x.name () == y.name ()))
      return false;

    if (!(x.dimension () == y.dimension ()))
      return false;

    if (!(x.description () == y.description ()))
      return false;

    return true;
  }

  bool
  operator!= (const NamedDimensionalType& x, const NamedDimensionalType& y)
  {
    return !(x == y);
  }

  // NamedDimensionalVariable
  //

  NamedDimensionalVariable::
  NamedDimensionalVariable (const name_type& name,
                            const dimension_type& dimension)
  : ::xml_schema::type (),
    name_ (name, this),
    dimension_ (dimension, this),
    description_ (this),
    exposure_ (this)
  {
  }

  NamedDimensionalVariable::
  NamedDimensionalVariable (const NamedDimensionalVariable& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    dimension_ (x.dimension_, f, this),
    description_ (x.description_, f, this),
    exposure_ (x.exposure_, f, this)
  {
  }

  NamedDimensionalVariable::
  NamedDimensionalVariable (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    dimension_ (this),
    description_ (this),
    exposure_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void NamedDimensionalVariable::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dimension" && n.namespace_ ().empty ())
      {
        this->dimension_.set (dimension_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "description" && n.namespace_ ().empty ())
      {
        this->description_.set (description_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "exposure" && n.namespace_ ().empty ())
      {
        this->exposure_.set (exposure_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!dimension_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "dimension",
        "");
    }
  }

  NamedDimensionalVariable* NamedDimensionalVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class NamedDimensionalVariable (*this, f, c);
  }

  NamedDimensionalVariable& NamedDimensionalVariable::
  operator= (const NamedDimensionalVariable& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->name_ = x.name_;
      this->dimension_ = x.dimension_;
      this->description_ = x.description_;
      this->exposure_ = x.exposure_;
    }

    return *this;
  }

  NamedDimensionalVariable::
  ~NamedDimensionalVariable ()
  {
  }

  bool
  operator== (const NamedDimensionalVariable& x, const NamedDimensionalVariable& y)
  {
    if (!(x.name () == y.name ()))
      return false;

    if (!(x.dimension () == y.dimension ()))
      return false;

    if (!(x.description () == y.description ()))
      return false;

    if (!(x.exposure () == y.exposure ()))
      return false;

    return true;
  }

  bool
  operator!= (const NamedDimensionalVariable& x, const NamedDimensionalVariable& y)
  {
    return !(x == y);
  }

  // Parameter
  //

  Parameter::
  Parameter (const name_type& name,
             const dimension_type& dimension)
  : ::neuroml2::NamedDimensionalType (name,
                                      dimension)
  {
  }

  Parameter::
  Parameter (const Parameter& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::neuroml2::NamedDimensionalType (x, f, c)
  {
  }

  Parameter::
  Parameter (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::neuroml2::NamedDimensionalType (e, f, c)
  {
  }

  Parameter* Parameter::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Parameter (*this, f, c);
  }

  Parameter::
  ~Parameter ()
  {
  }

  // LEMS_Property
  //

  LEMS_Property::
  LEMS_Property (const name_type& name,
                 const dimension_type& dimension)
  : ::neuroml2::NamedDimensionalType (name,
                                      dimension),
    defaultValue_ (this)
  {
  }

  LEMS_Property::
  LEMS_Property (const LEMS_Property& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::NamedDimensionalType (x, f, c),
    defaultValue_ (x.defaultValue_, f, this)
  {
  }

  LEMS_Property::
  LEMS_Property (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::NamedDimensionalType (e, f | ::xml_schema::flags::base, c),
    defaultValue_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void LEMS_Property::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::NamedDimensionalType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "defaultValue" && n.namespace_ ().empty ())
      {
        this->defaultValue_.set (defaultValue_traits::create (i, f, this));
        continue;
      }
    }
  }

  LEMS_Property* LEMS_Property::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LEMS_Property (*this, f, c);
  }

  LEMS_Property& LEMS_Property::
  operator= (const LEMS_Property& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::NamedDimensionalType& > (*this) = x;
      this->defaultValue_ = x.defaultValue_;
    }

    return *this;
  }

  LEMS_Property::
  ~LEMS_Property ()
  {
  }

  bool
  operator== (const LEMS_Property& x, const LEMS_Property& y)
  {
    if (!(static_cast< const ::neuroml2::NamedDimensionalType& > (x) ==
          static_cast< const ::neuroml2::NamedDimensionalType& > (y)))
      return false;

    if (!(x.defaultValue () == y.defaultValue ()))
      return false;

    return true;
  }

  bool
  operator!= (const LEMS_Property& x, const LEMS_Property& y)
  {
    return !(x == y);
  }

  // Requirement
  //

  Requirement::
  Requirement (const name_type& name,
               const dimension_type& dimension)
  : ::neuroml2::NamedDimensionalType (name,
                                      dimension)
  {
  }

  Requirement::
  Requirement (const Requirement& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::neuroml2::NamedDimensionalType (x, f, c)
  {
  }

  Requirement::
  Requirement (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::neuroml2::NamedDimensionalType (e, f, c)
  {
  }

  Requirement* Requirement::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Requirement (*this, f, c);
  }

  Requirement::
  ~Requirement ()
  {
  }

  // InstanceRequirement
  //

  InstanceRequirement::
  InstanceRequirement (const name_type& name,
                       const type_type& type)
  : ::xml_schema::type (),
    name_ (name, this),
    type_ (type, this)
  {
  }

  InstanceRequirement::
  InstanceRequirement (const InstanceRequirement& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    type_ (x.type_, f, this)
  {
  }

  InstanceRequirement::
  InstanceRequirement (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void InstanceRequirement::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  InstanceRequirement* InstanceRequirement::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InstanceRequirement (*this, f, c);
  }

  InstanceRequirement& InstanceRequirement::
  operator= (const InstanceRequirement& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->name_ = x.name_;
      this->type_ = x.type_;
    }

    return *this;
  }

  InstanceRequirement::
  ~InstanceRequirement ()
  {
  }

  bool
  operator== (const InstanceRequirement& x, const InstanceRequirement& y)
  {
    if (!(x.name () == y.name ()))
      return false;

    if (!(x.type () == y.type ()))
      return false;

    return true;
  }

  bool
  operator!= (const InstanceRequirement& x, const InstanceRequirement& y)
  {
    return !(x == y);
  }

  // Dynamics
  //

  Dynamics::
  Dynamics ()
  : ::xml_schema::type (),
    StateVariable_ (this),
    DerivedVariable_ (this),
    ConditionalDerivedVariable_ (this),
    TimeDerivative_ (this)
  {
  }

  Dynamics::
  Dynamics (const Dynamics& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    StateVariable_ (x.StateVariable_, f, this),
    DerivedVariable_ (x.DerivedVariable_, f, this),
    ConditionalDerivedVariable_ (x.ConditionalDerivedVariable_, f, this),
    TimeDerivative_ (x.TimeDerivative_, f, this)
  {
  }

  Dynamics::
  Dynamics (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    StateVariable_ (this),
    DerivedVariable_ (this),
    ConditionalDerivedVariable_ (this),
    TimeDerivative_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Dynamics::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // StateVariable
      //
      if (n.name () == "StateVariable" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< StateVariable_type > r (
          StateVariable_traits::create (i, f, this));

        this->StateVariable_.push_back (::std::move (r));
        continue;
      }

      // DerivedVariable
      //
      if (n.name () == "DerivedVariable" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< DerivedVariable_type > r (
          DerivedVariable_traits::create (i, f, this));

        this->DerivedVariable_.push_back (::std::move (r));
        continue;
      }

      // ConditionalDerivedVariable
      //
      if (n.name () == "ConditionalDerivedVariable" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< ConditionalDerivedVariable_type > r (
          ConditionalDerivedVariable_traits::create (i, f, this));

        this->ConditionalDerivedVariable_.push_back (::std::move (r));
        continue;
      }

      // TimeDerivative
      //
      if (n.name () == "TimeDerivative" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< TimeDerivative_type > r (
          TimeDerivative_traits::create (i, f, this));

        this->TimeDerivative_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Dynamics* Dynamics::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Dynamics (*this, f, c);
  }

  Dynamics& Dynamics::
  operator= (const Dynamics& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->StateVariable_ = x.StateVariable_;
      this->DerivedVariable_ = x.DerivedVariable_;
      this->ConditionalDerivedVariable_ = x.ConditionalDerivedVariable_;
      this->TimeDerivative_ = x.TimeDerivative_;
    }

    return *this;
  }

  Dynamics::
  ~Dynamics ()
  {
  }

  bool
  operator== (const Dynamics& x, const Dynamics& y)
  {
    if (!(x.StateVariable () == y.StateVariable ()))
      return false;

    if (!(x.DerivedVariable () == y.DerivedVariable ()))
      return false;

    if (!(x.ConditionalDerivedVariable () == y.ConditionalDerivedVariable ()))
      return false;

    if (!(x.TimeDerivative () == y.TimeDerivative ()))
      return false;

    return true;
  }

  bool
  operator!= (const Dynamics& x, const Dynamics& y)
  {
    return !(x == y);
  }

  // DerivedVariable
  //

  DerivedVariable::
  DerivedVariable (const name_type& name,
                   const dimension_type& dimension)
  : ::neuroml2::NamedDimensionalVariable (name,
                                          dimension),
    value_ (this),
    select_ (this)
  {
  }

  DerivedVariable::
  DerivedVariable (const DerivedVariable& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::neuroml2::NamedDimensionalVariable (x, f, c),
    value_ (x.value_, f, this),
    select_ (x.select_, f, this)
  {
  }

  DerivedVariable::
  DerivedVariable (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::neuroml2::NamedDimensionalVariable (e, f | ::xml_schema::flags::base, c),
    value_ (this),
    select_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void DerivedVariable::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::NamedDimensionalVariable::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "select" && n.namespace_ ().empty ())
      {
        this->select_.set (select_traits::create (i, f, this));
        continue;
      }
    }
  }

  DerivedVariable* DerivedVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DerivedVariable (*this, f, c);
  }

  DerivedVariable& DerivedVariable::
  operator= (const DerivedVariable& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::NamedDimensionalVariable& > (*this) = x;
      this->value_ = x.value_;
      this->select_ = x.select_;
    }

    return *this;
  }

  DerivedVariable::
  ~DerivedVariable ()
  {
  }

  bool
  operator== (const DerivedVariable& x, const DerivedVariable& y)
  {
    if (!(static_cast< const ::neuroml2::NamedDimensionalVariable& > (x) ==
          static_cast< const ::neuroml2::NamedDimensionalVariable& > (y)))
      return false;

    if (!(x.value () == y.value ()))
      return false;

    if (!(x.select () == y.select ()))
      return false;

    return true;
  }

  bool
  operator!= (const DerivedVariable& x, const DerivedVariable& y)
  {
    return !(x == y);
  }

  // StateVariable
  //

  StateVariable::
  StateVariable (const name_type& name,
                 const dimension_type& dimension)
  : ::neuroml2::NamedDimensionalVariable (name,
                                          dimension)
  {
  }

  StateVariable::
  StateVariable (const StateVariable& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::NamedDimensionalVariable (x, f, c)
  {
  }

  StateVariable::
  StateVariable (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::NamedDimensionalVariable (e, f, c)
  {
  }

  StateVariable* StateVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class StateVariable (*this, f, c);
  }

  StateVariable::
  ~StateVariable ()
  {
  }

  // ConditionalDerivedVariable
  //

  ConditionalDerivedVariable::
  ConditionalDerivedVariable (const name_type& name,
                              const dimension_type& dimension)
  : ::neuroml2::NamedDimensionalVariable (name,
                                          dimension),
    Case_ (this)
  {
  }

  ConditionalDerivedVariable::
  ConditionalDerivedVariable (const ConditionalDerivedVariable& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::neuroml2::NamedDimensionalVariable (x, f, c),
    Case_ (x.Case_, f, this)
  {
  }

  ConditionalDerivedVariable::
  ConditionalDerivedVariable (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::neuroml2::NamedDimensionalVariable (e, f | ::xml_schema::flags::base, c),
    Case_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ConditionalDerivedVariable::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::NamedDimensionalVariable::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Case
      //
      if (n.name () == "Case" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< Case_type > r (
          Case_traits::create (i, f, this));

        this->Case_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ConditionalDerivedVariable* ConditionalDerivedVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConditionalDerivedVariable (*this, f, c);
  }

  ConditionalDerivedVariable& ConditionalDerivedVariable::
  operator= (const ConditionalDerivedVariable& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::NamedDimensionalVariable& > (*this) = x;
      this->Case_ = x.Case_;
    }

    return *this;
  }

  ConditionalDerivedVariable::
  ~ConditionalDerivedVariable ()
  {
  }

  bool
  operator== (const ConditionalDerivedVariable& x, const ConditionalDerivedVariable& y)
  {
    if (!(static_cast< const ::neuroml2::NamedDimensionalVariable& > (x) ==
          static_cast< const ::neuroml2::NamedDimensionalVariable& > (y)))
      return false;

    if (!(x.Case () == y.Case ()))
      return false;

    return true;
  }

  bool
  operator!= (const ConditionalDerivedVariable& x, const ConditionalDerivedVariable& y)
  {
    return !(x == y);
  }

  // Case
  //

  Case::
  Case (const value_type& value)
  : ::xml_schema::type (),
    condition_ (this),
    value_ (value, this)
  {
  }

  Case::
  Case (const Case& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    condition_ (x.condition_, f, this),
    value_ (x.value_, f, this)
  {
  }

  Case::
  Case (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    condition_ (this),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Case::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "condition" && n.namespace_ ().empty ())
      {
        this->condition_.set (condition_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Case* Case::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Case (*this, f, c);
  }

  Case& Case::
  operator= (const Case& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->condition_ = x.condition_;
      this->value_ = x.value_;
    }

    return *this;
  }

  Case::
  ~Case ()
  {
  }

  bool
  operator== (const Case& x, const Case& y)
  {
    if (!(x.condition () == y.condition ()))
      return false;

    if (!(x.value () == y.value ()))
      return false;

    return true;
  }

  bool
  operator!= (const Case& x, const Case& y)
  {
    return !(x == y);
  }

  // TimeDerivative
  //

  TimeDerivative::
  TimeDerivative (const variable_type& variable,
                  const value_type& value)
  : ::xml_schema::type (),
    variable_ (variable, this),
    value_ (value, this)
  {
  }

  TimeDerivative::
  TimeDerivative (const TimeDerivative& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    variable_ (x.variable_, f, this),
    value_ (x.value_, f, this)
  {
  }

  TimeDerivative::
  TimeDerivative (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    variable_ (this),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void TimeDerivative::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "variable" && n.namespace_ ().empty ())
      {
        this->variable_.set (variable_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!variable_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "variable",
        "");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  TimeDerivative* TimeDerivative::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TimeDerivative (*this, f, c);
  }

  TimeDerivative& TimeDerivative::
  operator= (const TimeDerivative& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->variable_ = x.variable_;
      this->value_ = x.value_;
    }

    return *this;
  }

  TimeDerivative::
  ~TimeDerivative ()
  {
  }

  bool
  operator== (const TimeDerivative& x, const TimeDerivative& y)
  {
    if (!(x.variable () == y.variable ()))
      return false;

    if (!(x.value () == y.value ()))
      return false;

    return true;
  }

  bool
  operator!= (const TimeDerivative& x, const TimeDerivative& y)
  {
    return !(x == y);
  }

  // ZeroToOne
  //

  ZeroToOne::
  ZeroToOne (const ::xml_schema::float_& _xsd_float__base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base)
  {
  }

  ZeroToOne::
  ZeroToOne (const ZeroToOne& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  ZeroToOne::
  ZeroToOne (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  ZeroToOne::
  ZeroToOne (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  ZeroToOne::
  ZeroToOne (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  ZeroToOne* ZeroToOne::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ZeroToOne (*this, f, c);
  }

  ZeroToOne::
  ~ZeroToOne ()
  {
  }

  // BaseWithoutId
  //

  BaseWithoutId::
  BaseWithoutId ()
  : ::xml_schema::type (),
    neuroLexId_ (this)
  {
  }

  BaseWithoutId::
  BaseWithoutId (const BaseWithoutId& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    neuroLexId_ (x.neuroLexId_, f, this)
  {
  }

  BaseWithoutId::
  BaseWithoutId (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    neuroLexId_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void BaseWithoutId::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "neuroLexId" && n.namespace_ ().empty ())
      {
        this->neuroLexId_.set (neuroLexId_traits::create (i, f, this));
        continue;
      }
    }
  }

  BaseWithoutId* BaseWithoutId::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BaseWithoutId (*this, f, c);
  }

  BaseWithoutId& BaseWithoutId::
  operator= (const BaseWithoutId& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->neuroLexId_ = x.neuroLexId_;
    }

    return *this;
  }

  BaseWithoutId::
  ~BaseWithoutId ()
  {
  }

  bool
  operator== (const BaseWithoutId& x, const BaseWithoutId& y)
  {
    if (!(x.neuroLexId () == y.neuroLexId ()))
      return false;

    return true;
  }

  bool
  operator!= (const BaseWithoutId& x, const BaseWithoutId& y)
  {
    return !(x == y);
  }

  // Base
  //

  Base::
  Base (const id_type& id)
  : ::neuroml2::BaseWithoutId (),
    id_ (id, this)
  {
  }

  Base::
  Base (const Base& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::neuroml2::BaseWithoutId (x, f, c),
    id_ (x.id_, f, this)
  {
  }

  Base::
  Base (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::neuroml2::BaseWithoutId (e, f | ::xml_schema::flags::base, c),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Base::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseWithoutId::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  Base* Base::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Base (*this, f, c);
  }

  Base& Base::
  operator= (const Base& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseWithoutId& > (*this) = x;
      this->id_ = x.id_;
    }

    return *this;
  }

  Base::
  ~Base ()
  {
  }

  bool
  operator== (const Base& x, const Base& y)
  {
    if (!(static_cast< const ::neuroml2::BaseWithoutId& > (x) ==
          static_cast< const ::neuroml2::BaseWithoutId& > (y)))
      return false;

    if (!(x.id () == y.id ()))
      return false;

    return true;
  }

  bool
  operator!= (const Base& x, const Base& y)
  {
    return !(x == y);
  }

  // Standalone
  //

  Standalone::
  Standalone (const id_type& id)
  : ::neuroml2::Base (id),
    notes_ (this),
    property_ (this),
    annotation_ (this),
    metaid_ (this)
  {
  }

  Standalone::
  Standalone (const Standalone& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    notes_ (x.notes_, f, this),
    property_ (x.property_, f, this),
    annotation_ (x.annotation_, f, this),
    metaid_ (x.metaid_, f, this)
  {
  }

  Standalone::
  Standalone (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    notes_ (this),
    property_ (this),
    annotation_ (this),
    metaid_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Standalone::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // notes
      //
      if (n.name () == "notes" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< notes_type > r (
          notes_traits::create (i, f, this));

        if (!this->notes_)
        {
          this->notes_.set (::std::move (r));
          continue;
        }
      }

      // property
      //
      if (n.name () == "property" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< property_type > r (
          property_traits::create (i, f, this));

        this->property_.push_back (::std::move (r));
        continue;
      }

      // annotation
      //
      if (n.name () == "annotation" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< annotation_type > r (
          annotation_traits::create (i, f, this));

        if (!this->annotation_)
        {
          this->annotation_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "metaid" && n.namespace_ ().empty ())
      {
        this->metaid_.set (metaid_traits::create (i, f, this));
        continue;
      }
    }
  }

  Standalone* Standalone::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Standalone (*this, f, c);
  }

  Standalone& Standalone::
  operator= (const Standalone& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->notes_ = x.notes_;
      this->property_ = x.property_;
      this->annotation_ = x.annotation_;
      this->metaid_ = x.metaid_;
    }

    return *this;
  }

  Standalone::
  ~Standalone ()
  {
  }

  bool
  operator== (const Standalone& x, const Standalone& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.notes () == y.notes ()))
      return false;

    if (!(x.property () == y.property ()))
      return false;

    if (!(x.annotation () == y.annotation ()))
      return false;

    if (!(x.metaid () == y.metaid ()))
      return false;

    return true;
  }

  bool
  operator!= (const Standalone& x, const Standalone& y)
  {
    return !(x == y);
  }

  // NeuroMLDocument_base
  //

  NeuroMLDocument_base::
  NeuroMLDocument_base (const id_type& id)
  : ::neuroml2::Standalone (id),
    include_ (this),
    extracellularProperties_ (this),
    intracellularProperties_ (this),
    morphology_ (this),
    ionChannel_ (this),
    ionChannelHH_ (this),
    ionChannelVShift_ (this),
    ionChannelKS_ (this),
    decayingPoolConcentrationModel_ (this),
    fixedFactorConcentrationModel_ (this),
    alphaCurrentSynapse_ (this),
    alphaSynapse_ (this),
    expOneSynapse_ (this),
    expTwoSynapse_ (this),
    expThreeSynapse_ (this),
    blockingPlasticSynapse_ (this),
    doubleSynapse_ (this),
    gapJunction_ (this),
    silentSynapse_ (this),
    linearGradedSynapse_ (this),
    gradedSynapse_ (this),
    biophysicalProperties_ (this),
    cell_ (this),
    cell2CaPools_ (this),
    baseCell_ (this),
    iafTauCell_ (this),
    iafTauRefCell_ (this),
    iafCell_ (this),
    iafRefCell_ (this),
    izhikevichCell_ (this),
    izhikevich2007Cell_ (this),
    adExIaFCell_ (this),
    fitzHughNagumoCell_ (this),
    fitzHughNagumo1969Cell_ (this),
    pinskyRinzelCA3Cell_ (this),
    pulseGenerator_ (this),
    pulseGeneratorDL_ (this),
    sineGenerator_ (this),
    sineGeneratorDL_ (this),
    rampGenerator_ (this),
    rampGeneratorDL_ (this),
    compoundInput_ (this),
    compoundInputDL_ (this),
    voltageClamp_ (this),
    voltageClampTriple_ (this),
    spikeArray_ (this),
    timedSynapticInput_ (this),
    spikeGenerator_ (this),
    spikeGeneratorRandom_ (this),
    spikeGeneratorPoisson_ (this),
    spikeGeneratorRefPoisson_ (this),
    poissonFiringSynapse_ (this),
    transientPoissonFiringSynapse_ (this),
    IF_curr_alpha_ (this),
    IF_curr_exp_ (this),
    IF_cond_alpha_ (this),
    IF_cond_exp_ (this),
    EIF_cond_exp_isfa_ista_ (this),
    EIF_cond_alpha_isfa_ista_ (this),
    HH_cond_exp_ (this),
    expCondSynapse_ (this),
    alphaCondSynapse_ (this),
    expCurrSynapse_ (this),
    alphaCurrSynapse_ (this),
    SpikeSourcePoisson_ (this),
    network_ (this),
    ComponentType_ (this)
  {
  }

  NeuroMLDocument_base::
  NeuroMLDocument_base (const NeuroMLDocument_base& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    include_ (x.include_, f, this),
    extracellularProperties_ (x.extracellularProperties_, f, this),
    intracellularProperties_ (x.intracellularProperties_, f, this),
    morphology_ (x.morphology_, f, this),
    ionChannel_ (x.ionChannel_, f, this),
    ionChannelHH_ (x.ionChannelHH_, f, this),
    ionChannelVShift_ (x.ionChannelVShift_, f, this),
    ionChannelKS_ (x.ionChannelKS_, f, this),
    decayingPoolConcentrationModel_ (x.decayingPoolConcentrationModel_, f, this),
    fixedFactorConcentrationModel_ (x.fixedFactorConcentrationModel_, f, this),
    alphaCurrentSynapse_ (x.alphaCurrentSynapse_, f, this),
    alphaSynapse_ (x.alphaSynapse_, f, this),
    expOneSynapse_ (x.expOneSynapse_, f, this),
    expTwoSynapse_ (x.expTwoSynapse_, f, this),
    expThreeSynapse_ (x.expThreeSynapse_, f, this),
    blockingPlasticSynapse_ (x.blockingPlasticSynapse_, f, this),
    doubleSynapse_ (x.doubleSynapse_, f, this),
    gapJunction_ (x.gapJunction_, f, this),
    silentSynapse_ (x.silentSynapse_, f, this),
    linearGradedSynapse_ (x.linearGradedSynapse_, f, this),
    gradedSynapse_ (x.gradedSynapse_, f, this),
    biophysicalProperties_ (x.biophysicalProperties_, f, this),
    cell_ (x.cell_, f, this),
    cell2CaPools_ (x.cell2CaPools_, f, this),
    baseCell_ (x.baseCell_, f, this),
    iafTauCell_ (x.iafTauCell_, f, this),
    iafTauRefCell_ (x.iafTauRefCell_, f, this),
    iafCell_ (x.iafCell_, f, this),
    iafRefCell_ (x.iafRefCell_, f, this),
    izhikevichCell_ (x.izhikevichCell_, f, this),
    izhikevich2007Cell_ (x.izhikevich2007Cell_, f, this),
    adExIaFCell_ (x.adExIaFCell_, f, this),
    fitzHughNagumoCell_ (x.fitzHughNagumoCell_, f, this),
    fitzHughNagumo1969Cell_ (x.fitzHughNagumo1969Cell_, f, this),
    pinskyRinzelCA3Cell_ (x.pinskyRinzelCA3Cell_, f, this),
    pulseGenerator_ (x.pulseGenerator_, f, this),
    pulseGeneratorDL_ (x.pulseGeneratorDL_, f, this),
    sineGenerator_ (x.sineGenerator_, f, this),
    sineGeneratorDL_ (x.sineGeneratorDL_, f, this),
    rampGenerator_ (x.rampGenerator_, f, this),
    rampGeneratorDL_ (x.rampGeneratorDL_, f, this),
    compoundInput_ (x.compoundInput_, f, this),
    compoundInputDL_ (x.compoundInputDL_, f, this),
    voltageClamp_ (x.voltageClamp_, f, this),
    voltageClampTriple_ (x.voltageClampTriple_, f, this),
    spikeArray_ (x.spikeArray_, f, this),
    timedSynapticInput_ (x.timedSynapticInput_, f, this),
    spikeGenerator_ (x.spikeGenerator_, f, this),
    spikeGeneratorRandom_ (x.spikeGeneratorRandom_, f, this),
    spikeGeneratorPoisson_ (x.spikeGeneratorPoisson_, f, this),
    spikeGeneratorRefPoisson_ (x.spikeGeneratorRefPoisson_, f, this),
    poissonFiringSynapse_ (x.poissonFiringSynapse_, f, this),
    transientPoissonFiringSynapse_ (x.transientPoissonFiringSynapse_, f, this),
    IF_curr_alpha_ (x.IF_curr_alpha_, f, this),
    IF_curr_exp_ (x.IF_curr_exp_, f, this),
    IF_cond_alpha_ (x.IF_cond_alpha_, f, this),
    IF_cond_exp_ (x.IF_cond_exp_, f, this),
    EIF_cond_exp_isfa_ista_ (x.EIF_cond_exp_isfa_ista_, f, this),
    EIF_cond_alpha_isfa_ista_ (x.EIF_cond_alpha_isfa_ista_, f, this),
    HH_cond_exp_ (x.HH_cond_exp_, f, this),
    expCondSynapse_ (x.expCondSynapse_, f, this),
    alphaCondSynapse_ (x.alphaCondSynapse_, f, this),
    expCurrSynapse_ (x.expCurrSynapse_, f, this),
    alphaCurrSynapse_ (x.alphaCurrSynapse_, f, this),
    SpikeSourcePoisson_ (x.SpikeSourcePoisson_, f, this),
    network_ (x.network_, f, this),
    ComponentType_ (x.ComponentType_, f, this)
  {
  }

  NeuroMLDocument_base::
  NeuroMLDocument_base (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    include_ (this),
    extracellularProperties_ (this),
    intracellularProperties_ (this),
    morphology_ (this),
    ionChannel_ (this),
    ionChannelHH_ (this),
    ionChannelVShift_ (this),
    ionChannelKS_ (this),
    decayingPoolConcentrationModel_ (this),
    fixedFactorConcentrationModel_ (this),
    alphaCurrentSynapse_ (this),
    alphaSynapse_ (this),
    expOneSynapse_ (this),
    expTwoSynapse_ (this),
    expThreeSynapse_ (this),
    blockingPlasticSynapse_ (this),
    doubleSynapse_ (this),
    gapJunction_ (this),
    silentSynapse_ (this),
    linearGradedSynapse_ (this),
    gradedSynapse_ (this),
    biophysicalProperties_ (this),
    cell_ (this),
    cell2CaPools_ (this),
    baseCell_ (this),
    iafTauCell_ (this),
    iafTauRefCell_ (this),
    iafCell_ (this),
    iafRefCell_ (this),
    izhikevichCell_ (this),
    izhikevich2007Cell_ (this),
    adExIaFCell_ (this),
    fitzHughNagumoCell_ (this),
    fitzHughNagumo1969Cell_ (this),
    pinskyRinzelCA3Cell_ (this),
    pulseGenerator_ (this),
    pulseGeneratorDL_ (this),
    sineGenerator_ (this),
    sineGeneratorDL_ (this),
    rampGenerator_ (this),
    rampGeneratorDL_ (this),
    compoundInput_ (this),
    compoundInputDL_ (this),
    voltageClamp_ (this),
    voltageClampTriple_ (this),
    spikeArray_ (this),
    timedSynapticInput_ (this),
    spikeGenerator_ (this),
    spikeGeneratorRandom_ (this),
    spikeGeneratorPoisson_ (this),
    spikeGeneratorRefPoisson_ (this),
    poissonFiringSynapse_ (this),
    transientPoissonFiringSynapse_ (this),
    IF_curr_alpha_ (this),
    IF_curr_exp_ (this),
    IF_cond_alpha_ (this),
    IF_cond_exp_ (this),
    EIF_cond_exp_isfa_ista_ (this),
    EIF_cond_alpha_isfa_ista_ (this),
    HH_cond_exp_ (this),
    expCondSynapse_ (this),
    alphaCondSynapse_ (this),
    expCurrSynapse_ (this),
    alphaCurrSynapse_ (this),
    SpikeSourcePoisson_ (this),
    network_ (this),
    ComponentType_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void NeuroMLDocument_base::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // include
      //
      if (n.name () == "include" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< include_type > r (
          include_traits::create (i, f, this));

        this->include_.push_back (::std::move (r));
        continue;
      }

      // extracellularProperties
      //
      if (n.name () == "extracellularProperties" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< extracellularProperties_type > r (
          extracellularProperties_traits::create (i, f, this));

        this->extracellularProperties_.push_back (::std::move (r));
        continue;
      }

      // intracellularProperties
      //
      if (n.name () == "intracellularProperties" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< intracellularProperties_type > r (
          intracellularProperties_traits::create (i, f, this));

        this->intracellularProperties_.push_back (::std::move (r));
        continue;
      }

      // morphology
      //
      if (n.name () == "morphology" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< morphology_type > r (
          morphology_traits::create (i, f, this));

        this->morphology_.push_back (::std::move (r));
        continue;
      }

      // ionChannel
      //
      if (n.name () == "ionChannel" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< ionChannel_type > r (
          ionChannel_traits::create (i, f, this));

        this->ionChannel_.push_back (::std::move (r));
        continue;
      }

      // ionChannelHH
      //
      if (n.name () == "ionChannelHH" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< ionChannelHH_type > r (
          ionChannelHH_traits::create (i, f, this));

        this->ionChannelHH_.push_back (::std::move (r));
        continue;
      }

      // ionChannelVShift
      //
      if (n.name () == "ionChannelVShift" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< ionChannelVShift_type > r (
          ionChannelVShift_traits::create (i, f, this));

        this->ionChannelVShift_.push_back (::std::move (r));
        continue;
      }

      // ionChannelKS
      //
      if (n.name () == "ionChannelKS" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< ionChannelKS_type > r (
          ionChannelKS_traits::create (i, f, this));

        this->ionChannelKS_.push_back (::std::move (r));
        continue;
      }

      // decayingPoolConcentrationModel
      //
      if (n.name () == "decayingPoolConcentrationModel" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< decayingPoolConcentrationModel_type > r (
          decayingPoolConcentrationModel_traits::create (i, f, this));

        this->decayingPoolConcentrationModel_.push_back (::std::move (r));
        continue;
      }

      // fixedFactorConcentrationModel
      //
      if (n.name () == "fixedFactorConcentrationModel" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< fixedFactorConcentrationModel_type > r (
          fixedFactorConcentrationModel_traits::create (i, f, this));

        this->fixedFactorConcentrationModel_.push_back (::std::move (r));
        continue;
      }

      // alphaCurrentSynapse
      //
      if (n.name () == "alphaCurrentSynapse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< alphaCurrentSynapse_type > r (
          alphaCurrentSynapse_traits::create (i, f, this));

        this->alphaCurrentSynapse_.push_back (::std::move (r));
        continue;
      }

      // alphaSynapse
      //
      if (n.name () == "alphaSynapse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< alphaSynapse_type > r (
          alphaSynapse_traits::create (i, f, this));

        this->alphaSynapse_.push_back (::std::move (r));
        continue;
      }

      // expOneSynapse
      //
      if (n.name () == "expOneSynapse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< expOneSynapse_type > r (
          expOneSynapse_traits::create (i, f, this));

        this->expOneSynapse_.push_back (::std::move (r));
        continue;
      }

      // expTwoSynapse
      //
      if (n.name () == "expTwoSynapse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< expTwoSynapse_type > r (
          expTwoSynapse_traits::create (i, f, this));

        this->expTwoSynapse_.push_back (::std::move (r));
        continue;
      }

      // expThreeSynapse
      //
      if (n.name () == "expThreeSynapse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< expThreeSynapse_type > r (
          expThreeSynapse_traits::create (i, f, this));

        this->expThreeSynapse_.push_back (::std::move (r));
        continue;
      }

      // blockingPlasticSynapse
      //
      if (n.name () == "blockingPlasticSynapse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< blockingPlasticSynapse_type > r (
          blockingPlasticSynapse_traits::create (i, f, this));

        this->blockingPlasticSynapse_.push_back (::std::move (r));
        continue;
      }

      // doubleSynapse
      //
      if (n.name () == "doubleSynapse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< doubleSynapse_type > r (
          doubleSynapse_traits::create (i, f, this));

        this->doubleSynapse_.push_back (::std::move (r));
        continue;
      }

      // gapJunction
      //
      if (n.name () == "gapJunction" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< gapJunction_type > r (
          gapJunction_traits::create (i, f, this));

        this->gapJunction_.push_back (::std::move (r));
        continue;
      }

      // silentSynapse
      //
      if (n.name () == "silentSynapse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< silentSynapse_type > r (
          silentSynapse_traits::create (i, f, this));

        this->silentSynapse_.push_back (::std::move (r));
        continue;
      }

      // linearGradedSynapse
      //
      if (n.name () == "linearGradedSynapse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< linearGradedSynapse_type > r (
          linearGradedSynapse_traits::create (i, f, this));

        this->linearGradedSynapse_.push_back (::std::move (r));
        continue;
      }

      // gradedSynapse
      //
      if (n.name () == "gradedSynapse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< gradedSynapse_type > r (
          gradedSynapse_traits::create (i, f, this));

        this->gradedSynapse_.push_back (::std::move (r));
        continue;
      }

      // biophysicalProperties
      //
      if (n.name () == "biophysicalProperties" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< biophysicalProperties_type > r (
          biophysicalProperties_traits::create (i, f, this));

        this->biophysicalProperties_.push_back (::std::move (r));
        continue;
      }

      // cell
      //
      if (n.name () == "cell" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< cell_type > r (
          cell_traits::create (i, f, this));

        this->cell_.push_back (::std::move (r));
        continue;
      }

      // cell2CaPools
      //
      if (n.name () == "cell2CaPools" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< cell2CaPools_type > r (
          cell2CaPools_traits::create (i, f, this));

        this->cell2CaPools_.push_back (::std::move (r));
        continue;
      }

      // baseCell
      //
      if (n.name () == "baseCell" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< baseCell_type > r (
          baseCell_traits::create (i, f, this));

        this->baseCell_.push_back (::std::move (r));
        continue;
      }

      // iafTauCell
      //
      if (n.name () == "iafTauCell" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< iafTauCell_type > r (
          iafTauCell_traits::create (i, f, this));

        this->iafTauCell_.push_back (::std::move (r));
        continue;
      }

      // iafTauRefCell
      //
      if (n.name () == "iafTauRefCell" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< iafTauRefCell_type > r (
          iafTauRefCell_traits::create (i, f, this));

        this->iafTauRefCell_.push_back (::std::move (r));
        continue;
      }

      // iafCell
      //
      if (n.name () == "iafCell" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< iafCell_type > r (
          iafCell_traits::create (i, f, this));

        this->iafCell_.push_back (::std::move (r));
        continue;
      }

      // iafRefCell
      //
      if (n.name () == "iafRefCell" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< iafRefCell_type > r (
          iafRefCell_traits::create (i, f, this));

        this->iafRefCell_.push_back (::std::move (r));
        continue;
      }

      // izhikevichCell
      //
      if (n.name () == "izhikevichCell" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< izhikevichCell_type > r (
          izhikevichCell_traits::create (i, f, this));

        this->izhikevichCell_.push_back (::std::move (r));
        continue;
      }

      // izhikevich2007Cell
      //
      if (n.name () == "izhikevich2007Cell" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< izhikevich2007Cell_type > r (
          izhikevich2007Cell_traits::create (i, f, this));

        this->izhikevich2007Cell_.push_back (::std::move (r));
        continue;
      }

      // adExIaFCell
      //
      if (n.name () == "adExIaFCell" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< adExIaFCell_type > r (
          adExIaFCell_traits::create (i, f, this));

        this->adExIaFCell_.push_back (::std::move (r));
        continue;
      }

      // fitzHughNagumoCell
      //
      if (n.name () == "fitzHughNagumoCell" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< fitzHughNagumoCell_type > r (
          fitzHughNagumoCell_traits::create (i, f, this));

        this->fitzHughNagumoCell_.push_back (::std::move (r));
        continue;
      }

      // fitzHughNagumo1969Cell
      //
      if (n.name () == "fitzHughNagumo1969Cell" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< fitzHughNagumo1969Cell_type > r (
          fitzHughNagumo1969Cell_traits::create (i, f, this));

        this->fitzHughNagumo1969Cell_.push_back (::std::move (r));
        continue;
      }

      // pinskyRinzelCA3Cell
      //
      if (n.name () == "pinskyRinzelCA3Cell" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< pinskyRinzelCA3Cell_type > r (
          pinskyRinzelCA3Cell_traits::create (i, f, this));

        this->pinskyRinzelCA3Cell_.push_back (::std::move (r));
        continue;
      }

      // pulseGenerator
      //
      if (n.name () == "pulseGenerator" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< pulseGenerator_type > r (
          pulseGenerator_traits::create (i, f, this));

        this->pulseGenerator_.push_back (::std::move (r));
        continue;
      }

      // pulseGeneratorDL
      //
      if (n.name () == "pulseGeneratorDL" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< pulseGeneratorDL_type > r (
          pulseGeneratorDL_traits::create (i, f, this));

        this->pulseGeneratorDL_.push_back (::std::move (r));
        continue;
      }

      // sineGenerator
      //
      if (n.name () == "sineGenerator" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< sineGenerator_type > r (
          sineGenerator_traits::create (i, f, this));

        this->sineGenerator_.push_back (::std::move (r));
        continue;
      }

      // sineGeneratorDL
      //
      if (n.name () == "sineGeneratorDL" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< sineGeneratorDL_type > r (
          sineGeneratorDL_traits::create (i, f, this));

        this->sineGeneratorDL_.push_back (::std::move (r));
        continue;
      }

      // rampGenerator
      //
      if (n.name () == "rampGenerator" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< rampGenerator_type > r (
          rampGenerator_traits::create (i, f, this));

        this->rampGenerator_.push_back (::std::move (r));
        continue;
      }

      // rampGeneratorDL
      //
      if (n.name () == "rampGeneratorDL" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< rampGeneratorDL_type > r (
          rampGeneratorDL_traits::create (i, f, this));

        this->rampGeneratorDL_.push_back (::std::move (r));
        continue;
      }

      // compoundInput
      //
      if (n.name () == "compoundInput" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< compoundInput_type > r (
          compoundInput_traits::create (i, f, this));

        this->compoundInput_.push_back (::std::move (r));
        continue;
      }

      // compoundInputDL
      //
      if (n.name () == "compoundInputDL" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< compoundInputDL_type > r (
          compoundInputDL_traits::create (i, f, this));

        this->compoundInputDL_.push_back (::std::move (r));
        continue;
      }

      // voltageClamp
      //
      if (n.name () == "voltageClamp" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< voltageClamp_type > r (
          voltageClamp_traits::create (i, f, this));

        this->voltageClamp_.push_back (::std::move (r));
        continue;
      }

      // voltageClampTriple
      //
      if (n.name () == "voltageClampTriple" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< voltageClampTriple_type > r (
          voltageClampTriple_traits::create (i, f, this));

        this->voltageClampTriple_.push_back (::std::move (r));
        continue;
      }

      // spikeArray
      //
      if (n.name () == "spikeArray" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< spikeArray_type > r (
          spikeArray_traits::create (i, f, this));

        this->spikeArray_.push_back (::std::move (r));
        continue;
      }

      // timedSynapticInput
      //
      if (n.name () == "timedSynapticInput" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< timedSynapticInput_type > r (
          timedSynapticInput_traits::create (i, f, this));

        this->timedSynapticInput_.push_back (::std::move (r));
        continue;
      }

      // spikeGenerator
      //
      if (n.name () == "spikeGenerator" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< spikeGenerator_type > r (
          spikeGenerator_traits::create (i, f, this));

        this->spikeGenerator_.push_back (::std::move (r));
        continue;
      }

      // spikeGeneratorRandom
      //
      if (n.name () == "spikeGeneratorRandom" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< spikeGeneratorRandom_type > r (
          spikeGeneratorRandom_traits::create (i, f, this));

        this->spikeGeneratorRandom_.push_back (::std::move (r));
        continue;
      }

      // spikeGeneratorPoisson
      //
      if (n.name () == "spikeGeneratorPoisson" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< spikeGeneratorPoisson_type > r (
          spikeGeneratorPoisson_traits::create (i, f, this));

        this->spikeGeneratorPoisson_.push_back (::std::move (r));
        continue;
      }

      // spikeGeneratorRefPoisson
      //
      if (n.name () == "spikeGeneratorRefPoisson" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< spikeGeneratorRefPoisson_type > r (
          spikeGeneratorRefPoisson_traits::create (i, f, this));

        this->spikeGeneratorRefPoisson_.push_back (::std::move (r));
        continue;
      }

      // poissonFiringSynapse
      //
      if (n.name () == "poissonFiringSynapse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< poissonFiringSynapse_type > r (
          poissonFiringSynapse_traits::create (i, f, this));

        this->poissonFiringSynapse_.push_back (::std::move (r));
        continue;
      }

      // transientPoissonFiringSynapse
      //
      if (n.name () == "transientPoissonFiringSynapse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< transientPoissonFiringSynapse_type > r (
          transientPoissonFiringSynapse_traits::create (i, f, this));

        this->transientPoissonFiringSynapse_.push_back (::std::move (r));
        continue;
      }

      // IF_curr_alpha
      //
      if (n.name () == "IF_curr_alpha" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< IF_curr_alpha_type > r (
          IF_curr_alpha_traits::create (i, f, this));

        this->IF_curr_alpha_.push_back (::std::move (r));
        continue;
      }

      // IF_curr_exp
      //
      if (n.name () == "IF_curr_exp" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< IF_curr_exp_type > r (
          IF_curr_exp_traits::create (i, f, this));

        this->IF_curr_exp_.push_back (::std::move (r));
        continue;
      }

      // IF_cond_alpha
      //
      if (n.name () == "IF_cond_alpha" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< IF_cond_alpha_type > r (
          IF_cond_alpha_traits::create (i, f, this));

        this->IF_cond_alpha_.push_back (::std::move (r));
        continue;
      }

      // IF_cond_exp
      //
      if (n.name () == "IF_cond_exp" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< IF_cond_exp_type > r (
          IF_cond_exp_traits::create (i, f, this));

        this->IF_cond_exp_.push_back (::std::move (r));
        continue;
      }

      // EIF_cond_exp_isfa_ista
      //
      if (n.name () == "EIF_cond_exp_isfa_ista" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< EIF_cond_exp_isfa_ista_type > r (
          EIF_cond_exp_isfa_ista_traits::create (i, f, this));

        this->EIF_cond_exp_isfa_ista_.push_back (::std::move (r));
        continue;
      }

      // EIF_cond_alpha_isfa_ista
      //
      if (n.name () == "EIF_cond_alpha_isfa_ista" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< EIF_cond_alpha_isfa_ista_type > r (
          EIF_cond_alpha_isfa_ista_traits::create (i, f, this));

        this->EIF_cond_alpha_isfa_ista_.push_back (::std::move (r));
        continue;
      }

      // HH_cond_exp
      //
      if (n.name () == "HH_cond_exp" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< HH_cond_exp_type > r (
          HH_cond_exp_traits::create (i, f, this));

        this->HH_cond_exp_.push_back (::std::move (r));
        continue;
      }

      // expCondSynapse
      //
      if (n.name () == "expCondSynapse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< expCondSynapse_type > r (
          expCondSynapse_traits::create (i, f, this));

        this->expCondSynapse_.push_back (::std::move (r));
        continue;
      }

      // alphaCondSynapse
      //
      if (n.name () == "alphaCondSynapse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< alphaCondSynapse_type > r (
          alphaCondSynapse_traits::create (i, f, this));

        this->alphaCondSynapse_.push_back (::std::move (r));
        continue;
      }

      // expCurrSynapse
      //
      if (n.name () == "expCurrSynapse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< expCurrSynapse_type > r (
          expCurrSynapse_traits::create (i, f, this));

        this->expCurrSynapse_.push_back (::std::move (r));
        continue;
      }

      // alphaCurrSynapse
      //
      if (n.name () == "alphaCurrSynapse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< alphaCurrSynapse_type > r (
          alphaCurrSynapse_traits::create (i, f, this));

        this->alphaCurrSynapse_.push_back (::std::move (r));
        continue;
      }

      // SpikeSourcePoisson
      //
      if (n.name () == "SpikeSourcePoisson" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< SpikeSourcePoisson_type > r (
          SpikeSourcePoisson_traits::create (i, f, this));

        this->SpikeSourcePoisson_.push_back (::std::move (r));
        continue;
      }

      // network
      //
      if (n.name () == "network" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< network_type > r (
          network_traits::create (i, f, this));

        this->network_.push_back (::std::move (r));
        continue;
      }

      // ComponentType
      //
      if (n.name () == "ComponentType" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< ComponentType_type > r (
          ComponentType_traits::create (i, f, this));

        this->ComponentType_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  NeuroMLDocument_base* NeuroMLDocument_base::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class NeuroMLDocument_base (*this, f, c);
  }

  NeuroMLDocument_base& NeuroMLDocument_base::
  operator= (const NeuroMLDocument_base& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->include_ = x.include_;
      this->extracellularProperties_ = x.extracellularProperties_;
      this->intracellularProperties_ = x.intracellularProperties_;
      this->morphology_ = x.morphology_;
      this->ionChannel_ = x.ionChannel_;
      this->ionChannelHH_ = x.ionChannelHH_;
      this->ionChannelVShift_ = x.ionChannelVShift_;
      this->ionChannelKS_ = x.ionChannelKS_;
      this->decayingPoolConcentrationModel_ = x.decayingPoolConcentrationModel_;
      this->fixedFactorConcentrationModel_ = x.fixedFactorConcentrationModel_;
      this->alphaCurrentSynapse_ = x.alphaCurrentSynapse_;
      this->alphaSynapse_ = x.alphaSynapse_;
      this->expOneSynapse_ = x.expOneSynapse_;
      this->expTwoSynapse_ = x.expTwoSynapse_;
      this->expThreeSynapse_ = x.expThreeSynapse_;
      this->blockingPlasticSynapse_ = x.blockingPlasticSynapse_;
      this->doubleSynapse_ = x.doubleSynapse_;
      this->gapJunction_ = x.gapJunction_;
      this->silentSynapse_ = x.silentSynapse_;
      this->linearGradedSynapse_ = x.linearGradedSynapse_;
      this->gradedSynapse_ = x.gradedSynapse_;
      this->biophysicalProperties_ = x.biophysicalProperties_;
      this->cell_ = x.cell_;
      this->cell2CaPools_ = x.cell2CaPools_;
      this->baseCell_ = x.baseCell_;
      this->iafTauCell_ = x.iafTauCell_;
      this->iafTauRefCell_ = x.iafTauRefCell_;
      this->iafCell_ = x.iafCell_;
      this->iafRefCell_ = x.iafRefCell_;
      this->izhikevichCell_ = x.izhikevichCell_;
      this->izhikevich2007Cell_ = x.izhikevich2007Cell_;
      this->adExIaFCell_ = x.adExIaFCell_;
      this->fitzHughNagumoCell_ = x.fitzHughNagumoCell_;
      this->fitzHughNagumo1969Cell_ = x.fitzHughNagumo1969Cell_;
      this->pinskyRinzelCA3Cell_ = x.pinskyRinzelCA3Cell_;
      this->pulseGenerator_ = x.pulseGenerator_;
      this->pulseGeneratorDL_ = x.pulseGeneratorDL_;
      this->sineGenerator_ = x.sineGenerator_;
      this->sineGeneratorDL_ = x.sineGeneratorDL_;
      this->rampGenerator_ = x.rampGenerator_;
      this->rampGeneratorDL_ = x.rampGeneratorDL_;
      this->compoundInput_ = x.compoundInput_;
      this->compoundInputDL_ = x.compoundInputDL_;
      this->voltageClamp_ = x.voltageClamp_;
      this->voltageClampTriple_ = x.voltageClampTriple_;
      this->spikeArray_ = x.spikeArray_;
      this->timedSynapticInput_ = x.timedSynapticInput_;
      this->spikeGenerator_ = x.spikeGenerator_;
      this->spikeGeneratorRandom_ = x.spikeGeneratorRandom_;
      this->spikeGeneratorPoisson_ = x.spikeGeneratorPoisson_;
      this->spikeGeneratorRefPoisson_ = x.spikeGeneratorRefPoisson_;
      this->poissonFiringSynapse_ = x.poissonFiringSynapse_;
      this->transientPoissonFiringSynapse_ = x.transientPoissonFiringSynapse_;
      this->IF_curr_alpha_ = x.IF_curr_alpha_;
      this->IF_curr_exp_ = x.IF_curr_exp_;
      this->IF_cond_alpha_ = x.IF_cond_alpha_;
      this->IF_cond_exp_ = x.IF_cond_exp_;
      this->EIF_cond_exp_isfa_ista_ = x.EIF_cond_exp_isfa_ista_;
      this->EIF_cond_alpha_isfa_ista_ = x.EIF_cond_alpha_isfa_ista_;
      this->HH_cond_exp_ = x.HH_cond_exp_;
      this->expCondSynapse_ = x.expCondSynapse_;
      this->alphaCondSynapse_ = x.alphaCondSynapse_;
      this->expCurrSynapse_ = x.expCurrSynapse_;
      this->alphaCurrSynapse_ = x.alphaCurrSynapse_;
      this->SpikeSourcePoisson_ = x.SpikeSourcePoisson_;
      this->network_ = x.network_;
      this->ComponentType_ = x.ComponentType_;
    }

    return *this;
  }

  NeuroMLDocument_base::
  ~NeuroMLDocument_base ()
  {
  }

  bool
  operator== (const NeuroMLDocument_base& x, const NeuroMLDocument_base& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.include () == y.include ()))
      return false;

    if (!(x.extracellularProperties () == y.extracellularProperties ()))
      return false;

    if (!(x.intracellularProperties () == y.intracellularProperties ()))
      return false;

    if (!(x.morphology () == y.morphology ()))
      return false;

    if (!(x.ionChannel () == y.ionChannel ()))
      return false;

    if (!(x.ionChannelHH () == y.ionChannelHH ()))
      return false;

    if (!(x.ionChannelVShift () == y.ionChannelVShift ()))
      return false;

    if (!(x.ionChannelKS () == y.ionChannelKS ()))
      return false;

    if (!(x.decayingPoolConcentrationModel () == y.decayingPoolConcentrationModel ()))
      return false;

    if (!(x.fixedFactorConcentrationModel () == y.fixedFactorConcentrationModel ()))
      return false;

    if (!(x.alphaCurrentSynapse () == y.alphaCurrentSynapse ()))
      return false;

    if (!(x.alphaSynapse () == y.alphaSynapse ()))
      return false;

    if (!(x.expOneSynapse () == y.expOneSynapse ()))
      return false;

    if (!(x.expTwoSynapse () == y.expTwoSynapse ()))
      return false;

    if (!(x.expThreeSynapse () == y.expThreeSynapse ()))
      return false;

    if (!(x.blockingPlasticSynapse () == y.blockingPlasticSynapse ()))
      return false;

    if (!(x.doubleSynapse () == y.doubleSynapse ()))
      return false;

    if (!(x.gapJunction () == y.gapJunction ()))
      return false;

    if (!(x.silentSynapse () == y.silentSynapse ()))
      return false;

    if (!(x.linearGradedSynapse () == y.linearGradedSynapse ()))
      return false;

    if (!(x.gradedSynapse () == y.gradedSynapse ()))
      return false;

    if (!(x.biophysicalProperties () == y.biophysicalProperties ()))
      return false;

    if (!(x.cell () == y.cell ()))
      return false;

    if (!(x.cell2CaPools () == y.cell2CaPools ()))
      return false;

    if (!(x.baseCell () == y.baseCell ()))
      return false;

    if (!(x.iafTauCell () == y.iafTauCell ()))
      return false;

    if (!(x.iafTauRefCell () == y.iafTauRefCell ()))
      return false;

    if (!(x.iafCell () == y.iafCell ()))
      return false;

    if (!(x.iafRefCell () == y.iafRefCell ()))
      return false;

    if (!(x.izhikevichCell () == y.izhikevichCell ()))
      return false;

    if (!(x.izhikevich2007Cell () == y.izhikevich2007Cell ()))
      return false;

    if (!(x.adExIaFCell () == y.adExIaFCell ()))
      return false;

    if (!(x.fitzHughNagumoCell () == y.fitzHughNagumoCell ()))
      return false;

    if (!(x.fitzHughNagumo1969Cell () == y.fitzHughNagumo1969Cell ()))
      return false;

    if (!(x.pinskyRinzelCA3Cell () == y.pinskyRinzelCA3Cell ()))
      return false;

    if (!(x.pulseGenerator () == y.pulseGenerator ()))
      return false;

    if (!(x.pulseGeneratorDL () == y.pulseGeneratorDL ()))
      return false;

    if (!(x.sineGenerator () == y.sineGenerator ()))
      return false;

    if (!(x.sineGeneratorDL () == y.sineGeneratorDL ()))
      return false;

    if (!(x.rampGenerator () == y.rampGenerator ()))
      return false;

    if (!(x.rampGeneratorDL () == y.rampGeneratorDL ()))
      return false;

    if (!(x.compoundInput () == y.compoundInput ()))
      return false;

    if (!(x.compoundInputDL () == y.compoundInputDL ()))
      return false;

    if (!(x.voltageClamp () == y.voltageClamp ()))
      return false;

    if (!(x.voltageClampTriple () == y.voltageClampTriple ()))
      return false;

    if (!(x.spikeArray () == y.spikeArray ()))
      return false;

    if (!(x.timedSynapticInput () == y.timedSynapticInput ()))
      return false;

    if (!(x.spikeGenerator () == y.spikeGenerator ()))
      return false;

    if (!(x.spikeGeneratorRandom () == y.spikeGeneratorRandom ()))
      return false;

    if (!(x.spikeGeneratorPoisson () == y.spikeGeneratorPoisson ()))
      return false;

    if (!(x.spikeGeneratorRefPoisson () == y.spikeGeneratorRefPoisson ()))
      return false;

    if (!(x.poissonFiringSynapse () == y.poissonFiringSynapse ()))
      return false;

    if (!(x.transientPoissonFiringSynapse () == y.transientPoissonFiringSynapse ()))
      return false;

    if (!(x.IF_curr_alpha () == y.IF_curr_alpha ()))
      return false;

    if (!(x.IF_curr_exp () == y.IF_curr_exp ()))
      return false;

    if (!(x.IF_cond_alpha () == y.IF_cond_alpha ()))
      return false;

    if (!(x.IF_cond_exp () == y.IF_cond_exp ()))
      return false;

    if (!(x.EIF_cond_exp_isfa_ista () == y.EIF_cond_exp_isfa_ista ()))
      return false;

    if (!(x.EIF_cond_alpha_isfa_ista () == y.EIF_cond_alpha_isfa_ista ()))
      return false;

    if (!(x.HH_cond_exp () == y.HH_cond_exp ()))
      return false;

    if (!(x.expCondSynapse () == y.expCondSynapse ()))
      return false;

    if (!(x.alphaCondSynapse () == y.alphaCondSynapse ()))
      return false;

    if (!(x.expCurrSynapse () == y.expCurrSynapse ()))
      return false;

    if (!(x.alphaCurrSynapse () == y.alphaCurrSynapse ()))
      return false;

    if (!(x.SpikeSourcePoisson () == y.SpikeSourcePoisson ()))
      return false;

    if (!(x.network () == y.network ()))
      return false;

    if (!(x.ComponentType () == y.ComponentType ()))
      return false;

    return true;
  }

  bool
  operator!= (const NeuroMLDocument_base& x, const NeuroMLDocument_base& y)
  {
    return !(x == y);
  }

  // IncludeType
  //

  IncludeType::
  IncludeType (const href_type& href)
  : ::xml_schema::type (),
    href_ (href, this)
  {
  }

  IncludeType::
  IncludeType (const IncludeType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    href_ (x.href_, f, this)
  {
  }

  IncludeType::
  IncludeType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    href_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void IncludeType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "href" && n.namespace_ ().empty ())
      {
        this->href_.set (href_traits::create (i, f, this));
        continue;
      }
    }

    if (!href_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "href",
        "");
    }
  }

  IncludeType* IncludeType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IncludeType (*this, f, c);
  }

  IncludeType& IncludeType::
  operator= (const IncludeType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->href_ = x.href_;
    }

    return *this;
  }

  IncludeType::
  ~IncludeType ()
  {
  }

  bool
  operator== (const IncludeType& x, const IncludeType& y)
  {
    if (!(x.href () == y.href ()))
      return false;

    return true;
  }

  bool
  operator!= (const IncludeType& x, const IncludeType& y)
  {
    return !(x == y);
  }

  // IonChannelScalable
  //

  IonChannelScalable::
  IonChannelScalable (const id_type& id)
  : ::neuroml2::Standalone (id),
    q10ConductanceScaling_ (this)
  {
  }

  IonChannelScalable::
  IonChannelScalable (const IonChannelScalable& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    q10ConductanceScaling_ (x.q10ConductanceScaling_, f, this)
  {
  }

  IonChannelScalable::
  IonChannelScalable (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    q10ConductanceScaling_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void IonChannelScalable::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // q10ConductanceScaling
      //
      if (n.name () == "q10ConductanceScaling" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< q10ConductanceScaling_type > r (
          q10ConductanceScaling_traits::create (i, f, this));

        this->q10ConductanceScaling_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  IonChannelScalable* IonChannelScalable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IonChannelScalable (*this, f, c);
  }

  IonChannelScalable& IonChannelScalable::
  operator= (const IonChannelScalable& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->q10ConductanceScaling_ = x.q10ConductanceScaling_;
    }

    return *this;
  }

  IonChannelScalable::
  ~IonChannelScalable ()
  {
  }

  bool
  operator== (const IonChannelScalable& x, const IonChannelScalable& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.q10ConductanceScaling () == y.q10ConductanceScaling ()))
      return false;

    return true;
  }

  bool
  operator!= (const IonChannelScalable& x, const IonChannelScalable& y)
  {
    return !(x == y);
  }

  // IonChannelKS
  //

  IonChannelKS::
  IonChannelKS (const id_type& id)
  : ::neuroml2::Standalone (id),
    gateKS_ (this),
    species_ (this),
    conductance_ (this)
  {
  }

  IonChannelKS::
  IonChannelKS (const IonChannelKS& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    gateKS_ (x.gateKS_, f, this),
    species_ (x.species_, f, this),
    conductance_ (x.conductance_, f, this)
  {
  }

  IonChannelKS::
  IonChannelKS (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    gateKS_ (this),
    species_ (this),
    conductance_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void IonChannelKS::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // gateKS
      //
      if (n.name () == "gateKS" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< gateKS_type > r (
          gateKS_traits::create (i, f, this));

        this->gateKS_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "species" && n.namespace_ ().empty ())
      {
        this->species_.set (species_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "conductance" && n.namespace_ ().empty ())
      {
        this->conductance_.set (conductance_traits::create (i, f, this));
        continue;
      }
    }
  }

  IonChannelKS* IonChannelKS::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IonChannelKS (*this, f, c);
  }

  IonChannelKS& IonChannelKS::
  operator= (const IonChannelKS& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->gateKS_ = x.gateKS_;
      this->species_ = x.species_;
      this->conductance_ = x.conductance_;
    }

    return *this;
  }

  IonChannelKS::
  ~IonChannelKS ()
  {
  }

  bool
  operator== (const IonChannelKS& x, const IonChannelKS& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.gateKS () == y.gateKS ()))
      return false;

    if (!(x.species () == y.species ()))
      return false;

    if (!(x.conductance () == y.conductance ()))
      return false;

    return true;
  }

  bool
  operator!= (const IonChannelKS& x, const IonChannelKS& y)
  {
    return !(x == y);
  }

  // IonChannel
  //

  IonChannel::
  IonChannel (const id_type& id)
  : ::neuroml2::IonChannelScalable (id),
    gate_ (this),
    gateHHrates_ (this),
    gateHHratesTau_ (this),
    gateHHtauInf_ (this),
    gateHHratesInf_ (this),
    gateHHratesTauInf_ (this),
    gateHHInstantaneous_ (this),
    gateFractional_ (this),
    species_ (this),
    type_ (this),
    conductance_ (this)
  {
  }

  IonChannel::
  IonChannel (const IonChannel& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::neuroml2::IonChannelScalable (x, f, c),
    gate_ (x.gate_, f, this),
    gateHHrates_ (x.gateHHrates_, f, this),
    gateHHratesTau_ (x.gateHHratesTau_, f, this),
    gateHHtauInf_ (x.gateHHtauInf_, f, this),
    gateHHratesInf_ (x.gateHHratesInf_, f, this),
    gateHHratesTauInf_ (x.gateHHratesTauInf_, f, this),
    gateHHInstantaneous_ (x.gateHHInstantaneous_, f, this),
    gateFractional_ (x.gateFractional_, f, this),
    species_ (x.species_, f, this),
    type_ (x.type_, f, this),
    conductance_ (x.conductance_, f, this)
  {
  }

  IonChannel::
  IonChannel (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::neuroml2::IonChannelScalable (e, f | ::xml_schema::flags::base, c),
    gate_ (this),
    gateHHrates_ (this),
    gateHHratesTau_ (this),
    gateHHtauInf_ (this),
    gateHHratesInf_ (this),
    gateHHratesTauInf_ (this),
    gateHHInstantaneous_ (this),
    gateFractional_ (this),
    species_ (this),
    type_ (this),
    conductance_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void IonChannel::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::IonChannelScalable::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // gate
      //
      if (n.name () == "gate" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< gate_type > r (
          gate_traits::create (i, f, this));

        this->gate_.push_back (::std::move (r));
        continue;
      }

      // gateHHrates
      //
      if (n.name () == "gateHHrates" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< gateHHrates_type > r (
          gateHHrates_traits::create (i, f, this));

        this->gateHHrates_.push_back (::std::move (r));
        continue;
      }

      // gateHHratesTau
      //
      if (n.name () == "gateHHratesTau" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< gateHHratesTau_type > r (
          gateHHratesTau_traits::create (i, f, this));

        this->gateHHratesTau_.push_back (::std::move (r));
        continue;
      }

      // gateHHtauInf
      //
      if (n.name () == "gateHHtauInf" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< gateHHtauInf_type > r (
          gateHHtauInf_traits::create (i, f, this));

        this->gateHHtauInf_.push_back (::std::move (r));
        continue;
      }

      // gateHHratesInf
      //
      if (n.name () == "gateHHratesInf" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< gateHHratesInf_type > r (
          gateHHratesInf_traits::create (i, f, this));

        this->gateHHratesInf_.push_back (::std::move (r));
        continue;
      }

      // gateHHratesTauInf
      //
      if (n.name () == "gateHHratesTauInf" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< gateHHratesTauInf_type > r (
          gateHHratesTauInf_traits::create (i, f, this));

        this->gateHHratesTauInf_.push_back (::std::move (r));
        continue;
      }

      // gateHHInstantaneous
      //
      if (n.name () == "gateHHInstantaneous" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< gateHHInstantaneous_type > r (
          gateHHInstantaneous_traits::create (i, f, this));

        this->gateHHInstantaneous_.push_back (::std::move (r));
        continue;
      }

      // gateFractional
      //
      if (n.name () == "gateFractional" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< gateFractional_type > r (
          gateFractional_traits::create (i, f, this));

        this->gateFractional_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "species" && n.namespace_ ().empty ())
      {
        this->species_.set (species_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "conductance" && n.namespace_ ().empty ())
      {
        this->conductance_.set (conductance_traits::create (i, f, this));
        continue;
      }
    }
  }

  IonChannel* IonChannel::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IonChannel (*this, f, c);
  }

  IonChannel& IonChannel::
  operator= (const IonChannel& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::IonChannelScalable& > (*this) = x;
      this->gate_ = x.gate_;
      this->gateHHrates_ = x.gateHHrates_;
      this->gateHHratesTau_ = x.gateHHratesTau_;
      this->gateHHtauInf_ = x.gateHHtauInf_;
      this->gateHHratesInf_ = x.gateHHratesInf_;
      this->gateHHratesTauInf_ = x.gateHHratesTauInf_;
      this->gateHHInstantaneous_ = x.gateHHInstantaneous_;
      this->gateFractional_ = x.gateFractional_;
      this->species_ = x.species_;
      this->type_ = x.type_;
      this->conductance_ = x.conductance_;
    }

    return *this;
  }

  IonChannel::
  ~IonChannel ()
  {
  }

  bool
  operator== (const IonChannel& x, const IonChannel& y)
  {
    if (!(static_cast< const ::neuroml2::IonChannelScalable& > (x) ==
          static_cast< const ::neuroml2::IonChannelScalable& > (y)))
      return false;

    if (!(x.gate () == y.gate ()))
      return false;

    if (!(x.gateHHrates () == y.gateHHrates ()))
      return false;

    if (!(x.gateHHratesTau () == y.gateHHratesTau ()))
      return false;

    if (!(x.gateHHtauInf () == y.gateHHtauInf ()))
      return false;

    if (!(x.gateHHratesInf () == y.gateHHratesInf ()))
      return false;

    if (!(x.gateHHratesTauInf () == y.gateHHratesTauInf ()))
      return false;

    if (!(x.gateHHInstantaneous () == y.gateHHInstantaneous ()))
      return false;

    if (!(x.gateFractional () == y.gateFractional ()))
      return false;

    if (!(x.species () == y.species ()))
      return false;

    if (!(x.type () == y.type ()))
      return false;

    if (!(x.conductance () == y.conductance ()))
      return false;

    return true;
  }

  bool
  operator!= (const IonChannel& x, const IonChannel& y)
  {
    return !(x == y);
  }

  // IonChannelHH
  //

  IonChannelHH::
  IonChannelHH (const id_type& id)
  : ::neuroml2::IonChannel (id)
  {
  }

  IonChannelHH::
  IonChannelHH (const IonChannelHH& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::neuroml2::IonChannel (x, f, c)
  {
  }

  IonChannelHH::
  IonChannelHH (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::neuroml2::IonChannel (e, f, c)
  {
  }

  IonChannelHH* IonChannelHH::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IonChannelHH (*this, f, c);
  }

  IonChannelHH::
  ~IonChannelHH ()
  {
  }

  // IonChannelVShift
  //

  IonChannelVShift::
  IonChannelVShift (const id_type& id,
                    const vShift_type& vShift)
  : ::neuroml2::IonChannel (id),
    vShift_ (vShift, this)
  {
  }

  IonChannelVShift::
  IonChannelVShift (const IonChannelVShift& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::neuroml2::IonChannel (x, f, c),
    vShift_ (x.vShift_, f, this)
  {
  }

  IonChannelVShift::
  IonChannelVShift (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::neuroml2::IonChannel (e, f | ::xml_schema::flags::base, c),
    vShift_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void IonChannelVShift::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::IonChannel::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "vShift" && n.namespace_ ().empty ())
      {
        this->vShift_.set (vShift_traits::create (i, f, this));
        continue;
      }
    }

    if (!vShift_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "vShift",
        "");
    }
  }

  IonChannelVShift* IonChannelVShift::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IonChannelVShift (*this, f, c);
  }

  IonChannelVShift& IonChannelVShift::
  operator= (const IonChannelVShift& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::IonChannel& > (*this) = x;
      this->vShift_ = x.vShift_;
    }

    return *this;
  }

  IonChannelVShift::
  ~IonChannelVShift ()
  {
  }

  bool
  operator== (const IonChannelVShift& x, const IonChannelVShift& y)
  {
    if (!(static_cast< const ::neuroml2::IonChannel& > (x) ==
          static_cast< const ::neuroml2::IonChannel& > (y)))
      return false;

    if (!(x.vShift () == y.vShift ()))
      return false;

    return true;
  }

  bool
  operator!= (const IonChannelVShift& x, const IonChannelVShift& y)
  {
    return !(x == y);
  }

  // channelTypes
  //

  channelTypes::
  channelTypes (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_channelTypes_convert ();
  }

  channelTypes::
  channelTypes (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_channelTypes_convert ();
  }

  channelTypes::
  channelTypes (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_channelTypes_convert ();
  }

  channelTypes* channelTypes::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class channelTypes (*this, f, c);
  }

  channelTypes::value channelTypes::
  _xsd_channelTypes_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_channelTypes_literals_);
    const value* i (::std::lower_bound (
                      _xsd_channelTypes_indexes_,
                      _xsd_channelTypes_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_channelTypes_indexes_ + 2 || _xsd_channelTypes_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const channelTypes::
  _xsd_channelTypes_literals_[2] =
  {
    "ionChannelPassive",
    "ionChannelHH"
  };

  const channelTypes::value channelTypes::
  _xsd_channelTypes_indexes_[2] =
  {
    ::neuroml2::channelTypes::ionChannelHH,
    ::neuroml2::channelTypes::ionChannelPassive
  };

  // Q10ConductanceScaling
  //

  Q10ConductanceScaling::
  Q10ConductanceScaling (const q10Factor_type& q10Factor,
                         const experimentalTemp_type& experimentalTemp)
  : ::xml_schema::type (),
    q10Factor_ (q10Factor, this),
    experimentalTemp_ (experimentalTemp, this)
  {
  }

  Q10ConductanceScaling::
  Q10ConductanceScaling (const Q10ConductanceScaling& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    q10Factor_ (x.q10Factor_, f, this),
    experimentalTemp_ (x.experimentalTemp_, f, this)
  {
  }

  Q10ConductanceScaling::
  Q10ConductanceScaling (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    q10Factor_ (this),
    experimentalTemp_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Q10ConductanceScaling::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "q10Factor" && n.namespace_ ().empty ())
      {
        this->q10Factor_.set (q10Factor_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "experimentalTemp" && n.namespace_ ().empty ())
      {
        this->experimentalTemp_.set (experimentalTemp_traits::create (i, f, this));
        continue;
      }
    }

    if (!q10Factor_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "q10Factor",
        "");
    }

    if (!experimentalTemp_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "experimentalTemp",
        "");
    }
  }

  Q10ConductanceScaling* Q10ConductanceScaling::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Q10ConductanceScaling (*this, f, c);
  }

  Q10ConductanceScaling& Q10ConductanceScaling::
  operator= (const Q10ConductanceScaling& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->q10Factor_ = x.q10Factor_;
      this->experimentalTemp_ = x.experimentalTemp_;
    }

    return *this;
  }

  Q10ConductanceScaling::
  ~Q10ConductanceScaling ()
  {
  }

  bool
  operator== (const Q10ConductanceScaling& x, const Q10ConductanceScaling& y)
  {
    if (!(x.q10Factor () == y.q10Factor ()))
      return false;

    if (!(x.experimentalTemp () == y.experimentalTemp ()))
      return false;

    return true;
  }

  bool
  operator!= (const Q10ConductanceScaling& x, const Q10ConductanceScaling& y)
  {
    return !(x == y);
  }

  // gateTypes
  //

  gateTypes::
  gateTypes (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_gateTypes_convert ();
  }

  gateTypes::
  gateTypes (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_gateTypes_convert ();
  }

  gateTypes::
  gateTypes (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_gateTypes_convert ();
  }

  gateTypes* gateTypes::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class gateTypes (*this, f, c);
  }

  gateTypes::value gateTypes::
  _xsd_gateTypes_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_gateTypes_literals_);
    const value* i (::std::lower_bound (
                      _xsd_gateTypes_indexes_,
                      _xsd_gateTypes_indexes_ + 8,
                      *this,
                      c));

    if (i == _xsd_gateTypes_indexes_ + 8 || _xsd_gateTypes_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const gateTypes::
  _xsd_gateTypes_literals_[8] =
  {
    "gateHHrates",
    "gateHHratesTau",
    "gateHHtauInf",
    "gateHHratesInf",
    "gateHHratesTauInf",
    "gateHHInstantaneous",
    "gateKS",
    "gateFractional"
  };

  const gateTypes::value gateTypes::
  _xsd_gateTypes_indexes_[8] =
  {
    ::neuroml2::gateTypes::gateFractional,
    ::neuroml2::gateTypes::gateHHInstantaneous,
    ::neuroml2::gateTypes::gateHHrates,
    ::neuroml2::gateTypes::gateHHratesInf,
    ::neuroml2::gateTypes::gateHHratesTau,
    ::neuroml2::gateTypes::gateHHratesTauInf,
    ::neuroml2::gateTypes::gateHHtauInf,
    ::neuroml2::gateTypes::gateKS
  };

  // ClosedState
  //

  ClosedState::
  ClosedState (const id_type& id)
  : ::neuroml2::Base (id)
  {
  }

  ClosedState::
  ClosedState (const ClosedState& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c)
  {
  }

  ClosedState::
  ClosedState (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::neuroml2::Base (e, f, c)
  {
  }

  ClosedState* ClosedState::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClosedState (*this, f, c);
  }

  ClosedState::
  ~ClosedState ()
  {
  }

  // OpenState
  //

  OpenState::
  OpenState (const id_type& id)
  : ::neuroml2::Base (id)
  {
  }

  OpenState::
  OpenState (const OpenState& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c)
  {
  }

  OpenState::
  OpenState (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::neuroml2::Base (e, f, c)
  {
  }

  OpenState* OpenState::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OpenState (*this, f, c);
  }

  OpenState::
  ~OpenState ()
  {
  }

  // ForwardTransition
  //

  ForwardTransition::
  ForwardTransition (const id_type& id,
                     const from_type& from,
                     const to_type& to)
  : ::neuroml2::Base (id),
    from_ (from, this),
    to_ (to, this)
  {
  }

  ForwardTransition::
  ForwardTransition (const ForwardTransition& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    from_ (x.from_, f, this),
    to_ (x.to_, f, this)
  {
  }

  ForwardTransition::
  ForwardTransition (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    from_ (this),
    to_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ForwardTransition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "from" && n.namespace_ ().empty ())
      {
        this->from_.set (from_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "to" && n.namespace_ ().empty ())
      {
        this->to_.set (to_traits::create (i, f, this));
        continue;
      }
    }

    if (!from_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "from",
        "");
    }

    if (!to_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "to",
        "");
    }
  }

  ForwardTransition* ForwardTransition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ForwardTransition (*this, f, c);
  }

  ForwardTransition& ForwardTransition::
  operator= (const ForwardTransition& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->from_ = x.from_;
      this->to_ = x.to_;
    }

    return *this;
  }

  ForwardTransition::
  ~ForwardTransition ()
  {
  }

  bool
  operator== (const ForwardTransition& x, const ForwardTransition& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.from () == y.from ()))
      return false;

    if (!(x.to () == y.to ()))
      return false;

    return true;
  }

  bool
  operator!= (const ForwardTransition& x, const ForwardTransition& y)
  {
    return !(x == y);
  }

  // ReverseTransition
  //

  ReverseTransition::
  ReverseTransition (const id_type& id,
                     const from_type& from,
                     const to_type& to)
  : ::neuroml2::Base (id),
    from_ (from, this),
    to_ (to, this)
  {
  }

  ReverseTransition::
  ReverseTransition (const ReverseTransition& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    from_ (x.from_, f, this),
    to_ (x.to_, f, this)
  {
  }

  ReverseTransition::
  ReverseTransition (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    from_ (this),
    to_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ReverseTransition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "from" && n.namespace_ ().empty ())
      {
        this->from_.set (from_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "to" && n.namespace_ ().empty ())
      {
        this->to_.set (to_traits::create (i, f, this));
        continue;
      }
    }

    if (!from_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "from",
        "");
    }

    if (!to_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "to",
        "");
    }
  }

  ReverseTransition* ReverseTransition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ReverseTransition (*this, f, c);
  }

  ReverseTransition& ReverseTransition::
  operator= (const ReverseTransition& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->from_ = x.from_;
      this->to_ = x.to_;
    }

    return *this;
  }

  ReverseTransition::
  ~ReverseTransition ()
  {
  }

  bool
  operator== (const ReverseTransition& x, const ReverseTransition& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.from () == y.from ()))
      return false;

    if (!(x.to () == y.to ()))
      return false;

    return true;
  }

  bool
  operator!= (const ReverseTransition& x, const ReverseTransition& y)
  {
    return !(x == y);
  }

  // TauInfTransition
  //

  TauInfTransition::
  TauInfTransition (const id_type& id,
                    const steadyState_type& steadyState,
                    const timeCourse_type& timeCourse,
                    const from_type& from,
                    const to_type& to)
  : ::neuroml2::Base (id),
    steadyState_ (steadyState, this),
    timeCourse_ (timeCourse, this),
    from_ (from, this),
    to_ (to, this)
  {
  }

  TauInfTransition::
  TauInfTransition (const id_type& id,
                    ::std::unique_ptr< steadyState_type > steadyState,
                    ::std::unique_ptr< timeCourse_type > timeCourse,
                    const from_type& from,
                    const to_type& to)
  : ::neuroml2::Base (id),
    steadyState_ (std::move (steadyState), this),
    timeCourse_ (std::move (timeCourse), this),
    from_ (from, this),
    to_ (to, this)
  {
  }

  TauInfTransition::
  TauInfTransition (const TauInfTransition& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    steadyState_ (x.steadyState_, f, this),
    timeCourse_ (x.timeCourse_, f, this),
    from_ (x.from_, f, this),
    to_ (x.to_, f, this)
  {
  }

  TauInfTransition::
  TauInfTransition (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    steadyState_ (this),
    timeCourse_ (this),
    from_ (this),
    to_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void TauInfTransition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // steadyState
      //
      if (n.name () == "steadyState" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< steadyState_type > r (
          steadyState_traits::create (i, f, this));

        if (!steadyState_.present ())
        {
          this->steadyState_.set (::std::move (r));
          continue;
        }
      }

      // timeCourse
      //
      if (n.name () == "timeCourse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< timeCourse_type > r (
          timeCourse_traits::create (i, f, this));

        if (!timeCourse_.present ())
        {
          this->timeCourse_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!steadyState_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "steadyState",
        "http://www.neuroml.org/schema/neuroml2");
    }

    if (!timeCourse_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "timeCourse",
        "http://www.neuroml.org/schema/neuroml2");
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "from" && n.namespace_ ().empty ())
      {
        this->from_.set (from_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "to" && n.namespace_ ().empty ())
      {
        this->to_.set (to_traits::create (i, f, this));
        continue;
      }
    }

    if (!from_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "from",
        "");
    }

    if (!to_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "to",
        "");
    }
  }

  TauInfTransition* TauInfTransition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TauInfTransition (*this, f, c);
  }

  TauInfTransition& TauInfTransition::
  operator= (const TauInfTransition& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->steadyState_ = x.steadyState_;
      this->timeCourse_ = x.timeCourse_;
      this->from_ = x.from_;
      this->to_ = x.to_;
    }

    return *this;
  }

  TauInfTransition::
  ~TauInfTransition ()
  {
  }

  bool
  operator== (const TauInfTransition& x, const TauInfTransition& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.steadyState () == y.steadyState ()))
      return false;

    if (!(x.timeCourse () == y.timeCourse ()))
      return false;

    if (!(x.from () == y.from ()))
      return false;

    if (!(x.to () == y.to ()))
      return false;

    return true;
  }

  bool
  operator!= (const TauInfTransition& x, const TauInfTransition& y)
  {
    return !(x == y);
  }

  // GateKS
  //

  GateKS::
  GateKS (const id_type& id,
          const instances_type& instances)
  : ::neuroml2::Base (id),
    notes_ (this),
    q10Settings_ (this),
    closedState_ (this),
    openState_ (this),
    forwardTransition_ (this),
    reverseTransition_ (this),
    tauInfTransition_ (this),
    instances_ (instances, this)
  {
  }

  GateKS::
  GateKS (const GateKS& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    notes_ (x.notes_, f, this),
    q10Settings_ (x.q10Settings_, f, this),
    closedState_ (x.closedState_, f, this),
    openState_ (x.openState_, f, this),
    forwardTransition_ (x.forwardTransition_, f, this),
    reverseTransition_ (x.reverseTransition_, f, this),
    tauInfTransition_ (x.tauInfTransition_, f, this),
    instances_ (x.instances_, f, this)
  {
  }

  GateKS::
  GateKS (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    notes_ (this),
    q10Settings_ (this),
    closedState_ (this),
    openState_ (this),
    forwardTransition_ (this),
    reverseTransition_ (this),
    tauInfTransition_ (this),
    instances_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GateKS::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // notes
      //
      if (n.name () == "notes" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< notes_type > r (
          notes_traits::create (i, f, this));

        if (!this->notes_)
        {
          this->notes_.set (::std::move (r));
          continue;
        }
      }

      // q10Settings
      //
      if (n.name () == "q10Settings" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< q10Settings_type > r (
          q10Settings_traits::create (i, f, this));

        if (!this->q10Settings_)
        {
          this->q10Settings_.set (::std::move (r));
          continue;
        }
      }

      // closedState
      //
      if (n.name () == "closedState" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< closedState_type > r (
          closedState_traits::create (i, f, this));

        this->closedState_.push_back (::std::move (r));
        continue;
      }

      // openState
      //
      if (n.name () == "openState" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< openState_type > r (
          openState_traits::create (i, f, this));

        this->openState_.push_back (::std::move (r));
        continue;
      }

      // forwardTransition
      //
      if (n.name () == "forwardTransition" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< forwardTransition_type > r (
          forwardTransition_traits::create (i, f, this));

        this->forwardTransition_.push_back (::std::move (r));
        continue;
      }

      // reverseTransition
      //
      if (n.name () == "reverseTransition" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< reverseTransition_type > r (
          reverseTransition_traits::create (i, f, this));

        this->reverseTransition_.push_back (::std::move (r));
        continue;
      }

      // tauInfTransition
      //
      if (n.name () == "tauInfTransition" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< tauInfTransition_type > r (
          tauInfTransition_traits::create (i, f, this));

        this->tauInfTransition_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "instances" && n.namespace_ ().empty ())
      {
        this->instances_.set (instances_traits::create (i, f, this));
        continue;
      }
    }

    if (!instances_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "instances",
        "");
    }
  }

  GateKS* GateKS::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class GateKS (*this, f, c);
  }

  GateKS& GateKS::
  operator= (const GateKS& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->notes_ = x.notes_;
      this->q10Settings_ = x.q10Settings_;
      this->closedState_ = x.closedState_;
      this->openState_ = x.openState_;
      this->forwardTransition_ = x.forwardTransition_;
      this->reverseTransition_ = x.reverseTransition_;
      this->tauInfTransition_ = x.tauInfTransition_;
      this->instances_ = x.instances_;
    }

    return *this;
  }

  GateKS::
  ~GateKS ()
  {
  }

  bool
  operator== (const GateKS& x, const GateKS& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.notes () == y.notes ()))
      return false;

    if (!(x.q10Settings () == y.q10Settings ()))
      return false;

    if (!(x.closedState () == y.closedState ()))
      return false;

    if (!(x.openState () == y.openState ()))
      return false;

    if (!(x.forwardTransition () == y.forwardTransition ()))
      return false;

    if (!(x.reverseTransition () == y.reverseTransition ()))
      return false;

    if (!(x.tauInfTransition () == y.tauInfTransition ()))
      return false;

    if (!(x.instances () == y.instances ()))
      return false;

    return true;
  }

  bool
  operator!= (const GateKS& x, const GateKS& y)
  {
    return !(x == y);
  }

  // GateHHUndetermined
  //

  GateHHUndetermined::
  GateHHUndetermined (const id_type& id,
                      const instances_type& instances,
                      const type_type& type)
  : ::neuroml2::Base (id),
    notes_ (this),
    q10Settings_ (this),
    forwardRate_ (this),
    reverseRate_ (this),
    timeCourse_ (this),
    steadyState_ (this),
    subGate_ (this),
    instances_ (instances, this),
    type_ (type, this)
  {
  }

  GateHHUndetermined::
  GateHHUndetermined (const GateHHUndetermined& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    notes_ (x.notes_, f, this),
    q10Settings_ (x.q10Settings_, f, this),
    forwardRate_ (x.forwardRate_, f, this),
    reverseRate_ (x.reverseRate_, f, this),
    timeCourse_ (x.timeCourse_, f, this),
    steadyState_ (x.steadyState_, f, this),
    subGate_ (x.subGate_, f, this),
    instances_ (x.instances_, f, this),
    type_ (x.type_, f, this)
  {
  }

  GateHHUndetermined::
  GateHHUndetermined (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    notes_ (this),
    q10Settings_ (this),
    forwardRate_ (this),
    reverseRate_ (this),
    timeCourse_ (this),
    steadyState_ (this),
    subGate_ (this),
    instances_ (this),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GateHHUndetermined::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // notes
      //
      if (n.name () == "notes" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< notes_type > r (
          notes_traits::create (i, f, this));

        if (!this->notes_)
        {
          this->notes_.set (::std::move (r));
          continue;
        }
      }

      // q10Settings
      //
      if (n.name () == "q10Settings" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< q10Settings_type > r (
          q10Settings_traits::create (i, f, this));

        if (!this->q10Settings_)
        {
          this->q10Settings_.set (::std::move (r));
          continue;
        }
      }

      // forwardRate
      //
      if (n.name () == "forwardRate" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< forwardRate_type > r (
          forwardRate_traits::create (i, f, this));

        if (!this->forwardRate_)
        {
          this->forwardRate_.set (::std::move (r));
          continue;
        }
      }

      // reverseRate
      //
      if (n.name () == "reverseRate" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< reverseRate_type > r (
          reverseRate_traits::create (i, f, this));

        if (!this->reverseRate_)
        {
          this->reverseRate_.set (::std::move (r));
          continue;
        }
      }

      // timeCourse
      //
      if (n.name () == "timeCourse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< timeCourse_type > r (
          timeCourse_traits::create (i, f, this));

        if (!this->timeCourse_)
        {
          this->timeCourse_.set (::std::move (r));
          continue;
        }
      }

      // steadyState
      //
      if (n.name () == "steadyState" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< steadyState_type > r (
          steadyState_traits::create (i, f, this));

        if (!this->steadyState_)
        {
          this->steadyState_.set (::std::move (r));
          continue;
        }
      }

      // subGate
      //
      if (n.name () == "subGate" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< subGate_type > r (
          subGate_traits::create (i, f, this));

        this->subGate_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "instances" && n.namespace_ ().empty ())
      {
        this->instances_.set (instances_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    if (!instances_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "instances",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  GateHHUndetermined* GateHHUndetermined::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class GateHHUndetermined (*this, f, c);
  }

  GateHHUndetermined& GateHHUndetermined::
  operator= (const GateHHUndetermined& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->notes_ = x.notes_;
      this->q10Settings_ = x.q10Settings_;
      this->forwardRate_ = x.forwardRate_;
      this->reverseRate_ = x.reverseRate_;
      this->timeCourse_ = x.timeCourse_;
      this->steadyState_ = x.steadyState_;
      this->subGate_ = x.subGate_;
      this->instances_ = x.instances_;
      this->type_ = x.type_;
    }

    return *this;
  }

  GateHHUndetermined::
  ~GateHHUndetermined ()
  {
  }

  bool
  operator== (const GateHHUndetermined& x, const GateHHUndetermined& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.notes () == y.notes ()))
      return false;

    if (!(x.q10Settings () == y.q10Settings ()))
      return false;

    if (!(x.forwardRate () == y.forwardRate ()))
      return false;

    if (!(x.reverseRate () == y.reverseRate ()))
      return false;

    if (!(x.timeCourse () == y.timeCourse ()))
      return false;

    if (!(x.steadyState () == y.steadyState ()))
      return false;

    if (!(x.subGate () == y.subGate ()))
      return false;

    if (!(x.instances () == y.instances ()))
      return false;

    if (!(x.type () == y.type ()))
      return false;

    return true;
  }

  bool
  operator!= (const GateHHUndetermined& x, const GateHHUndetermined& y)
  {
    return !(x == y);
  }

  // GateHHRates
  //

  GateHHRates::
  GateHHRates (const id_type& id,
               const forwardRate_type& forwardRate,
               const reverseRate_type& reverseRate,
               const instances_type& instances)
  : ::neuroml2::Base (id),
    notes_ (this),
    q10Settings_ (this),
    forwardRate_ (forwardRate, this),
    reverseRate_ (reverseRate, this),
    instances_ (instances, this)
  {
  }

  GateHHRates::
  GateHHRates (const id_type& id,
               ::std::unique_ptr< forwardRate_type > forwardRate,
               ::std::unique_ptr< reverseRate_type > reverseRate,
               const instances_type& instances)
  : ::neuroml2::Base (id),
    notes_ (this),
    q10Settings_ (this),
    forwardRate_ (std::move (forwardRate), this),
    reverseRate_ (std::move (reverseRate), this),
    instances_ (instances, this)
  {
  }

  GateHHRates::
  GateHHRates (const GateHHRates& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    notes_ (x.notes_, f, this),
    q10Settings_ (x.q10Settings_, f, this),
    forwardRate_ (x.forwardRate_, f, this),
    reverseRate_ (x.reverseRate_, f, this),
    instances_ (x.instances_, f, this)
  {
  }

  GateHHRates::
  GateHHRates (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    notes_ (this),
    q10Settings_ (this),
    forwardRate_ (this),
    reverseRate_ (this),
    instances_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GateHHRates::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // notes
      //
      if (n.name () == "notes" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< notes_type > r (
          notes_traits::create (i, f, this));

        if (!this->notes_)
        {
          this->notes_.set (::std::move (r));
          continue;
        }
      }

      // q10Settings
      //
      if (n.name () == "q10Settings" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< q10Settings_type > r (
          q10Settings_traits::create (i, f, this));

        if (!this->q10Settings_)
        {
          this->q10Settings_.set (::std::move (r));
          continue;
        }
      }

      // forwardRate
      //
      if (n.name () == "forwardRate" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< forwardRate_type > r (
          forwardRate_traits::create (i, f, this));

        if (!forwardRate_.present ())
        {
          this->forwardRate_.set (::std::move (r));
          continue;
        }
      }

      // reverseRate
      //
      if (n.name () == "reverseRate" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< reverseRate_type > r (
          reverseRate_traits::create (i, f, this));

        if (!reverseRate_.present ())
        {
          this->reverseRate_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!forwardRate_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "forwardRate",
        "http://www.neuroml.org/schema/neuroml2");
    }

    if (!reverseRate_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "reverseRate",
        "http://www.neuroml.org/schema/neuroml2");
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "instances" && n.namespace_ ().empty ())
      {
        this->instances_.set (instances_traits::create (i, f, this));
        continue;
      }
    }

    if (!instances_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "instances",
        "");
    }
  }

  GateHHRates* GateHHRates::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class GateHHRates (*this, f, c);
  }

  GateHHRates& GateHHRates::
  operator= (const GateHHRates& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->notes_ = x.notes_;
      this->q10Settings_ = x.q10Settings_;
      this->forwardRate_ = x.forwardRate_;
      this->reverseRate_ = x.reverseRate_;
      this->instances_ = x.instances_;
    }

    return *this;
  }

  GateHHRates::
  ~GateHHRates ()
  {
  }

  bool
  operator== (const GateHHRates& x, const GateHHRates& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.notes () == y.notes ()))
      return false;

    if (!(x.q10Settings () == y.q10Settings ()))
      return false;

    if (!(x.forwardRate () == y.forwardRate ()))
      return false;

    if (!(x.reverseRate () == y.reverseRate ()))
      return false;

    if (!(x.instances () == y.instances ()))
      return false;

    return true;
  }

  bool
  operator!= (const GateHHRates& x, const GateHHRates& y)
  {
    return !(x == y);
  }

  // GateHHTauInf
  //

  GateHHTauInf::
  GateHHTauInf (const id_type& id,
                const timeCourse_type& timeCourse,
                const steadyState_type& steadyState,
                const instances_type& instances)
  : ::neuroml2::Base (id),
    notes_ (this),
    q10Settings_ (this),
    timeCourse_ (timeCourse, this),
    steadyState_ (steadyState, this),
    instances_ (instances, this)
  {
  }

  GateHHTauInf::
  GateHHTauInf (const id_type& id,
                ::std::unique_ptr< timeCourse_type > timeCourse,
                ::std::unique_ptr< steadyState_type > steadyState,
                const instances_type& instances)
  : ::neuroml2::Base (id),
    notes_ (this),
    q10Settings_ (this),
    timeCourse_ (std::move (timeCourse), this),
    steadyState_ (std::move (steadyState), this),
    instances_ (instances, this)
  {
  }

  GateHHTauInf::
  GateHHTauInf (const GateHHTauInf& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    notes_ (x.notes_, f, this),
    q10Settings_ (x.q10Settings_, f, this),
    timeCourse_ (x.timeCourse_, f, this),
    steadyState_ (x.steadyState_, f, this),
    instances_ (x.instances_, f, this)
  {
  }

  GateHHTauInf::
  GateHHTauInf (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    notes_ (this),
    q10Settings_ (this),
    timeCourse_ (this),
    steadyState_ (this),
    instances_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GateHHTauInf::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // notes
      //
      if (n.name () == "notes" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< notes_type > r (
          notes_traits::create (i, f, this));

        if (!this->notes_)
        {
          this->notes_.set (::std::move (r));
          continue;
        }
      }

      // q10Settings
      //
      if (n.name () == "q10Settings" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< q10Settings_type > r (
          q10Settings_traits::create (i, f, this));

        if (!this->q10Settings_)
        {
          this->q10Settings_.set (::std::move (r));
          continue;
        }
      }

      // timeCourse
      //
      if (n.name () == "timeCourse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< timeCourse_type > r (
          timeCourse_traits::create (i, f, this));

        if (!timeCourse_.present ())
        {
          this->timeCourse_.set (::std::move (r));
          continue;
        }
      }

      // steadyState
      //
      if (n.name () == "steadyState" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< steadyState_type > r (
          steadyState_traits::create (i, f, this));

        if (!steadyState_.present ())
        {
          this->steadyState_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!timeCourse_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "timeCourse",
        "http://www.neuroml.org/schema/neuroml2");
    }

    if (!steadyState_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "steadyState",
        "http://www.neuroml.org/schema/neuroml2");
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "instances" && n.namespace_ ().empty ())
      {
        this->instances_.set (instances_traits::create (i, f, this));
        continue;
      }
    }

    if (!instances_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "instances",
        "");
    }
  }

  GateHHTauInf* GateHHTauInf::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class GateHHTauInf (*this, f, c);
  }

  GateHHTauInf& GateHHTauInf::
  operator= (const GateHHTauInf& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->notes_ = x.notes_;
      this->q10Settings_ = x.q10Settings_;
      this->timeCourse_ = x.timeCourse_;
      this->steadyState_ = x.steadyState_;
      this->instances_ = x.instances_;
    }

    return *this;
  }

  GateHHTauInf::
  ~GateHHTauInf ()
  {
  }

  bool
  operator== (const GateHHTauInf& x, const GateHHTauInf& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.notes () == y.notes ()))
      return false;

    if (!(x.q10Settings () == y.q10Settings ()))
      return false;

    if (!(x.timeCourse () == y.timeCourse ()))
      return false;

    if (!(x.steadyState () == y.steadyState ()))
      return false;

    if (!(x.instances () == y.instances ()))
      return false;

    return true;
  }

  bool
  operator!= (const GateHHTauInf& x, const GateHHTauInf& y)
  {
    return !(x == y);
  }

  // GateHHRatesTauInf
  //

  GateHHRatesTauInf::
  GateHHRatesTauInf (const id_type& id,
                     const forwardRate_type& forwardRate,
                     const reverseRate_type& reverseRate,
                     const timeCourse_type& timeCourse,
                     const steadyState_type& steadyState,
                     const instances_type& instances)
  : ::neuroml2::Base (id),
    notes_ (this),
    q10Settings_ (this),
    forwardRate_ (forwardRate, this),
    reverseRate_ (reverseRate, this),
    timeCourse_ (timeCourse, this),
    steadyState_ (steadyState, this),
    instances_ (instances, this)
  {
  }

  GateHHRatesTauInf::
  GateHHRatesTauInf (const id_type& id,
                     ::std::unique_ptr< forwardRate_type > forwardRate,
                     ::std::unique_ptr< reverseRate_type > reverseRate,
                     ::std::unique_ptr< timeCourse_type > timeCourse,
                     ::std::unique_ptr< steadyState_type > steadyState,
                     const instances_type& instances)
  : ::neuroml2::Base (id),
    notes_ (this),
    q10Settings_ (this),
    forwardRate_ (std::move (forwardRate), this),
    reverseRate_ (std::move (reverseRate), this),
    timeCourse_ (std::move (timeCourse), this),
    steadyState_ (std::move (steadyState), this),
    instances_ (instances, this)
  {
  }

  GateHHRatesTauInf::
  GateHHRatesTauInf (const GateHHRatesTauInf& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    notes_ (x.notes_, f, this),
    q10Settings_ (x.q10Settings_, f, this),
    forwardRate_ (x.forwardRate_, f, this),
    reverseRate_ (x.reverseRate_, f, this),
    timeCourse_ (x.timeCourse_, f, this),
    steadyState_ (x.steadyState_, f, this),
    instances_ (x.instances_, f, this)
  {
  }

  GateHHRatesTauInf::
  GateHHRatesTauInf (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    notes_ (this),
    q10Settings_ (this),
    forwardRate_ (this),
    reverseRate_ (this),
    timeCourse_ (this),
    steadyState_ (this),
    instances_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GateHHRatesTauInf::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // notes
      //
      if (n.name () == "notes" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< notes_type > r (
          notes_traits::create (i, f, this));

        if (!this->notes_)
        {
          this->notes_.set (::std::move (r));
          continue;
        }
      }

      // q10Settings
      //
      if (n.name () == "q10Settings" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< q10Settings_type > r (
          q10Settings_traits::create (i, f, this));

        if (!this->q10Settings_)
        {
          this->q10Settings_.set (::std::move (r));
          continue;
        }
      }

      // forwardRate
      //
      if (n.name () == "forwardRate" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< forwardRate_type > r (
          forwardRate_traits::create (i, f, this));

        if (!forwardRate_.present ())
        {
          this->forwardRate_.set (::std::move (r));
          continue;
        }
      }

      // reverseRate
      //
      if (n.name () == "reverseRate" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< reverseRate_type > r (
          reverseRate_traits::create (i, f, this));

        if (!reverseRate_.present ())
        {
          this->reverseRate_.set (::std::move (r));
          continue;
        }
      }

      // timeCourse
      //
      if (n.name () == "timeCourse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< timeCourse_type > r (
          timeCourse_traits::create (i, f, this));

        if (!timeCourse_.present ())
        {
          this->timeCourse_.set (::std::move (r));
          continue;
        }
      }

      // steadyState
      //
      if (n.name () == "steadyState" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< steadyState_type > r (
          steadyState_traits::create (i, f, this));

        if (!steadyState_.present ())
        {
          this->steadyState_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!forwardRate_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "forwardRate",
        "http://www.neuroml.org/schema/neuroml2");
    }

    if (!reverseRate_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "reverseRate",
        "http://www.neuroml.org/schema/neuroml2");
    }

    if (!timeCourse_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "timeCourse",
        "http://www.neuroml.org/schema/neuroml2");
    }

    if (!steadyState_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "steadyState",
        "http://www.neuroml.org/schema/neuroml2");
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "instances" && n.namespace_ ().empty ())
      {
        this->instances_.set (instances_traits::create (i, f, this));
        continue;
      }
    }

    if (!instances_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "instances",
        "");
    }
  }

  GateHHRatesTauInf* GateHHRatesTauInf::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class GateHHRatesTauInf (*this, f, c);
  }

  GateHHRatesTauInf& GateHHRatesTauInf::
  operator= (const GateHHRatesTauInf& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->notes_ = x.notes_;
      this->q10Settings_ = x.q10Settings_;
      this->forwardRate_ = x.forwardRate_;
      this->reverseRate_ = x.reverseRate_;
      this->timeCourse_ = x.timeCourse_;
      this->steadyState_ = x.steadyState_;
      this->instances_ = x.instances_;
    }

    return *this;
  }

  GateHHRatesTauInf::
  ~GateHHRatesTauInf ()
  {
  }

  bool
  operator== (const GateHHRatesTauInf& x, const GateHHRatesTauInf& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.notes () == y.notes ()))
      return false;

    if (!(x.q10Settings () == y.q10Settings ()))
      return false;

    if (!(x.forwardRate () == y.forwardRate ()))
      return false;

    if (!(x.reverseRate () == y.reverseRate ()))
      return false;

    if (!(x.timeCourse () == y.timeCourse ()))
      return false;

    if (!(x.steadyState () == y.steadyState ()))
      return false;

    if (!(x.instances () == y.instances ()))
      return false;

    return true;
  }

  bool
  operator!= (const GateHHRatesTauInf& x, const GateHHRatesTauInf& y)
  {
    return !(x == y);
  }

  // GateHHRatesTau
  //

  GateHHRatesTau::
  GateHHRatesTau (const id_type& id,
                  const forwardRate_type& forwardRate,
                  const reverseRate_type& reverseRate,
                  const timeCourse_type& timeCourse,
                  const instances_type& instances)
  : ::neuroml2::Base (id),
    notes_ (this),
    q10Settings_ (this),
    forwardRate_ (forwardRate, this),
    reverseRate_ (reverseRate, this),
    timeCourse_ (timeCourse, this),
    instances_ (instances, this)
  {
  }

  GateHHRatesTau::
  GateHHRatesTau (const id_type& id,
                  ::std::unique_ptr< forwardRate_type > forwardRate,
                  ::std::unique_ptr< reverseRate_type > reverseRate,
                  ::std::unique_ptr< timeCourse_type > timeCourse,
                  const instances_type& instances)
  : ::neuroml2::Base (id),
    notes_ (this),
    q10Settings_ (this),
    forwardRate_ (std::move (forwardRate), this),
    reverseRate_ (std::move (reverseRate), this),
    timeCourse_ (std::move (timeCourse), this),
    instances_ (instances, this)
  {
  }

  GateHHRatesTau::
  GateHHRatesTau (const GateHHRatesTau& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    notes_ (x.notes_, f, this),
    q10Settings_ (x.q10Settings_, f, this),
    forwardRate_ (x.forwardRate_, f, this),
    reverseRate_ (x.reverseRate_, f, this),
    timeCourse_ (x.timeCourse_, f, this),
    instances_ (x.instances_, f, this)
  {
  }

  GateHHRatesTau::
  GateHHRatesTau (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    notes_ (this),
    q10Settings_ (this),
    forwardRate_ (this),
    reverseRate_ (this),
    timeCourse_ (this),
    instances_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GateHHRatesTau::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // notes
      //
      if (n.name () == "notes" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< notes_type > r (
          notes_traits::create (i, f, this));

        if (!this->notes_)
        {
          this->notes_.set (::std::move (r));
          continue;
        }
      }

      // q10Settings
      //
      if (n.name () == "q10Settings" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< q10Settings_type > r (
          q10Settings_traits::create (i, f, this));

        if (!this->q10Settings_)
        {
          this->q10Settings_.set (::std::move (r));
          continue;
        }
      }

      // forwardRate
      //
      if (n.name () == "forwardRate" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< forwardRate_type > r (
          forwardRate_traits::create (i, f, this));

        if (!forwardRate_.present ())
        {
          this->forwardRate_.set (::std::move (r));
          continue;
        }
      }

      // reverseRate
      //
      if (n.name () == "reverseRate" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< reverseRate_type > r (
          reverseRate_traits::create (i, f, this));

        if (!reverseRate_.present ())
        {
          this->reverseRate_.set (::std::move (r));
          continue;
        }
      }

      // timeCourse
      //
      if (n.name () == "timeCourse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< timeCourse_type > r (
          timeCourse_traits::create (i, f, this));

        if (!timeCourse_.present ())
        {
          this->timeCourse_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!forwardRate_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "forwardRate",
        "http://www.neuroml.org/schema/neuroml2");
    }

    if (!reverseRate_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "reverseRate",
        "http://www.neuroml.org/schema/neuroml2");
    }

    if (!timeCourse_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "timeCourse",
        "http://www.neuroml.org/schema/neuroml2");
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "instances" && n.namespace_ ().empty ())
      {
        this->instances_.set (instances_traits::create (i, f, this));
        continue;
      }
    }

    if (!instances_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "instances",
        "");
    }
  }

  GateHHRatesTau* GateHHRatesTau::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class GateHHRatesTau (*this, f, c);
  }

  GateHHRatesTau& GateHHRatesTau::
  operator= (const GateHHRatesTau& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->notes_ = x.notes_;
      this->q10Settings_ = x.q10Settings_;
      this->forwardRate_ = x.forwardRate_;
      this->reverseRate_ = x.reverseRate_;
      this->timeCourse_ = x.timeCourse_;
      this->instances_ = x.instances_;
    }

    return *this;
  }

  GateHHRatesTau::
  ~GateHHRatesTau ()
  {
  }

  bool
  operator== (const GateHHRatesTau& x, const GateHHRatesTau& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.notes () == y.notes ()))
      return false;

    if (!(x.q10Settings () == y.q10Settings ()))
      return false;

    if (!(x.forwardRate () == y.forwardRate ()))
      return false;

    if (!(x.reverseRate () == y.reverseRate ()))
      return false;

    if (!(x.timeCourse () == y.timeCourse ()))
      return false;

    if (!(x.instances () == y.instances ()))
      return false;

    return true;
  }

  bool
  operator!= (const GateHHRatesTau& x, const GateHHRatesTau& y)
  {
    return !(x == y);
  }

  // GateHHRatesInf
  //

  GateHHRatesInf::
  GateHHRatesInf (const id_type& id,
                  const forwardRate_type& forwardRate,
                  const reverseRate_type& reverseRate,
                  const steadyState_type& steadyState,
                  const instances_type& instances)
  : ::neuroml2::Base (id),
    notes_ (this),
    q10Settings_ (this),
    forwardRate_ (forwardRate, this),
    reverseRate_ (reverseRate, this),
    steadyState_ (steadyState, this),
    instances_ (instances, this)
  {
  }

  GateHHRatesInf::
  GateHHRatesInf (const id_type& id,
                  ::std::unique_ptr< forwardRate_type > forwardRate,
                  ::std::unique_ptr< reverseRate_type > reverseRate,
                  ::std::unique_ptr< steadyState_type > steadyState,
                  const instances_type& instances)
  : ::neuroml2::Base (id),
    notes_ (this),
    q10Settings_ (this),
    forwardRate_ (std::move (forwardRate), this),
    reverseRate_ (std::move (reverseRate), this),
    steadyState_ (std::move (steadyState), this),
    instances_ (instances, this)
  {
  }

  GateHHRatesInf::
  GateHHRatesInf (const GateHHRatesInf& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    notes_ (x.notes_, f, this),
    q10Settings_ (x.q10Settings_, f, this),
    forwardRate_ (x.forwardRate_, f, this),
    reverseRate_ (x.reverseRate_, f, this),
    steadyState_ (x.steadyState_, f, this),
    instances_ (x.instances_, f, this)
  {
  }

  GateHHRatesInf::
  GateHHRatesInf (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    notes_ (this),
    q10Settings_ (this),
    forwardRate_ (this),
    reverseRate_ (this),
    steadyState_ (this),
    instances_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GateHHRatesInf::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // notes
      //
      if (n.name () == "notes" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< notes_type > r (
          notes_traits::create (i, f, this));

        if (!this->notes_)
        {
          this->notes_.set (::std::move (r));
          continue;
        }
      }

      // q10Settings
      //
      if (n.name () == "q10Settings" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< q10Settings_type > r (
          q10Settings_traits::create (i, f, this));

        if (!this->q10Settings_)
        {
          this->q10Settings_.set (::std::move (r));
          continue;
        }
      }

      // forwardRate
      //
      if (n.name () == "forwardRate" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< forwardRate_type > r (
          forwardRate_traits::create (i, f, this));

        if (!forwardRate_.present ())
        {
          this->forwardRate_.set (::std::move (r));
          continue;
        }
      }

      // reverseRate
      //
      if (n.name () == "reverseRate" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< reverseRate_type > r (
          reverseRate_traits::create (i, f, this));

        if (!reverseRate_.present ())
        {
          this->reverseRate_.set (::std::move (r));
          continue;
        }
      }

      // steadyState
      //
      if (n.name () == "steadyState" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< steadyState_type > r (
          steadyState_traits::create (i, f, this));

        if (!steadyState_.present ())
        {
          this->steadyState_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!forwardRate_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "forwardRate",
        "http://www.neuroml.org/schema/neuroml2");
    }

    if (!reverseRate_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "reverseRate",
        "http://www.neuroml.org/schema/neuroml2");
    }

    if (!steadyState_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "steadyState",
        "http://www.neuroml.org/schema/neuroml2");
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "instances" && n.namespace_ ().empty ())
      {
        this->instances_.set (instances_traits::create (i, f, this));
        continue;
      }
    }

    if (!instances_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "instances",
        "");
    }
  }

  GateHHRatesInf* GateHHRatesInf::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class GateHHRatesInf (*this, f, c);
  }

  GateHHRatesInf& GateHHRatesInf::
  operator= (const GateHHRatesInf& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->notes_ = x.notes_;
      this->q10Settings_ = x.q10Settings_;
      this->forwardRate_ = x.forwardRate_;
      this->reverseRate_ = x.reverseRate_;
      this->steadyState_ = x.steadyState_;
      this->instances_ = x.instances_;
    }

    return *this;
  }

  GateHHRatesInf::
  ~GateHHRatesInf ()
  {
  }

  bool
  operator== (const GateHHRatesInf& x, const GateHHRatesInf& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.notes () == y.notes ()))
      return false;

    if (!(x.q10Settings () == y.q10Settings ()))
      return false;

    if (!(x.forwardRate () == y.forwardRate ()))
      return false;

    if (!(x.reverseRate () == y.reverseRate ()))
      return false;

    if (!(x.steadyState () == y.steadyState ()))
      return false;

    if (!(x.instances () == y.instances ()))
      return false;

    return true;
  }

  bool
  operator!= (const GateHHRatesInf& x, const GateHHRatesInf& y)
  {
    return !(x == y);
  }

  // GateHHInstantaneous
  //

  GateHHInstantaneous::
  GateHHInstantaneous (const id_type& id,
                       const steadyState_type& steadyState,
                       const instances_type& instances)
  : ::neuroml2::Base (id),
    notes_ (this),
    steadyState_ (steadyState, this),
    instances_ (instances, this)
  {
  }

  GateHHInstantaneous::
  GateHHInstantaneous (const id_type& id,
                       ::std::unique_ptr< steadyState_type > steadyState,
                       const instances_type& instances)
  : ::neuroml2::Base (id),
    notes_ (this),
    steadyState_ (std::move (steadyState), this),
    instances_ (instances, this)
  {
  }

  GateHHInstantaneous::
  GateHHInstantaneous (const GateHHInstantaneous& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    notes_ (x.notes_, f, this),
    steadyState_ (x.steadyState_, f, this),
    instances_ (x.instances_, f, this)
  {
  }

  GateHHInstantaneous::
  GateHHInstantaneous (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    notes_ (this),
    steadyState_ (this),
    instances_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GateHHInstantaneous::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // notes
      //
      if (n.name () == "notes" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< notes_type > r (
          notes_traits::create (i, f, this));

        if (!this->notes_)
        {
          this->notes_.set (::std::move (r));
          continue;
        }
      }

      // steadyState
      //
      if (n.name () == "steadyState" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< steadyState_type > r (
          steadyState_traits::create (i, f, this));

        if (!steadyState_.present ())
        {
          this->steadyState_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!steadyState_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "steadyState",
        "http://www.neuroml.org/schema/neuroml2");
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "instances" && n.namespace_ ().empty ())
      {
        this->instances_.set (instances_traits::create (i, f, this));
        continue;
      }
    }

    if (!instances_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "instances",
        "");
    }
  }

  GateHHInstantaneous* GateHHInstantaneous::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class GateHHInstantaneous (*this, f, c);
  }

  GateHHInstantaneous& GateHHInstantaneous::
  operator= (const GateHHInstantaneous& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->notes_ = x.notes_;
      this->steadyState_ = x.steadyState_;
      this->instances_ = x.instances_;
    }

    return *this;
  }

  GateHHInstantaneous::
  ~GateHHInstantaneous ()
  {
  }

  bool
  operator== (const GateHHInstantaneous& x, const GateHHInstantaneous& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.notes () == y.notes ()))
      return false;

    if (!(x.steadyState () == y.steadyState ()))
      return false;

    if (!(x.instances () == y.instances ()))
      return false;

    return true;
  }

  bool
  operator!= (const GateHHInstantaneous& x, const GateHHInstantaneous& y)
  {
    return !(x == y);
  }

  // GateFractional
  //

  GateFractional::
  GateFractional (const id_type& id,
                  const instances_type& instances)
  : ::neuroml2::Base (id),
    notes_ (this),
    q10Settings_ (this),
    subGate_ (this),
    instances_ (instances, this)
  {
  }

  GateFractional::
  GateFractional (const GateFractional& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    notes_ (x.notes_, f, this),
    q10Settings_ (x.q10Settings_, f, this),
    subGate_ (x.subGate_, f, this),
    instances_ (x.instances_, f, this)
  {
  }

  GateFractional::
  GateFractional (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    notes_ (this),
    q10Settings_ (this),
    subGate_ (this),
    instances_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GateFractional::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // notes
      //
      if (n.name () == "notes" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< notes_type > r (
          notes_traits::create (i, f, this));

        if (!this->notes_)
        {
          this->notes_.set (::std::move (r));
          continue;
        }
      }

      // q10Settings
      //
      if (n.name () == "q10Settings" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< q10Settings_type > r (
          q10Settings_traits::create (i, f, this));

        if (!this->q10Settings_)
        {
          this->q10Settings_.set (::std::move (r));
          continue;
        }
      }

      // subGate
      //
      if (n.name () == "subGate" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< subGate_type > r (
          subGate_traits::create (i, f, this));

        this->subGate_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "instances" && n.namespace_ ().empty ())
      {
        this->instances_.set (instances_traits::create (i, f, this));
        continue;
      }
    }

    if (!instances_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "instances",
        "");
    }
  }

  GateFractional* GateFractional::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class GateFractional (*this, f, c);
  }

  GateFractional& GateFractional::
  operator= (const GateFractional& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->notes_ = x.notes_;
      this->q10Settings_ = x.q10Settings_;
      this->subGate_ = x.subGate_;
      this->instances_ = x.instances_;
    }

    return *this;
  }

  GateFractional::
  ~GateFractional ()
  {
  }

  bool
  operator== (const GateFractional& x, const GateFractional& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.notes () == y.notes ()))
      return false;

    if (!(x.q10Settings () == y.q10Settings ()))
      return false;

    if (!(x.subGate () == y.subGate ()))
      return false;

    if (!(x.instances () == y.instances ()))
      return false;

    return true;
  }

  bool
  operator!= (const GateFractional& x, const GateFractional& y)
  {
    return !(x == y);
  }

  // GateFractionalSubgate
  //

  GateFractionalSubgate::
  GateFractionalSubgate (const id_type& id,
                         const steadyState_type& steadyState,
                         const timeCourse_type& timeCourse,
                         const fractionalConductance_type& fractionalConductance)
  : ::neuroml2::Base (id),
    notes_ (this),
    q10Settings_ (this),
    steadyState_ (steadyState, this),
    timeCourse_ (timeCourse, this),
    fractionalConductance_ (fractionalConductance, this)
  {
  }

  GateFractionalSubgate::
  GateFractionalSubgate (const id_type& id,
                         ::std::unique_ptr< steadyState_type > steadyState,
                         ::std::unique_ptr< timeCourse_type > timeCourse,
                         const fractionalConductance_type& fractionalConductance)
  : ::neuroml2::Base (id),
    notes_ (this),
    q10Settings_ (this),
    steadyState_ (std::move (steadyState), this),
    timeCourse_ (std::move (timeCourse), this),
    fractionalConductance_ (fractionalConductance, this)
  {
  }

  GateFractionalSubgate::
  GateFractionalSubgate (const GateFractionalSubgate& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    notes_ (x.notes_, f, this),
    q10Settings_ (x.q10Settings_, f, this),
    steadyState_ (x.steadyState_, f, this),
    timeCourse_ (x.timeCourse_, f, this),
    fractionalConductance_ (x.fractionalConductance_, f, this)
  {
  }

  GateFractionalSubgate::
  GateFractionalSubgate (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    notes_ (this),
    q10Settings_ (this),
    steadyState_ (this),
    timeCourse_ (this),
    fractionalConductance_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GateFractionalSubgate::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // notes
      //
      if (n.name () == "notes" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< notes_type > r (
          notes_traits::create (i, f, this));

        if (!this->notes_)
        {
          this->notes_.set (::std::move (r));
          continue;
        }
      }

      // q10Settings
      //
      if (n.name () == "q10Settings" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< q10Settings_type > r (
          q10Settings_traits::create (i, f, this));

        if (!this->q10Settings_)
        {
          this->q10Settings_.set (::std::move (r));
          continue;
        }
      }

      // steadyState
      //
      if (n.name () == "steadyState" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< steadyState_type > r (
          steadyState_traits::create (i, f, this));

        if (!steadyState_.present ())
        {
          this->steadyState_.set (::std::move (r));
          continue;
        }
      }

      // timeCourse
      //
      if (n.name () == "timeCourse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< timeCourse_type > r (
          timeCourse_traits::create (i, f, this));

        if (!timeCourse_.present ())
        {
          this->timeCourse_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!steadyState_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "steadyState",
        "http://www.neuroml.org/schema/neuroml2");
    }

    if (!timeCourse_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "timeCourse",
        "http://www.neuroml.org/schema/neuroml2");
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "fractionalConductance" && n.namespace_ ().empty ())
      {
        this->fractionalConductance_.set (fractionalConductance_traits::create (i, f, this));
        continue;
      }
    }

    if (!fractionalConductance_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "fractionalConductance",
        "");
    }
  }

  GateFractionalSubgate* GateFractionalSubgate::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class GateFractionalSubgate (*this, f, c);
  }

  GateFractionalSubgate& GateFractionalSubgate::
  operator= (const GateFractionalSubgate& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->notes_ = x.notes_;
      this->q10Settings_ = x.q10Settings_;
      this->steadyState_ = x.steadyState_;
      this->timeCourse_ = x.timeCourse_;
      this->fractionalConductance_ = x.fractionalConductance_;
    }

    return *this;
  }

  GateFractionalSubgate::
  ~GateFractionalSubgate ()
  {
  }

  bool
  operator== (const GateFractionalSubgate& x, const GateFractionalSubgate& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.notes () == y.notes ()))
      return false;

    if (!(x.q10Settings () == y.q10Settings ()))
      return false;

    if (!(x.steadyState () == y.steadyState ()))
      return false;

    if (!(x.timeCourse () == y.timeCourse ()))
      return false;

    if (!(x.fractionalConductance () == y.fractionalConductance ()))
      return false;

    return true;
  }

  bool
  operator!= (const GateFractionalSubgate& x, const GateFractionalSubgate& y)
  {
    return !(x == y);
  }

  // Q10Settings
  //

  Q10Settings::
  Q10Settings (const type_type& type)
  : ::xml_schema::type (),
    type_ (type, this),
    fixedQ10_ (this),
    q10Factor_ (this),
    experimentalTemp_ (this)
  {
  }

  Q10Settings::
  Q10Settings (const Q10Settings& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    fixedQ10_ (x.fixedQ10_, f, this),
    q10Factor_ (x.q10Factor_, f, this),
    experimentalTemp_ (x.experimentalTemp_, f, this)
  {
  }

  Q10Settings::
  Q10Settings (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    fixedQ10_ (this),
    q10Factor_ (this),
    experimentalTemp_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Q10Settings::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "fixedQ10" && n.namespace_ ().empty ())
      {
        this->fixedQ10_.set (fixedQ10_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "q10Factor" && n.namespace_ ().empty ())
      {
        this->q10Factor_.set (q10Factor_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "experimentalTemp" && n.namespace_ ().empty ())
      {
        this->experimentalTemp_.set (experimentalTemp_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  Q10Settings* Q10Settings::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Q10Settings (*this, f, c);
  }

  Q10Settings& Q10Settings::
  operator= (const Q10Settings& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->fixedQ10_ = x.fixedQ10_;
      this->q10Factor_ = x.q10Factor_;
      this->experimentalTemp_ = x.experimentalTemp_;
    }

    return *this;
  }

  Q10Settings::
  ~Q10Settings ()
  {
  }

  bool
  operator== (const Q10Settings& x, const Q10Settings& y)
  {
    if (!(x.type () == y.type ()))
      return false;

    if (!(x.fixedQ10 () == y.fixedQ10 ()))
      return false;

    if (!(x.q10Factor () == y.q10Factor ()))
      return false;

    if (!(x.experimentalTemp () == y.experimentalTemp ()))
      return false;

    return true;
  }

  bool
  operator!= (const Q10Settings& x, const Q10Settings& y)
  {
    return !(x == y);
  }

  // HHRate
  //

  HHRate::
  HHRate (const type_type& type)
  : ::xml_schema::type (),
    type_ (type, this),
    rate_ (this),
    midpoint_ (this),
    scale_ (this)
  {
  }

  HHRate::
  HHRate (const HHRate& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    rate_ (x.rate_, f, this),
    midpoint_ (x.midpoint_, f, this),
    scale_ (x.scale_, f, this)
  {
  }

  HHRate::
  HHRate (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    rate_ (this),
    midpoint_ (this),
    scale_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void HHRate::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "rate" && n.namespace_ ().empty ())
      {
        this->rate_.set (rate_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "midpoint" && n.namespace_ ().empty ())
      {
        this->midpoint_.set (midpoint_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "scale" && n.namespace_ ().empty ())
      {
        this->scale_.set (scale_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  HHRate* HHRate::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class HHRate (*this, f, c);
  }

  HHRate& HHRate::
  operator= (const HHRate& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->rate_ = x.rate_;
      this->midpoint_ = x.midpoint_;
      this->scale_ = x.scale_;
    }

    return *this;
  }

  HHRate::
  ~HHRate ()
  {
  }

  bool
  operator== (const HHRate& x, const HHRate& y)
  {
    if (!(x.type () == y.type ()))
      return false;

    if (!(x.rate () == y.rate ()))
      return false;

    if (!(x.midpoint () == y.midpoint ()))
      return false;

    if (!(x.scale () == y.scale ()))
      return false;

    return true;
  }

  bool
  operator!= (const HHRate& x, const HHRate& y)
  {
    return !(x == y);
  }

  // HHVariable
  //

  HHVariable::
  HHVariable (const type_type& type)
  : ::xml_schema::type (),
    type_ (type, this),
    rate_ (this),
    midpoint_ (this),
    scale_ (this)
  {
  }

  HHVariable::
  HHVariable (const HHVariable& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    rate_ (x.rate_, f, this),
    midpoint_ (x.midpoint_, f, this),
    scale_ (x.scale_, f, this)
  {
  }

  HHVariable::
  HHVariable (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    rate_ (this),
    midpoint_ (this),
    scale_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void HHVariable::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "rate" && n.namespace_ ().empty ())
      {
        this->rate_.set (rate_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "midpoint" && n.namespace_ ().empty ())
      {
        this->midpoint_.set (midpoint_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "scale" && n.namespace_ ().empty ())
      {
        this->scale_.set (scale_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  HHVariable* HHVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class HHVariable (*this, f, c);
  }

  HHVariable& HHVariable::
  operator= (const HHVariable& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->rate_ = x.rate_;
      this->midpoint_ = x.midpoint_;
      this->scale_ = x.scale_;
    }

    return *this;
  }

  HHVariable::
  ~HHVariable ()
  {
  }

  bool
  operator== (const HHVariable& x, const HHVariable& y)
  {
    if (!(x.type () == y.type ()))
      return false;

    if (!(x.rate () == y.rate ()))
      return false;

    if (!(x.midpoint () == y.midpoint ()))
      return false;

    if (!(x.scale () == y.scale ()))
      return false;

    return true;
  }

  bool
  operator!= (const HHVariable& x, const HHVariable& y)
  {
    return !(x == y);
  }

  // HHTime
  //

  HHTime::
  HHTime (const type_type& type)
  : ::xml_schema::type (),
    type_ (type, this),
    rate_ (this),
    midpoint_ (this),
    scale_ (this),
    tau_ (this)
  {
  }

  HHTime::
  HHTime (const HHTime& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    rate_ (x.rate_, f, this),
    midpoint_ (x.midpoint_, f, this),
    scale_ (x.scale_, f, this),
    tau_ (x.tau_, f, this)
  {
  }

  HHTime::
  HHTime (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    rate_ (this),
    midpoint_ (this),
    scale_ (this),
    tau_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void HHTime::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "rate" && n.namespace_ ().empty ())
      {
        this->rate_.set (rate_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "midpoint" && n.namespace_ ().empty ())
      {
        this->midpoint_.set (midpoint_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "scale" && n.namespace_ ().empty ())
      {
        this->scale_.set (scale_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "tau" && n.namespace_ ().empty ())
      {
        this->tau_.set (tau_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  HHTime* HHTime::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class HHTime (*this, f, c);
  }

  HHTime& HHTime::
  operator= (const HHTime& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->rate_ = x.rate_;
      this->midpoint_ = x.midpoint_;
      this->scale_ = x.scale_;
      this->tau_ = x.tau_;
    }

    return *this;
  }

  HHTime::
  ~HHTime ()
  {
  }

  bool
  operator== (const HHTime& x, const HHTime& y)
  {
    if (!(x.type () == y.type ()))
      return false;

    if (!(x.rate () == y.rate ()))
      return false;

    if (!(x.midpoint () == y.midpoint ()))
      return false;

    if (!(x.scale () == y.scale ()))
      return false;

    if (!(x.tau () == y.tau ()))
      return false;

    return true;
  }

  bool
  operator!= (const HHTime& x, const HHTime& y)
  {
    return !(x == y);
  }

  // DecayingPoolConcentrationModel
  //

  DecayingPoolConcentrationModel::
  DecayingPoolConcentrationModel (const id_type& id,
                                  const ion_type& ion,
                                  const restingConc_type& restingConc,
                                  const decayConstant_type& decayConstant,
                                  const shellThickness_type& shellThickness)
  : ::neuroml2::Standalone (id),
    ion_ (ion, this),
    restingConc_ (restingConc, this),
    decayConstant_ (decayConstant, this),
    shellThickness_ (shellThickness, this)
  {
  }

  DecayingPoolConcentrationModel::
  DecayingPoolConcentrationModel (const DecayingPoolConcentrationModel& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    ion_ (x.ion_, f, this),
    restingConc_ (x.restingConc_, f, this),
    decayConstant_ (x.decayConstant_, f, this),
    shellThickness_ (x.shellThickness_, f, this)
  {
  }

  DecayingPoolConcentrationModel::
  DecayingPoolConcentrationModel (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    ion_ (this),
    restingConc_ (this),
    decayConstant_ (this),
    shellThickness_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DecayingPoolConcentrationModel::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ion" && n.namespace_ ().empty ())
      {
        this->ion_.set (ion_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "restingConc" && n.namespace_ ().empty ())
      {
        this->restingConc_.set (restingConc_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "decayConstant" && n.namespace_ ().empty ())
      {
        this->decayConstant_.set (decayConstant_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "shellThickness" && n.namespace_ ().empty ())
      {
        this->shellThickness_.set (shellThickness_traits::create (i, f, this));
        continue;
      }
    }

    if (!ion_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ion",
        "");
    }

    if (!restingConc_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "restingConc",
        "");
    }

    if (!decayConstant_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "decayConstant",
        "");
    }

    if (!shellThickness_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "shellThickness",
        "");
    }
  }

  DecayingPoolConcentrationModel* DecayingPoolConcentrationModel::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DecayingPoolConcentrationModel (*this, f, c);
  }

  DecayingPoolConcentrationModel& DecayingPoolConcentrationModel::
  operator= (const DecayingPoolConcentrationModel& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->ion_ = x.ion_;
      this->restingConc_ = x.restingConc_;
      this->decayConstant_ = x.decayConstant_;
      this->shellThickness_ = x.shellThickness_;
    }

    return *this;
  }

  DecayingPoolConcentrationModel::
  ~DecayingPoolConcentrationModel ()
  {
  }

  bool
  operator== (const DecayingPoolConcentrationModel& x, const DecayingPoolConcentrationModel& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.ion () == y.ion ()))
      return false;

    if (!(x.restingConc () == y.restingConc ()))
      return false;

    if (!(x.decayConstant () == y.decayConstant ()))
      return false;

    if (!(x.shellThickness () == y.shellThickness ()))
      return false;

    return true;
  }

  bool
  operator!= (const DecayingPoolConcentrationModel& x, const DecayingPoolConcentrationModel& y)
  {
    return !(x == y);
  }

  // FixedFactorConcentrationModel
  //

  FixedFactorConcentrationModel::
  FixedFactorConcentrationModel (const id_type& id,
                                 const ion_type& ion,
                                 const restingConc_type& restingConc,
                                 const decayConstant_type& decayConstant,
                                 const rho_type& rho)
  : ::neuroml2::Standalone (id),
    ion_ (ion, this),
    restingConc_ (restingConc, this),
    decayConstant_ (decayConstant, this),
    rho_ (rho, this)
  {
  }

  FixedFactorConcentrationModel::
  FixedFactorConcentrationModel (const FixedFactorConcentrationModel& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    ion_ (x.ion_, f, this),
    restingConc_ (x.restingConc_, f, this),
    decayConstant_ (x.decayConstant_, f, this),
    rho_ (x.rho_, f, this)
  {
  }

  FixedFactorConcentrationModel::
  FixedFactorConcentrationModel (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    ion_ (this),
    restingConc_ (this),
    decayConstant_ (this),
    rho_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void FixedFactorConcentrationModel::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ion" && n.namespace_ ().empty ())
      {
        this->ion_.set (ion_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "restingConc" && n.namespace_ ().empty ())
      {
        this->restingConc_.set (restingConc_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "decayConstant" && n.namespace_ ().empty ())
      {
        this->decayConstant_.set (decayConstant_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "rho" && n.namespace_ ().empty ())
      {
        this->rho_.set (rho_traits::create (i, f, this));
        continue;
      }
    }

    if (!ion_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ion",
        "");
    }

    if (!restingConc_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "restingConc",
        "");
    }

    if (!decayConstant_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "decayConstant",
        "");
    }

    if (!rho_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "rho",
        "");
    }
  }

  FixedFactorConcentrationModel* FixedFactorConcentrationModel::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FixedFactorConcentrationModel (*this, f, c);
  }

  FixedFactorConcentrationModel& FixedFactorConcentrationModel::
  operator= (const FixedFactorConcentrationModel& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->ion_ = x.ion_;
      this->restingConc_ = x.restingConc_;
      this->decayConstant_ = x.decayConstant_;
      this->rho_ = x.rho_;
    }

    return *this;
  }

  FixedFactorConcentrationModel::
  ~FixedFactorConcentrationModel ()
  {
  }

  bool
  operator== (const FixedFactorConcentrationModel& x, const FixedFactorConcentrationModel& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.ion () == y.ion ()))
      return false;

    if (!(x.restingConc () == y.restingConc ()))
      return false;

    if (!(x.decayConstant () == y.decayConstant ()))
      return false;

    if (!(x.rho () == y.rho ()))
      return false;

    return true;
  }

  bool
  operator!= (const FixedFactorConcentrationModel& x, const FixedFactorConcentrationModel& y)
  {
    return !(x == y);
  }

  // BaseSynapse
  //

  BaseSynapse::
  BaseSynapse (const id_type& id)
  : ::neuroml2::Standalone (id)
  {
  }

  BaseSynapse::
  BaseSynapse (const BaseSynapse& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c)
  {
  }

  BaseSynapse::
  BaseSynapse (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f, c)
  {
  }

  BaseSynapse* BaseSynapse::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BaseSynapse (*this, f, c);
  }

  BaseSynapse::
  ~BaseSynapse ()
  {
  }

  // BaseVoltageDepSynapse
  //

  BaseVoltageDepSynapse::
  BaseVoltageDepSynapse (const id_type& id)
  : ::neuroml2::BaseSynapse (id)
  {
  }

  BaseVoltageDepSynapse::
  BaseVoltageDepSynapse (const BaseVoltageDepSynapse& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::neuroml2::BaseSynapse (x, f, c)
  {
  }

  BaseVoltageDepSynapse::
  BaseVoltageDepSynapse (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::neuroml2::BaseSynapse (e, f, c)
  {
  }

  BaseVoltageDepSynapse* BaseVoltageDepSynapse::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BaseVoltageDepSynapse (*this, f, c);
  }

  BaseVoltageDepSynapse::
  ~BaseVoltageDepSynapse ()
  {
  }

  // BaseCurrentBasedSynapse
  //

  BaseCurrentBasedSynapse::
  BaseCurrentBasedSynapse (const id_type& id)
  : ::neuroml2::BaseSynapse (id)
  {
  }

  BaseCurrentBasedSynapse::
  BaseCurrentBasedSynapse (const BaseCurrentBasedSynapse& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::neuroml2::BaseSynapse (x, f, c)
  {
  }

  BaseCurrentBasedSynapse::
  BaseCurrentBasedSynapse (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::neuroml2::BaseSynapse (e, f, c)
  {
  }

  BaseCurrentBasedSynapse* BaseCurrentBasedSynapse::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BaseCurrentBasedSynapse (*this, f, c);
  }

  BaseCurrentBasedSynapse::
  ~BaseCurrentBasedSynapse ()
  {
  }

  // BaseConductanceBasedSynapse
  //

  BaseConductanceBasedSynapse::
  BaseConductanceBasedSynapse (const id_type& id,
                               const gbase_type& gbase,
                               const erev_type& erev)
  : ::neuroml2::BaseVoltageDepSynapse (id),
    gbase_ (gbase, this),
    erev_ (erev, this)
  {
  }

  BaseConductanceBasedSynapse::
  BaseConductanceBasedSynapse (const BaseConductanceBasedSynapse& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::neuroml2::BaseVoltageDepSynapse (x, f, c),
    gbase_ (x.gbase_, f, this),
    erev_ (x.erev_, f, this)
  {
  }

  BaseConductanceBasedSynapse::
  BaseConductanceBasedSynapse (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::neuroml2::BaseVoltageDepSynapse (e, f | ::xml_schema::flags::base, c),
    gbase_ (this),
    erev_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void BaseConductanceBasedSynapse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseVoltageDepSynapse::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "gbase" && n.namespace_ ().empty ())
      {
        this->gbase_.set (gbase_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "erev" && n.namespace_ ().empty ())
      {
        this->erev_.set (erev_traits::create (i, f, this));
        continue;
      }
    }

    if (!gbase_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "gbase",
        "");
    }

    if (!erev_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "erev",
        "");
    }
  }

  BaseConductanceBasedSynapse* BaseConductanceBasedSynapse::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BaseConductanceBasedSynapse (*this, f, c);
  }

  BaseConductanceBasedSynapse& BaseConductanceBasedSynapse::
  operator= (const BaseConductanceBasedSynapse& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseVoltageDepSynapse& > (*this) = x;
      this->gbase_ = x.gbase_;
      this->erev_ = x.erev_;
    }

    return *this;
  }

  BaseConductanceBasedSynapse::
  ~BaseConductanceBasedSynapse ()
  {
  }

  bool
  operator== (const BaseConductanceBasedSynapse& x, const BaseConductanceBasedSynapse& y)
  {
    if (!(static_cast< const ::neuroml2::BaseVoltageDepSynapse& > (x) ==
          static_cast< const ::neuroml2::BaseVoltageDepSynapse& > (y)))
      return false;

    if (!(x.gbase () == y.gbase ()))
      return false;

    if (!(x.erev () == y.erev ()))
      return false;

    return true;
  }

  bool
  operator!= (const BaseConductanceBasedSynapse& x, const BaseConductanceBasedSynapse& y)
  {
    return !(x == y);
  }

  // BaseConductanceBasedSynapseTwo
  //

  BaseConductanceBasedSynapseTwo::
  BaseConductanceBasedSynapseTwo (const id_type& id,
                                  const gbase1_type& gbase1,
                                  const gbase2_type& gbase2,
                                  const erev_type& erev)
  : ::neuroml2::BaseVoltageDepSynapse (id),
    gbase1_ (gbase1, this),
    gbase2_ (gbase2, this),
    erev_ (erev, this)
  {
  }

  BaseConductanceBasedSynapseTwo::
  BaseConductanceBasedSynapseTwo (const BaseConductanceBasedSynapseTwo& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::neuroml2::BaseVoltageDepSynapse (x, f, c),
    gbase1_ (x.gbase1_, f, this),
    gbase2_ (x.gbase2_, f, this),
    erev_ (x.erev_, f, this)
  {
  }

  BaseConductanceBasedSynapseTwo::
  BaseConductanceBasedSynapseTwo (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::neuroml2::BaseVoltageDepSynapse (e, f | ::xml_schema::flags::base, c),
    gbase1_ (this),
    gbase2_ (this),
    erev_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void BaseConductanceBasedSynapseTwo::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseVoltageDepSynapse::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "gbase1" && n.namespace_ ().empty ())
      {
        this->gbase1_.set (gbase1_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "gbase2" && n.namespace_ ().empty ())
      {
        this->gbase2_.set (gbase2_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "erev" && n.namespace_ ().empty ())
      {
        this->erev_.set (erev_traits::create (i, f, this));
        continue;
      }
    }

    if (!gbase1_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "gbase1",
        "");
    }

    if (!gbase2_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "gbase2",
        "");
    }

    if (!erev_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "erev",
        "");
    }
  }

  BaseConductanceBasedSynapseTwo* BaseConductanceBasedSynapseTwo::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BaseConductanceBasedSynapseTwo (*this, f, c);
  }

  BaseConductanceBasedSynapseTwo& BaseConductanceBasedSynapseTwo::
  operator= (const BaseConductanceBasedSynapseTwo& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseVoltageDepSynapse& > (*this) = x;
      this->gbase1_ = x.gbase1_;
      this->gbase2_ = x.gbase2_;
      this->erev_ = x.erev_;
    }

    return *this;
  }

  BaseConductanceBasedSynapseTwo::
  ~BaseConductanceBasedSynapseTwo ()
  {
  }

  bool
  operator== (const BaseConductanceBasedSynapseTwo& x, const BaseConductanceBasedSynapseTwo& y)
  {
    if (!(static_cast< const ::neuroml2::BaseVoltageDepSynapse& > (x) ==
          static_cast< const ::neuroml2::BaseVoltageDepSynapse& > (y)))
      return false;

    if (!(x.gbase1 () == y.gbase1 ()))
      return false;

    if (!(x.gbase2 () == y.gbase2 ()))
      return false;

    if (!(x.erev () == y.erev ()))
      return false;

    return true;
  }

  bool
  operator!= (const BaseConductanceBasedSynapseTwo& x, const BaseConductanceBasedSynapseTwo& y)
  {
    return !(x == y);
  }

  // GapJunction
  //

  GapJunction::
  GapJunction (const id_type& id,
               const conductance_type& conductance)
  : ::neuroml2::BaseSynapse (id),
    conductance_ (conductance, this)
  {
  }

  GapJunction::
  GapJunction (const GapJunction& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::neuroml2::BaseSynapse (x, f, c),
    conductance_ (x.conductance_, f, this)
  {
  }

  GapJunction::
  GapJunction (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::neuroml2::BaseSynapse (e, f | ::xml_schema::flags::base, c),
    conductance_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GapJunction::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseSynapse::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "conductance" && n.namespace_ ().empty ())
      {
        this->conductance_.set (conductance_traits::create (i, f, this));
        continue;
      }
    }

    if (!conductance_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "conductance",
        "");
    }
  }

  GapJunction* GapJunction::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class GapJunction (*this, f, c);
  }

  GapJunction& GapJunction::
  operator= (const GapJunction& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseSynapse& > (*this) = x;
      this->conductance_ = x.conductance_;
    }

    return *this;
  }

  GapJunction::
  ~GapJunction ()
  {
  }

  bool
  operator== (const GapJunction& x, const GapJunction& y)
  {
    if (!(static_cast< const ::neuroml2::BaseSynapse& > (x) ==
          static_cast< const ::neuroml2::BaseSynapse& > (y)))
      return false;

    if (!(x.conductance () == y.conductance ()))
      return false;

    return true;
  }

  bool
  operator!= (const GapJunction& x, const GapJunction& y)
  {
    return !(x == y);
  }

  // SilentSynapse
  //

  SilentSynapse::
  SilentSynapse (const id_type& id)
  : ::neuroml2::BaseSynapse (id)
  {
  }

  SilentSynapse::
  SilentSynapse (const SilentSynapse& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::BaseSynapse (x, f, c)
  {
  }

  SilentSynapse::
  SilentSynapse (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::BaseSynapse (e, f, c)
  {
  }

  SilentSynapse* SilentSynapse::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SilentSynapse (*this, f, c);
  }

  SilentSynapse::
  ~SilentSynapse ()
  {
  }

  // LinearGradedSynapse
  //

  LinearGradedSynapse::
  LinearGradedSynapse (const id_type& id,
                       const conductance_type& conductance)
  : ::neuroml2::BaseSynapse (id),
    conductance_ (conductance, this)
  {
  }

  LinearGradedSynapse::
  LinearGradedSynapse (const LinearGradedSynapse& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::neuroml2::BaseSynapse (x, f, c),
    conductance_ (x.conductance_, f, this)
  {
  }

  LinearGradedSynapse::
  LinearGradedSynapse (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::neuroml2::BaseSynapse (e, f | ::xml_schema::flags::base, c),
    conductance_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void LinearGradedSynapse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseSynapse::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "conductance" && n.namespace_ ().empty ())
      {
        this->conductance_.set (conductance_traits::create (i, f, this));
        continue;
      }
    }

    if (!conductance_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "conductance",
        "");
    }
  }

  LinearGradedSynapse* LinearGradedSynapse::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LinearGradedSynapse (*this, f, c);
  }

  LinearGradedSynapse& LinearGradedSynapse::
  operator= (const LinearGradedSynapse& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseSynapse& > (*this) = x;
      this->conductance_ = x.conductance_;
    }

    return *this;
  }

  LinearGradedSynapse::
  ~LinearGradedSynapse ()
  {
  }

  bool
  operator== (const LinearGradedSynapse& x, const LinearGradedSynapse& y)
  {
    if (!(static_cast< const ::neuroml2::BaseSynapse& > (x) ==
          static_cast< const ::neuroml2::BaseSynapse& > (y)))
      return false;

    if (!(x.conductance () == y.conductance ()))
      return false;

    return true;
  }

  bool
  operator!= (const LinearGradedSynapse& x, const LinearGradedSynapse& y)
  {
    return !(x == y);
  }

  // GradedSynapse
  //

  GradedSynapse::
  GradedSynapse (const id_type& id,
                 const conductance_type& conductance,
                 const delta_type& delta,
                 const Vth_type& Vth,
                 const k_type& k,
                 const erev_type& erev)
  : ::neuroml2::BaseSynapse (id),
    conductance_ (conductance, this),
    delta_ (delta, this),
    Vth_ (Vth, this),
    k_ (k, this),
    erev_ (erev, this)
  {
  }

  GradedSynapse::
  GradedSynapse (const GradedSynapse& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::BaseSynapse (x, f, c),
    conductance_ (x.conductance_, f, this),
    delta_ (x.delta_, f, this),
    Vth_ (x.Vth_, f, this),
    k_ (x.k_, f, this),
    erev_ (x.erev_, f, this)
  {
  }

  GradedSynapse::
  GradedSynapse (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::BaseSynapse (e, f | ::xml_schema::flags::base, c),
    conductance_ (this),
    delta_ (this),
    Vth_ (this),
    k_ (this),
    erev_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GradedSynapse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseSynapse::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "conductance" && n.namespace_ ().empty ())
      {
        this->conductance_.set (conductance_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "delta" && n.namespace_ ().empty ())
      {
        this->delta_.set (delta_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Vth" && n.namespace_ ().empty ())
      {
        this->Vth_.set (Vth_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "k" && n.namespace_ ().empty ())
      {
        this->k_.set (k_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "erev" && n.namespace_ ().empty ())
      {
        this->erev_.set (erev_traits::create (i, f, this));
        continue;
      }
    }

    if (!conductance_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "conductance",
        "");
    }

    if (!delta_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "delta",
        "");
    }

    if (!Vth_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Vth",
        "");
    }

    if (!k_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "k",
        "");
    }

    if (!erev_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "erev",
        "");
    }
  }

  GradedSynapse* GradedSynapse::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class GradedSynapse (*this, f, c);
  }

  GradedSynapse& GradedSynapse::
  operator= (const GradedSynapse& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseSynapse& > (*this) = x;
      this->conductance_ = x.conductance_;
      this->delta_ = x.delta_;
      this->Vth_ = x.Vth_;
      this->k_ = x.k_;
      this->erev_ = x.erev_;
    }

    return *this;
  }

  GradedSynapse::
  ~GradedSynapse ()
  {
  }

  bool
  operator== (const GradedSynapse& x, const GradedSynapse& y)
  {
    if (!(static_cast< const ::neuroml2::BaseSynapse& > (x) ==
          static_cast< const ::neuroml2::BaseSynapse& > (y)))
      return false;

    if (!(x.conductance () == y.conductance ()))
      return false;

    if (!(x.delta () == y.delta ()))
      return false;

    if (!(x.Vth () == y.Vth ()))
      return false;

    if (!(x.k () == y.k ()))
      return false;

    if (!(x.erev () == y.erev ()))
      return false;

    return true;
  }

  bool
  operator!= (const GradedSynapse& x, const GradedSynapse& y)
  {
    return !(x == y);
  }

  // AlphaCurrentSynapse
  //

  AlphaCurrentSynapse::
  AlphaCurrentSynapse (const id_type& id,
                       const tau_type& tau,
                       const ibase_type& ibase)
  : ::neuroml2::BaseCurrentBasedSynapse (id),
    tau_ (tau, this),
    ibase_ (ibase, this)
  {
  }

  AlphaCurrentSynapse::
  AlphaCurrentSynapse (const AlphaCurrentSynapse& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::neuroml2::BaseCurrentBasedSynapse (x, f, c),
    tau_ (x.tau_, f, this),
    ibase_ (x.ibase_, f, this)
  {
  }

  AlphaCurrentSynapse::
  AlphaCurrentSynapse (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::neuroml2::BaseCurrentBasedSynapse (e, f | ::xml_schema::flags::base, c),
    tau_ (this),
    ibase_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AlphaCurrentSynapse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseCurrentBasedSynapse::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "tau" && n.namespace_ ().empty ())
      {
        this->tau_.set (tau_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ibase" && n.namespace_ ().empty ())
      {
        this->ibase_.set (ibase_traits::create (i, f, this));
        continue;
      }
    }

    if (!tau_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "tau",
        "");
    }

    if (!ibase_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ibase",
        "");
    }
  }

  AlphaCurrentSynapse* AlphaCurrentSynapse::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AlphaCurrentSynapse (*this, f, c);
  }

  AlphaCurrentSynapse& AlphaCurrentSynapse::
  operator= (const AlphaCurrentSynapse& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseCurrentBasedSynapse& > (*this) = x;
      this->tau_ = x.tau_;
      this->ibase_ = x.ibase_;
    }

    return *this;
  }

  AlphaCurrentSynapse::
  ~AlphaCurrentSynapse ()
  {
  }

  bool
  operator== (const AlphaCurrentSynapse& x, const AlphaCurrentSynapse& y)
  {
    if (!(static_cast< const ::neuroml2::BaseCurrentBasedSynapse& > (x) ==
          static_cast< const ::neuroml2::BaseCurrentBasedSynapse& > (y)))
      return false;

    if (!(x.tau () == y.tau ()))
      return false;

    if (!(x.ibase () == y.ibase ()))
      return false;

    return true;
  }

  bool
  operator!= (const AlphaCurrentSynapse& x, const AlphaCurrentSynapse& y)
  {
    return !(x == y);
  }

  // AlphaSynapse
  //

  AlphaSynapse::
  AlphaSynapse (const id_type& id,
                const gbase_type& gbase,
                const erev_type& erev,
                const tau_type& tau)
  : ::neuroml2::BaseConductanceBasedSynapse (id,
                                             gbase,
                                             erev),
    tau_ (tau, this)
  {
  }

  AlphaSynapse::
  AlphaSynapse (const AlphaSynapse& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::neuroml2::BaseConductanceBasedSynapse (x, f, c),
    tau_ (x.tau_, f, this)
  {
  }

  AlphaSynapse::
  AlphaSynapse (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::neuroml2::BaseConductanceBasedSynapse (e, f | ::xml_schema::flags::base, c),
    tau_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AlphaSynapse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseConductanceBasedSynapse::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "tau" && n.namespace_ ().empty ())
      {
        this->tau_.set (tau_traits::create (i, f, this));
        continue;
      }
    }

    if (!tau_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "tau",
        "");
    }
  }

  AlphaSynapse* AlphaSynapse::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AlphaSynapse (*this, f, c);
  }

  AlphaSynapse& AlphaSynapse::
  operator= (const AlphaSynapse& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseConductanceBasedSynapse& > (*this) = x;
      this->tau_ = x.tau_;
    }

    return *this;
  }

  AlphaSynapse::
  ~AlphaSynapse ()
  {
  }

  bool
  operator== (const AlphaSynapse& x, const AlphaSynapse& y)
  {
    if (!(static_cast< const ::neuroml2::BaseConductanceBasedSynapse& > (x) ==
          static_cast< const ::neuroml2::BaseConductanceBasedSynapse& > (y)))
      return false;

    if (!(x.tau () == y.tau ()))
      return false;

    return true;
  }

  bool
  operator!= (const AlphaSynapse& x, const AlphaSynapse& y)
  {
    return !(x == y);
  }

  // ExpOneSynapse
  //

  ExpOneSynapse::
  ExpOneSynapse (const id_type& id,
                 const gbase_type& gbase,
                 const erev_type& erev,
                 const tauDecay_type& tauDecay)
  : ::neuroml2::BaseConductanceBasedSynapse (id,
                                             gbase,
                                             erev),
    tauDecay_ (tauDecay, this)
  {
  }

  ExpOneSynapse::
  ExpOneSynapse (const ExpOneSynapse& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::BaseConductanceBasedSynapse (x, f, c),
    tauDecay_ (x.tauDecay_, f, this)
  {
  }

  ExpOneSynapse::
  ExpOneSynapse (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::BaseConductanceBasedSynapse (e, f | ::xml_schema::flags::base, c),
    tauDecay_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ExpOneSynapse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseConductanceBasedSynapse::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "tauDecay" && n.namespace_ ().empty ())
      {
        this->tauDecay_.set (tauDecay_traits::create (i, f, this));
        continue;
      }
    }

    if (!tauDecay_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "tauDecay",
        "");
    }
  }

  ExpOneSynapse* ExpOneSynapse::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ExpOneSynapse (*this, f, c);
  }

  ExpOneSynapse& ExpOneSynapse::
  operator= (const ExpOneSynapse& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseConductanceBasedSynapse& > (*this) = x;
      this->tauDecay_ = x.tauDecay_;
    }

    return *this;
  }

  ExpOneSynapse::
  ~ExpOneSynapse ()
  {
  }

  bool
  operator== (const ExpOneSynapse& x, const ExpOneSynapse& y)
  {
    if (!(static_cast< const ::neuroml2::BaseConductanceBasedSynapse& > (x) ==
          static_cast< const ::neuroml2::BaseConductanceBasedSynapse& > (y)))
      return false;

    if (!(x.tauDecay () == y.tauDecay ()))
      return false;

    return true;
  }

  bool
  operator!= (const ExpOneSynapse& x, const ExpOneSynapse& y)
  {
    return !(x == y);
  }

  // ExpTwoSynapse
  //

  ExpTwoSynapse::
  ExpTwoSynapse (const id_type& id,
                 const gbase_type& gbase,
                 const erev_type& erev,
                 const tauDecay_type& tauDecay,
                 const tauRise_type& tauRise)
  : ::neuroml2::BaseConductanceBasedSynapse (id,
                                             gbase,
                                             erev),
    tauDecay_ (tauDecay, this),
    tauRise_ (tauRise, this)
  {
  }

  ExpTwoSynapse::
  ExpTwoSynapse (const ExpTwoSynapse& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::BaseConductanceBasedSynapse (x, f, c),
    tauDecay_ (x.tauDecay_, f, this),
    tauRise_ (x.tauRise_, f, this)
  {
  }

  ExpTwoSynapse::
  ExpTwoSynapse (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::BaseConductanceBasedSynapse (e, f | ::xml_schema::flags::base, c),
    tauDecay_ (this),
    tauRise_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ExpTwoSynapse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseConductanceBasedSynapse::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "tauDecay" && n.namespace_ ().empty ())
      {
        this->tauDecay_.set (tauDecay_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "tauRise" && n.namespace_ ().empty ())
      {
        this->tauRise_.set (tauRise_traits::create (i, f, this));
        continue;
      }
    }

    if (!tauDecay_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "tauDecay",
        "");
    }

    if (!tauRise_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "tauRise",
        "");
    }
  }

  ExpTwoSynapse* ExpTwoSynapse::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ExpTwoSynapse (*this, f, c);
  }

  ExpTwoSynapse& ExpTwoSynapse::
  operator= (const ExpTwoSynapse& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseConductanceBasedSynapse& > (*this) = x;
      this->tauDecay_ = x.tauDecay_;
      this->tauRise_ = x.tauRise_;
    }

    return *this;
  }

  ExpTwoSynapse::
  ~ExpTwoSynapse ()
  {
  }

  bool
  operator== (const ExpTwoSynapse& x, const ExpTwoSynapse& y)
  {
    if (!(static_cast< const ::neuroml2::BaseConductanceBasedSynapse& > (x) ==
          static_cast< const ::neuroml2::BaseConductanceBasedSynapse& > (y)))
      return false;

    if (!(x.tauDecay () == y.tauDecay ()))
      return false;

    if (!(x.tauRise () == y.tauRise ()))
      return false;

    return true;
  }

  bool
  operator!= (const ExpTwoSynapse& x, const ExpTwoSynapse& y)
  {
    return !(x == y);
  }

  // ExpThreeSynapse
  //

  ExpThreeSynapse::
  ExpThreeSynapse (const id_type& id,
                   const gbase1_type& gbase1,
                   const gbase2_type& gbase2,
                   const erev_type& erev,
                   const tauDecay1_type& tauDecay1,
                   const tauDecay2_type& tauDecay2,
                   const tauRise_type& tauRise)
  : ::neuroml2::BaseConductanceBasedSynapseTwo (id,
                                                gbase1,
                                                gbase2,
                                                erev),
    tauDecay1_ (tauDecay1, this),
    tauDecay2_ (tauDecay2, this),
    tauRise_ (tauRise, this)
  {
  }

  ExpThreeSynapse::
  ExpThreeSynapse (const ExpThreeSynapse& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::neuroml2::BaseConductanceBasedSynapseTwo (x, f, c),
    tauDecay1_ (x.tauDecay1_, f, this),
    tauDecay2_ (x.tauDecay2_, f, this),
    tauRise_ (x.tauRise_, f, this)
  {
  }

  ExpThreeSynapse::
  ExpThreeSynapse (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::neuroml2::BaseConductanceBasedSynapseTwo (e, f | ::xml_schema::flags::base, c),
    tauDecay1_ (this),
    tauDecay2_ (this),
    tauRise_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ExpThreeSynapse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseConductanceBasedSynapseTwo::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "tauDecay1" && n.namespace_ ().empty ())
      {
        this->tauDecay1_.set (tauDecay1_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "tauDecay2" && n.namespace_ ().empty ())
      {
        this->tauDecay2_.set (tauDecay2_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "tauRise" && n.namespace_ ().empty ())
      {
        this->tauRise_.set (tauRise_traits::create (i, f, this));
        continue;
      }
    }

    if (!tauDecay1_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "tauDecay1",
        "");
    }

    if (!tauDecay2_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "tauDecay2",
        "");
    }

    if (!tauRise_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "tauRise",
        "");
    }
  }

  ExpThreeSynapse* ExpThreeSynapse::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ExpThreeSynapse (*this, f, c);
  }

  ExpThreeSynapse& ExpThreeSynapse::
  operator= (const ExpThreeSynapse& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseConductanceBasedSynapseTwo& > (*this) = x;
      this->tauDecay1_ = x.tauDecay1_;
      this->tauDecay2_ = x.tauDecay2_;
      this->tauRise_ = x.tauRise_;
    }

    return *this;
  }

  ExpThreeSynapse::
  ~ExpThreeSynapse ()
  {
  }

  bool
  operator== (const ExpThreeSynapse& x, const ExpThreeSynapse& y)
  {
    if (!(static_cast< const ::neuroml2::BaseConductanceBasedSynapseTwo& > (x) ==
          static_cast< const ::neuroml2::BaseConductanceBasedSynapseTwo& > (y)))
      return false;

    if (!(x.tauDecay1 () == y.tauDecay1 ()))
      return false;

    if (!(x.tauDecay2 () == y.tauDecay2 ()))
      return false;

    if (!(x.tauRise () == y.tauRise ()))
      return false;

    return true;
  }

  bool
  operator!= (const ExpThreeSynapse& x, const ExpThreeSynapse& y)
  {
    return !(x == y);
  }

  // DoubleSynapse
  //

  DoubleSynapse::
  DoubleSynapse (const id_type& id,
                 const synapse1_type& synapse1,
                 const synapse2_type& synapse2,
                 const synapse1Path_type& synapse1Path,
                 const synapse2Path_type& synapse2Path)
  : ::neuroml2::BaseVoltageDepSynapse (id),
    synapse1_ (synapse1, this),
    synapse2_ (synapse2, this),
    synapse1Path_ (synapse1Path, this),
    synapse2Path_ (synapse2Path, this)
  {
  }

  DoubleSynapse::
  DoubleSynapse (const DoubleSynapse& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::BaseVoltageDepSynapse (x, f, c),
    synapse1_ (x.synapse1_, f, this),
    synapse2_ (x.synapse2_, f, this),
    synapse1Path_ (x.synapse1Path_, f, this),
    synapse2Path_ (x.synapse2Path_, f, this)
  {
  }

  DoubleSynapse::
  DoubleSynapse (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::BaseVoltageDepSynapse (e, f | ::xml_schema::flags::base, c),
    synapse1_ (this),
    synapse2_ (this),
    synapse1Path_ (this),
    synapse2Path_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DoubleSynapse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseVoltageDepSynapse::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "synapse1" && n.namespace_ ().empty ())
      {
        this->synapse1_.set (synapse1_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "synapse2" && n.namespace_ ().empty ())
      {
        this->synapse2_.set (synapse2_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "synapse1Path" && n.namespace_ ().empty ())
      {
        this->synapse1Path_.set (synapse1Path_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "synapse2Path" && n.namespace_ ().empty ())
      {
        this->synapse2Path_.set (synapse2Path_traits::create (i, f, this));
        continue;
      }
    }

    if (!synapse1_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "synapse1",
        "");
    }

    if (!synapse2_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "synapse2",
        "");
    }

    if (!synapse1Path_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "synapse1Path",
        "");
    }

    if (!synapse2Path_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "synapse2Path",
        "");
    }
  }

  DoubleSynapse* DoubleSynapse::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DoubleSynapse (*this, f, c);
  }

  DoubleSynapse& DoubleSynapse::
  operator= (const DoubleSynapse& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseVoltageDepSynapse& > (*this) = x;
      this->synapse1_ = x.synapse1_;
      this->synapse2_ = x.synapse2_;
      this->synapse1Path_ = x.synapse1Path_;
      this->synapse2Path_ = x.synapse2Path_;
    }

    return *this;
  }

  DoubleSynapse::
  ~DoubleSynapse ()
  {
  }

  bool
  operator== (const DoubleSynapse& x, const DoubleSynapse& y)
  {
    if (!(static_cast< const ::neuroml2::BaseVoltageDepSynapse& > (x) ==
          static_cast< const ::neuroml2::BaseVoltageDepSynapse& > (y)))
      return false;

    if (!(x.synapse1 () == y.synapse1 ()))
      return false;

    if (!(x.synapse2 () == y.synapse2 ()))
      return false;

    if (!(x.synapse1Path () == y.synapse1Path ()))
      return false;

    if (!(x.synapse2Path () == y.synapse2Path ()))
      return false;

    return true;
  }

  bool
  operator!= (const DoubleSynapse& x, const DoubleSynapse& y)
  {
    return !(x == y);
  }

  // BlockingPlasticSynapse
  //

  BlockingPlasticSynapse::
  BlockingPlasticSynapse (const id_type& id,
                          const gbase_type& gbase,
                          const erev_type& erev,
                          const tauDecay_type& tauDecay,
                          const tauRise_type& tauRise)
  : ::neuroml2::ExpTwoSynapse (id,
                               gbase,
                               erev,
                               tauDecay,
                               tauRise),
    plasticityMechanism_ (this),
    blockMechanism_ (this)
  {
  }

  BlockingPlasticSynapse::
  BlockingPlasticSynapse (const BlockingPlasticSynapse& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::neuroml2::ExpTwoSynapse (x, f, c),
    plasticityMechanism_ (x.plasticityMechanism_, f, this),
    blockMechanism_ (x.blockMechanism_, f, this)
  {
  }

  BlockingPlasticSynapse::
  BlockingPlasticSynapse (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::neuroml2::ExpTwoSynapse (e, f | ::xml_schema::flags::base, c),
    plasticityMechanism_ (this),
    blockMechanism_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void BlockingPlasticSynapse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::ExpTwoSynapse::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // plasticityMechanism
      //
      if (n.name () == "plasticityMechanism" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< plasticityMechanism_type > r (
          plasticityMechanism_traits::create (i, f, this));

        if (!this->plasticityMechanism_)
        {
          this->plasticityMechanism_.set (::std::move (r));
          continue;
        }
      }

      // blockMechanism
      //
      if (n.name () == "blockMechanism" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< blockMechanism_type > r (
          blockMechanism_traits::create (i, f, this));

        if (!this->blockMechanism_)
        {
          this->blockMechanism_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  BlockingPlasticSynapse* BlockingPlasticSynapse::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BlockingPlasticSynapse (*this, f, c);
  }

  BlockingPlasticSynapse& BlockingPlasticSynapse::
  operator= (const BlockingPlasticSynapse& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::ExpTwoSynapse& > (*this) = x;
      this->plasticityMechanism_ = x.plasticityMechanism_;
      this->blockMechanism_ = x.blockMechanism_;
    }

    return *this;
  }

  BlockingPlasticSynapse::
  ~BlockingPlasticSynapse ()
  {
  }

  bool
  operator== (const BlockingPlasticSynapse& x, const BlockingPlasticSynapse& y)
  {
    if (!(static_cast< const ::neuroml2::ExpTwoSynapse& > (x) ==
          static_cast< const ::neuroml2::ExpTwoSynapse& > (y)))
      return false;

    if (!(x.plasticityMechanism () == y.plasticityMechanism ()))
      return false;

    if (!(x.blockMechanism () == y.blockMechanism ()))
      return false;

    return true;
  }

  bool
  operator!= (const BlockingPlasticSynapse& x, const BlockingPlasticSynapse& y)
  {
    return !(x == y);
  }

  // BlockTypes
  //

  BlockTypes::
  BlockTypes (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_BlockTypes_convert ();
  }

  BlockTypes::
  BlockTypes (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_BlockTypes_convert ();
  }

  BlockTypes::
  BlockTypes (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_BlockTypes_convert ();
  }

  BlockTypes* BlockTypes::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BlockTypes (*this, f, c);
  }

  BlockTypes::value BlockTypes::
  _xsd_BlockTypes_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_BlockTypes_literals_);
    const value* i (::std::lower_bound (
                      _xsd_BlockTypes_indexes_,
                      _xsd_BlockTypes_indexes_ + 1,
                      *this,
                      c));

    if (i == _xsd_BlockTypes_indexes_ + 1 || _xsd_BlockTypes_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const BlockTypes::
  _xsd_BlockTypes_literals_[1] =
  {
    "voltageConcDepBlockMechanism"
  };

  const BlockTypes::value BlockTypes::
  _xsd_BlockTypes_indexes_[1] =
  {
    ::neuroml2::BlockTypes::voltageConcDepBlockMechanism
  };

  // BlockMechanism
  //

  BlockMechanism::
  BlockMechanism (const type_type& type,
                  const species_type& species,
                  const blockConcentration_type& blockConcentration,
                  const scalingConc_type& scalingConc,
                  const scalingVolt_type& scalingVolt)
  : ::xml_schema::type (),
    type_ (type, this),
    species_ (species, this),
    blockConcentration_ (blockConcentration, this),
    scalingConc_ (scalingConc, this),
    scalingVolt_ (scalingVolt, this)
  {
  }

  BlockMechanism::
  BlockMechanism (const BlockMechanism& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    species_ (x.species_, f, this),
    blockConcentration_ (x.blockConcentration_, f, this),
    scalingConc_ (x.scalingConc_, f, this),
    scalingVolt_ (x.scalingVolt_, f, this)
  {
  }

  BlockMechanism::
  BlockMechanism (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    species_ (this),
    blockConcentration_ (this),
    scalingConc_ (this),
    scalingVolt_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void BlockMechanism::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "species" && n.namespace_ ().empty ())
      {
        this->species_.set (species_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "blockConcentration" && n.namespace_ ().empty ())
      {
        this->blockConcentration_.set (blockConcentration_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "scalingConc" && n.namespace_ ().empty ())
      {
        this->scalingConc_.set (scalingConc_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "scalingVolt" && n.namespace_ ().empty ())
      {
        this->scalingVolt_.set (scalingVolt_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!species_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "species",
        "");
    }

    if (!blockConcentration_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "blockConcentration",
        "");
    }

    if (!scalingConc_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "scalingConc",
        "");
    }

    if (!scalingVolt_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "scalingVolt",
        "");
    }
  }

  BlockMechanism* BlockMechanism::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BlockMechanism (*this, f, c);
  }

  BlockMechanism& BlockMechanism::
  operator= (const BlockMechanism& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->species_ = x.species_;
      this->blockConcentration_ = x.blockConcentration_;
      this->scalingConc_ = x.scalingConc_;
      this->scalingVolt_ = x.scalingVolt_;
    }

    return *this;
  }

  BlockMechanism::
  ~BlockMechanism ()
  {
  }

  bool
  operator== (const BlockMechanism& x, const BlockMechanism& y)
  {
    if (!(x.type () == y.type ()))
      return false;

    if (!(x.species () == y.species ()))
      return false;

    if (!(x.blockConcentration () == y.blockConcentration ()))
      return false;

    if (!(x.scalingConc () == y.scalingConc ()))
      return false;

    if (!(x.scalingVolt () == y.scalingVolt ()))
      return false;

    return true;
  }

  bool
  operator!= (const BlockMechanism& x, const BlockMechanism& y)
  {
    return !(x == y);
  }

  // PlasticityTypes
  //

  PlasticityTypes::
  PlasticityTypes (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_PlasticityTypes_convert ();
  }

  PlasticityTypes::
  PlasticityTypes (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_PlasticityTypes_convert ();
  }

  PlasticityTypes::
  PlasticityTypes (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_PlasticityTypes_convert ();
  }

  PlasticityTypes* PlasticityTypes::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PlasticityTypes (*this, f, c);
  }

  PlasticityTypes::value PlasticityTypes::
  _xsd_PlasticityTypes_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_PlasticityTypes_literals_);
    const value* i (::std::lower_bound (
                      _xsd_PlasticityTypes_indexes_,
                      _xsd_PlasticityTypes_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_PlasticityTypes_indexes_ + 2 || _xsd_PlasticityTypes_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const PlasticityTypes::
  _xsd_PlasticityTypes_literals_[2] =
  {
    "tsodyksMarkramDepMechanism",
    "tsodyksMarkramDepFacMechanism"
  };

  const PlasticityTypes::value PlasticityTypes::
  _xsd_PlasticityTypes_indexes_[2] =
  {
    ::neuroml2::PlasticityTypes::tsodyksMarkramDepFacMechanism,
    ::neuroml2::PlasticityTypes::tsodyksMarkramDepMechanism
  };

  // PlasticityMechanism
  //

  PlasticityMechanism::
  PlasticityMechanism (const type_type& type,
                       const initReleaseProb_type& initReleaseProb,
                       const tauRec_type& tauRec)
  : ::xml_schema::type (),
    type_ (type, this),
    initReleaseProb_ (initReleaseProb, this),
    tauRec_ (tauRec, this),
    tauFac_ (this)
  {
  }

  PlasticityMechanism::
  PlasticityMechanism (const PlasticityMechanism& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    initReleaseProb_ (x.initReleaseProb_, f, this),
    tauRec_ (x.tauRec_, f, this),
    tauFac_ (x.tauFac_, f, this)
  {
  }

  PlasticityMechanism::
  PlasticityMechanism (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    initReleaseProb_ (this),
    tauRec_ (this),
    tauFac_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void PlasticityMechanism::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "initReleaseProb" && n.namespace_ ().empty ())
      {
        this->initReleaseProb_.set (initReleaseProb_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "tauRec" && n.namespace_ ().empty ())
      {
        this->tauRec_.set (tauRec_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "tauFac" && n.namespace_ ().empty ())
      {
        this->tauFac_.set (tauFac_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!initReleaseProb_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "initReleaseProb",
        "");
    }

    if (!tauRec_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "tauRec",
        "");
    }
  }

  PlasticityMechanism* PlasticityMechanism::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PlasticityMechanism (*this, f, c);
  }

  PlasticityMechanism& PlasticityMechanism::
  operator= (const PlasticityMechanism& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->initReleaseProb_ = x.initReleaseProb_;
      this->tauRec_ = x.tauRec_;
      this->tauFac_ = x.tauFac_;
    }

    return *this;
  }

  PlasticityMechanism::
  ~PlasticityMechanism ()
  {
  }

  bool
  operator== (const PlasticityMechanism& x, const PlasticityMechanism& y)
  {
    if (!(x.type () == y.type ()))
      return false;

    if (!(x.initReleaseProb () == y.initReleaseProb ()))
      return false;

    if (!(x.tauRec () == y.tauRec ()))
      return false;

    if (!(x.tauFac () == y.tauFac ()))
      return false;

    return true;
  }

  bool
  operator!= (const PlasticityMechanism& x, const PlasticityMechanism& y)
  {
    return !(x == y);
  }

  // BaseCell
  //

  BaseCell::
  BaseCell (const id_type& id)
  : ::neuroml2::Standalone (id)
  {
  }

  BaseCell::
  BaseCell (const BaseCell& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c)
  {
  }

  BaseCell::
  BaseCell (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f, c)
  {
  }

  BaseCell* BaseCell::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BaseCell (*this, f, c);
  }

  BaseCell::
  ~BaseCell ()
  {
  }

  // IafTauCell
  //

  IafTauCell::
  IafTauCell (const id_type& id,
              const leakReversal_type& leakReversal,
              const thresh_type& thresh,
              const reset_type& reset,
              const tau_type& tau)
  : ::neuroml2::BaseCell (id),
    leakReversal_ (leakReversal, this),
    thresh_ (thresh, this),
    reset_ (reset, this),
    tau_ (tau, this)
  {
  }

  IafTauCell::
  IafTauCell (const IafTauCell& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::neuroml2::BaseCell (x, f, c),
    leakReversal_ (x.leakReversal_, f, this),
    thresh_ (x.thresh_, f, this),
    reset_ (x.reset_, f, this),
    tau_ (x.tau_, f, this)
  {
  }

  IafTauCell::
  IafTauCell (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::neuroml2::BaseCell (e, f | ::xml_schema::flags::base, c),
    leakReversal_ (this),
    thresh_ (this),
    reset_ (this),
    tau_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void IafTauCell::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseCell::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "leakReversal" && n.namespace_ ().empty ())
      {
        this->leakReversal_.set (leakReversal_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "thresh" && n.namespace_ ().empty ())
      {
        this->thresh_.set (thresh_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "reset" && n.namespace_ ().empty ())
      {
        this->reset_.set (reset_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "tau" && n.namespace_ ().empty ())
      {
        this->tau_.set (tau_traits::create (i, f, this));
        continue;
      }
    }

    if (!leakReversal_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "leakReversal",
        "");
    }

    if (!thresh_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "thresh",
        "");
    }

    if (!reset_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "reset",
        "");
    }

    if (!tau_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "tau",
        "");
    }
  }

  IafTauCell* IafTauCell::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IafTauCell (*this, f, c);
  }

  IafTauCell& IafTauCell::
  operator= (const IafTauCell& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseCell& > (*this) = x;
      this->leakReversal_ = x.leakReversal_;
      this->thresh_ = x.thresh_;
      this->reset_ = x.reset_;
      this->tau_ = x.tau_;
    }

    return *this;
  }

  IafTauCell::
  ~IafTauCell ()
  {
  }

  bool
  operator== (const IafTauCell& x, const IafTauCell& y)
  {
    if (!(static_cast< const ::neuroml2::BaseCell& > (x) ==
          static_cast< const ::neuroml2::BaseCell& > (y)))
      return false;

    if (!(x.leakReversal () == y.leakReversal ()))
      return false;

    if (!(x.thresh () == y.thresh ()))
      return false;

    if (!(x.reset () == y.reset ()))
      return false;

    if (!(x.tau () == y.tau ()))
      return false;

    return true;
  }

  bool
  operator!= (const IafTauCell& x, const IafTauCell& y)
  {
    return !(x == y);
  }

  // IafTauRefCell
  //

  IafTauRefCell::
  IafTauRefCell (const id_type& id,
                 const leakReversal_type& leakReversal,
                 const thresh_type& thresh,
                 const reset_type& reset,
                 const tau_type& tau,
                 const refract_type& refract)
  : ::neuroml2::IafTauCell (id,
                            leakReversal,
                            thresh,
                            reset,
                            tau),
    refract_ (refract, this)
  {
  }

  IafTauRefCell::
  IafTauRefCell (const IafTauRefCell& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::IafTauCell (x, f, c),
    refract_ (x.refract_, f, this)
  {
  }

  IafTauRefCell::
  IafTauRefCell (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::IafTauCell (e, f | ::xml_schema::flags::base, c),
    refract_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void IafTauRefCell::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::IafTauCell::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "refract" && n.namespace_ ().empty ())
      {
        this->refract_.set (refract_traits::create (i, f, this));
        continue;
      }
    }

    if (!refract_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "refract",
        "");
    }
  }

  IafTauRefCell* IafTauRefCell::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IafTauRefCell (*this, f, c);
  }

  IafTauRefCell& IafTauRefCell::
  operator= (const IafTauRefCell& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::IafTauCell& > (*this) = x;
      this->refract_ = x.refract_;
    }

    return *this;
  }

  IafTauRefCell::
  ~IafTauRefCell ()
  {
  }

  bool
  operator== (const IafTauRefCell& x, const IafTauRefCell& y)
  {
    if (!(static_cast< const ::neuroml2::IafTauCell& > (x) ==
          static_cast< const ::neuroml2::IafTauCell& > (y)))
      return false;

    if (!(x.refract () == y.refract ()))
      return false;

    return true;
  }

  bool
  operator!= (const IafTauRefCell& x, const IafTauRefCell& y)
  {
    return !(x == y);
  }

  // IafCell
  //

  IafCell::
  IafCell (const id_type& id,
           const leakReversal_type& leakReversal,
           const thresh_type& thresh,
           const reset_type& reset,
           const C_type& C,
           const leakConductance_type& leakConductance)
  : ::neuroml2::BaseCell (id),
    leakReversal_ (leakReversal, this),
    thresh_ (thresh, this),
    reset_ (reset, this),
    C_ (C, this),
    leakConductance_ (leakConductance, this)
  {
  }

  IafCell::
  IafCell (const IafCell& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::neuroml2::BaseCell (x, f, c),
    leakReversal_ (x.leakReversal_, f, this),
    thresh_ (x.thresh_, f, this),
    reset_ (x.reset_, f, this),
    C_ (x.C_, f, this),
    leakConductance_ (x.leakConductance_, f, this)
  {
  }

  IafCell::
  IafCell (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::neuroml2::BaseCell (e, f | ::xml_schema::flags::base, c),
    leakReversal_ (this),
    thresh_ (this),
    reset_ (this),
    C_ (this),
    leakConductance_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void IafCell::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseCell::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "leakReversal" && n.namespace_ ().empty ())
      {
        this->leakReversal_.set (leakReversal_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "thresh" && n.namespace_ ().empty ())
      {
        this->thresh_.set (thresh_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "reset" && n.namespace_ ().empty ())
      {
        this->reset_.set (reset_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "C" && n.namespace_ ().empty ())
      {
        this->C_.set (C_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "leakConductance" && n.namespace_ ().empty ())
      {
        this->leakConductance_.set (leakConductance_traits::create (i, f, this));
        continue;
      }
    }

    if (!leakReversal_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "leakReversal",
        "");
    }

    if (!thresh_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "thresh",
        "");
    }

    if (!reset_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "reset",
        "");
    }

    if (!C_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "C",
        "");
    }

    if (!leakConductance_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "leakConductance",
        "");
    }
  }

  IafCell* IafCell::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IafCell (*this, f, c);
  }

  IafCell& IafCell::
  operator= (const IafCell& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseCell& > (*this) = x;
      this->leakReversal_ = x.leakReversal_;
      this->thresh_ = x.thresh_;
      this->reset_ = x.reset_;
      this->C_ = x.C_;
      this->leakConductance_ = x.leakConductance_;
    }

    return *this;
  }

  IafCell::
  ~IafCell ()
  {
  }

  bool
  operator== (const IafCell& x, const IafCell& y)
  {
    if (!(static_cast< const ::neuroml2::BaseCell& > (x) ==
          static_cast< const ::neuroml2::BaseCell& > (y)))
      return false;

    if (!(x.leakReversal () == y.leakReversal ()))
      return false;

    if (!(x.thresh () == y.thresh ()))
      return false;

    if (!(x.reset () == y.reset ()))
      return false;

    if (!(x.C () == y.C ()))
      return false;

    if (!(x.leakConductance () == y.leakConductance ()))
      return false;

    return true;
  }

  bool
  operator!= (const IafCell& x, const IafCell& y)
  {
    return !(x == y);
  }

  // IafRefCell
  //

  IafRefCell::
  IafRefCell (const id_type& id,
              const leakReversal_type& leakReversal,
              const thresh_type& thresh,
              const reset_type& reset,
              const C_type& C,
              const leakConductance_type& leakConductance,
              const refract_type& refract)
  : ::neuroml2::IafCell (id,
                         leakReversal,
                         thresh,
                         reset,
                         C,
                         leakConductance),
    refract_ (refract, this)
  {
  }

  IafRefCell::
  IafRefCell (const IafRefCell& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::neuroml2::IafCell (x, f, c),
    refract_ (x.refract_, f, this)
  {
  }

  IafRefCell::
  IafRefCell (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::neuroml2::IafCell (e, f | ::xml_schema::flags::base, c),
    refract_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void IafRefCell::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::IafCell::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "refract" && n.namespace_ ().empty ())
      {
        this->refract_.set (refract_traits::create (i, f, this));
        continue;
      }
    }

    if (!refract_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "refract",
        "");
    }
  }

  IafRefCell* IafRefCell::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IafRefCell (*this, f, c);
  }

  IafRefCell& IafRefCell::
  operator= (const IafRefCell& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::IafCell& > (*this) = x;
      this->refract_ = x.refract_;
    }

    return *this;
  }

  IafRefCell::
  ~IafRefCell ()
  {
  }

  bool
  operator== (const IafRefCell& x, const IafRefCell& y)
  {
    if (!(static_cast< const ::neuroml2::IafCell& > (x) ==
          static_cast< const ::neuroml2::IafCell& > (y)))
      return false;

    if (!(x.refract () == y.refract ()))
      return false;

    return true;
  }

  bool
  operator!= (const IafRefCell& x, const IafRefCell& y)
  {
    return !(x == y);
  }

  // IzhikevichCell
  //

  IzhikevichCell::
  IzhikevichCell (const id_type& id,
                  const v0_type& v0,
                  const thresh_type& thresh,
                  const a_type& a,
                  const b_type& b,
                  const c_type& c,
                  const d_type& d)
  : ::neuroml2::BaseCell (id),
    v0_ (v0, this),
    thresh_ (thresh, this),
    a_ (a, this),
    b_ (b, this),
    c_ (c, this),
    d_ (d, this)
  {
  }

  IzhikevichCell::
  IzhikevichCell (const IzhikevichCell& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::neuroml2::BaseCell (x, f, c),
    v0_ (x.v0_, f, this),
    thresh_ (x.thresh_, f, this),
    a_ (x.a_, f, this),
    b_ (x.b_, f, this),
    c_ (x.c_, f, this),
    d_ (x.d_, f, this)
  {
  }

  IzhikevichCell::
  IzhikevichCell (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::neuroml2::BaseCell (e, f | ::xml_schema::flags::base, c),
    v0_ (this),
    thresh_ (this),
    a_ (this),
    b_ (this),
    c_ (this),
    d_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void IzhikevichCell::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseCell::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "v0" && n.namespace_ ().empty ())
      {
        this->v0_.set (v0_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "thresh" && n.namespace_ ().empty ())
      {
        this->thresh_.set (thresh_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "a" && n.namespace_ ().empty ())
      {
        this->a_.set (a_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "b" && n.namespace_ ().empty ())
      {
        this->b_.set (b_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "c" && n.namespace_ ().empty ())
      {
        this->c_.set (c_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "d" && n.namespace_ ().empty ())
      {
        this->d_.set (d_traits::create (i, f, this));
        continue;
      }
    }

    if (!v0_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "v0",
        "");
    }

    if (!thresh_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "thresh",
        "");
    }

    if (!a_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "a",
        "");
    }

    if (!b_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "b",
        "");
    }

    if (!c_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "c",
        "");
    }

    if (!d_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "d",
        "");
    }
  }

  IzhikevichCell* IzhikevichCell::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IzhikevichCell (*this, f, c);
  }

  IzhikevichCell& IzhikevichCell::
  operator= (const IzhikevichCell& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseCell& > (*this) = x;
      this->v0_ = x.v0_;
      this->thresh_ = x.thresh_;
      this->a_ = x.a_;
      this->b_ = x.b_;
      this->c_ = x.c_;
      this->d_ = x.d_;
    }

    return *this;
  }

  IzhikevichCell::
  ~IzhikevichCell ()
  {
  }

  bool
  operator== (const IzhikevichCell& x, const IzhikevichCell& y)
  {
    if (!(static_cast< const ::neuroml2::BaseCell& > (x) ==
          static_cast< const ::neuroml2::BaseCell& > (y)))
      return false;

    if (!(x.v0 () == y.v0 ()))
      return false;

    if (!(x.thresh () == y.thresh ()))
      return false;

    if (!(x.a () == y.a ()))
      return false;

    if (!(x.b () == y.b ()))
      return false;

    if (!(x.c () == y.c ()))
      return false;

    if (!(x.d () == y.d ()))
      return false;

    return true;
  }

  bool
  operator!= (const IzhikevichCell& x, const IzhikevichCell& y)
  {
    return !(x == y);
  }

  // BaseCellMembPotCap
  //

  BaseCellMembPotCap::
  BaseCellMembPotCap (const id_type& id,
                      const C_type& C)
  : ::neuroml2::BaseCell (id),
    C_ (C, this)
  {
  }

  BaseCellMembPotCap::
  BaseCellMembPotCap (const BaseCellMembPotCap& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::neuroml2::BaseCell (x, f, c),
    C_ (x.C_, f, this)
  {
  }

  BaseCellMembPotCap::
  BaseCellMembPotCap (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::neuroml2::BaseCell (e, f | ::xml_schema::flags::base, c),
    C_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void BaseCellMembPotCap::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseCell::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "C" && n.namespace_ ().empty ())
      {
        this->C_.set (C_traits::create (i, f, this));
        continue;
      }
    }

    if (!C_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "C",
        "");
    }
  }

  BaseCellMembPotCap* BaseCellMembPotCap::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BaseCellMembPotCap (*this, f, c);
  }

  BaseCellMembPotCap& BaseCellMembPotCap::
  operator= (const BaseCellMembPotCap& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseCell& > (*this) = x;
      this->C_ = x.C_;
    }

    return *this;
  }

  BaseCellMembPotCap::
  ~BaseCellMembPotCap ()
  {
  }

  bool
  operator== (const BaseCellMembPotCap& x, const BaseCellMembPotCap& y)
  {
    if (!(static_cast< const ::neuroml2::BaseCell& > (x) ==
          static_cast< const ::neuroml2::BaseCell& > (y)))
      return false;

    if (!(x.C () == y.C ()))
      return false;

    return true;
  }

  bool
  operator!= (const BaseCellMembPotCap& x, const BaseCellMembPotCap& y)
  {
    return !(x == y);
  }

  // Izhikevich2007Cell
  //

  Izhikevich2007Cell::
  Izhikevich2007Cell (const id_type& id,
                      const C_type& C,
                      const v0_type& v0,
                      const k_type& k,
                      const vr_type& vr,
                      const vt_type& vt,
                      const vpeak_type& vpeak,
                      const a_type& a,
                      const b_type& b,
                      const c_type& c,
                      const d_type& d)
  : ::neuroml2::BaseCellMembPotCap (id,
                                    C),
    v0_ (v0, this),
    k_ (k, this),
    vr_ (vr, this),
    vt_ (vt, this),
    vpeak_ (vpeak, this),
    a_ (a, this),
    b_ (b, this),
    c_ (c, this),
    d_ (d, this)
  {
  }

  Izhikevich2007Cell::
  Izhikevich2007Cell (const Izhikevich2007Cell& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::neuroml2::BaseCellMembPotCap (x, f, c),
    v0_ (x.v0_, f, this),
    k_ (x.k_, f, this),
    vr_ (x.vr_, f, this),
    vt_ (x.vt_, f, this),
    vpeak_ (x.vpeak_, f, this),
    a_ (x.a_, f, this),
    b_ (x.b_, f, this),
    c_ (x.c_, f, this),
    d_ (x.d_, f, this)
  {
  }

  Izhikevich2007Cell::
  Izhikevich2007Cell (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::neuroml2::BaseCellMembPotCap (e, f | ::xml_schema::flags::base, c),
    v0_ (this),
    k_ (this),
    vr_ (this),
    vt_ (this),
    vpeak_ (this),
    a_ (this),
    b_ (this),
    c_ (this),
    d_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Izhikevich2007Cell::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseCellMembPotCap::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "v0" && n.namespace_ ().empty ())
      {
        this->v0_.set (v0_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "k" && n.namespace_ ().empty ())
      {
        this->k_.set (k_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "vr" && n.namespace_ ().empty ())
      {
        this->vr_.set (vr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "vt" && n.namespace_ ().empty ())
      {
        this->vt_.set (vt_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "vpeak" && n.namespace_ ().empty ())
      {
        this->vpeak_.set (vpeak_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "a" && n.namespace_ ().empty ())
      {
        this->a_.set (a_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "b" && n.namespace_ ().empty ())
      {
        this->b_.set (b_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "c" && n.namespace_ ().empty ())
      {
        this->c_.set (c_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "d" && n.namespace_ ().empty ())
      {
        this->d_.set (d_traits::create (i, f, this));
        continue;
      }
    }

    if (!v0_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "v0",
        "");
    }

    if (!k_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "k",
        "");
    }

    if (!vr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "vr",
        "");
    }

    if (!vt_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "vt",
        "");
    }

    if (!vpeak_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "vpeak",
        "");
    }

    if (!a_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "a",
        "");
    }

    if (!b_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "b",
        "");
    }

    if (!c_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "c",
        "");
    }

    if (!d_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "d",
        "");
    }
  }

  Izhikevich2007Cell* Izhikevich2007Cell::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Izhikevich2007Cell (*this, f, c);
  }

  Izhikevich2007Cell& Izhikevich2007Cell::
  operator= (const Izhikevich2007Cell& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseCellMembPotCap& > (*this) = x;
      this->v0_ = x.v0_;
      this->k_ = x.k_;
      this->vr_ = x.vr_;
      this->vt_ = x.vt_;
      this->vpeak_ = x.vpeak_;
      this->a_ = x.a_;
      this->b_ = x.b_;
      this->c_ = x.c_;
      this->d_ = x.d_;
    }

    return *this;
  }

  Izhikevich2007Cell::
  ~Izhikevich2007Cell ()
  {
  }

  bool
  operator== (const Izhikevich2007Cell& x, const Izhikevich2007Cell& y)
  {
    if (!(static_cast< const ::neuroml2::BaseCellMembPotCap& > (x) ==
          static_cast< const ::neuroml2::BaseCellMembPotCap& > (y)))
      return false;

    if (!(x.v0 () == y.v0 ()))
      return false;

    if (!(x.k () == y.k ()))
      return false;

    if (!(x.vr () == y.vr ()))
      return false;

    if (!(x.vt () == y.vt ()))
      return false;

    if (!(x.vpeak () == y.vpeak ()))
      return false;

    if (!(x.a () == y.a ()))
      return false;

    if (!(x.b () == y.b ()))
      return false;

    if (!(x.c () == y.c ()))
      return false;

    if (!(x.d () == y.d ()))
      return false;

    return true;
  }

  bool
  operator!= (const Izhikevich2007Cell& x, const Izhikevich2007Cell& y)
  {
    return !(x == y);
  }

  // AdExIaFCell
  //

  AdExIaFCell::
  AdExIaFCell (const id_type& id,
               const C_type& C,
               const gL_type& gL,
               const EL_type& EL,
               const reset_type& reset,
               const VT_type& VT,
               const thresh_type& thresh,
               const delT_type& delT,
               const tauw_type& tauw,
               const refract_type& refract,
               const a_type& a,
               const b_type& b)
  : ::neuroml2::BaseCellMembPotCap (id,
                                    C),
    gL_ (gL, this),
    EL_ (EL, this),
    reset_ (reset, this),
    VT_ (VT, this),
    thresh_ (thresh, this),
    delT_ (delT, this),
    tauw_ (tauw, this),
    refract_ (refract, this),
    a_ (a, this),
    b_ (b, this)
  {
  }

  AdExIaFCell::
  AdExIaFCell (const AdExIaFCell& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::neuroml2::BaseCellMembPotCap (x, f, c),
    gL_ (x.gL_, f, this),
    EL_ (x.EL_, f, this),
    reset_ (x.reset_, f, this),
    VT_ (x.VT_, f, this),
    thresh_ (x.thresh_, f, this),
    delT_ (x.delT_, f, this),
    tauw_ (x.tauw_, f, this),
    refract_ (x.refract_, f, this),
    a_ (x.a_, f, this),
    b_ (x.b_, f, this)
  {
  }

  AdExIaFCell::
  AdExIaFCell (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::neuroml2::BaseCellMembPotCap (e, f | ::xml_schema::flags::base, c),
    gL_ (this),
    EL_ (this),
    reset_ (this),
    VT_ (this),
    thresh_ (this),
    delT_ (this),
    tauw_ (this),
    refract_ (this),
    a_ (this),
    b_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AdExIaFCell::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseCellMembPotCap::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "gL" && n.namespace_ ().empty ())
      {
        this->gL_.set (gL_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "EL" && n.namespace_ ().empty ())
      {
        this->EL_.set (EL_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "reset" && n.namespace_ ().empty ())
      {
        this->reset_.set (reset_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "VT" && n.namespace_ ().empty ())
      {
        this->VT_.set (VT_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "thresh" && n.namespace_ ().empty ())
      {
        this->thresh_.set (thresh_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "delT" && n.namespace_ ().empty ())
      {
        this->delT_.set (delT_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "tauw" && n.namespace_ ().empty ())
      {
        this->tauw_.set (tauw_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "refract" && n.namespace_ ().empty ())
      {
        this->refract_.set (refract_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "a" && n.namespace_ ().empty ())
      {
        this->a_.set (a_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "b" && n.namespace_ ().empty ())
      {
        this->b_.set (b_traits::create (i, f, this));
        continue;
      }
    }

    if (!gL_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "gL",
        "");
    }

    if (!EL_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "EL",
        "");
    }

    if (!reset_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "reset",
        "");
    }

    if (!VT_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "VT",
        "");
    }

    if (!thresh_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "thresh",
        "");
    }

    if (!delT_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "delT",
        "");
    }

    if (!tauw_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "tauw",
        "");
    }

    if (!refract_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "refract",
        "");
    }

    if (!a_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "a",
        "");
    }

    if (!b_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "b",
        "");
    }
  }

  AdExIaFCell* AdExIaFCell::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AdExIaFCell (*this, f, c);
  }

  AdExIaFCell& AdExIaFCell::
  operator= (const AdExIaFCell& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseCellMembPotCap& > (*this) = x;
      this->gL_ = x.gL_;
      this->EL_ = x.EL_;
      this->reset_ = x.reset_;
      this->VT_ = x.VT_;
      this->thresh_ = x.thresh_;
      this->delT_ = x.delT_;
      this->tauw_ = x.tauw_;
      this->refract_ = x.refract_;
      this->a_ = x.a_;
      this->b_ = x.b_;
    }

    return *this;
  }

  AdExIaFCell::
  ~AdExIaFCell ()
  {
  }

  bool
  operator== (const AdExIaFCell& x, const AdExIaFCell& y)
  {
    if (!(static_cast< const ::neuroml2::BaseCellMembPotCap& > (x) ==
          static_cast< const ::neuroml2::BaseCellMembPotCap& > (y)))
      return false;

    if (!(x.gL () == y.gL ()))
      return false;

    if (!(x.EL () == y.EL ()))
      return false;

    if (!(x.reset () == y.reset ()))
      return false;

    if (!(x.VT () == y.VT ()))
      return false;

    if (!(x.thresh () == y.thresh ()))
      return false;

    if (!(x.delT () == y.delT ()))
      return false;

    if (!(x.tauw () == y.tauw ()))
      return false;

    if (!(x.refract () == y.refract ()))
      return false;

    if (!(x.a () == y.a ()))
      return false;

    if (!(x.b () == y.b ()))
      return false;

    return true;
  }

  bool
  operator!= (const AdExIaFCell& x, const AdExIaFCell& y)
  {
    return !(x == y);
  }

  // FitzHughNagumoCell
  //

  FitzHughNagumoCell::
  FitzHughNagumoCell (const id_type& id,
                      const I_type& I)
  : ::neuroml2::BaseCell (id),
    I_ (I, this)
  {
  }

  FitzHughNagumoCell::
  FitzHughNagumoCell (const FitzHughNagumoCell& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::neuroml2::BaseCell (x, f, c),
    I_ (x.I_, f, this)
  {
  }

  FitzHughNagumoCell::
  FitzHughNagumoCell (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::neuroml2::BaseCell (e, f | ::xml_schema::flags::base, c),
    I_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void FitzHughNagumoCell::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseCell::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "I" && n.namespace_ ().empty ())
      {
        this->I_.set (I_traits::create (i, f, this));
        continue;
      }
    }

    if (!I_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "I",
        "");
    }
  }

  FitzHughNagumoCell* FitzHughNagumoCell::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FitzHughNagumoCell (*this, f, c);
  }

  FitzHughNagumoCell& FitzHughNagumoCell::
  operator= (const FitzHughNagumoCell& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseCell& > (*this) = x;
      this->I_ = x.I_;
    }

    return *this;
  }

  FitzHughNagumoCell::
  ~FitzHughNagumoCell ()
  {
  }

  bool
  operator== (const FitzHughNagumoCell& x, const FitzHughNagumoCell& y)
  {
    if (!(static_cast< const ::neuroml2::BaseCell& > (x) ==
          static_cast< const ::neuroml2::BaseCell& > (y)))
      return false;

    if (!(x.I () == y.I ()))
      return false;

    return true;
  }

  bool
  operator!= (const FitzHughNagumoCell& x, const FitzHughNagumoCell& y)
  {
    return !(x == y);
  }

  // FitzHughNagumo1969Cell
  //

  FitzHughNagumo1969Cell::
  FitzHughNagumo1969Cell (const id_type& id,
                          const a_type& a,
                          const b_type& b,
                          const I_type& I,
                          const phi_type& phi,
                          const V0_type& V0,
                          const W0_type& W0)
  : ::neuroml2::BaseCell (id),
    a_ (a, this),
    b_ (b, this),
    I_ (I, this),
    phi_ (phi, this),
    V0_ (V0, this),
    W0_ (W0, this)
  {
  }

  FitzHughNagumo1969Cell::
  FitzHughNagumo1969Cell (const FitzHughNagumo1969Cell& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::neuroml2::BaseCell (x, f, c),
    a_ (x.a_, f, this),
    b_ (x.b_, f, this),
    I_ (x.I_, f, this),
    phi_ (x.phi_, f, this),
    V0_ (x.V0_, f, this),
    W0_ (x.W0_, f, this)
  {
  }

  FitzHughNagumo1969Cell::
  FitzHughNagumo1969Cell (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::neuroml2::BaseCell (e, f | ::xml_schema::flags::base, c),
    a_ (this),
    b_ (this),
    I_ (this),
    phi_ (this),
    V0_ (this),
    W0_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void FitzHughNagumo1969Cell::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseCell::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "a" && n.namespace_ ().empty ())
      {
        this->a_.set (a_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "b" && n.namespace_ ().empty ())
      {
        this->b_.set (b_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "I" && n.namespace_ ().empty ())
      {
        this->I_.set (I_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "phi" && n.namespace_ ().empty ())
      {
        this->phi_.set (phi_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "V0" && n.namespace_ ().empty ())
      {
        this->V0_.set (V0_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "W0" && n.namespace_ ().empty ())
      {
        this->W0_.set (W0_traits::create (i, f, this));
        continue;
      }
    }

    if (!a_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "a",
        "");
    }

    if (!b_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "b",
        "");
    }

    if (!I_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "I",
        "");
    }

    if (!phi_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "phi",
        "");
    }

    if (!V0_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "V0",
        "");
    }

    if (!W0_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "W0",
        "");
    }
  }

  FitzHughNagumo1969Cell* FitzHughNagumo1969Cell::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FitzHughNagumo1969Cell (*this, f, c);
  }

  FitzHughNagumo1969Cell& FitzHughNagumo1969Cell::
  operator= (const FitzHughNagumo1969Cell& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseCell& > (*this) = x;
      this->a_ = x.a_;
      this->b_ = x.b_;
      this->I_ = x.I_;
      this->phi_ = x.phi_;
      this->V0_ = x.V0_;
      this->W0_ = x.W0_;
    }

    return *this;
  }

  FitzHughNagumo1969Cell::
  ~FitzHughNagumo1969Cell ()
  {
  }

  bool
  operator== (const FitzHughNagumo1969Cell& x, const FitzHughNagumo1969Cell& y)
  {
    if (!(static_cast< const ::neuroml2::BaseCell& > (x) ==
          static_cast< const ::neuroml2::BaseCell& > (y)))
      return false;

    if (!(x.a () == y.a ()))
      return false;

    if (!(x.b () == y.b ()))
      return false;

    if (!(x.I () == y.I ()))
      return false;

    if (!(x.phi () == y.phi ()))
      return false;

    if (!(x.V0 () == y.V0 ()))
      return false;

    if (!(x.W0 () == y.W0 ()))
      return false;

    return true;
  }

  bool
  operator!= (const FitzHughNagumo1969Cell& x, const FitzHughNagumo1969Cell& y)
  {
    return !(x == y);
  }

  // PinskyRinzelCA3Cell
  //

  PinskyRinzelCA3Cell::
  PinskyRinzelCA3Cell (const id_type& id,
                       const iSoma_type& iSoma,
                       const iDend_type& iDend,
                       const gc_type& gc,
                       const gLs_type& gLs,
                       const gLd_type& gLd,
                       const gNa_type& gNa,
                       const gKdr_type& gKdr,
                       const gCa_type& gCa,
                       const gKahp_type& gKahp,
                       const gKC_type& gKC,
                       const gNmda_type& gNmda,
                       const gAmpa_type& gAmpa,
                       const eNa_type& eNa,
                       const eCa_type& eCa,
                       const eK_type& eK,
                       const eL_type& eL,
                       const qd0_type& qd0,
                       const pp_type& pp,
                       const alphac_type& alphac,
                       const betac_type& betac,
                       const cm_type& cm)
  : ::neuroml2::BaseCell (id),
    iSoma_ (iSoma, this),
    iDend_ (iDend, this),
    gc_ (gc, this),
    gLs_ (gLs, this),
    gLd_ (gLd, this),
    gNa_ (gNa, this),
    gKdr_ (gKdr, this),
    gCa_ (gCa, this),
    gKahp_ (gKahp, this),
    gKC_ (gKC, this),
    gNmda_ (gNmda, this),
    gAmpa_ (gAmpa, this),
    eNa_ (eNa, this),
    eCa_ (eCa, this),
    eK_ (eK, this),
    eL_ (eL, this),
    qd0_ (qd0, this),
    pp_ (pp, this),
    alphac_ (alphac, this),
    betac_ (betac, this),
    cm_ (cm, this)
  {
  }

  PinskyRinzelCA3Cell::
  PinskyRinzelCA3Cell (const PinskyRinzelCA3Cell& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::neuroml2::BaseCell (x, f, c),
    iSoma_ (x.iSoma_, f, this),
    iDend_ (x.iDend_, f, this),
    gc_ (x.gc_, f, this),
    gLs_ (x.gLs_, f, this),
    gLd_ (x.gLd_, f, this),
    gNa_ (x.gNa_, f, this),
    gKdr_ (x.gKdr_, f, this),
    gCa_ (x.gCa_, f, this),
    gKahp_ (x.gKahp_, f, this),
    gKC_ (x.gKC_, f, this),
    gNmda_ (x.gNmda_, f, this),
    gAmpa_ (x.gAmpa_, f, this),
    eNa_ (x.eNa_, f, this),
    eCa_ (x.eCa_, f, this),
    eK_ (x.eK_, f, this),
    eL_ (x.eL_, f, this),
    qd0_ (x.qd0_, f, this),
    pp_ (x.pp_, f, this),
    alphac_ (x.alphac_, f, this),
    betac_ (x.betac_, f, this),
    cm_ (x.cm_, f, this)
  {
  }

  PinskyRinzelCA3Cell::
  PinskyRinzelCA3Cell (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::neuroml2::BaseCell (e, f | ::xml_schema::flags::base, c),
    iSoma_ (this),
    iDend_ (this),
    gc_ (this),
    gLs_ (this),
    gLd_ (this),
    gNa_ (this),
    gKdr_ (this),
    gCa_ (this),
    gKahp_ (this),
    gKC_ (this),
    gNmda_ (this),
    gAmpa_ (this),
    eNa_ (this),
    eCa_ (this),
    eK_ (this),
    eL_ (this),
    qd0_ (this),
    pp_ (this),
    alphac_ (this),
    betac_ (this),
    cm_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void PinskyRinzelCA3Cell::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseCell::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "iSoma" && n.namespace_ ().empty ())
      {
        this->iSoma_.set (iSoma_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "iDend" && n.namespace_ ().empty ())
      {
        this->iDend_.set (iDend_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "gc" && n.namespace_ ().empty ())
      {
        this->gc_.set (gc_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "gLs" && n.namespace_ ().empty ())
      {
        this->gLs_.set (gLs_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "gLd" && n.namespace_ ().empty ())
      {
        this->gLd_.set (gLd_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "gNa" && n.namespace_ ().empty ())
      {
        this->gNa_.set (gNa_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "gKdr" && n.namespace_ ().empty ())
      {
        this->gKdr_.set (gKdr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "gCa" && n.namespace_ ().empty ())
      {
        this->gCa_.set (gCa_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "gKahp" && n.namespace_ ().empty ())
      {
        this->gKahp_.set (gKahp_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "gKC" && n.namespace_ ().empty ())
      {
        this->gKC_.set (gKC_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "gNmda" && n.namespace_ ().empty ())
      {
        this->gNmda_.set (gNmda_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "gAmpa" && n.namespace_ ().empty ())
      {
        this->gAmpa_.set (gAmpa_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "eNa" && n.namespace_ ().empty ())
      {
        this->eNa_.set (eNa_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "eCa" && n.namespace_ ().empty ())
      {
        this->eCa_.set (eCa_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "eK" && n.namespace_ ().empty ())
      {
        this->eK_.set (eK_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "eL" && n.namespace_ ().empty ())
      {
        this->eL_.set (eL_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "qd0" && n.namespace_ ().empty ())
      {
        this->qd0_.set (qd0_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "pp" && n.namespace_ ().empty ())
      {
        this->pp_.set (pp_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "alphac" && n.namespace_ ().empty ())
      {
        this->alphac_.set (alphac_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "betac" && n.namespace_ ().empty ())
      {
        this->betac_.set (betac_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "cm" && n.namespace_ ().empty ())
      {
        this->cm_.set (cm_traits::create (i, f, this));
        continue;
      }
    }

    if (!iSoma_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "iSoma",
        "");
    }

    if (!iDend_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "iDend",
        "");
    }

    if (!gc_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "gc",
        "");
    }

    if (!gLs_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "gLs",
        "");
    }

    if (!gLd_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "gLd",
        "");
    }

    if (!gNa_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "gNa",
        "");
    }

    if (!gKdr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "gKdr",
        "");
    }

    if (!gCa_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "gCa",
        "");
    }

    if (!gKahp_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "gKahp",
        "");
    }

    if (!gKC_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "gKC",
        "");
    }

    if (!gNmda_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "gNmda",
        "");
    }

    if (!gAmpa_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "gAmpa",
        "");
    }

    if (!eNa_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "eNa",
        "");
    }

    if (!eCa_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "eCa",
        "");
    }

    if (!eK_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "eK",
        "");
    }

    if (!eL_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "eL",
        "");
    }

    if (!qd0_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "qd0",
        "");
    }

    if (!pp_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "pp",
        "");
    }

    if (!alphac_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "alphac",
        "");
    }

    if (!betac_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "betac",
        "");
    }

    if (!cm_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "cm",
        "");
    }
  }

  PinskyRinzelCA3Cell* PinskyRinzelCA3Cell::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PinskyRinzelCA3Cell (*this, f, c);
  }

  PinskyRinzelCA3Cell& PinskyRinzelCA3Cell::
  operator= (const PinskyRinzelCA3Cell& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseCell& > (*this) = x;
      this->iSoma_ = x.iSoma_;
      this->iDend_ = x.iDend_;
      this->gc_ = x.gc_;
      this->gLs_ = x.gLs_;
      this->gLd_ = x.gLd_;
      this->gNa_ = x.gNa_;
      this->gKdr_ = x.gKdr_;
      this->gCa_ = x.gCa_;
      this->gKahp_ = x.gKahp_;
      this->gKC_ = x.gKC_;
      this->gNmda_ = x.gNmda_;
      this->gAmpa_ = x.gAmpa_;
      this->eNa_ = x.eNa_;
      this->eCa_ = x.eCa_;
      this->eK_ = x.eK_;
      this->eL_ = x.eL_;
      this->qd0_ = x.qd0_;
      this->pp_ = x.pp_;
      this->alphac_ = x.alphac_;
      this->betac_ = x.betac_;
      this->cm_ = x.cm_;
    }

    return *this;
  }

  PinskyRinzelCA3Cell::
  ~PinskyRinzelCA3Cell ()
  {
  }

  bool
  operator== (const PinskyRinzelCA3Cell& x, const PinskyRinzelCA3Cell& y)
  {
    if (!(static_cast< const ::neuroml2::BaseCell& > (x) ==
          static_cast< const ::neuroml2::BaseCell& > (y)))
      return false;

    if (!(x.iSoma () == y.iSoma ()))
      return false;

    if (!(x.iDend () == y.iDend ()))
      return false;

    if (!(x.gc () == y.gc ()))
      return false;

    if (!(x.gLs () == y.gLs ()))
      return false;

    if (!(x.gLd () == y.gLd ()))
      return false;

    if (!(x.gNa () == y.gNa ()))
      return false;

    if (!(x.gKdr () == y.gKdr ()))
      return false;

    if (!(x.gCa () == y.gCa ()))
      return false;

    if (!(x.gKahp () == y.gKahp ()))
      return false;

    if (!(x.gKC () == y.gKC ()))
      return false;

    if (!(x.gNmda () == y.gNmda ()))
      return false;

    if (!(x.gAmpa () == y.gAmpa ()))
      return false;

    if (!(x.eNa () == y.eNa ()))
      return false;

    if (!(x.eCa () == y.eCa ()))
      return false;

    if (!(x.eK () == y.eK ()))
      return false;

    if (!(x.eL () == y.eL ()))
      return false;

    if (!(x.qd0 () == y.qd0 ()))
      return false;

    if (!(x.pp () == y.pp ()))
      return false;

    if (!(x.alphac () == y.alphac ()))
      return false;

    if (!(x.betac () == y.betac ()))
      return false;

    if (!(x.cm () == y.cm ()))
      return false;

    return true;
  }

  bool
  operator!= (const PinskyRinzelCA3Cell& x, const PinskyRinzelCA3Cell& y)
  {
    return !(x == y);
  }

  // Cell
  //

  Cell::
  Cell (const id_type& id)
  : ::neuroml2::BaseCell (id),
    morphology_ (this),
    biophysicalProperties_ (this),
    morphology1_ (this),
    biophysicalProperties1_ (this)
  {
  }

  Cell::
  Cell (const Cell& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::neuroml2::BaseCell (x, f, c),
    morphology_ (x.morphology_, f, this),
    biophysicalProperties_ (x.biophysicalProperties_, f, this),
    morphology1_ (x.morphology1_, f, this),
    biophysicalProperties1_ (x.biophysicalProperties1_, f, this)
  {
  }

  Cell::
  Cell (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::neuroml2::BaseCell (e, f | ::xml_schema::flags::base, c),
    morphology_ (this),
    biophysicalProperties_ (this),
    morphology1_ (this),
    biophysicalProperties1_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Cell::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseCell::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // morphology
      //
      if (n.name () == "morphology" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< morphology_type > r (
          morphology_traits::create (i, f, this));

        if (!this->morphology_)
        {
          this->morphology_.set (::std::move (r));
          continue;
        }
      }

      // biophysicalProperties
      //
      if (n.name () == "biophysicalProperties" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< biophysicalProperties_type > r (
          biophysicalProperties_traits::create (i, f, this));

        if (!this->biophysicalProperties_)
        {
          this->biophysicalProperties_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "morphology" && n.namespace_ ().empty ())
      {
        this->morphology1_.set (morphology1_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "biophysicalProperties" && n.namespace_ ().empty ())
      {
        this->biophysicalProperties1_.set (biophysicalProperties1_traits::create (i, f, this));
        continue;
      }
    }
  }

  Cell* Cell::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Cell (*this, f, c);
  }

  Cell& Cell::
  operator= (const Cell& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseCell& > (*this) = x;
      this->morphology_ = x.morphology_;
      this->biophysicalProperties_ = x.biophysicalProperties_;
      this->morphology1_ = x.morphology1_;
      this->biophysicalProperties1_ = x.biophysicalProperties1_;
    }

    return *this;
  }

  Cell::
  ~Cell ()
  {
  }

  bool
  operator== (const Cell& x, const Cell& y)
  {
    if (!(static_cast< const ::neuroml2::BaseCell& > (x) ==
          static_cast< const ::neuroml2::BaseCell& > (y)))
      return false;

    if (!(x.morphology () == y.morphology ()))
      return false;

    if (!(x.biophysicalProperties () == y.biophysicalProperties ()))
      return false;

    if (!(x.morphology1 () == y.morphology1 ()))
      return false;

    if (!(x.biophysicalProperties1 () == y.biophysicalProperties1 ()))
      return false;

    return true;
  }

  bool
  operator!= (const Cell& x, const Cell& y)
  {
    return !(x == y);
  }

  // Cell2CaPools
  //

  Cell2CaPools::
  Cell2CaPools (const id_type& id)
  : ::neuroml2::Cell (id),
    biophysicalProperties2CaPools_ (this)
  {
  }

  Cell2CaPools::
  Cell2CaPools (const Cell2CaPools& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::neuroml2::Cell (x, f, c),
    biophysicalProperties2CaPools_ (x.biophysicalProperties2CaPools_, f, this)
  {
  }

  Cell2CaPools::
  Cell2CaPools (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::neuroml2::Cell (e, f | ::xml_schema::flags::base, c),
    biophysicalProperties2CaPools_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Cell2CaPools::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Cell::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // biophysicalProperties2CaPools
      //
      if (n.name () == "biophysicalProperties2CaPools" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< biophysicalProperties2CaPools_type > r (
          biophysicalProperties2CaPools_traits::create (i, f, this));

        if (!this->biophysicalProperties2CaPools_)
        {
          this->biophysicalProperties2CaPools_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  Cell2CaPools* Cell2CaPools::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Cell2CaPools (*this, f, c);
  }

  Cell2CaPools& Cell2CaPools::
  operator= (const Cell2CaPools& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Cell& > (*this) = x;
      this->biophysicalProperties2CaPools_ = x.biophysicalProperties2CaPools_;
    }

    return *this;
  }

  Cell2CaPools::
  ~Cell2CaPools ()
  {
  }

  bool
  operator== (const Cell2CaPools& x, const Cell2CaPools& y)
  {
    if (!(static_cast< const ::neuroml2::Cell& > (x) ==
          static_cast< const ::neuroml2::Cell& > (y)))
      return false;

    if (!(x.biophysicalProperties2CaPools () == y.biophysicalProperties2CaPools ()))
      return false;

    return true;
  }

  bool
  operator!= (const Cell2CaPools& x, const Cell2CaPools& y)
  {
    return !(x == y);
  }

  // Morphology_base
  //

  Morphology_base::
  Morphology_base (const id_type& id)
  : ::neuroml2::Standalone (id),
    segment_ (this),
    segmentGroup_ (this)
  {
  }

  Morphology_base::
  Morphology_base (const Morphology_base& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    segment_ (x.segment_, f, this),
    segmentGroup_ (x.segmentGroup_, f, this)
  {
  }

  Morphology_base::
  Morphology_base (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    segment_ (this),
    segmentGroup_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Morphology_base::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // segment
      //
      if (n.name () == "segment" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< segment_type > r (
          segment_traits::create (i, f, this));

        this->segment_.push_back (::std::move (r));
        continue;
      }

      // segmentGroup
      //
      if (n.name () == "segmentGroup" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< segmentGroup_type > r (
          segmentGroup_traits::create (i, f, this));

        this->segmentGroup_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Morphology_base* Morphology_base::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Morphology_base (*this, f, c);
  }

  Morphology_base& Morphology_base::
  operator= (const Morphology_base& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->segment_ = x.segment_;
      this->segmentGroup_ = x.segmentGroup_;
    }

    return *this;
  }

  Morphology_base::
  ~Morphology_base ()
  {
  }

  bool
  operator== (const Morphology_base& x, const Morphology_base& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.segment () == y.segment ()))
      return false;

    if (!(x.segmentGroup () == y.segmentGroup ()))
      return false;

    return true;
  }

  bool
  operator!= (const Morphology_base& x, const Morphology_base& y)
  {
    return !(x == y);
  }

  // BaseNonNegativeIntegerId
  //

  BaseNonNegativeIntegerId::
  BaseNonNegativeIntegerId (const id_type& id)
  : ::neuroml2::BaseWithoutId (),
    id_ (id, this)
  {
  }

  BaseNonNegativeIntegerId::
  BaseNonNegativeIntegerId (const BaseNonNegativeIntegerId& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::neuroml2::BaseWithoutId (x, f, c),
    id_ (x.id_, f, this)
  {
  }

  BaseNonNegativeIntegerId::
  BaseNonNegativeIntegerId (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::neuroml2::BaseWithoutId (e, f | ::xml_schema::flags::base, c),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void BaseNonNegativeIntegerId::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseWithoutId::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  BaseNonNegativeIntegerId* BaseNonNegativeIntegerId::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BaseNonNegativeIntegerId (*this, f, c);
  }

  BaseNonNegativeIntegerId& BaseNonNegativeIntegerId::
  operator= (const BaseNonNegativeIntegerId& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseWithoutId& > (*this) = x;
      this->id_ = x.id_;
    }

    return *this;
  }

  BaseNonNegativeIntegerId::
  ~BaseNonNegativeIntegerId ()
  {
  }

  bool
  operator== (const BaseNonNegativeIntegerId& x, const BaseNonNegativeIntegerId& y)
  {
    if (!(static_cast< const ::neuroml2::BaseWithoutId& > (x) ==
          static_cast< const ::neuroml2::BaseWithoutId& > (y)))
      return false;

    if (!(x.id () == y.id ()))
      return false;

    return true;
  }

  bool
  operator!= (const BaseNonNegativeIntegerId& x, const BaseNonNegativeIntegerId& y)
  {
    return !(x == y);
  }

  // Segment_base
  //

  Segment_base::
  Segment_base (const id_type& id,
                const distal_type& distal)
  : ::neuroml2::BaseNonNegativeIntegerId (id),
    parent_ (this),
    proximal_ (this),
    distal_ (distal, this),
    name_ (this)
  {
  }

  Segment_base::
  Segment_base (const id_type& id,
                ::std::unique_ptr< distal_type > distal)
  : ::neuroml2::BaseNonNegativeIntegerId (id),
    parent_ (this),
    proximal_ (this),
    distal_ (std::move (distal), this),
    name_ (this)
  {
  }

  Segment_base::
  Segment_base (const Segment_base& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::neuroml2::BaseNonNegativeIntegerId (x, f, c),
    parent_ (x.parent_, f, this),
    proximal_ (x.proximal_, f, this),
    distal_ (x.distal_, f, this),
    name_ (x.name_, f, this)
  {
  }

  Segment_base::
  Segment_base (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::neuroml2::BaseNonNegativeIntegerId (e, f | ::xml_schema::flags::base, c),
    parent_ (this),
    proximal_ (this),
    distal_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Segment_base::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseNonNegativeIntegerId::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parent
      //
      if (n.name () == "parent" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< parent_type > r (
          parent_traits::create (i, f, this));

        if (!this->parent_)
        {
          this->parent_.set (::std::move (r));
          continue;
        }
      }

      // proximal
      //
      if (n.name () == "proximal" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< proximal_type > r (
          proximal_traits::create (i, f, this));

        if (!this->proximal_)
        {
          this->proximal_.set (::std::move (r));
          continue;
        }
      }

      // distal
      //
      if (n.name () == "distal" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< distal_type > r (
          distal_traits::create (i, f, this));

        if (!distal_.present ())
        {
          this->distal_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!distal_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "distal",
        "http://www.neuroml.org/schema/neuroml2");
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }
    }
  }

  Segment_base* Segment_base::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Segment_base (*this, f, c);
  }

  Segment_base& Segment_base::
  operator= (const Segment_base& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseNonNegativeIntegerId& > (*this) = x;
      this->parent_ = x.parent_;
      this->proximal_ = x.proximal_;
      this->distal_ = x.distal_;
      this->name_ = x.name_;
    }

    return *this;
  }

  Segment_base::
  ~Segment_base ()
  {
  }

  bool
  operator== (const Segment_base& x, const Segment_base& y)
  {
    if (!(static_cast< const ::neuroml2::BaseNonNegativeIntegerId& > (x) ==
          static_cast< const ::neuroml2::BaseNonNegativeIntegerId& > (y)))
      return false;

    if (!(x.parent () == y.parent ()))
      return false;

    if (!(x.proximal () == y.proximal ()))
      return false;

    if (!(x.distal () == y.distal ()))
      return false;

    if (!(x.name () == y.name ()))
      return false;

    return true;
  }

  bool
  operator!= (const Segment_base& x, const Segment_base& y)
  {
    return !(x == y);
  }

  // SegmentParent
  //

  SegmentParent::
  SegmentParent (const segment_type& segment)
  : ::xml_schema::type (),
    segment_ (segment, this),
    fractionAlong_ (fractionAlong_default_value (), this)
  {
  }

  SegmentParent::
  SegmentParent (const SegmentParent& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    segment_ (x.segment_, f, this),
    fractionAlong_ (x.fractionAlong_, f, this)
  {
  }

  SegmentParent::
  SegmentParent (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    segment_ (this),
    fractionAlong_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void SegmentParent::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "segment" && n.namespace_ ().empty ())
      {
        this->segment_.set (segment_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "fractionAlong" && n.namespace_ ().empty ())
      {
        this->fractionAlong_.set (fractionAlong_traits::create (i, f, this));
        continue;
      }
    }

    if (!segment_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "segment",
        "");
    }

    if (!fractionAlong_.present ())
    {
      this->fractionAlong_.set (fractionAlong_default_value ());
    }
  }

  SegmentParent* SegmentParent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SegmentParent (*this, f, c);
  }

  SegmentParent& SegmentParent::
  operator= (const SegmentParent& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->segment_ = x.segment_;
      this->fractionAlong_ = x.fractionAlong_;
    }

    return *this;
  }

  SegmentParent::
  ~SegmentParent ()
  {
  }

  bool
  operator== (const SegmentParent& x, const SegmentParent& y)
  {
    if (!(x.segment () == y.segment ()))
      return false;

    if (!(x.fractionAlong () == y.fractionAlong ()))
      return false;

    return true;
  }

  bool
  operator!= (const SegmentParent& x, const SegmentParent& y)
  {
    return !(x == y);
  }

  // Point3DWithDiam
  //

  Point3DWithDiam::
  Point3DWithDiam (const x_type& x,
                   const y_type& y,
                   const z_type& z,
                   const diameter_type& diameter)
  : ::xml_schema::type (),
    x_ (x, this),
    y_ (y, this),
    z_ (z, this),
    diameter_ (diameter, this)
  {
  }

  Point3DWithDiam::
  Point3DWithDiam (const Point3DWithDiam& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this),
    z_ (x.z_, f, this),
    diameter_ (x.diameter_, f, this)
  {
  }

  Point3DWithDiam::
  Point3DWithDiam (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    x_ (this),
    y_ (this),
    z_ (this),
    diameter_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Point3DWithDiam::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "y" && n.namespace_ ().empty ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "z" && n.namespace_ ().empty ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "diameter" && n.namespace_ ().empty ())
      {
        this->diameter_.set (diameter_traits::create (i, f, this));
        continue;
      }
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "x",
        "");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "y",
        "");
    }

    if (!z_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "z",
        "");
    }

    if (!diameter_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "diameter",
        "");
    }
  }

  Point3DWithDiam* Point3DWithDiam::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Point3DWithDiam (*this, f, c);
  }

  Point3DWithDiam& Point3DWithDiam::
  operator= (const Point3DWithDiam& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->x_ = x.x_;
      this->y_ = x.y_;
      this->z_ = x.z_;
      this->diameter_ = x.diameter_;
    }

    return *this;
  }

  Point3DWithDiam::
  ~Point3DWithDiam ()
  {
  }

  bool
  operator== (const Point3DWithDiam& x, const Point3DWithDiam& y)
  {
    if (!(x.x () == y.x ()))
      return false;

    if (!(x.y () == y.y ()))
      return false;

    if (!(x.z () == y.z ()))
      return false;

    if (!(x.diameter () == y.diameter ()))
      return false;

    return true;
  }

  bool
  operator!= (const Point3DWithDiam& x, const Point3DWithDiam& y)
  {
    return !(x == y);
  }

  // SegmentGroup
  //

  SegmentGroup::
  SegmentGroup (const id_type& id)
  : ::neuroml2::Base (id),
    notes_ (this),
    property_ (this),
    annotation_ (this),
    member_ (this),
    include_ (this),
    path_ (this),
    subTree_ (this),
    inhomogeneousParameter_ (this)
  {
  }

  SegmentGroup::
  SegmentGroup (const SegmentGroup& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    notes_ (x.notes_, f, this),
    property_ (x.property_, f, this),
    annotation_ (x.annotation_, f, this),
    member_ (x.member_, f, this),
    include_ (x.include_, f, this),
    path_ (x.path_, f, this),
    subTree_ (x.subTree_, f, this),
    inhomogeneousParameter_ (x.inhomogeneousParameter_, f, this)
  {
  }

  SegmentGroup::
  SegmentGroup (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    notes_ (this),
    property_ (this),
    annotation_ (this),
    member_ (this),
    include_ (this),
    path_ (this),
    subTree_ (this),
    inhomogeneousParameter_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SegmentGroup::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // notes
      //
      if (n.name () == "notes" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< notes_type > r (
          notes_traits::create (i, f, this));

        if (!this->notes_)
        {
          this->notes_.set (::std::move (r));
          continue;
        }
      }

      // property
      //
      if (n.name () == "property" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< property_type > r (
          property_traits::create (i, f, this));

        this->property_.push_back (::std::move (r));
        continue;
      }

      // annotation
      //
      if (n.name () == "annotation" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< annotation_type > r (
          annotation_traits::create (i, f, this));

        if (!this->annotation_)
        {
          this->annotation_.set (::std::move (r));
          continue;
        }
      }

      // member
      //
      if (n.name () == "member" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< member_type > r (
          member_traits::create (i, f, this));

        this->member_.push_back (::std::move (r));
        continue;
      }

      // include
      //
      if (n.name () == "include" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< include_type > r (
          include_traits::create (i, f, this));

        this->include_.push_back (::std::move (r));
        continue;
      }

      // path
      //
      if (n.name () == "path" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< path_type > r (
          path_traits::create (i, f, this));

        this->path_.push_back (::std::move (r));
        continue;
      }

      // subTree
      //
      if (n.name () == "subTree" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< subTree_type > r (
          subTree_traits::create (i, f, this));

        this->subTree_.push_back (::std::move (r));
        continue;
      }

      // inhomogeneousParameter
      //
      if (n.name () == "inhomogeneousParameter" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< inhomogeneousParameter_type > r (
          inhomogeneousParameter_traits::create (i, f, this));

        this->inhomogeneousParameter_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  SegmentGroup* SegmentGroup::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SegmentGroup (*this, f, c);
  }

  SegmentGroup& SegmentGroup::
  operator= (const SegmentGroup& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->notes_ = x.notes_;
      this->property_ = x.property_;
      this->annotation_ = x.annotation_;
      this->member_ = x.member_;
      this->include_ = x.include_;
      this->path_ = x.path_;
      this->subTree_ = x.subTree_;
      this->inhomogeneousParameter_ = x.inhomogeneousParameter_;
    }

    return *this;
  }

  SegmentGroup::
  ~SegmentGroup ()
  {
  }

  bool
  operator== (const SegmentGroup& x, const SegmentGroup& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.notes () == y.notes ()))
      return false;

    if (!(x.property () == y.property ()))
      return false;

    if (!(x.annotation () == y.annotation ()))
      return false;

    if (!(x.member () == y.member ()))
      return false;

    if (!(x.include () == y.include ()))
      return false;

    if (!(x.path () == y.path ()))
      return false;

    if (!(x.subTree () == y.subTree ()))
      return false;

    if (!(x.inhomogeneousParameter () == y.inhomogeneousParameter ()))
      return false;

    return true;
  }

  bool
  operator!= (const SegmentGroup& x, const SegmentGroup& y)
  {
    return !(x == y);
  }

  // InhomogeneousParameter
  //

  InhomogeneousParameter::
  InhomogeneousParameter (const id_type& id,
                          const variable_type& variable,
                          const metric_type& metric)
  : ::neuroml2::Base (id),
    proximal_ (this),
    distal_ (this),
    variable_ (variable, this),
    metric_ (metric, this)
  {
  }

  InhomogeneousParameter::
  InhomogeneousParameter (const InhomogeneousParameter& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    proximal_ (x.proximal_, f, this),
    distal_ (x.distal_, f, this),
    variable_ (x.variable_, f, this),
    metric_ (x.metric_, f, this)
  {
  }

  InhomogeneousParameter::
  InhomogeneousParameter (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    proximal_ (this),
    distal_ (this),
    variable_ (this),
    metric_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void InhomogeneousParameter::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // proximal
      //
      if (n.name () == "proximal" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< proximal_type > r (
          proximal_traits::create (i, f, this));

        if (!this->proximal_)
        {
          this->proximal_.set (::std::move (r));
          continue;
        }
      }

      // distal
      //
      if (n.name () == "distal" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< distal_type > r (
          distal_traits::create (i, f, this));

        if (!this->distal_)
        {
          this->distal_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "variable" && n.namespace_ ().empty ())
      {
        this->variable_.set (variable_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "metric" && n.namespace_ ().empty ())
      {
        this->metric_.set (metric_traits::create (i, f, this));
        continue;
      }
    }

    if (!variable_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "variable",
        "");
    }

    if (!metric_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "metric",
        "");
    }
  }

  InhomogeneousParameter* InhomogeneousParameter::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InhomogeneousParameter (*this, f, c);
  }

  InhomogeneousParameter& InhomogeneousParameter::
  operator= (const InhomogeneousParameter& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->proximal_ = x.proximal_;
      this->distal_ = x.distal_;
      this->variable_ = x.variable_;
      this->metric_ = x.metric_;
    }

    return *this;
  }

  InhomogeneousParameter::
  ~InhomogeneousParameter ()
  {
  }

  bool
  operator== (const InhomogeneousParameter& x, const InhomogeneousParameter& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.proximal () == y.proximal ()))
      return false;

    if (!(x.distal () == y.distal ()))
      return false;

    if (!(x.variable () == y.variable ()))
      return false;

    if (!(x.metric () == y.metric ()))
      return false;

    return true;
  }

  bool
  operator!= (const InhomogeneousParameter& x, const InhomogeneousParameter& y)
  {
    return !(x == y);
  }

  // Metric
  //

  Metric::
  Metric (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_Metric_convert ();
  }

  Metric::
  Metric (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_Metric_convert ();
  }

  Metric::
  Metric (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_Metric_convert ();
  }

  Metric* Metric::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Metric (*this, f, c);
  }

  Metric::value Metric::
  _xsd_Metric_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Metric_literals_);
    const value* i (::std::lower_bound (
                      _xsd_Metric_indexes_,
                      _xsd_Metric_indexes_ + 1,
                      *this,
                      c));

    if (i == _xsd_Metric_indexes_ + 1 || _xsd_Metric_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const Metric::
  _xsd_Metric_literals_[1] =
  {
    "Path Length from root"
  };

  const Metric::value Metric::
  _xsd_Metric_indexes_[1] =
  {
    ::neuroml2::Metric::Path_Length_from_root
  };

  // ProximalDetails
  //

  ProximalDetails::
  ProximalDetails (const translationStart_type& translationStart)
  : ::xml_schema::type (),
    translationStart_ (translationStart, this)
  {
  }

  ProximalDetails::
  ProximalDetails (const ProximalDetails& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    translationStart_ (x.translationStart_, f, this)
  {
  }

  ProximalDetails::
  ProximalDetails (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    translationStart_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ProximalDetails::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "translationStart" && n.namespace_ ().empty ())
      {
        this->translationStart_.set (translationStart_traits::create (i, f, this));
        continue;
      }
    }

    if (!translationStart_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "translationStart",
        "");
    }
  }

  ProximalDetails* ProximalDetails::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ProximalDetails (*this, f, c);
  }

  ProximalDetails& ProximalDetails::
  operator= (const ProximalDetails& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->translationStart_ = x.translationStart_;
    }

    return *this;
  }

  ProximalDetails::
  ~ProximalDetails ()
  {
  }

  bool
  operator== (const ProximalDetails& x, const ProximalDetails& y)
  {
    if (!(x.translationStart () == y.translationStart ()))
      return false;

    return true;
  }

  bool
  operator!= (const ProximalDetails& x, const ProximalDetails& y)
  {
    return !(x == y);
  }

  // DistalDetails
  //

  DistalDetails::
  DistalDetails (const normalizationEnd_type& normalizationEnd)
  : ::xml_schema::type (),
    normalizationEnd_ (normalizationEnd, this)
  {
  }

  DistalDetails::
  DistalDetails (const DistalDetails& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    normalizationEnd_ (x.normalizationEnd_, f, this)
  {
  }

  DistalDetails::
  DistalDetails (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    normalizationEnd_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void DistalDetails::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "normalizationEnd" && n.namespace_ ().empty ())
      {
        this->normalizationEnd_.set (normalizationEnd_traits::create (i, f, this));
        continue;
      }
    }

    if (!normalizationEnd_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "normalizationEnd",
        "");
    }
  }

  DistalDetails* DistalDetails::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DistalDetails (*this, f, c);
  }

  DistalDetails& DistalDetails::
  operator= (const DistalDetails& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->normalizationEnd_ = x.normalizationEnd_;
    }

    return *this;
  }

  DistalDetails::
  ~DistalDetails ()
  {
  }

  bool
  operator== (const DistalDetails& x, const DistalDetails& y)
  {
    if (!(x.normalizationEnd () == y.normalizationEnd ()))
      return false;

    return true;
  }

  bool
  operator!= (const DistalDetails& x, const DistalDetails& y)
  {
    return !(x == y);
  }

  // Member
  //

  Member::
  Member (const segment_type& segment)
  : ::xml_schema::type (),
    segment_ (segment, this)
  {
  }

  Member::
  Member (const Member& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    segment_ (x.segment_, f, this)
  {
  }

  Member::
  Member (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    segment_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Member::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "segment" && n.namespace_ ().empty ())
      {
        this->segment_.set (segment_traits::create (i, f, this));
        continue;
      }
    }

    if (!segment_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "segment",
        "");
    }
  }

  Member* Member::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Member (*this, f, c);
  }

  Member& Member::
  operator= (const Member& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->segment_ = x.segment_;
    }

    return *this;
  }

  Member::
  ~Member ()
  {
  }

  bool
  operator== (const Member& x, const Member& y)
  {
    if (!(x.segment () == y.segment ()))
      return false;

    return true;
  }

  bool
  operator!= (const Member& x, const Member& y)
  {
    return !(x == y);
  }

  // Include
  //

  Include::
  Include (const segmentGroup_type& segmentGroup)
  : ::xml_schema::type (),
    segmentGroup_ (segmentGroup, this)
  {
  }

  Include::
  Include (const Include& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    segmentGroup_ (x.segmentGroup_, f, this)
  {
  }

  Include::
  Include (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    segmentGroup_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Include::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "segmentGroup" && n.namespace_ ().empty ())
      {
        this->segmentGroup_.set (segmentGroup_traits::create (i, f, this));
        continue;
      }
    }

    if (!segmentGroup_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "segmentGroup",
        "");
    }
  }

  Include* Include::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Include (*this, f, c);
  }

  Include& Include::
  operator= (const Include& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->segmentGroup_ = x.segmentGroup_;
    }

    return *this;
  }

  Include::
  ~Include ()
  {
  }

  bool
  operator== (const Include& x, const Include& y)
  {
    if (!(x.segmentGroup () == y.segmentGroup ()))
      return false;

    return true;
  }

  bool
  operator!= (const Include& x, const Include& y)
  {
    return !(x == y);
  }

  // Path
  //

  Path::
  Path ()
  : ::xml_schema::type (),
    from_ (this),
    to_ (this)
  {
  }

  Path::
  Path (const Path& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    from_ (x.from_, f, this),
    to_ (x.to_, f, this)
  {
  }

  Path::
  Path (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    from_ (this),
    to_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Path::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // from
      //
      if (n.name () == "from" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< from_type > r (
          from_traits::create (i, f, this));

        if (!this->from_)
        {
          this->from_.set (::std::move (r));
          continue;
        }
      }

      // to
      //
      if (n.name () == "to" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< to_type > r (
          to_traits::create (i, f, this));

        if (!this->to_)
        {
          this->to_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  Path* Path::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Path (*this, f, c);
  }

  Path& Path::
  operator= (const Path& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->from_ = x.from_;
      this->to_ = x.to_;
    }

    return *this;
  }

  Path::
  ~Path ()
  {
  }

  bool
  operator== (const Path& x, const Path& y)
  {
    if (!(x.from () == y.from ()))
      return false;

    if (!(x.to () == y.to ()))
      return false;

    return true;
  }

  bool
  operator!= (const Path& x, const Path& y)
  {
    return !(x == y);
  }

  // SubTree
  //

  SubTree::
  SubTree ()
  : ::xml_schema::type (),
    from_ (this),
    to_ (this)
  {
  }

  SubTree::
  SubTree (const SubTree& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    from_ (x.from_, f, this),
    to_ (x.to_, f, this)
  {
  }

  SubTree::
  SubTree (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    from_ (this),
    to_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SubTree::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // from
      //
      if (n.name () == "from" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< from_type > r (
          from_traits::create (i, f, this));

        if (!this->from_)
        {
          this->from_.set (::std::move (r));
          continue;
        }
      }

      // to
      //
      if (n.name () == "to" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< to_type > r (
          to_traits::create (i, f, this));

        if (!this->to_)
        {
          this->to_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  SubTree* SubTree::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SubTree (*this, f, c);
  }

  SubTree& SubTree::
  operator= (const SubTree& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->from_ = x.from_;
      this->to_ = x.to_;
    }

    return *this;
  }

  SubTree::
  ~SubTree ()
  {
  }

  bool
  operator== (const SubTree& x, const SubTree& y)
  {
    if (!(x.from () == y.from ()))
      return false;

    if (!(x.to () == y.to ()))
      return false;

    return true;
  }

  bool
  operator!= (const SubTree& x, const SubTree& y)
  {
    return !(x == y);
  }

  // SegmentEndPoint
  //

  SegmentEndPoint::
  SegmentEndPoint (const segment_type& segment)
  : ::xml_schema::type (),
    segment_ (segment, this)
  {
  }

  SegmentEndPoint::
  SegmentEndPoint (const SegmentEndPoint& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    segment_ (x.segment_, f, this)
  {
  }

  SegmentEndPoint::
  SegmentEndPoint (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    segment_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void SegmentEndPoint::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "segment" && n.namespace_ ().empty ())
      {
        this->segment_.set (segment_traits::create (i, f, this));
        continue;
      }
    }

    if (!segment_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "segment",
        "");
    }
  }

  SegmentEndPoint* SegmentEndPoint::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SegmentEndPoint (*this, f, c);
  }

  SegmentEndPoint& SegmentEndPoint::
  operator= (const SegmentEndPoint& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->segment_ = x.segment_;
    }

    return *this;
  }

  SegmentEndPoint::
  ~SegmentEndPoint ()
  {
  }

  bool
  operator== (const SegmentEndPoint& x, const SegmentEndPoint& y)
  {
    if (!(x.segment () == y.segment ()))
      return false;

    return true;
  }

  bool
  operator!= (const SegmentEndPoint& x, const SegmentEndPoint& y)
  {
    return !(x == y);
  }

  // BiophysicalProperties
  //

  BiophysicalProperties::
  BiophysicalProperties (const id_type& id,
                         const membraneProperties_type& membraneProperties)
  : ::neuroml2::Standalone (id),
    membraneProperties_ (membraneProperties, this),
    intracellularProperties_ (this),
    extracellularProperties_ (this)
  {
  }

  BiophysicalProperties::
  BiophysicalProperties (const id_type& id,
                         ::std::unique_ptr< membraneProperties_type > membraneProperties)
  : ::neuroml2::Standalone (id),
    membraneProperties_ (std::move (membraneProperties), this),
    intracellularProperties_ (this),
    extracellularProperties_ (this)
  {
  }

  BiophysicalProperties::
  BiophysicalProperties (const BiophysicalProperties& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    membraneProperties_ (x.membraneProperties_, f, this),
    intracellularProperties_ (x.intracellularProperties_, f, this),
    extracellularProperties_ (x.extracellularProperties_, f, this)
  {
  }

  BiophysicalProperties::
  BiophysicalProperties (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    membraneProperties_ (this),
    intracellularProperties_ (this),
    extracellularProperties_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void BiophysicalProperties::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // membraneProperties
      //
      if (n.name () == "membraneProperties" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< membraneProperties_type > r (
          membraneProperties_traits::create (i, f, this));

        if (!membraneProperties_.present ())
        {
          this->membraneProperties_.set (::std::move (r));
          continue;
        }
      }

      // intracellularProperties
      //
      if (n.name () == "intracellularProperties" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< intracellularProperties_type > r (
          intracellularProperties_traits::create (i, f, this));

        if (!this->intracellularProperties_)
        {
          this->intracellularProperties_.set (::std::move (r));
          continue;
        }
      }

      // extracellularProperties
      //
      if (n.name () == "extracellularProperties" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< extracellularProperties_type > r (
          extracellularProperties_traits::create (i, f, this));

        if (!this->extracellularProperties_)
        {
          this->extracellularProperties_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!membraneProperties_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "membraneProperties",
        "http://www.neuroml.org/schema/neuroml2");
    }
  }

  BiophysicalProperties* BiophysicalProperties::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BiophysicalProperties (*this, f, c);
  }

  BiophysicalProperties& BiophysicalProperties::
  operator= (const BiophysicalProperties& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->membraneProperties_ = x.membraneProperties_;
      this->intracellularProperties_ = x.intracellularProperties_;
      this->extracellularProperties_ = x.extracellularProperties_;
    }

    return *this;
  }

  BiophysicalProperties::
  ~BiophysicalProperties ()
  {
  }

  bool
  operator== (const BiophysicalProperties& x, const BiophysicalProperties& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.membraneProperties () == y.membraneProperties ()))
      return false;

    if (!(x.intracellularProperties () == y.intracellularProperties ()))
      return false;

    if (!(x.extracellularProperties () == y.extracellularProperties ()))
      return false;

    return true;
  }

  bool
  operator!= (const BiophysicalProperties& x, const BiophysicalProperties& y)
  {
    return !(x == y);
  }

  // BiophysicalProperties2CaPools
  //

  BiophysicalProperties2CaPools::
  BiophysicalProperties2CaPools (const id_type& id,
                                 const membraneProperties2CaPools_type& membraneProperties2CaPools)
  : ::neuroml2::Standalone (id),
    membraneProperties2CaPools_ (membraneProperties2CaPools, this),
    intracellularProperties2CaPools_ (this),
    extracellularProperties_ (this)
  {
  }

  BiophysicalProperties2CaPools::
  BiophysicalProperties2CaPools (const id_type& id,
                                 ::std::unique_ptr< membraneProperties2CaPools_type > membraneProperties2CaPools)
  : ::neuroml2::Standalone (id),
    membraneProperties2CaPools_ (std::move (membraneProperties2CaPools), this),
    intracellularProperties2CaPools_ (this),
    extracellularProperties_ (this)
  {
  }

  BiophysicalProperties2CaPools::
  BiophysicalProperties2CaPools (const BiophysicalProperties2CaPools& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    membraneProperties2CaPools_ (x.membraneProperties2CaPools_, f, this),
    intracellularProperties2CaPools_ (x.intracellularProperties2CaPools_, f, this),
    extracellularProperties_ (x.extracellularProperties_, f, this)
  {
  }

  BiophysicalProperties2CaPools::
  BiophysicalProperties2CaPools (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    membraneProperties2CaPools_ (this),
    intracellularProperties2CaPools_ (this),
    extracellularProperties_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void BiophysicalProperties2CaPools::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // membraneProperties2CaPools
      //
      if (n.name () == "membraneProperties2CaPools" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< membraneProperties2CaPools_type > r (
          membraneProperties2CaPools_traits::create (i, f, this));

        if (!membraneProperties2CaPools_.present ())
        {
          this->membraneProperties2CaPools_.set (::std::move (r));
          continue;
        }
      }

      // intracellularProperties2CaPools
      //
      if (n.name () == "intracellularProperties2CaPools" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< intracellularProperties2CaPools_type > r (
          intracellularProperties2CaPools_traits::create (i, f, this));

        if (!this->intracellularProperties2CaPools_)
        {
          this->intracellularProperties2CaPools_.set (::std::move (r));
          continue;
        }
      }

      // extracellularProperties
      //
      if (n.name () == "extracellularProperties" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< extracellularProperties_type > r (
          extracellularProperties_traits::create (i, f, this));

        if (!this->extracellularProperties_)
        {
          this->extracellularProperties_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!membraneProperties2CaPools_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "membraneProperties2CaPools",
        "http://www.neuroml.org/schema/neuroml2");
    }
  }

  BiophysicalProperties2CaPools* BiophysicalProperties2CaPools::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BiophysicalProperties2CaPools (*this, f, c);
  }

  BiophysicalProperties2CaPools& BiophysicalProperties2CaPools::
  operator= (const BiophysicalProperties2CaPools& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->membraneProperties2CaPools_ = x.membraneProperties2CaPools_;
      this->intracellularProperties2CaPools_ = x.intracellularProperties2CaPools_;
      this->extracellularProperties_ = x.extracellularProperties_;
    }

    return *this;
  }

  BiophysicalProperties2CaPools::
  ~BiophysicalProperties2CaPools ()
  {
  }

  bool
  operator== (const BiophysicalProperties2CaPools& x, const BiophysicalProperties2CaPools& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.membraneProperties2CaPools () == y.membraneProperties2CaPools ()))
      return false;

    if (!(x.intracellularProperties2CaPools () == y.intracellularProperties2CaPools ()))
      return false;

    if (!(x.extracellularProperties () == y.extracellularProperties ()))
      return false;

    return true;
  }

  bool
  operator!= (const BiophysicalProperties2CaPools& x, const BiophysicalProperties2CaPools& y)
  {
    return !(x == y);
  }

  // MembraneProperties
  //

  MembraneProperties::
  MembraneProperties ()
  : ::xml_schema::type (),
    channelPopulation_ (this),
    channelDensity_ (this),
    channelDensityVShift_ (this),
    channelDensityNernst_ (this),
    channelDensityGHK_ (this),
    channelDensityGHK2_ (this),
    channelDensityNonUniform_ (this),
    channelDensityNonUniformNernst_ (this),
    channelDensityNonUniformGHK_ (this),
    spikeThresh_ (this),
    specificCapacitance_ (this),
    initMembPotential_ (this)
  {
  }

  MembraneProperties::
  MembraneProperties (const MembraneProperties& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    channelPopulation_ (x.channelPopulation_, f, this),
    channelDensity_ (x.channelDensity_, f, this),
    channelDensityVShift_ (x.channelDensityVShift_, f, this),
    channelDensityNernst_ (x.channelDensityNernst_, f, this),
    channelDensityGHK_ (x.channelDensityGHK_, f, this),
    channelDensityGHK2_ (x.channelDensityGHK2_, f, this),
    channelDensityNonUniform_ (x.channelDensityNonUniform_, f, this),
    channelDensityNonUniformNernst_ (x.channelDensityNonUniformNernst_, f, this),
    channelDensityNonUniformGHK_ (x.channelDensityNonUniformGHK_, f, this),
    spikeThresh_ (x.spikeThresh_, f, this),
    specificCapacitance_ (x.specificCapacitance_, f, this),
    initMembPotential_ (x.initMembPotential_, f, this)
  {
  }

  MembraneProperties::
  MembraneProperties (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    channelPopulation_ (this),
    channelDensity_ (this),
    channelDensityVShift_ (this),
    channelDensityNernst_ (this),
    channelDensityGHK_ (this),
    channelDensityGHK2_ (this),
    channelDensityNonUniform_ (this),
    channelDensityNonUniformNernst_ (this),
    channelDensityNonUniformGHK_ (this),
    spikeThresh_ (this),
    specificCapacitance_ (this),
    initMembPotential_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void MembraneProperties::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // channelPopulation
      //
      if (n.name () == "channelPopulation" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< channelPopulation_type > r (
          channelPopulation_traits::create (i, f, this));

        this->channelPopulation_.push_back (::std::move (r));
        continue;
      }

      // channelDensity
      //
      if (n.name () == "channelDensity" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< channelDensity_type > r (
          channelDensity_traits::create (i, f, this));

        this->channelDensity_.push_back (::std::move (r));
        continue;
      }

      // channelDensityVShift
      //
      if (n.name () == "channelDensityVShift" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< channelDensityVShift_type > r (
          channelDensityVShift_traits::create (i, f, this));

        this->channelDensityVShift_.push_back (::std::move (r));
        continue;
      }

      // channelDensityNernst
      //
      if (n.name () == "channelDensityNernst" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< channelDensityNernst_type > r (
          channelDensityNernst_traits::create (i, f, this));

        this->channelDensityNernst_.push_back (::std::move (r));
        continue;
      }

      // channelDensityGHK
      //
      if (n.name () == "channelDensityGHK" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< channelDensityGHK_type > r (
          channelDensityGHK_traits::create (i, f, this));

        this->channelDensityGHK_.push_back (::std::move (r));
        continue;
      }

      // channelDensityGHK2
      //
      if (n.name () == "channelDensityGHK2" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< channelDensityGHK2_type > r (
          channelDensityGHK2_traits::create (i, f, this));

        this->channelDensityGHK2_.push_back (::std::move (r));
        continue;
      }

      // channelDensityNonUniform
      //
      if (n.name () == "channelDensityNonUniform" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< channelDensityNonUniform_type > r (
          channelDensityNonUniform_traits::create (i, f, this));

        this->channelDensityNonUniform_.push_back (::std::move (r));
        continue;
      }

      // channelDensityNonUniformNernst
      //
      if (n.name () == "channelDensityNonUniformNernst" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< channelDensityNonUniformNernst_type > r (
          channelDensityNonUniformNernst_traits::create (i, f, this));

        this->channelDensityNonUniformNernst_.push_back (::std::move (r));
        continue;
      }

      // channelDensityNonUniformGHK
      //
      if (n.name () == "channelDensityNonUniformGHK" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< channelDensityNonUniformGHK_type > r (
          channelDensityNonUniformGHK_traits::create (i, f, this));

        this->channelDensityNonUniformGHK_.push_back (::std::move (r));
        continue;
      }

      // spikeThresh
      //
      if (n.name () == "spikeThresh" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< spikeThresh_type > r (
          spikeThresh_traits::create (i, f, this));

        this->spikeThresh_.push_back (::std::move (r));
        continue;
      }

      // specificCapacitance
      //
      if (n.name () == "specificCapacitance" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< specificCapacitance_type > r (
          specificCapacitance_traits::create (i, f, this));

        this->specificCapacitance_.push_back (::std::move (r));
        continue;
      }

      // initMembPotential
      //
      if (n.name () == "initMembPotential" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< initMembPotential_type > r (
          initMembPotential_traits::create (i, f, this));

        this->initMembPotential_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  MembraneProperties* MembraneProperties::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MembraneProperties (*this, f, c);
  }

  MembraneProperties& MembraneProperties::
  operator= (const MembraneProperties& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->channelPopulation_ = x.channelPopulation_;
      this->channelDensity_ = x.channelDensity_;
      this->channelDensityVShift_ = x.channelDensityVShift_;
      this->channelDensityNernst_ = x.channelDensityNernst_;
      this->channelDensityGHK_ = x.channelDensityGHK_;
      this->channelDensityGHK2_ = x.channelDensityGHK2_;
      this->channelDensityNonUniform_ = x.channelDensityNonUniform_;
      this->channelDensityNonUniformNernst_ = x.channelDensityNonUniformNernst_;
      this->channelDensityNonUniformGHK_ = x.channelDensityNonUniformGHK_;
      this->spikeThresh_ = x.spikeThresh_;
      this->specificCapacitance_ = x.specificCapacitance_;
      this->initMembPotential_ = x.initMembPotential_;
    }

    return *this;
  }

  MembraneProperties::
  ~MembraneProperties ()
  {
  }

  bool
  operator== (const MembraneProperties& x, const MembraneProperties& y)
  {
    if (!(x.channelPopulation () == y.channelPopulation ()))
      return false;

    if (!(x.channelDensity () == y.channelDensity ()))
      return false;

    if (!(x.channelDensityVShift () == y.channelDensityVShift ()))
      return false;

    if (!(x.channelDensityNernst () == y.channelDensityNernst ()))
      return false;

    if (!(x.channelDensityGHK () == y.channelDensityGHK ()))
      return false;

    if (!(x.channelDensityGHK2 () == y.channelDensityGHK2 ()))
      return false;

    if (!(x.channelDensityNonUniform () == y.channelDensityNonUniform ()))
      return false;

    if (!(x.channelDensityNonUniformNernst () == y.channelDensityNonUniformNernst ()))
      return false;

    if (!(x.channelDensityNonUniformGHK () == y.channelDensityNonUniformGHK ()))
      return false;

    if (!(x.spikeThresh () == y.spikeThresh ()))
      return false;

    if (!(x.specificCapacitance () == y.specificCapacitance ()))
      return false;

    if (!(x.initMembPotential () == y.initMembPotential ()))
      return false;

    return true;
  }

  bool
  operator!= (const MembraneProperties& x, const MembraneProperties& y)
  {
    return !(x == y);
  }

  // MembraneProperties2CaPools
  //

  MembraneProperties2CaPools::
  MembraneProperties2CaPools ()
  : ::neuroml2::MembraneProperties (),
    channelDensityNernstCa2_ (this)
  {
  }

  MembraneProperties2CaPools::
  MembraneProperties2CaPools (const MembraneProperties2CaPools& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::neuroml2::MembraneProperties (x, f, c),
    channelDensityNernstCa2_ (x.channelDensityNernstCa2_, f, this)
  {
  }

  MembraneProperties2CaPools::
  MembraneProperties2CaPools (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::neuroml2::MembraneProperties (e, f | ::xml_schema::flags::base, c),
    channelDensityNernstCa2_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void MembraneProperties2CaPools::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::MembraneProperties::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // channelDensityNernstCa2
      //
      if (n.name () == "channelDensityNernstCa2" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< channelDensityNernstCa2_type > r (
          channelDensityNernstCa2_traits::create (i, f, this));

        this->channelDensityNernstCa2_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  MembraneProperties2CaPools* MembraneProperties2CaPools::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MembraneProperties2CaPools (*this, f, c);
  }

  MembraneProperties2CaPools& MembraneProperties2CaPools::
  operator= (const MembraneProperties2CaPools& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::MembraneProperties& > (*this) = x;
      this->channelDensityNernstCa2_ = x.channelDensityNernstCa2_;
    }

    return *this;
  }

  MembraneProperties2CaPools::
  ~MembraneProperties2CaPools ()
  {
  }

  bool
  operator== (const MembraneProperties2CaPools& x, const MembraneProperties2CaPools& y)
  {
    if (!(static_cast< const ::neuroml2::MembraneProperties& > (x) ==
          static_cast< const ::neuroml2::MembraneProperties& > (y)))
      return false;

    if (!(x.channelDensityNernstCa2 () == y.channelDensityNernstCa2 ()))
      return false;

    return true;
  }

  bool
  operator!= (const MembraneProperties2CaPools& x, const MembraneProperties2CaPools& y)
  {
    return !(x == y);
  }

  // SpikeThresh
  //

  const SpikeThresh::segmentGroup_type SpikeThresh::segmentGroup_default_value_ (
    "all");

  SpikeThresh::
  SpikeThresh (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this),
    segmentGroup_ (segmentGroup_default_value (), this)
  {
  }

  SpikeThresh::
  SpikeThresh (const SpikeThresh& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this),
    segmentGroup_ (x.segmentGroup_, f, this)
  {
  }

  SpikeThresh::
  SpikeThresh (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this),
    segmentGroup_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void SpikeThresh::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "segmentGroup" && n.namespace_ ().empty ())
      {
        this->segmentGroup_.set (segmentGroup_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }

    if (!segmentGroup_.present ())
    {
      this->segmentGroup_.set (segmentGroup_default_value ());
    }
  }

  SpikeThresh* SpikeThresh::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SpikeThresh (*this, f, c);
  }

  SpikeThresh& SpikeThresh::
  operator= (const SpikeThresh& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
      this->segmentGroup_ = x.segmentGroup_;
    }

    return *this;
  }

  SpikeThresh::
  ~SpikeThresh ()
  {
  }

  bool
  operator== (const SpikeThresh& x, const SpikeThresh& y)
  {
    if (!(x.value () == y.value ()))
      return false;

    if (!(x.segmentGroup () == y.segmentGroup ()))
      return false;

    return true;
  }

  bool
  operator!= (const SpikeThresh& x, const SpikeThresh& y)
  {
    return !(x == y);
  }

  // SpecificCapacitance
  //

  const SpecificCapacitance::segmentGroup_type SpecificCapacitance::segmentGroup_default_value_ (
    "all");

  SpecificCapacitance::
  SpecificCapacitance (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this),
    segmentGroup_ (segmentGroup_default_value (), this)
  {
  }

  SpecificCapacitance::
  SpecificCapacitance (const SpecificCapacitance& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this),
    segmentGroup_ (x.segmentGroup_, f, this)
  {
  }

  SpecificCapacitance::
  SpecificCapacitance (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this),
    segmentGroup_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void SpecificCapacitance::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "segmentGroup" && n.namespace_ ().empty ())
      {
        this->segmentGroup_.set (segmentGroup_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }

    if (!segmentGroup_.present ())
    {
      this->segmentGroup_.set (segmentGroup_default_value ());
    }
  }

  SpecificCapacitance* SpecificCapacitance::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SpecificCapacitance (*this, f, c);
  }

  SpecificCapacitance& SpecificCapacitance::
  operator= (const SpecificCapacitance& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
      this->segmentGroup_ = x.segmentGroup_;
    }

    return *this;
  }

  SpecificCapacitance::
  ~SpecificCapacitance ()
  {
  }

  bool
  operator== (const SpecificCapacitance& x, const SpecificCapacitance& y)
  {
    if (!(x.value () == y.value ()))
      return false;

    if (!(x.segmentGroup () == y.segmentGroup ()))
      return false;

    return true;
  }

  bool
  operator!= (const SpecificCapacitance& x, const SpecificCapacitance& y)
  {
    return !(x == y);
  }

  // InitMembPotential
  //

  const InitMembPotential::segmentGroup_type InitMembPotential::segmentGroup_default_value_ (
    "all");

  InitMembPotential::
  InitMembPotential (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this),
    segmentGroup_ (segmentGroup_default_value (), this)
  {
  }

  InitMembPotential::
  InitMembPotential (const InitMembPotential& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this),
    segmentGroup_ (x.segmentGroup_, f, this)
  {
  }

  InitMembPotential::
  InitMembPotential (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this),
    segmentGroup_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void InitMembPotential::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "segmentGroup" && n.namespace_ ().empty ())
      {
        this->segmentGroup_.set (segmentGroup_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }

    if (!segmentGroup_.present ())
    {
      this->segmentGroup_.set (segmentGroup_default_value ());
    }
  }

  InitMembPotential* InitMembPotential::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InitMembPotential (*this, f, c);
  }

  InitMembPotential& InitMembPotential::
  operator= (const InitMembPotential& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
      this->segmentGroup_ = x.segmentGroup_;
    }

    return *this;
  }

  InitMembPotential::
  ~InitMembPotential ()
  {
  }

  bool
  operator== (const InitMembPotential& x, const InitMembPotential& y)
  {
    if (!(x.value () == y.value ()))
      return false;

    if (!(x.segmentGroup () == y.segmentGroup ()))
      return false;

    return true;
  }

  bool
  operator!= (const InitMembPotential& x, const InitMembPotential& y)
  {
    return !(x == y);
  }

  // Resistivity
  //

  const Resistivity::segmentGroup_type Resistivity::segmentGroup_default_value_ (
    "all");

  Resistivity::
  Resistivity (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this),
    segmentGroup_ (segmentGroup_default_value (), this)
  {
  }

  Resistivity::
  Resistivity (const Resistivity& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this),
    segmentGroup_ (x.segmentGroup_, f, this)
  {
  }

  Resistivity::
  Resistivity (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this),
    segmentGroup_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Resistivity::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "segmentGroup" && n.namespace_ ().empty ())
      {
        this->segmentGroup_.set (segmentGroup_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }

    if (!segmentGroup_.present ())
    {
      this->segmentGroup_.set (segmentGroup_default_value ());
    }
  }

  Resistivity* Resistivity::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Resistivity (*this, f, c);
  }

  Resistivity& Resistivity::
  operator= (const Resistivity& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
      this->segmentGroup_ = x.segmentGroup_;
    }

    return *this;
  }

  Resistivity::
  ~Resistivity ()
  {
  }

  bool
  operator== (const Resistivity& x, const Resistivity& y)
  {
    if (!(x.value () == y.value ()))
      return false;

    if (!(x.segmentGroup () == y.segmentGroup ()))
      return false;

    return true;
  }

  bool
  operator!= (const Resistivity& x, const Resistivity& y)
  {
    return !(x == y);
  }

  // ChannelPopulation
  //

  const ChannelPopulation::segmentGroup_type ChannelPopulation::segmentGroup_default_value_ (
    "all");

  ChannelPopulation::
  ChannelPopulation (const id_type& id,
                     const ionChannel_type& ionChannel,
                     const number_type& number,
                     const erev_type& erev,
                     const ion_type& ion)
  : ::neuroml2::Base (id),
    variableParameter_ (this),
    ionChannel_ (ionChannel, this),
    number_ (number, this),
    erev_ (erev, this),
    segmentGroup_ (segmentGroup_default_value (), this),
    segment_ (this),
    ion_ (ion, this)
  {
  }

  ChannelPopulation::
  ChannelPopulation (const ChannelPopulation& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    variableParameter_ (x.variableParameter_, f, this),
    ionChannel_ (x.ionChannel_, f, this),
    number_ (x.number_, f, this),
    erev_ (x.erev_, f, this),
    segmentGroup_ (x.segmentGroup_, f, this),
    segment_ (x.segment_, f, this),
    ion_ (x.ion_, f, this)
  {
  }

  ChannelPopulation::
  ChannelPopulation (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    variableParameter_ (this),
    ionChannel_ (this),
    number_ (this),
    erev_ (this),
    segmentGroup_ (this),
    segment_ (this),
    ion_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ChannelPopulation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // variableParameter
      //
      if (n.name () == "variableParameter" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< variableParameter_type > r (
          variableParameter_traits::create (i, f, this));

        this->variableParameter_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ionChannel" && n.namespace_ ().empty ())
      {
        this->ionChannel_.set (ionChannel_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "erev" && n.namespace_ ().empty ())
      {
        this->erev_.set (erev_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "segmentGroup" && n.namespace_ ().empty ())
      {
        this->segmentGroup_.set (segmentGroup_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "segment" && n.namespace_ ().empty ())
      {
        this->segment_.set (segment_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ion" && n.namespace_ ().empty ())
      {
        this->ion_.set (ion_traits::create (i, f, this));
        continue;
      }
    }

    if (!ionChannel_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ionChannel",
        "");
    }

    if (!number_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "number",
        "");
    }

    if (!erev_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "erev",
        "");
    }

    if (!segmentGroup_.present ())
    {
      this->segmentGroup_.set (segmentGroup_default_value ());
    }

    if (!ion_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ion",
        "");
    }
  }

  ChannelPopulation* ChannelPopulation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ChannelPopulation (*this, f, c);
  }

  ChannelPopulation& ChannelPopulation::
  operator= (const ChannelPopulation& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->variableParameter_ = x.variableParameter_;
      this->ionChannel_ = x.ionChannel_;
      this->number_ = x.number_;
      this->erev_ = x.erev_;
      this->segmentGroup_ = x.segmentGroup_;
      this->segment_ = x.segment_;
      this->ion_ = x.ion_;
    }

    return *this;
  }

  ChannelPopulation::
  ~ChannelPopulation ()
  {
  }

  bool
  operator== (const ChannelPopulation& x, const ChannelPopulation& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.variableParameter () == y.variableParameter ()))
      return false;

    if (!(x.ionChannel () == y.ionChannel ()))
      return false;

    if (!(x.number () == y.number ()))
      return false;

    if (!(x.erev () == y.erev ()))
      return false;

    if (!(x.segmentGroup () == y.segmentGroup ()))
      return false;

    if (!(x.segment () == y.segment ()))
      return false;

    if (!(x.ion () == y.ion ()))
      return false;

    return true;
  }

  bool
  operator!= (const ChannelPopulation& x, const ChannelPopulation& y)
  {
    return !(x == y);
  }

  // ChannelDensityNonUniform
  //

  ChannelDensityNonUniform::
  ChannelDensityNonUniform (const id_type& id,
                            const ionChannel_type& ionChannel,
                            const erev_type& erev,
                            const ion_type& ion)
  : ::neuroml2::Base (id),
    variableParameter_ (this),
    ionChannel_ (ionChannel, this),
    erev_ (erev, this),
    ion_ (ion, this)
  {
  }

  ChannelDensityNonUniform::
  ChannelDensityNonUniform (const ChannelDensityNonUniform& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    variableParameter_ (x.variableParameter_, f, this),
    ionChannel_ (x.ionChannel_, f, this),
    erev_ (x.erev_, f, this),
    ion_ (x.ion_, f, this)
  {
  }

  ChannelDensityNonUniform::
  ChannelDensityNonUniform (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    variableParameter_ (this),
    ionChannel_ (this),
    erev_ (this),
    ion_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ChannelDensityNonUniform::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // variableParameter
      //
      if (n.name () == "variableParameter" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< variableParameter_type > r (
          variableParameter_traits::create (i, f, this));

        this->variableParameter_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ionChannel" && n.namespace_ ().empty ())
      {
        this->ionChannel_.set (ionChannel_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "erev" && n.namespace_ ().empty ())
      {
        this->erev_.set (erev_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ion" && n.namespace_ ().empty ())
      {
        this->ion_.set (ion_traits::create (i, f, this));
        continue;
      }
    }

    if (!ionChannel_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ionChannel",
        "");
    }

    if (!erev_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "erev",
        "");
    }

    if (!ion_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ion",
        "");
    }
  }

  ChannelDensityNonUniform* ChannelDensityNonUniform::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ChannelDensityNonUniform (*this, f, c);
  }

  ChannelDensityNonUniform& ChannelDensityNonUniform::
  operator= (const ChannelDensityNonUniform& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->variableParameter_ = x.variableParameter_;
      this->ionChannel_ = x.ionChannel_;
      this->erev_ = x.erev_;
      this->ion_ = x.ion_;
    }

    return *this;
  }

  ChannelDensityNonUniform::
  ~ChannelDensityNonUniform ()
  {
  }

  bool
  operator== (const ChannelDensityNonUniform& x, const ChannelDensityNonUniform& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.variableParameter () == y.variableParameter ()))
      return false;

    if (!(x.ionChannel () == y.ionChannel ()))
      return false;

    if (!(x.erev () == y.erev ()))
      return false;

    if (!(x.ion () == y.ion ()))
      return false;

    return true;
  }

  bool
  operator!= (const ChannelDensityNonUniform& x, const ChannelDensityNonUniform& y)
  {
    return !(x == y);
  }

  // ChannelDensityNonUniformNernst
  //

  ChannelDensityNonUniformNernst::
  ChannelDensityNonUniformNernst (const id_type& id,
                                  const ionChannel_type& ionChannel,
                                  const ion_type& ion)
  : ::neuroml2::Base (id),
    variableParameter_ (this),
    ionChannel_ (ionChannel, this),
    ion_ (ion, this)
  {
  }

  ChannelDensityNonUniformNernst::
  ChannelDensityNonUniformNernst (const ChannelDensityNonUniformNernst& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    variableParameter_ (x.variableParameter_, f, this),
    ionChannel_ (x.ionChannel_, f, this),
    ion_ (x.ion_, f, this)
  {
  }

  ChannelDensityNonUniformNernst::
  ChannelDensityNonUniformNernst (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    variableParameter_ (this),
    ionChannel_ (this),
    ion_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ChannelDensityNonUniformNernst::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // variableParameter
      //
      if (n.name () == "variableParameter" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< variableParameter_type > r (
          variableParameter_traits::create (i, f, this));

        this->variableParameter_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ionChannel" && n.namespace_ ().empty ())
      {
        this->ionChannel_.set (ionChannel_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ion" && n.namespace_ ().empty ())
      {
        this->ion_.set (ion_traits::create (i, f, this));
        continue;
      }
    }

    if (!ionChannel_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ionChannel",
        "");
    }

    if (!ion_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ion",
        "");
    }
  }

  ChannelDensityNonUniformNernst* ChannelDensityNonUniformNernst::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ChannelDensityNonUniformNernst (*this, f, c);
  }

  ChannelDensityNonUniformNernst& ChannelDensityNonUniformNernst::
  operator= (const ChannelDensityNonUniformNernst& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->variableParameter_ = x.variableParameter_;
      this->ionChannel_ = x.ionChannel_;
      this->ion_ = x.ion_;
    }

    return *this;
  }

  ChannelDensityNonUniformNernst::
  ~ChannelDensityNonUniformNernst ()
  {
  }

  bool
  operator== (const ChannelDensityNonUniformNernst& x, const ChannelDensityNonUniformNernst& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.variableParameter () == y.variableParameter ()))
      return false;

    if (!(x.ionChannel () == y.ionChannel ()))
      return false;

    if (!(x.ion () == y.ion ()))
      return false;

    return true;
  }

  bool
  operator!= (const ChannelDensityNonUniformNernst& x, const ChannelDensityNonUniformNernst& y)
  {
    return !(x == y);
  }

  // ChannelDensityNonUniformGHK
  //

  ChannelDensityNonUniformGHK::
  ChannelDensityNonUniformGHK (const id_type& id,
                               const ionChannel_type& ionChannel,
                               const ion_type& ion)
  : ::neuroml2::Base (id),
    variableParameter_ (this),
    ionChannel_ (ionChannel, this),
    ion_ (ion, this)
  {
  }

  ChannelDensityNonUniformGHK::
  ChannelDensityNonUniformGHK (const ChannelDensityNonUniformGHK& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    variableParameter_ (x.variableParameter_, f, this),
    ionChannel_ (x.ionChannel_, f, this),
    ion_ (x.ion_, f, this)
  {
  }

  ChannelDensityNonUniformGHK::
  ChannelDensityNonUniformGHK (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    variableParameter_ (this),
    ionChannel_ (this),
    ion_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ChannelDensityNonUniformGHK::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // variableParameter
      //
      if (n.name () == "variableParameter" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< variableParameter_type > r (
          variableParameter_traits::create (i, f, this));

        this->variableParameter_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ionChannel" && n.namespace_ ().empty ())
      {
        this->ionChannel_.set (ionChannel_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ion" && n.namespace_ ().empty ())
      {
        this->ion_.set (ion_traits::create (i, f, this));
        continue;
      }
    }

    if (!ionChannel_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ionChannel",
        "");
    }

    if (!ion_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ion",
        "");
    }
  }

  ChannelDensityNonUniformGHK* ChannelDensityNonUniformGHK::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ChannelDensityNonUniformGHK (*this, f, c);
  }

  ChannelDensityNonUniformGHK& ChannelDensityNonUniformGHK::
  operator= (const ChannelDensityNonUniformGHK& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->variableParameter_ = x.variableParameter_;
      this->ionChannel_ = x.ionChannel_;
      this->ion_ = x.ion_;
    }

    return *this;
  }

  ChannelDensityNonUniformGHK::
  ~ChannelDensityNonUniformGHK ()
  {
  }

  bool
  operator== (const ChannelDensityNonUniformGHK& x, const ChannelDensityNonUniformGHK& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.variableParameter () == y.variableParameter ()))
      return false;

    if (!(x.ionChannel () == y.ionChannel ()))
      return false;

    if (!(x.ion () == y.ion ()))
      return false;

    return true;
  }

  bool
  operator!= (const ChannelDensityNonUniformGHK& x, const ChannelDensityNonUniformGHK& y)
  {
    return !(x == y);
  }

  // ChannelDensity
  //

  const ChannelDensity::segmentGroup_type ChannelDensity::segmentGroup_default_value_ (
    "all");

  ChannelDensity::
  ChannelDensity (const id_type& id,
                  const ionChannel_type& ionChannel,
                  const erev_type& erev,
                  const ion_type& ion)
  : ::neuroml2::Base (id),
    variableParameter_ (this),
    ionChannel_ (ionChannel, this),
    condDensity_ (this),
    erev_ (erev, this),
    segmentGroup_ (segmentGroup_default_value (), this),
    segment_ (this),
    ion_ (ion, this)
  {
  }

  ChannelDensity::
  ChannelDensity (const ChannelDensity& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    variableParameter_ (x.variableParameter_, f, this),
    ionChannel_ (x.ionChannel_, f, this),
    condDensity_ (x.condDensity_, f, this),
    erev_ (x.erev_, f, this),
    segmentGroup_ (x.segmentGroup_, f, this),
    segment_ (x.segment_, f, this),
    ion_ (x.ion_, f, this)
  {
  }

  ChannelDensity::
  ChannelDensity (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    variableParameter_ (this),
    ionChannel_ (this),
    condDensity_ (this),
    erev_ (this),
    segmentGroup_ (this),
    segment_ (this),
    ion_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ChannelDensity::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // variableParameter
      //
      if (n.name () == "variableParameter" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< variableParameter_type > r (
          variableParameter_traits::create (i, f, this));

        this->variableParameter_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ionChannel" && n.namespace_ ().empty ())
      {
        this->ionChannel_.set (ionChannel_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "condDensity" && n.namespace_ ().empty ())
      {
        this->condDensity_.set (condDensity_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "erev" && n.namespace_ ().empty ())
      {
        this->erev_.set (erev_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "segmentGroup" && n.namespace_ ().empty ())
      {
        this->segmentGroup_.set (segmentGroup_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "segment" && n.namespace_ ().empty ())
      {
        this->segment_.set (segment_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ion" && n.namespace_ ().empty ())
      {
        this->ion_.set (ion_traits::create (i, f, this));
        continue;
      }
    }

    if (!ionChannel_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ionChannel",
        "");
    }

    if (!erev_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "erev",
        "");
    }

    if (!segmentGroup_.present ())
    {
      this->segmentGroup_.set (segmentGroup_default_value ());
    }

    if (!ion_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ion",
        "");
    }
  }

  ChannelDensity* ChannelDensity::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ChannelDensity (*this, f, c);
  }

  ChannelDensity& ChannelDensity::
  operator= (const ChannelDensity& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->variableParameter_ = x.variableParameter_;
      this->ionChannel_ = x.ionChannel_;
      this->condDensity_ = x.condDensity_;
      this->erev_ = x.erev_;
      this->segmentGroup_ = x.segmentGroup_;
      this->segment_ = x.segment_;
      this->ion_ = x.ion_;
    }

    return *this;
  }

  ChannelDensity::
  ~ChannelDensity ()
  {
  }

  bool
  operator== (const ChannelDensity& x, const ChannelDensity& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.variableParameter () == y.variableParameter ()))
      return false;

    if (!(x.ionChannel () == y.ionChannel ()))
      return false;

    if (!(x.condDensity () == y.condDensity ()))
      return false;

    if (!(x.erev () == y.erev ()))
      return false;

    if (!(x.segmentGroup () == y.segmentGroup ()))
      return false;

    if (!(x.segment () == y.segment ()))
      return false;

    if (!(x.ion () == y.ion ()))
      return false;

    return true;
  }

  bool
  operator!= (const ChannelDensity& x, const ChannelDensity& y)
  {
    return !(x == y);
  }

  // ChannelDensityVShift
  //

  ChannelDensityVShift::
  ChannelDensityVShift (const id_type& id,
                        const ionChannel_type& ionChannel,
                        const erev_type& erev,
                        const ion_type& ion,
                        const vShift_type& vShift)
  : ::neuroml2::ChannelDensity (id,
                                ionChannel,
                                erev,
                                ion),
    vShift_ (vShift, this)
  {
  }

  ChannelDensityVShift::
  ChannelDensityVShift (const ChannelDensityVShift& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::neuroml2::ChannelDensity (x, f, c),
    vShift_ (x.vShift_, f, this)
  {
  }

  ChannelDensityVShift::
  ChannelDensityVShift (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::neuroml2::ChannelDensity (e, f | ::xml_schema::flags::base, c),
    vShift_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ChannelDensityVShift::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::ChannelDensity::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "vShift" && n.namespace_ ().empty ())
      {
        this->vShift_.set (vShift_traits::create (i, f, this));
        continue;
      }
    }

    if (!vShift_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "vShift",
        "");
    }
  }

  ChannelDensityVShift* ChannelDensityVShift::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ChannelDensityVShift (*this, f, c);
  }

  ChannelDensityVShift& ChannelDensityVShift::
  operator= (const ChannelDensityVShift& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::ChannelDensity& > (*this) = x;
      this->vShift_ = x.vShift_;
    }

    return *this;
  }

  ChannelDensityVShift::
  ~ChannelDensityVShift ()
  {
  }

  bool
  operator== (const ChannelDensityVShift& x, const ChannelDensityVShift& y)
  {
    if (!(static_cast< const ::neuroml2::ChannelDensity& > (x) ==
          static_cast< const ::neuroml2::ChannelDensity& > (y)))
      return false;

    if (!(x.vShift () == y.vShift ()))
      return false;

    return true;
  }

  bool
  operator!= (const ChannelDensityVShift& x, const ChannelDensityVShift& y)
  {
    return !(x == y);
  }

  // ChannelDensityNernst
  //

  const ChannelDensityNernst::segmentGroup_type ChannelDensityNernst::segmentGroup_default_value_ (
    "all");

  ChannelDensityNernst::
  ChannelDensityNernst (const id_type& id,
                        const ionChannel_type& ionChannel,
                        const ion_type& ion)
  : ::neuroml2::Base (id),
    variableParameter_ (this),
    ionChannel_ (ionChannel, this),
    condDensity_ (this),
    segmentGroup_ (segmentGroup_default_value (), this),
    segment_ (this),
    ion_ (ion, this)
  {
  }

  ChannelDensityNernst::
  ChannelDensityNernst (const ChannelDensityNernst& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    variableParameter_ (x.variableParameter_, f, this),
    ionChannel_ (x.ionChannel_, f, this),
    condDensity_ (x.condDensity_, f, this),
    segmentGroup_ (x.segmentGroup_, f, this),
    segment_ (x.segment_, f, this),
    ion_ (x.ion_, f, this)
  {
  }

  ChannelDensityNernst::
  ChannelDensityNernst (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    variableParameter_ (this),
    ionChannel_ (this),
    condDensity_ (this),
    segmentGroup_ (this),
    segment_ (this),
    ion_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ChannelDensityNernst::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // variableParameter
      //
      if (n.name () == "variableParameter" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< variableParameter_type > r (
          variableParameter_traits::create (i, f, this));

        this->variableParameter_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ionChannel" && n.namespace_ ().empty ())
      {
        this->ionChannel_.set (ionChannel_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "condDensity" && n.namespace_ ().empty ())
      {
        this->condDensity_.set (condDensity_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "segmentGroup" && n.namespace_ ().empty ())
      {
        this->segmentGroup_.set (segmentGroup_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "segment" && n.namespace_ ().empty ())
      {
        this->segment_.set (segment_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ion" && n.namespace_ ().empty ())
      {
        this->ion_.set (ion_traits::create (i, f, this));
        continue;
      }
    }

    if (!ionChannel_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ionChannel",
        "");
    }

    if (!segmentGroup_.present ())
    {
      this->segmentGroup_.set (segmentGroup_default_value ());
    }

    if (!ion_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ion",
        "");
    }
  }

  ChannelDensityNernst* ChannelDensityNernst::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ChannelDensityNernst (*this, f, c);
  }

  ChannelDensityNernst& ChannelDensityNernst::
  operator= (const ChannelDensityNernst& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->variableParameter_ = x.variableParameter_;
      this->ionChannel_ = x.ionChannel_;
      this->condDensity_ = x.condDensity_;
      this->segmentGroup_ = x.segmentGroup_;
      this->segment_ = x.segment_;
      this->ion_ = x.ion_;
    }

    return *this;
  }

  ChannelDensityNernst::
  ~ChannelDensityNernst ()
  {
  }

  bool
  operator== (const ChannelDensityNernst& x, const ChannelDensityNernst& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.variableParameter () == y.variableParameter ()))
      return false;

    if (!(x.ionChannel () == y.ionChannel ()))
      return false;

    if (!(x.condDensity () == y.condDensity ()))
      return false;

    if (!(x.segmentGroup () == y.segmentGroup ()))
      return false;

    if (!(x.segment () == y.segment ()))
      return false;

    if (!(x.ion () == y.ion ()))
      return false;

    return true;
  }

  bool
  operator!= (const ChannelDensityNernst& x, const ChannelDensityNernst& y)
  {
    return !(x == y);
  }

  // ChannelDensityNernstCa2
  //

  ChannelDensityNernstCa2::
  ChannelDensityNernstCa2 (const id_type& id,
                           const ionChannel_type& ionChannel,
                           const ion_type& ion)
  : ::neuroml2::ChannelDensityNernst (id,
                                      ionChannel,
                                      ion)
  {
  }

  ChannelDensityNernstCa2::
  ChannelDensityNernstCa2 (const ChannelDensityNernstCa2& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::neuroml2::ChannelDensityNernst (x, f, c)
  {
  }

  ChannelDensityNernstCa2::
  ChannelDensityNernstCa2 (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::neuroml2::ChannelDensityNernst (e, f, c)
  {
  }

  ChannelDensityNernstCa2* ChannelDensityNernstCa2::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ChannelDensityNernstCa2 (*this, f, c);
  }

  ChannelDensityNernstCa2::
  ~ChannelDensityNernstCa2 ()
  {
  }

  // ChannelDensityGHK
  //

  const ChannelDensityGHK::segmentGroup_type ChannelDensityGHK::segmentGroup_default_value_ (
    "all");

  ChannelDensityGHK::
  ChannelDensityGHK (const id_type& id,
                     const ionChannel_type& ionChannel,
                     const permeability_type& permeability,
                     const ion_type& ion)
  : ::neuroml2::Base (id),
    ionChannel_ (ionChannel, this),
    permeability_ (permeability, this),
    segmentGroup_ (segmentGroup_default_value (), this),
    segment_ (this),
    ion_ (ion, this)
  {
  }

  ChannelDensityGHK::
  ChannelDensityGHK (const ChannelDensityGHK& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    ionChannel_ (x.ionChannel_, f, this),
    permeability_ (x.permeability_, f, this),
    segmentGroup_ (x.segmentGroup_, f, this),
    segment_ (x.segment_, f, this),
    ion_ (x.ion_, f, this)
  {
  }

  ChannelDensityGHK::
  ChannelDensityGHK (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    ionChannel_ (this),
    permeability_ (this),
    segmentGroup_ (this),
    segment_ (this),
    ion_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ChannelDensityGHK::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ionChannel" && n.namespace_ ().empty ())
      {
        this->ionChannel_.set (ionChannel_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "permeability" && n.namespace_ ().empty ())
      {
        this->permeability_.set (permeability_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "segmentGroup" && n.namespace_ ().empty ())
      {
        this->segmentGroup_.set (segmentGroup_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "segment" && n.namespace_ ().empty ())
      {
        this->segment_.set (segment_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ion" && n.namespace_ ().empty ())
      {
        this->ion_.set (ion_traits::create (i, f, this));
        continue;
      }
    }

    if (!ionChannel_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ionChannel",
        "");
    }

    if (!permeability_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "permeability",
        "");
    }

    if (!segmentGroup_.present ())
    {
      this->segmentGroup_.set (segmentGroup_default_value ());
    }

    if (!ion_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ion",
        "");
    }
  }

  ChannelDensityGHK* ChannelDensityGHK::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ChannelDensityGHK (*this, f, c);
  }

  ChannelDensityGHK& ChannelDensityGHK::
  operator= (const ChannelDensityGHK& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->ionChannel_ = x.ionChannel_;
      this->permeability_ = x.permeability_;
      this->segmentGroup_ = x.segmentGroup_;
      this->segment_ = x.segment_;
      this->ion_ = x.ion_;
    }

    return *this;
  }

  ChannelDensityGHK::
  ~ChannelDensityGHK ()
  {
  }

  bool
  operator== (const ChannelDensityGHK& x, const ChannelDensityGHK& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.ionChannel () == y.ionChannel ()))
      return false;

    if (!(x.permeability () == y.permeability ()))
      return false;

    if (!(x.segmentGroup () == y.segmentGroup ()))
      return false;

    if (!(x.segment () == y.segment ()))
      return false;

    if (!(x.ion () == y.ion ()))
      return false;

    return true;
  }

  bool
  operator!= (const ChannelDensityGHK& x, const ChannelDensityGHK& y)
  {
    return !(x == y);
  }

  // ChannelDensityGHK2
  //

  const ChannelDensityGHK2::segmentGroup_type ChannelDensityGHK2::segmentGroup_default_value_ (
    "all");

  ChannelDensityGHK2::
  ChannelDensityGHK2 (const id_type& id,
                      const ionChannel_type& ionChannel,
                      const ion_type& ion)
  : ::neuroml2::Base (id),
    ionChannel_ (ionChannel, this),
    condDensity_ (this),
    segmentGroup_ (segmentGroup_default_value (), this),
    segment_ (this),
    ion_ (ion, this)
  {
  }

  ChannelDensityGHK2::
  ChannelDensityGHK2 (const ChannelDensityGHK2& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    ionChannel_ (x.ionChannel_, f, this),
    condDensity_ (x.condDensity_, f, this),
    segmentGroup_ (x.segmentGroup_, f, this),
    segment_ (x.segment_, f, this),
    ion_ (x.ion_, f, this)
  {
  }

  ChannelDensityGHK2::
  ChannelDensityGHK2 (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    ionChannel_ (this),
    condDensity_ (this),
    segmentGroup_ (this),
    segment_ (this),
    ion_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ChannelDensityGHK2::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ionChannel" && n.namespace_ ().empty ())
      {
        this->ionChannel_.set (ionChannel_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "condDensity" && n.namespace_ ().empty ())
      {
        this->condDensity_.set (condDensity_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "segmentGroup" && n.namespace_ ().empty ())
      {
        this->segmentGroup_.set (segmentGroup_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "segment" && n.namespace_ ().empty ())
      {
        this->segment_.set (segment_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ion" && n.namespace_ ().empty ())
      {
        this->ion_.set (ion_traits::create (i, f, this));
        continue;
      }
    }

    if (!ionChannel_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ionChannel",
        "");
    }

    if (!segmentGroup_.present ())
    {
      this->segmentGroup_.set (segmentGroup_default_value ());
    }

    if (!ion_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ion",
        "");
    }
  }

  ChannelDensityGHK2* ChannelDensityGHK2::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ChannelDensityGHK2 (*this, f, c);
  }

  ChannelDensityGHK2& ChannelDensityGHK2::
  operator= (const ChannelDensityGHK2& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->ionChannel_ = x.ionChannel_;
      this->condDensity_ = x.condDensity_;
      this->segmentGroup_ = x.segmentGroup_;
      this->segment_ = x.segment_;
      this->ion_ = x.ion_;
    }

    return *this;
  }

  ChannelDensityGHK2::
  ~ChannelDensityGHK2 ()
  {
  }

  bool
  operator== (const ChannelDensityGHK2& x, const ChannelDensityGHK2& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.ionChannel () == y.ionChannel ()))
      return false;

    if (!(x.condDensity () == y.condDensity ()))
      return false;

    if (!(x.segmentGroup () == y.segmentGroup ()))
      return false;

    if (!(x.segment () == y.segment ()))
      return false;

    if (!(x.ion () == y.ion ()))
      return false;

    return true;
  }

  bool
  operator!= (const ChannelDensityGHK2& x, const ChannelDensityGHK2& y)
  {
    return !(x == y);
  }

  // VariableParameter
  //

  VariableParameter::
  VariableParameter (const parameter_type& parameter,
                     const segmentGroup_type& segmentGroup)
  : ::xml_schema::type (),
    inhomogeneousValue_ (this),
    parameter_ (parameter, this),
    segmentGroup_ (segmentGroup, this)
  {
  }

  VariableParameter::
  VariableParameter (const VariableParameter& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    inhomogeneousValue_ (x.inhomogeneousValue_, f, this),
    parameter_ (x.parameter_, f, this),
    segmentGroup_ (x.segmentGroup_, f, this)
  {
  }

  VariableParameter::
  VariableParameter (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    inhomogeneousValue_ (this),
    parameter_ (this),
    segmentGroup_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void VariableParameter::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // inhomogeneousValue
      //
      if (n.name () == "inhomogeneousValue" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< inhomogeneousValue_type > r (
          inhomogeneousValue_traits::create (i, f, this));

        if (!this->inhomogeneousValue_)
        {
          this->inhomogeneousValue_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "parameter" && n.namespace_ ().empty ())
      {
        this->parameter_.set (parameter_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "segmentGroup" && n.namespace_ ().empty ())
      {
        this->segmentGroup_.set (segmentGroup_traits::create (i, f, this));
        continue;
      }
    }

    if (!parameter_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "parameter",
        "");
    }

    if (!segmentGroup_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "segmentGroup",
        "");
    }
  }

  VariableParameter* VariableParameter::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VariableParameter (*this, f, c);
  }

  VariableParameter& VariableParameter::
  operator= (const VariableParameter& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->inhomogeneousValue_ = x.inhomogeneousValue_;
      this->parameter_ = x.parameter_;
      this->segmentGroup_ = x.segmentGroup_;
    }

    return *this;
  }

  VariableParameter::
  ~VariableParameter ()
  {
  }

  bool
  operator== (const VariableParameter& x, const VariableParameter& y)
  {
    if (!(x.inhomogeneousValue () == y.inhomogeneousValue ()))
      return false;

    if (!(x.parameter () == y.parameter ()))
      return false;

    if (!(x.segmentGroup () == y.segmentGroup ()))
      return false;

    return true;
  }

  bool
  operator!= (const VariableParameter& x, const VariableParameter& y)
  {
    return !(x == y);
  }

  // InhomogeneousValue
  //

  InhomogeneousValue::
  InhomogeneousValue (const inhomogeneousParameter_type& inhomogeneousParameter,
                      const value_type& value)
  : ::xml_schema::type (),
    inhomogeneousParameter_ (inhomogeneousParameter, this),
    value_ (value, this)
  {
  }

  InhomogeneousValue::
  InhomogeneousValue (const InhomogeneousValue& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    inhomogeneousParameter_ (x.inhomogeneousParameter_, f, this),
    value_ (x.value_, f, this)
  {
  }

  InhomogeneousValue::
  InhomogeneousValue (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    inhomogeneousParameter_ (this),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void InhomogeneousValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "inhomogeneousParameter" && n.namespace_ ().empty ())
      {
        this->inhomogeneousParameter_.set (inhomogeneousParameter_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!inhomogeneousParameter_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "inhomogeneousParameter",
        "");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  InhomogeneousValue* InhomogeneousValue::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InhomogeneousValue (*this, f, c);
  }

  InhomogeneousValue& InhomogeneousValue::
  operator= (const InhomogeneousValue& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->inhomogeneousParameter_ = x.inhomogeneousParameter_;
      this->value_ = x.value_;
    }

    return *this;
  }

  InhomogeneousValue::
  ~InhomogeneousValue ()
  {
  }

  bool
  operator== (const InhomogeneousValue& x, const InhomogeneousValue& y)
  {
    if (!(x.inhomogeneousParameter () == y.inhomogeneousParameter ()))
      return false;

    if (!(x.value () == y.value ()))
      return false;

    return true;
  }

  bool
  operator!= (const InhomogeneousValue& x, const InhomogeneousValue& y)
  {
    return !(x == y);
  }

  // Species
  //

  const Species::segmentGroup_type Species::segmentGroup_default_value_ (
    "all");

  Species::
  Species (const id_type& id,
           const concentrationModel_type& concentrationModel,
           const initialConcentration_type& initialConcentration,
           const initialExtConcentration_type& initialExtConcentration)
  : ::xml_schema::type (),
    id_ (id, this),
    concentrationModel_ (concentrationModel, this),
    ion_ (this),
    initialConcentration_ (initialConcentration, this),
    initialExtConcentration_ (initialExtConcentration, this),
    segmentGroup_ (segmentGroup_default_value (), this)
  {
  }

  Species::
  Species (const Species& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this),
    concentrationModel_ (x.concentrationModel_, f, this),
    ion_ (x.ion_, f, this),
    initialConcentration_ (x.initialConcentration_, f, this),
    initialExtConcentration_ (x.initialExtConcentration_, f, this),
    segmentGroup_ (x.segmentGroup_, f, this)
  {
  }

  Species::
  Species (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (this),
    concentrationModel_ (this),
    ion_ (this),
    initialConcentration_ (this),
    initialExtConcentration_ (this),
    segmentGroup_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Species::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "concentrationModel" && n.namespace_ ().empty ())
      {
        this->concentrationModel_.set (concentrationModel_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ion" && n.namespace_ ().empty ())
      {
        this->ion_.set (ion_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "initialConcentration" && n.namespace_ ().empty ())
      {
        this->initialConcentration_.set (initialConcentration_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "initialExtConcentration" && n.namespace_ ().empty ())
      {
        this->initialExtConcentration_.set (initialExtConcentration_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "segmentGroup" && n.namespace_ ().empty ())
      {
        this->segmentGroup_.set (segmentGroup_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!concentrationModel_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "concentrationModel",
        "");
    }

    if (!initialConcentration_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "initialConcentration",
        "");
    }

    if (!initialExtConcentration_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "initialExtConcentration",
        "");
    }

    if (!segmentGroup_.present ())
    {
      this->segmentGroup_.set (segmentGroup_default_value ());
    }
  }

  Species* Species::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Species (*this, f, c);
  }

  Species& Species::
  operator= (const Species& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->id_ = x.id_;
      this->concentrationModel_ = x.concentrationModel_;
      this->ion_ = x.ion_;
      this->initialConcentration_ = x.initialConcentration_;
      this->initialExtConcentration_ = x.initialExtConcentration_;
      this->segmentGroup_ = x.segmentGroup_;
    }

    return *this;
  }

  Species::
  ~Species ()
  {
  }

  bool
  operator== (const Species& x, const Species& y)
  {
    if (!(x.id () == y.id ()))
      return false;

    if (!(x.concentrationModel () == y.concentrationModel ()))
      return false;

    if (!(x.ion () == y.ion ()))
      return false;

    if (!(x.initialConcentration () == y.initialConcentration ()))
      return false;

    if (!(x.initialExtConcentration () == y.initialExtConcentration ()))
      return false;

    if (!(x.segmentGroup () == y.segmentGroup ()))
      return false;

    return true;
  }

  bool
  operator!= (const Species& x, const Species& y)
  {
    return !(x == y);
  }

  // ConcentrationModel_D
  //

  const ConcentrationModel_D::type_type ConcentrationModel_D::type_default_value_ (
    ::xml_schema::simple_type ("decayingPoolConcentrationModel"));

  ConcentrationModel_D::
  ConcentrationModel_D (const id_type& id,
                        const ion_type& ion,
                        const restingConc_type& restingConc,
                        const decayConstant_type& decayConstant,
                        const shellThickness_type& shellThickness)
  : ::neuroml2::DecayingPoolConcentrationModel (id,
                                                ion,
                                                restingConc,
                                                decayConstant,
                                                shellThickness),
    type_ (type_default_value (), this)
  {
  }

  ConcentrationModel_D::
  ConcentrationModel_D (const ConcentrationModel_D& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::neuroml2::DecayingPoolConcentrationModel (x, f, c),
    type_ (x.type_, f, this)
  {
  }

  ConcentrationModel_D::
  ConcentrationModel_D (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::neuroml2::DecayingPoolConcentrationModel (e, f | ::xml_schema::flags::base, c),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ConcentrationModel_D::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::DecayingPoolConcentrationModel::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      this->type_.set (type_default_value ());
    }
  }

  ConcentrationModel_D* ConcentrationModel_D::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConcentrationModel_D (*this, f, c);
  }

  ConcentrationModel_D& ConcentrationModel_D::
  operator= (const ConcentrationModel_D& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::DecayingPoolConcentrationModel& > (*this) = x;
      this->type_ = x.type_;
    }

    return *this;
  }

  ConcentrationModel_D::
  ~ConcentrationModel_D ()
  {
  }

  bool
  operator== (const ConcentrationModel_D& x, const ConcentrationModel_D& y)
  {
    if (!(static_cast< const ::neuroml2::DecayingPoolConcentrationModel& > (x) ==
          static_cast< const ::neuroml2::DecayingPoolConcentrationModel& > (y)))
      return false;

    if (!(x.type () == y.type ()))
      return false;

    return true;
  }

  bool
  operator!= (const ConcentrationModel_D& x, const ConcentrationModel_D& y)
  {
    return !(x == y);
  }

  // IntracellularProperties
  //

  IntracellularProperties::
  IntracellularProperties ()
  : ::xml_schema::type (),
    species_ (this),
    resistivity_ (this)
  {
  }

  IntracellularProperties::
  IntracellularProperties (const IntracellularProperties& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    species_ (x.species_, f, this),
    resistivity_ (x.resistivity_, f, this)
  {
  }

  IntracellularProperties::
  IntracellularProperties (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    species_ (this),
    resistivity_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void IntracellularProperties::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // species
      //
      if (n.name () == "species" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< species_type > r (
          species_traits::create (i, f, this));

        this->species_.push_back (::std::move (r));
        continue;
      }

      // resistivity
      //
      if (n.name () == "resistivity" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< resistivity_type > r (
          resistivity_traits::create (i, f, this));

        this->resistivity_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  IntracellularProperties* IntracellularProperties::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IntracellularProperties (*this, f, c);
  }

  IntracellularProperties& IntracellularProperties::
  operator= (const IntracellularProperties& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->species_ = x.species_;
      this->resistivity_ = x.resistivity_;
    }

    return *this;
  }

  IntracellularProperties::
  ~IntracellularProperties ()
  {
  }

  bool
  operator== (const IntracellularProperties& x, const IntracellularProperties& y)
  {
    if (!(x.species () == y.species ()))
      return false;

    if (!(x.resistivity () == y.resistivity ()))
      return false;

    return true;
  }

  bool
  operator!= (const IntracellularProperties& x, const IntracellularProperties& y)
  {
    return !(x == y);
  }

  // IntracellularProperties2CaPools
  //

  IntracellularProperties2CaPools::
  IntracellularProperties2CaPools ()
  : ::neuroml2::IntracellularProperties ()
  {
  }

  IntracellularProperties2CaPools::
  IntracellularProperties2CaPools (const IntracellularProperties2CaPools& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::neuroml2::IntracellularProperties (x, f, c)
  {
  }

  IntracellularProperties2CaPools::
  IntracellularProperties2CaPools (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::neuroml2::IntracellularProperties (e, f, c)
  {
  }

  IntracellularProperties2CaPools* IntracellularProperties2CaPools::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IntracellularProperties2CaPools (*this, f, c);
  }

  IntracellularProperties2CaPools::
  ~IntracellularProperties2CaPools ()
  {
  }

  // ExtracellularProperties
  //

  ExtracellularProperties::
  ExtracellularProperties (const id_type& id)
  : ::neuroml2::Base (id),
    species_ (this)
  {
  }

  ExtracellularProperties::
  ExtracellularProperties (const ExtracellularProperties& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    species_ (x.species_, f, this)
  {
  }

  ExtracellularProperties::
  ExtracellularProperties (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    species_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ExtracellularProperties::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // species
      //
      if (n.name () == "species" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< species_type > r (
          species_traits::create (i, f, this));

        this->species_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ExtracellularProperties* ExtracellularProperties::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ExtracellularProperties (*this, f, c);
  }

  ExtracellularProperties& ExtracellularProperties::
  operator= (const ExtracellularProperties& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->species_ = x.species_;
    }

    return *this;
  }

  ExtracellularProperties::
  ~ExtracellularProperties ()
  {
  }

  bool
  operator== (const ExtracellularProperties& x, const ExtracellularProperties& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.species () == y.species ()))
      return false;

    return true;
  }

  bool
  operator!= (const ExtracellularProperties& x, const ExtracellularProperties& y)
  {
    return !(x == y);
  }

  // ExtracellularPropertiesLocal
  //

  ExtracellularPropertiesLocal::
  ExtracellularPropertiesLocal ()
  : ::xml_schema::type (),
    species_ (this)
  {
  }

  ExtracellularPropertiesLocal::
  ExtracellularPropertiesLocal (const ExtracellularPropertiesLocal& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    species_ (x.species_, f, this)
  {
  }

  ExtracellularPropertiesLocal::
  ExtracellularPropertiesLocal (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    species_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ExtracellularPropertiesLocal::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // species
      //
      if (n.name () == "species" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< species_type > r (
          species_traits::create (i, f, this));

        this->species_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ExtracellularPropertiesLocal* ExtracellularPropertiesLocal::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ExtracellularPropertiesLocal (*this, f, c);
  }

  ExtracellularPropertiesLocal& ExtracellularPropertiesLocal::
  operator= (const ExtracellularPropertiesLocal& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->species_ = x.species_;
    }

    return *this;
  }

  ExtracellularPropertiesLocal::
  ~ExtracellularPropertiesLocal ()
  {
  }

  bool
  operator== (const ExtracellularPropertiesLocal& x, const ExtracellularPropertiesLocal& y)
  {
    if (!(x.species () == y.species ()))
      return false;

    return true;
  }

  bool
  operator!= (const ExtracellularPropertiesLocal& x, const ExtracellularPropertiesLocal& y)
  {
    return !(x == y);
  }

  // ReactionScheme
  //

  ReactionScheme::
  ReactionScheme (const id_type& id,
                  const source_type& source,
                  const type_type& type)
  : ::neuroml2::Base (id),
    source_ (source, this),
    type_ (type, this)
  {
  }

  ReactionScheme::
  ReactionScheme (const ReactionScheme& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    source_ (x.source_, f, this),
    type_ (x.type_, f, this)
  {
  }

  ReactionScheme::
  ReactionScheme (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    source_ (this),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ReactionScheme::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "source" && n.namespace_ ().empty ())
      {
        this->source_.set (source_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    if (!source_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "source",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  ReactionScheme* ReactionScheme::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ReactionScheme (*this, f, c);
  }

  ReactionScheme& ReactionScheme::
  operator= (const ReactionScheme& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->source_ = x.source_;
      this->type_ = x.type_;
    }

    return *this;
  }

  ReactionScheme::
  ~ReactionScheme ()
  {
  }

  bool
  operator== (const ReactionScheme& x, const ReactionScheme& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.source () == y.source ()))
      return false;

    if (!(x.type () == y.type ()))
      return false;

    return true;
  }

  bool
  operator!= (const ReactionScheme& x, const ReactionScheme& y)
  {
    return !(x == y);
  }

  // PulseGenerator
  //

  PulseGenerator::
  PulseGenerator (const id_type& id,
                  const delay_type& delay,
                  const duration_type& duration,
                  const amplitude_type& amplitude)
  : ::neuroml2::Standalone (id),
    delay_ (delay, this),
    duration_ (duration, this),
    amplitude_ (amplitude, this)
  {
  }

  PulseGenerator::
  PulseGenerator (const PulseGenerator& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    delay_ (x.delay_, f, this),
    duration_ (x.duration_, f, this),
    amplitude_ (x.amplitude_, f, this)
  {
  }

  PulseGenerator::
  PulseGenerator (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    delay_ (this),
    duration_ (this),
    amplitude_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void PulseGenerator::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "delay" && n.namespace_ ().empty ())
      {
        this->delay_.set (delay_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "duration" && n.namespace_ ().empty ())
      {
        this->duration_.set (duration_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "amplitude" && n.namespace_ ().empty ())
      {
        this->amplitude_.set (amplitude_traits::create (i, f, this));
        continue;
      }
    }

    if (!delay_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "delay",
        "");
    }

    if (!duration_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "duration",
        "");
    }

    if (!amplitude_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "amplitude",
        "");
    }
  }

  PulseGenerator* PulseGenerator::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PulseGenerator (*this, f, c);
  }

  PulseGenerator& PulseGenerator::
  operator= (const PulseGenerator& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->delay_ = x.delay_;
      this->duration_ = x.duration_;
      this->amplitude_ = x.amplitude_;
    }

    return *this;
  }

  PulseGenerator::
  ~PulseGenerator ()
  {
  }

  bool
  operator== (const PulseGenerator& x, const PulseGenerator& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.delay () == y.delay ()))
      return false;

    if (!(x.duration () == y.duration ()))
      return false;

    if (!(x.amplitude () == y.amplitude ()))
      return false;

    return true;
  }

  bool
  operator!= (const PulseGenerator& x, const PulseGenerator& y)
  {
    return !(x == y);
  }

  // PulseGeneratorDL
  //

  PulseGeneratorDL::
  PulseGeneratorDL (const id_type& id,
                    const delay_type& delay,
                    const duration_type& duration,
                    const amplitude_type& amplitude)
  : ::neuroml2::Standalone (id),
    delay_ (delay, this),
    duration_ (duration, this),
    amplitude_ (amplitude, this)
  {
  }

  PulseGeneratorDL::
  PulseGeneratorDL (const PulseGeneratorDL& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    delay_ (x.delay_, f, this),
    duration_ (x.duration_, f, this),
    amplitude_ (x.amplitude_, f, this)
  {
  }

  PulseGeneratorDL::
  PulseGeneratorDL (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    delay_ (this),
    duration_ (this),
    amplitude_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void PulseGeneratorDL::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "delay" && n.namespace_ ().empty ())
      {
        this->delay_.set (delay_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "duration" && n.namespace_ ().empty ())
      {
        this->duration_.set (duration_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "amplitude" && n.namespace_ ().empty ())
      {
        this->amplitude_.set (amplitude_traits::create (i, f, this));
        continue;
      }
    }

    if (!delay_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "delay",
        "");
    }

    if (!duration_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "duration",
        "");
    }

    if (!amplitude_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "amplitude",
        "");
    }
  }

  PulseGeneratorDL* PulseGeneratorDL::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PulseGeneratorDL (*this, f, c);
  }

  PulseGeneratorDL& PulseGeneratorDL::
  operator= (const PulseGeneratorDL& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->delay_ = x.delay_;
      this->duration_ = x.duration_;
      this->amplitude_ = x.amplitude_;
    }

    return *this;
  }

  PulseGeneratorDL::
  ~PulseGeneratorDL ()
  {
  }

  bool
  operator== (const PulseGeneratorDL& x, const PulseGeneratorDL& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.delay () == y.delay ()))
      return false;

    if (!(x.duration () == y.duration ()))
      return false;

    if (!(x.amplitude () == y.amplitude ()))
      return false;

    return true;
  }

  bool
  operator!= (const PulseGeneratorDL& x, const PulseGeneratorDL& y)
  {
    return !(x == y);
  }

  // SineGenerator
  //

  SineGenerator::
  SineGenerator (const id_type& id,
                 const delay_type& delay,
                 const phase_type& phase,
                 const duration_type& duration,
                 const amplitude_type& amplitude,
                 const period_type& period)
  : ::neuroml2::Standalone (id),
    delay_ (delay, this),
    phase_ (phase, this),
    duration_ (duration, this),
    amplitude_ (amplitude, this),
    period_ (period, this)
  {
  }

  SineGenerator::
  SineGenerator (const SineGenerator& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    delay_ (x.delay_, f, this),
    phase_ (x.phase_, f, this),
    duration_ (x.duration_, f, this),
    amplitude_ (x.amplitude_, f, this),
    period_ (x.period_, f, this)
  {
  }

  SineGenerator::
  SineGenerator (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    delay_ (this),
    phase_ (this),
    duration_ (this),
    amplitude_ (this),
    period_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SineGenerator::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "delay" && n.namespace_ ().empty ())
      {
        this->delay_.set (delay_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "phase" && n.namespace_ ().empty ())
      {
        this->phase_.set (phase_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "duration" && n.namespace_ ().empty ())
      {
        this->duration_.set (duration_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "amplitude" && n.namespace_ ().empty ())
      {
        this->amplitude_.set (amplitude_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "period" && n.namespace_ ().empty ())
      {
        this->period_.set (period_traits::create (i, f, this));
        continue;
      }
    }

    if (!delay_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "delay",
        "");
    }

    if (!phase_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "phase",
        "");
    }

    if (!duration_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "duration",
        "");
    }

    if (!amplitude_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "amplitude",
        "");
    }

    if (!period_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "period",
        "");
    }
  }

  SineGenerator* SineGenerator::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SineGenerator (*this, f, c);
  }

  SineGenerator& SineGenerator::
  operator= (const SineGenerator& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->delay_ = x.delay_;
      this->phase_ = x.phase_;
      this->duration_ = x.duration_;
      this->amplitude_ = x.amplitude_;
      this->period_ = x.period_;
    }

    return *this;
  }

  SineGenerator::
  ~SineGenerator ()
  {
  }

  bool
  operator== (const SineGenerator& x, const SineGenerator& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.delay () == y.delay ()))
      return false;

    if (!(x.phase () == y.phase ()))
      return false;

    if (!(x.duration () == y.duration ()))
      return false;

    if (!(x.amplitude () == y.amplitude ()))
      return false;

    if (!(x.period () == y.period ()))
      return false;

    return true;
  }

  bool
  operator!= (const SineGenerator& x, const SineGenerator& y)
  {
    return !(x == y);
  }

  // SineGeneratorDL
  //

  SineGeneratorDL::
  SineGeneratorDL (const id_type& id,
                   const delay_type& delay,
                   const phase_type& phase,
                   const duration_type& duration,
                   const amplitude_type& amplitude,
                   const period_type& period)
  : ::neuroml2::Standalone (id),
    delay_ (delay, this),
    phase_ (phase, this),
    duration_ (duration, this),
    amplitude_ (amplitude, this),
    period_ (period, this)
  {
  }

  SineGeneratorDL::
  SineGeneratorDL (const SineGeneratorDL& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    delay_ (x.delay_, f, this),
    phase_ (x.phase_, f, this),
    duration_ (x.duration_, f, this),
    amplitude_ (x.amplitude_, f, this),
    period_ (x.period_, f, this)
  {
  }

  SineGeneratorDL::
  SineGeneratorDL (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    delay_ (this),
    phase_ (this),
    duration_ (this),
    amplitude_ (this),
    period_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SineGeneratorDL::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "delay" && n.namespace_ ().empty ())
      {
        this->delay_.set (delay_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "phase" && n.namespace_ ().empty ())
      {
        this->phase_.set (phase_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "duration" && n.namespace_ ().empty ())
      {
        this->duration_.set (duration_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "amplitude" && n.namespace_ ().empty ())
      {
        this->amplitude_.set (amplitude_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "period" && n.namespace_ ().empty ())
      {
        this->period_.set (period_traits::create (i, f, this));
        continue;
      }
    }

    if (!delay_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "delay",
        "");
    }

    if (!phase_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "phase",
        "");
    }

    if (!duration_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "duration",
        "");
    }

    if (!amplitude_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "amplitude",
        "");
    }

    if (!period_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "period",
        "");
    }
  }

  SineGeneratorDL* SineGeneratorDL::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SineGeneratorDL (*this, f, c);
  }

  SineGeneratorDL& SineGeneratorDL::
  operator= (const SineGeneratorDL& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->delay_ = x.delay_;
      this->phase_ = x.phase_;
      this->duration_ = x.duration_;
      this->amplitude_ = x.amplitude_;
      this->period_ = x.period_;
    }

    return *this;
  }

  SineGeneratorDL::
  ~SineGeneratorDL ()
  {
  }

  bool
  operator== (const SineGeneratorDL& x, const SineGeneratorDL& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.delay () == y.delay ()))
      return false;

    if (!(x.phase () == y.phase ()))
      return false;

    if (!(x.duration () == y.duration ()))
      return false;

    if (!(x.amplitude () == y.amplitude ()))
      return false;

    if (!(x.period () == y.period ()))
      return false;

    return true;
  }

  bool
  operator!= (const SineGeneratorDL& x, const SineGeneratorDL& y)
  {
    return !(x == y);
  }

  // RampGenerator
  //

  RampGenerator::
  RampGenerator (const id_type& id,
                 const delay_type& delay,
                 const duration_type& duration,
                 const startAmplitude_type& startAmplitude,
                 const finishAmplitude_type& finishAmplitude,
                 const baselineAmplitude_type& baselineAmplitude)
  : ::neuroml2::Standalone (id),
    delay_ (delay, this),
    duration_ (duration, this),
    startAmplitude_ (startAmplitude, this),
    finishAmplitude_ (finishAmplitude, this),
    baselineAmplitude_ (baselineAmplitude, this)
  {
  }

  RampGenerator::
  RampGenerator (const RampGenerator& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    delay_ (x.delay_, f, this),
    duration_ (x.duration_, f, this),
    startAmplitude_ (x.startAmplitude_, f, this),
    finishAmplitude_ (x.finishAmplitude_, f, this),
    baselineAmplitude_ (x.baselineAmplitude_, f, this)
  {
  }

  RampGenerator::
  RampGenerator (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    delay_ (this),
    duration_ (this),
    startAmplitude_ (this),
    finishAmplitude_ (this),
    baselineAmplitude_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void RampGenerator::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "delay" && n.namespace_ ().empty ())
      {
        this->delay_.set (delay_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "duration" && n.namespace_ ().empty ())
      {
        this->duration_.set (duration_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "startAmplitude" && n.namespace_ ().empty ())
      {
        this->startAmplitude_.set (startAmplitude_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "finishAmplitude" && n.namespace_ ().empty ())
      {
        this->finishAmplitude_.set (finishAmplitude_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "baselineAmplitude" && n.namespace_ ().empty ())
      {
        this->baselineAmplitude_.set (baselineAmplitude_traits::create (i, f, this));
        continue;
      }
    }

    if (!delay_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "delay",
        "");
    }

    if (!duration_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "duration",
        "");
    }

    if (!startAmplitude_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "startAmplitude",
        "");
    }

    if (!finishAmplitude_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "finishAmplitude",
        "");
    }

    if (!baselineAmplitude_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "baselineAmplitude",
        "");
    }
  }

  RampGenerator* RampGenerator::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RampGenerator (*this, f, c);
  }

  RampGenerator& RampGenerator::
  operator= (const RampGenerator& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->delay_ = x.delay_;
      this->duration_ = x.duration_;
      this->startAmplitude_ = x.startAmplitude_;
      this->finishAmplitude_ = x.finishAmplitude_;
      this->baselineAmplitude_ = x.baselineAmplitude_;
    }

    return *this;
  }

  RampGenerator::
  ~RampGenerator ()
  {
  }

  bool
  operator== (const RampGenerator& x, const RampGenerator& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.delay () == y.delay ()))
      return false;

    if (!(x.duration () == y.duration ()))
      return false;

    if (!(x.startAmplitude () == y.startAmplitude ()))
      return false;

    if (!(x.finishAmplitude () == y.finishAmplitude ()))
      return false;

    if (!(x.baselineAmplitude () == y.baselineAmplitude ()))
      return false;

    return true;
  }

  bool
  operator!= (const RampGenerator& x, const RampGenerator& y)
  {
    return !(x == y);
  }

  // RampGeneratorDL
  //

  RampGeneratorDL::
  RampGeneratorDL (const id_type& id,
                   const delay_type& delay,
                   const duration_type& duration,
                   const startAmplitude_type& startAmplitude,
                   const finishAmplitude_type& finishAmplitude,
                   const baselineAmplitude_type& baselineAmplitude)
  : ::neuroml2::Standalone (id),
    delay_ (delay, this),
    duration_ (duration, this),
    startAmplitude_ (startAmplitude, this),
    finishAmplitude_ (finishAmplitude, this),
    baselineAmplitude_ (baselineAmplitude, this)
  {
  }

  RampGeneratorDL::
  RampGeneratorDL (const RampGeneratorDL& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    delay_ (x.delay_, f, this),
    duration_ (x.duration_, f, this),
    startAmplitude_ (x.startAmplitude_, f, this),
    finishAmplitude_ (x.finishAmplitude_, f, this),
    baselineAmplitude_ (x.baselineAmplitude_, f, this)
  {
  }

  RampGeneratorDL::
  RampGeneratorDL (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    delay_ (this),
    duration_ (this),
    startAmplitude_ (this),
    finishAmplitude_ (this),
    baselineAmplitude_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void RampGeneratorDL::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "delay" && n.namespace_ ().empty ())
      {
        this->delay_.set (delay_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "duration" && n.namespace_ ().empty ())
      {
        this->duration_.set (duration_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "startAmplitude" && n.namespace_ ().empty ())
      {
        this->startAmplitude_.set (startAmplitude_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "finishAmplitude" && n.namespace_ ().empty ())
      {
        this->finishAmplitude_.set (finishAmplitude_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "baselineAmplitude" && n.namespace_ ().empty ())
      {
        this->baselineAmplitude_.set (baselineAmplitude_traits::create (i, f, this));
        continue;
      }
    }

    if (!delay_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "delay",
        "");
    }

    if (!duration_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "duration",
        "");
    }

    if (!startAmplitude_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "startAmplitude",
        "");
    }

    if (!finishAmplitude_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "finishAmplitude",
        "");
    }

    if (!baselineAmplitude_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "baselineAmplitude",
        "");
    }
  }

  RampGeneratorDL* RampGeneratorDL::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RampGeneratorDL (*this, f, c);
  }

  RampGeneratorDL& RampGeneratorDL::
  operator= (const RampGeneratorDL& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->delay_ = x.delay_;
      this->duration_ = x.duration_;
      this->startAmplitude_ = x.startAmplitude_;
      this->finishAmplitude_ = x.finishAmplitude_;
      this->baselineAmplitude_ = x.baselineAmplitude_;
    }

    return *this;
  }

  RampGeneratorDL::
  ~RampGeneratorDL ()
  {
  }

  bool
  operator== (const RampGeneratorDL& x, const RampGeneratorDL& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.delay () == y.delay ()))
      return false;

    if (!(x.duration () == y.duration ()))
      return false;

    if (!(x.startAmplitude () == y.startAmplitude ()))
      return false;

    if (!(x.finishAmplitude () == y.finishAmplitude ()))
      return false;

    if (!(x.baselineAmplitude () == y.baselineAmplitude ()))
      return false;

    return true;
  }

  bool
  operator!= (const RampGeneratorDL& x, const RampGeneratorDL& y)
  {
    return !(x == y);
  }

  // CompoundInput
  //

  CompoundInput::
  CompoundInput (const id_type& id)
  : ::neuroml2::Standalone (id),
    pulseGenerator_ (this),
    sineGenerator_ (this),
    rampGenerator_ (this)
  {
  }

  CompoundInput::
  CompoundInput (const CompoundInput& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    pulseGenerator_ (x.pulseGenerator_, f, this),
    sineGenerator_ (x.sineGenerator_, f, this),
    rampGenerator_ (x.rampGenerator_, f, this)
  {
  }

  CompoundInput::
  CompoundInput (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    pulseGenerator_ (this),
    sineGenerator_ (this),
    rampGenerator_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void CompoundInput::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // pulseGenerator
      //
      if (n.name () == "pulseGenerator" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< pulseGenerator_type > r (
          pulseGenerator_traits::create (i, f, this));

        this->pulseGenerator_.push_back (::std::move (r));
        continue;
      }

      // sineGenerator
      //
      if (n.name () == "sineGenerator" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< sineGenerator_type > r (
          sineGenerator_traits::create (i, f, this));

        this->sineGenerator_.push_back (::std::move (r));
        continue;
      }

      // rampGenerator
      //
      if (n.name () == "rampGenerator" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< rampGenerator_type > r (
          rampGenerator_traits::create (i, f, this));

        this->rampGenerator_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  CompoundInput* CompoundInput::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CompoundInput (*this, f, c);
  }

  CompoundInput& CompoundInput::
  operator= (const CompoundInput& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->pulseGenerator_ = x.pulseGenerator_;
      this->sineGenerator_ = x.sineGenerator_;
      this->rampGenerator_ = x.rampGenerator_;
    }

    return *this;
  }

  CompoundInput::
  ~CompoundInput ()
  {
  }

  bool
  operator== (const CompoundInput& x, const CompoundInput& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.pulseGenerator () == y.pulseGenerator ()))
      return false;

    if (!(x.sineGenerator () == y.sineGenerator ()))
      return false;

    if (!(x.rampGenerator () == y.rampGenerator ()))
      return false;

    return true;
  }

  bool
  operator!= (const CompoundInput& x, const CompoundInput& y)
  {
    return !(x == y);
  }

  // CompoundInputDL
  //

  CompoundInputDL::
  CompoundInputDL (const id_type& id)
  : ::neuroml2::Standalone (id),
    pulseGeneratorDL_ (this),
    sineGeneratorDL_ (this),
    rampGeneratorDL_ (this)
  {
  }

  CompoundInputDL::
  CompoundInputDL (const CompoundInputDL& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    pulseGeneratorDL_ (x.pulseGeneratorDL_, f, this),
    sineGeneratorDL_ (x.sineGeneratorDL_, f, this),
    rampGeneratorDL_ (x.rampGeneratorDL_, f, this)
  {
  }

  CompoundInputDL::
  CompoundInputDL (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    pulseGeneratorDL_ (this),
    sineGeneratorDL_ (this),
    rampGeneratorDL_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void CompoundInputDL::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // pulseGeneratorDL
      //
      if (n.name () == "pulseGeneratorDL" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< pulseGeneratorDL_type > r (
          pulseGeneratorDL_traits::create (i, f, this));

        this->pulseGeneratorDL_.push_back (::std::move (r));
        continue;
      }

      // sineGeneratorDL
      //
      if (n.name () == "sineGeneratorDL" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< sineGeneratorDL_type > r (
          sineGeneratorDL_traits::create (i, f, this));

        this->sineGeneratorDL_.push_back (::std::move (r));
        continue;
      }

      // rampGeneratorDL
      //
      if (n.name () == "rampGeneratorDL" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< rampGeneratorDL_type > r (
          rampGeneratorDL_traits::create (i, f, this));

        this->rampGeneratorDL_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  CompoundInputDL* CompoundInputDL::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CompoundInputDL (*this, f, c);
  }

  CompoundInputDL& CompoundInputDL::
  operator= (const CompoundInputDL& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->pulseGeneratorDL_ = x.pulseGeneratorDL_;
      this->sineGeneratorDL_ = x.sineGeneratorDL_;
      this->rampGeneratorDL_ = x.rampGeneratorDL_;
    }

    return *this;
  }

  CompoundInputDL::
  ~CompoundInputDL ()
  {
  }

  bool
  operator== (const CompoundInputDL& x, const CompoundInputDL& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.pulseGeneratorDL () == y.pulseGeneratorDL ()))
      return false;

    if (!(x.sineGeneratorDL () == y.sineGeneratorDL ()))
      return false;

    if (!(x.rampGeneratorDL () == y.rampGeneratorDL ()))
      return false;

    return true;
  }

  bool
  operator!= (const CompoundInputDL& x, const CompoundInputDL& y)
  {
    return !(x == y);
  }

  // VoltageClamp
  //

  VoltageClamp::
  VoltageClamp (const id_type& id,
                const delay_type& delay,
                const duration_type& duration,
                const targetVoltage_type& targetVoltage,
                const simpleSeriesResistance_type& simpleSeriesResistance)
  : ::neuroml2::Standalone (id),
    delay_ (delay, this),
    duration_ (duration, this),
    targetVoltage_ (targetVoltage, this),
    simpleSeriesResistance_ (simpleSeriesResistance, this)
  {
  }

  VoltageClamp::
  VoltageClamp (const VoltageClamp& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    delay_ (x.delay_, f, this),
    duration_ (x.duration_, f, this),
    targetVoltage_ (x.targetVoltage_, f, this),
    simpleSeriesResistance_ (x.simpleSeriesResistance_, f, this)
  {
  }

  VoltageClamp::
  VoltageClamp (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    delay_ (this),
    duration_ (this),
    targetVoltage_ (this),
    simpleSeriesResistance_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void VoltageClamp::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "delay" && n.namespace_ ().empty ())
      {
        this->delay_.set (delay_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "duration" && n.namespace_ ().empty ())
      {
        this->duration_.set (duration_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "targetVoltage" && n.namespace_ ().empty ())
      {
        this->targetVoltage_.set (targetVoltage_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "simpleSeriesResistance" && n.namespace_ ().empty ())
      {
        this->simpleSeriesResistance_.set (simpleSeriesResistance_traits::create (i, f, this));
        continue;
      }
    }

    if (!delay_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "delay",
        "");
    }

    if (!duration_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "duration",
        "");
    }

    if (!targetVoltage_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "targetVoltage",
        "");
    }

    if (!simpleSeriesResistance_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "simpleSeriesResistance",
        "");
    }
  }

  VoltageClamp* VoltageClamp::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VoltageClamp (*this, f, c);
  }

  VoltageClamp& VoltageClamp::
  operator= (const VoltageClamp& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->delay_ = x.delay_;
      this->duration_ = x.duration_;
      this->targetVoltage_ = x.targetVoltage_;
      this->simpleSeriesResistance_ = x.simpleSeriesResistance_;
    }

    return *this;
  }

  VoltageClamp::
  ~VoltageClamp ()
  {
  }

  bool
  operator== (const VoltageClamp& x, const VoltageClamp& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.delay () == y.delay ()))
      return false;

    if (!(x.duration () == y.duration ()))
      return false;

    if (!(x.targetVoltage () == y.targetVoltage ()))
      return false;

    if (!(x.simpleSeriesResistance () == y.simpleSeriesResistance ()))
      return false;

    return true;
  }

  bool
  operator!= (const VoltageClamp& x, const VoltageClamp& y)
  {
    return !(x == y);
  }

  // VoltageClampTriple
  //

  VoltageClampTriple::
  VoltageClampTriple (const id_type& id,
                      const active_type& active,
                      const delay_type& delay,
                      const duration_type& duration,
                      const conditioningVoltage_type& conditioningVoltage,
                      const testingVoltage_type& testingVoltage,
                      const returnVoltage_type& returnVoltage,
                      const simpleSeriesResistance_type& simpleSeriesResistance)
  : ::neuroml2::Standalone (id),
    active_ (active, this),
    delay_ (delay, this),
    duration_ (duration, this),
    conditioningVoltage_ (conditioningVoltage, this),
    testingVoltage_ (testingVoltage, this),
    returnVoltage_ (returnVoltage, this),
    simpleSeriesResistance_ (simpleSeriesResistance, this)
  {
  }

  VoltageClampTriple::
  VoltageClampTriple (const VoltageClampTriple& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    active_ (x.active_, f, this),
    delay_ (x.delay_, f, this),
    duration_ (x.duration_, f, this),
    conditioningVoltage_ (x.conditioningVoltage_, f, this),
    testingVoltage_ (x.testingVoltage_, f, this),
    returnVoltage_ (x.returnVoltage_, f, this),
    simpleSeriesResistance_ (x.simpleSeriesResistance_, f, this)
  {
  }

  VoltageClampTriple::
  VoltageClampTriple (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    active_ (this),
    delay_ (this),
    duration_ (this),
    conditioningVoltage_ (this),
    testingVoltage_ (this),
    returnVoltage_ (this),
    simpleSeriesResistance_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void VoltageClampTriple::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "active" && n.namespace_ ().empty ())
      {
        this->active_.set (active_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "delay" && n.namespace_ ().empty ())
      {
        this->delay_.set (delay_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "duration" && n.namespace_ ().empty ())
      {
        this->duration_.set (duration_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "conditioningVoltage" && n.namespace_ ().empty ())
      {
        this->conditioningVoltage_.set (conditioningVoltage_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "testingVoltage" && n.namespace_ ().empty ())
      {
        this->testingVoltage_.set (testingVoltage_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "returnVoltage" && n.namespace_ ().empty ())
      {
        this->returnVoltage_.set (returnVoltage_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "simpleSeriesResistance" && n.namespace_ ().empty ())
      {
        this->simpleSeriesResistance_.set (simpleSeriesResistance_traits::create (i, f, this));
        continue;
      }
    }

    if (!active_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "active",
        "");
    }

    if (!delay_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "delay",
        "");
    }

    if (!duration_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "duration",
        "");
    }

    if (!conditioningVoltage_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "conditioningVoltage",
        "");
    }

    if (!testingVoltage_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "testingVoltage",
        "");
    }

    if (!returnVoltage_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "returnVoltage",
        "");
    }

    if (!simpleSeriesResistance_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "simpleSeriesResistance",
        "");
    }
  }

  VoltageClampTriple* VoltageClampTriple::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VoltageClampTriple (*this, f, c);
  }

  VoltageClampTriple& VoltageClampTriple::
  operator= (const VoltageClampTriple& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->active_ = x.active_;
      this->delay_ = x.delay_;
      this->duration_ = x.duration_;
      this->conditioningVoltage_ = x.conditioningVoltage_;
      this->testingVoltage_ = x.testingVoltage_;
      this->returnVoltage_ = x.returnVoltage_;
      this->simpleSeriesResistance_ = x.simpleSeriesResistance_;
    }

    return *this;
  }

  VoltageClampTriple::
  ~VoltageClampTriple ()
  {
  }

  bool
  operator== (const VoltageClampTriple& x, const VoltageClampTriple& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.active () == y.active ()))
      return false;

    if (!(x.delay () == y.delay ()))
      return false;

    if (!(x.duration () == y.duration ()))
      return false;

    if (!(x.conditioningVoltage () == y.conditioningVoltage ()))
      return false;

    if (!(x.testingVoltage () == y.testingVoltage ()))
      return false;

    if (!(x.returnVoltage () == y.returnVoltage ()))
      return false;

    if (!(x.simpleSeriesResistance () == y.simpleSeriesResistance ()))
      return false;

    return true;
  }

  bool
  operator!= (const VoltageClampTriple& x, const VoltageClampTriple& y)
  {
    return !(x == y);
  }

  // Spike
  //

  Spike::
  Spike (const id_type& id,
         const time_type& time)
  : ::neuroml2::BaseNonNegativeIntegerId (id),
    time_ (time, this)
  {
  }

  Spike::
  Spike (const Spike& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::neuroml2::BaseNonNegativeIntegerId (x, f, c),
    time_ (x.time_, f, this)
  {
  }

  Spike::
  Spike (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::neuroml2::BaseNonNegativeIntegerId (e, f | ::xml_schema::flags::base, c),
    time_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Spike::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseNonNegativeIntegerId::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "time" && n.namespace_ ().empty ())
      {
        this->time_.set (time_traits::create (i, f, this));
        continue;
      }
    }

    if (!time_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "time",
        "");
    }
  }

  Spike* Spike::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Spike (*this, f, c);
  }

  Spike& Spike::
  operator= (const Spike& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseNonNegativeIntegerId& > (*this) = x;
      this->time_ = x.time_;
    }

    return *this;
  }

  Spike::
  ~Spike ()
  {
  }

  bool
  operator== (const Spike& x, const Spike& y)
  {
    if (!(static_cast< const ::neuroml2::BaseNonNegativeIntegerId& > (x) ==
          static_cast< const ::neuroml2::BaseNonNegativeIntegerId& > (y)))
      return false;

    if (!(x.time () == y.time ()))
      return false;

    return true;
  }

  bool
  operator!= (const Spike& x, const Spike& y)
  {
    return !(x == y);
  }

  // SpikeArray
  //

  SpikeArray::
  SpikeArray (const id_type& id)
  : ::neuroml2::Standalone (id),
    spike_ (this)
  {
  }

  SpikeArray::
  SpikeArray (const SpikeArray& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    spike_ (x.spike_, f, this)
  {
  }

  SpikeArray::
  SpikeArray (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    spike_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SpikeArray::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // spike
      //
      if (n.name () == "spike" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< spike_type > r (
          spike_traits::create (i, f, this));

        this->spike_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  SpikeArray* SpikeArray::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SpikeArray (*this, f, c);
  }

  SpikeArray& SpikeArray::
  operator= (const SpikeArray& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->spike_ = x.spike_;
    }

    return *this;
  }

  SpikeArray::
  ~SpikeArray ()
  {
  }

  bool
  operator== (const SpikeArray& x, const SpikeArray& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.spike () == y.spike ()))
      return false;

    return true;
  }

  bool
  operator!= (const SpikeArray& x, const SpikeArray& y)
  {
    return !(x == y);
  }

  // TimedSynapticInput
  //

  TimedSynapticInput::
  TimedSynapticInput (const id_type& id,
                      const synapse_type& synapse,
                      const spikeTarget_type& spikeTarget)
  : ::neuroml2::Standalone (id),
    spike_ (this),
    synapse_ (synapse, this),
    spikeTarget_ (spikeTarget, this)
  {
  }

  TimedSynapticInput::
  TimedSynapticInput (const TimedSynapticInput& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    spike_ (x.spike_, f, this),
    synapse_ (x.synapse_, f, this),
    spikeTarget_ (x.spikeTarget_, f, this)
  {
  }

  TimedSynapticInput::
  TimedSynapticInput (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    spike_ (this),
    synapse_ (this),
    spikeTarget_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void TimedSynapticInput::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // spike
      //
      if (n.name () == "spike" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< spike_type > r (
          spike_traits::create (i, f, this));

        this->spike_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "synapse" && n.namespace_ ().empty ())
      {
        this->synapse_.set (synapse_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "spikeTarget" && n.namespace_ ().empty ())
      {
        this->spikeTarget_.set (spikeTarget_traits::create (i, f, this));
        continue;
      }
    }

    if (!synapse_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "synapse",
        "");
    }

    if (!spikeTarget_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "spikeTarget",
        "");
    }
  }

  TimedSynapticInput* TimedSynapticInput::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TimedSynapticInput (*this, f, c);
  }

  TimedSynapticInput& TimedSynapticInput::
  operator= (const TimedSynapticInput& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->spike_ = x.spike_;
      this->synapse_ = x.synapse_;
      this->spikeTarget_ = x.spikeTarget_;
    }

    return *this;
  }

  TimedSynapticInput::
  ~TimedSynapticInput ()
  {
  }

  bool
  operator== (const TimedSynapticInput& x, const TimedSynapticInput& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.spike () == y.spike ()))
      return false;

    if (!(x.synapse () == y.synapse ()))
      return false;

    if (!(x.spikeTarget () == y.spikeTarget ()))
      return false;

    return true;
  }

  bool
  operator!= (const TimedSynapticInput& x, const TimedSynapticInput& y)
  {
    return !(x == y);
  }

  // SpikeGenerator
  //

  SpikeGenerator::
  SpikeGenerator (const id_type& id,
                  const period_type& period)
  : ::neuroml2::Standalone (id),
    period_ (period, this)
  {
  }

  SpikeGenerator::
  SpikeGenerator (const SpikeGenerator& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    period_ (x.period_, f, this)
  {
  }

  SpikeGenerator::
  SpikeGenerator (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    period_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SpikeGenerator::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "period" && n.namespace_ ().empty ())
      {
        this->period_.set (period_traits::create (i, f, this));
        continue;
      }
    }

    if (!period_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "period",
        "");
    }
  }

  SpikeGenerator* SpikeGenerator::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SpikeGenerator (*this, f, c);
  }

  SpikeGenerator& SpikeGenerator::
  operator= (const SpikeGenerator& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->period_ = x.period_;
    }

    return *this;
  }

  SpikeGenerator::
  ~SpikeGenerator ()
  {
  }

  bool
  operator== (const SpikeGenerator& x, const SpikeGenerator& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.period () == y.period ()))
      return false;

    return true;
  }

  bool
  operator!= (const SpikeGenerator& x, const SpikeGenerator& y)
  {
    return !(x == y);
  }

  // SpikeGeneratorRandom
  //

  SpikeGeneratorRandom::
  SpikeGeneratorRandom (const id_type& id,
                        const maxISI_type& maxISI,
                        const minISI_type& minISI)
  : ::neuroml2::Standalone (id),
    maxISI_ (maxISI, this),
    minISI_ (minISI, this)
  {
  }

  SpikeGeneratorRandom::
  SpikeGeneratorRandom (const SpikeGeneratorRandom& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    maxISI_ (x.maxISI_, f, this),
    minISI_ (x.minISI_, f, this)
  {
  }

  SpikeGeneratorRandom::
  SpikeGeneratorRandom (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    maxISI_ (this),
    minISI_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SpikeGeneratorRandom::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "maxISI" && n.namespace_ ().empty ())
      {
        this->maxISI_.set (maxISI_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "minISI" && n.namespace_ ().empty ())
      {
        this->minISI_.set (minISI_traits::create (i, f, this));
        continue;
      }
    }

    if (!maxISI_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "maxISI",
        "");
    }

    if (!minISI_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "minISI",
        "");
    }
  }

  SpikeGeneratorRandom* SpikeGeneratorRandom::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SpikeGeneratorRandom (*this, f, c);
  }

  SpikeGeneratorRandom& SpikeGeneratorRandom::
  operator= (const SpikeGeneratorRandom& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->maxISI_ = x.maxISI_;
      this->minISI_ = x.minISI_;
    }

    return *this;
  }

  SpikeGeneratorRandom::
  ~SpikeGeneratorRandom ()
  {
  }

  bool
  operator== (const SpikeGeneratorRandom& x, const SpikeGeneratorRandom& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.maxISI () == y.maxISI ()))
      return false;

    if (!(x.minISI () == y.minISI ()))
      return false;

    return true;
  }

  bool
  operator!= (const SpikeGeneratorRandom& x, const SpikeGeneratorRandom& y)
  {
    return !(x == y);
  }

  // SpikeGeneratorPoisson
  //

  SpikeGeneratorPoisson::
  SpikeGeneratorPoisson (const id_type& id,
                         const averageRate_type& averageRate)
  : ::neuroml2::Standalone (id),
    averageRate_ (averageRate, this)
  {
  }

  SpikeGeneratorPoisson::
  SpikeGeneratorPoisson (const SpikeGeneratorPoisson& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    averageRate_ (x.averageRate_, f, this)
  {
  }

  SpikeGeneratorPoisson::
  SpikeGeneratorPoisson (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    averageRate_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SpikeGeneratorPoisson::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "averageRate" && n.namespace_ ().empty ())
      {
        this->averageRate_.set (averageRate_traits::create (i, f, this));
        continue;
      }
    }

    if (!averageRate_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "averageRate",
        "");
    }
  }

  SpikeGeneratorPoisson* SpikeGeneratorPoisson::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SpikeGeneratorPoisson (*this, f, c);
  }

  SpikeGeneratorPoisson& SpikeGeneratorPoisson::
  operator= (const SpikeGeneratorPoisson& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->averageRate_ = x.averageRate_;
    }

    return *this;
  }

  SpikeGeneratorPoisson::
  ~SpikeGeneratorPoisson ()
  {
  }

  bool
  operator== (const SpikeGeneratorPoisson& x, const SpikeGeneratorPoisson& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.averageRate () == y.averageRate ()))
      return false;

    return true;
  }

  bool
  operator!= (const SpikeGeneratorPoisson& x, const SpikeGeneratorPoisson& y)
  {
    return !(x == y);
  }

  // SpikeGeneratorRefPoisson
  //

  SpikeGeneratorRefPoisson::
  SpikeGeneratorRefPoisson (const id_type& id,
                            const averageRate_type& averageRate,
                            const minimumISI_type& minimumISI)
  : ::neuroml2::SpikeGeneratorPoisson (id,
                                       averageRate),
    minimumISI_ (minimumISI, this)
  {
  }

  SpikeGeneratorRefPoisson::
  SpikeGeneratorRefPoisson (const SpikeGeneratorRefPoisson& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::neuroml2::SpikeGeneratorPoisson (x, f, c),
    minimumISI_ (x.minimumISI_, f, this)
  {
  }

  SpikeGeneratorRefPoisson::
  SpikeGeneratorRefPoisson (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::neuroml2::SpikeGeneratorPoisson (e, f | ::xml_schema::flags::base, c),
    minimumISI_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SpikeGeneratorRefPoisson::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::SpikeGeneratorPoisson::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "minimumISI" && n.namespace_ ().empty ())
      {
        this->minimumISI_.set (minimumISI_traits::create (i, f, this));
        continue;
      }
    }

    if (!minimumISI_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "minimumISI",
        "");
    }
  }

  SpikeGeneratorRefPoisson* SpikeGeneratorRefPoisson::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SpikeGeneratorRefPoisson (*this, f, c);
  }

  SpikeGeneratorRefPoisson& SpikeGeneratorRefPoisson::
  operator= (const SpikeGeneratorRefPoisson& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::SpikeGeneratorPoisson& > (*this) = x;
      this->minimumISI_ = x.minimumISI_;
    }

    return *this;
  }

  SpikeGeneratorRefPoisson::
  ~SpikeGeneratorRefPoisson ()
  {
  }

  bool
  operator== (const SpikeGeneratorRefPoisson& x, const SpikeGeneratorRefPoisson& y)
  {
    if (!(static_cast< const ::neuroml2::SpikeGeneratorPoisson& > (x) ==
          static_cast< const ::neuroml2::SpikeGeneratorPoisson& > (y)))
      return false;

    if (!(x.minimumISI () == y.minimumISI ()))
      return false;

    return true;
  }

  bool
  operator!= (const SpikeGeneratorRefPoisson& x, const SpikeGeneratorRefPoisson& y)
  {
    return !(x == y);
  }

  // PoissonFiringSynapse
  //

  PoissonFiringSynapse::
  PoissonFiringSynapse (const id_type& id,
                        const averageRate_type& averageRate,
                        const synapse_type& synapse,
                        const spikeTarget_type& spikeTarget)
  : ::neuroml2::Standalone (id),
    averageRate_ (averageRate, this),
    synapse_ (synapse, this),
    spikeTarget_ (spikeTarget, this)
  {
  }

  PoissonFiringSynapse::
  PoissonFiringSynapse (const PoissonFiringSynapse& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    averageRate_ (x.averageRate_, f, this),
    synapse_ (x.synapse_, f, this),
    spikeTarget_ (x.spikeTarget_, f, this)
  {
  }

  PoissonFiringSynapse::
  PoissonFiringSynapse (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    averageRate_ (this),
    synapse_ (this),
    spikeTarget_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void PoissonFiringSynapse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "averageRate" && n.namespace_ ().empty ())
      {
        this->averageRate_.set (averageRate_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "synapse" && n.namespace_ ().empty ())
      {
        this->synapse_.set (synapse_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "spikeTarget" && n.namespace_ ().empty ())
      {
        this->spikeTarget_.set (spikeTarget_traits::create (i, f, this));
        continue;
      }
    }

    if (!averageRate_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "averageRate",
        "");
    }

    if (!synapse_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "synapse",
        "");
    }

    if (!spikeTarget_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "spikeTarget",
        "");
    }
  }

  PoissonFiringSynapse* PoissonFiringSynapse::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PoissonFiringSynapse (*this, f, c);
  }

  PoissonFiringSynapse& PoissonFiringSynapse::
  operator= (const PoissonFiringSynapse& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->averageRate_ = x.averageRate_;
      this->synapse_ = x.synapse_;
      this->spikeTarget_ = x.spikeTarget_;
    }

    return *this;
  }

  PoissonFiringSynapse::
  ~PoissonFiringSynapse ()
  {
  }

  bool
  operator== (const PoissonFiringSynapse& x, const PoissonFiringSynapse& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.averageRate () == y.averageRate ()))
      return false;

    if (!(x.synapse () == y.synapse ()))
      return false;

    if (!(x.spikeTarget () == y.spikeTarget ()))
      return false;

    return true;
  }

  bool
  operator!= (const PoissonFiringSynapse& x, const PoissonFiringSynapse& y)
  {
    return !(x == y);
  }

  // TransientPoissonFiringSynapse
  //

  TransientPoissonFiringSynapse::
  TransientPoissonFiringSynapse (const id_type& id,
                                 const averageRate_type& averageRate,
                                 const delay_type& delay,
                                 const duration_type& duration,
                                 const synapse_type& synapse,
                                 const spikeTarget_type& spikeTarget)
  : ::neuroml2::Standalone (id),
    averageRate_ (averageRate, this),
    delay_ (delay, this),
    duration_ (duration, this),
    synapse_ (synapse, this),
    spikeTarget_ (spikeTarget, this)
  {
  }

  TransientPoissonFiringSynapse::
  TransientPoissonFiringSynapse (const TransientPoissonFiringSynapse& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    averageRate_ (x.averageRate_, f, this),
    delay_ (x.delay_, f, this),
    duration_ (x.duration_, f, this),
    synapse_ (x.synapse_, f, this),
    spikeTarget_ (x.spikeTarget_, f, this)
  {
  }

  TransientPoissonFiringSynapse::
  TransientPoissonFiringSynapse (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    averageRate_ (this),
    delay_ (this),
    duration_ (this),
    synapse_ (this),
    spikeTarget_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void TransientPoissonFiringSynapse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "averageRate" && n.namespace_ ().empty ())
      {
        this->averageRate_.set (averageRate_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "delay" && n.namespace_ ().empty ())
      {
        this->delay_.set (delay_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "duration" && n.namespace_ ().empty ())
      {
        this->duration_.set (duration_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "synapse" && n.namespace_ ().empty ())
      {
        this->synapse_.set (synapse_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "spikeTarget" && n.namespace_ ().empty ())
      {
        this->spikeTarget_.set (spikeTarget_traits::create (i, f, this));
        continue;
      }
    }

    if (!averageRate_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "averageRate",
        "");
    }

    if (!delay_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "delay",
        "");
    }

    if (!duration_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "duration",
        "");
    }

    if (!synapse_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "synapse",
        "");
    }

    if (!spikeTarget_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "spikeTarget",
        "");
    }
  }

  TransientPoissonFiringSynapse* TransientPoissonFiringSynapse::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TransientPoissonFiringSynapse (*this, f, c);
  }

  TransientPoissonFiringSynapse& TransientPoissonFiringSynapse::
  operator= (const TransientPoissonFiringSynapse& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->averageRate_ = x.averageRate_;
      this->delay_ = x.delay_;
      this->duration_ = x.duration_;
      this->synapse_ = x.synapse_;
      this->spikeTarget_ = x.spikeTarget_;
    }

    return *this;
  }

  TransientPoissonFiringSynapse::
  ~TransientPoissonFiringSynapse ()
  {
  }

  bool
  operator== (const TransientPoissonFiringSynapse& x, const TransientPoissonFiringSynapse& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.averageRate () == y.averageRate ()))
      return false;

    if (!(x.delay () == y.delay ()))
      return false;

    if (!(x.duration () == y.duration ()))
      return false;

    if (!(x.synapse () == y.synapse ()))
      return false;

    if (!(x.spikeTarget () == y.spikeTarget ()))
      return false;

    return true;
  }

  bool
  operator!= (const TransientPoissonFiringSynapse& x, const TransientPoissonFiringSynapse& y)
  {
    return !(x == y);
  }

  // Network
  //

  Network::
  Network (const id_type& id)
  : ::neuroml2::Standalone (id),
    space_ (this),
    region_ (this),
    extracellularProperties_ (this),
    population_ (this),
    cellSet_ (this),
    synapticConnection_ (this),
    projection_ (this),
    electricalProjection_ (this),
    continuousProjection_ (this),
    explicitInput_ (this),
    inputList_ (this),
    type_ (this),
    temperature_ (this)
  {
  }

  Network::
  Network (const Network& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    space_ (x.space_, f, this),
    region_ (x.region_, f, this),
    extracellularProperties_ (x.extracellularProperties_, f, this),
    population_ (x.population_, f, this),
    cellSet_ (x.cellSet_, f, this),
    synapticConnection_ (x.synapticConnection_, f, this),
    projection_ (x.projection_, f, this),
    electricalProjection_ (x.electricalProjection_, f, this),
    continuousProjection_ (x.continuousProjection_, f, this),
    explicitInput_ (x.explicitInput_, f, this),
    inputList_ (x.inputList_, f, this),
    type_ (x.type_, f, this),
    temperature_ (x.temperature_, f, this)
  {
  }

  Network::
  Network (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    space_ (this),
    region_ (this),
    extracellularProperties_ (this),
    population_ (this),
    cellSet_ (this),
    synapticConnection_ (this),
    projection_ (this),
    electricalProjection_ (this),
    continuousProjection_ (this),
    explicitInput_ (this),
    inputList_ (this),
    type_ (this),
    temperature_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Network::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // space
      //
      if (n.name () == "space" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< space_type > r (
          space_traits::create (i, f, this));

        this->space_.push_back (::std::move (r));
        continue;
      }

      // region
      //
      if (n.name () == "region" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< region_type > r (
          region_traits::create (i, f, this));

        this->region_.push_back (::std::move (r));
        continue;
      }

      // extracellularProperties
      //
      if (n.name () == "extracellularProperties" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< extracellularProperties_type > r (
          extracellularProperties_traits::create (i, f, this));

        this->extracellularProperties_.push_back (::std::move (r));
        continue;
      }

      // population
      //
      if (n.name () == "population" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< population_type > r (
          population_traits::create (i, f, this));

        this->population_.push_back (::std::move (r));
        continue;
      }

      // cellSet
      //
      if (n.name () == "cellSet" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< cellSet_type > r (
          cellSet_traits::create (i, f, this));

        this->cellSet_.push_back (::std::move (r));
        continue;
      }

      // synapticConnection
      //
      if (n.name () == "synapticConnection" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< synapticConnection_type > r (
          synapticConnection_traits::create (i, f, this));

        this->synapticConnection_.push_back (::std::move (r));
        continue;
      }

      // projection
      //
      if (n.name () == "projection" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< projection_type > r (
          projection_traits::create (i, f, this));

        this->projection_.push_back (::std::move (r));
        continue;
      }

      // electricalProjection
      //
      if (n.name () == "electricalProjection" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< electricalProjection_type > r (
          electricalProjection_traits::create (i, f, this));

        this->electricalProjection_.push_back (::std::move (r));
        continue;
      }

      // continuousProjection
      //
      if (n.name () == "continuousProjection" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< continuousProjection_type > r (
          continuousProjection_traits::create (i, f, this));

        this->continuousProjection_.push_back (::std::move (r));
        continue;
      }

      // explicitInput
      //
      if (n.name () == "explicitInput" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< explicitInput_type > r (
          explicitInput_traits::create (i, f, this));

        this->explicitInput_.push_back (::std::move (r));
        continue;
      }

      // inputList
      //
      if (n.name () == "inputList" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< inputList_type > r (
          inputList_traits::create (i, f, this));

        this->inputList_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "temperature" && n.namespace_ ().empty ())
      {
        this->temperature_.set (temperature_traits::create (i, f, this));
        continue;
      }
    }
  }

  Network* Network::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Network (*this, f, c);
  }

  Network& Network::
  operator= (const Network& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->space_ = x.space_;
      this->region_ = x.region_;
      this->extracellularProperties_ = x.extracellularProperties_;
      this->population_ = x.population_;
      this->cellSet_ = x.cellSet_;
      this->synapticConnection_ = x.synapticConnection_;
      this->projection_ = x.projection_;
      this->electricalProjection_ = x.electricalProjection_;
      this->continuousProjection_ = x.continuousProjection_;
      this->explicitInput_ = x.explicitInput_;
      this->inputList_ = x.inputList_;
      this->type_ = x.type_;
      this->temperature_ = x.temperature_;
    }

    return *this;
  }

  Network::
  ~Network ()
  {
  }

  bool
  operator== (const Network& x, const Network& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.space () == y.space ()))
      return false;

    if (!(x.region () == y.region ()))
      return false;

    if (!(x.extracellularProperties () == y.extracellularProperties ()))
      return false;

    if (!(x.population () == y.population ()))
      return false;

    if (!(x.cellSet () == y.cellSet ()))
      return false;

    if (!(x.synapticConnection () == y.synapticConnection ()))
      return false;

    if (!(x.projection () == y.projection ()))
      return false;

    if (!(x.electricalProjection () == y.electricalProjection ()))
      return false;

    if (!(x.continuousProjection () == y.continuousProjection ()))
      return false;

    if (!(x.explicitInput () == y.explicitInput ()))
      return false;

    if (!(x.inputList () == y.inputList ()))
      return false;

    if (!(x.type () == y.type ()))
      return false;

    if (!(x.temperature () == y.temperature ()))
      return false;

    return true;
  }

  bool
  operator!= (const Network& x, const Network& y)
  {
    return !(x == y);
  }

  // networkTypes
  //

  networkTypes::
  networkTypes (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_networkTypes_convert ();
  }

  networkTypes::
  networkTypes (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_networkTypes_convert ();
  }

  networkTypes::
  networkTypes (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_networkTypes_convert ();
  }

  networkTypes* networkTypes::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class networkTypes (*this, f, c);
  }

  networkTypes::value networkTypes::
  _xsd_networkTypes_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_networkTypes_literals_);
    const value* i (::std::lower_bound (
                      _xsd_networkTypes_indexes_,
                      _xsd_networkTypes_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_networkTypes_indexes_ + 2 || _xsd_networkTypes_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const networkTypes::
  _xsd_networkTypes_literals_[2] =
  {
    "network",
    "networkWithTemperature"
  };

  const networkTypes::value networkTypes::
  _xsd_networkTypes_indexes_[2] =
  {
    ::neuroml2::networkTypes::network,
    ::neuroml2::networkTypes::networkWithTemperature
  };

  // Space
  //

  Space::
  Space (const id_type& id)
  : ::neuroml2::Base (id),
    structure_ (this),
    basedOn_ (this)
  {
  }

  Space::
  Space (const Space& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    structure_ (x.structure_, f, this),
    basedOn_ (x.basedOn_, f, this)
  {
  }

  Space::
  Space (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    structure_ (this),
    basedOn_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Space::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // structure
      //
      if (n.name () == "structure" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< structure_type > r (
          structure_traits::create (i, f, this));

        if (!this->structure_)
        {
          this->structure_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "basedOn" && n.namespace_ ().empty ())
      {
        this->basedOn_.set (basedOn_traits::create (i, f, this));
        continue;
      }
    }
  }

  Space* Space::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Space (*this, f, c);
  }

  Space& Space::
  operator= (const Space& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->structure_ = x.structure_;
      this->basedOn_ = x.basedOn_;
    }

    return *this;
  }

  Space::
  ~Space ()
  {
  }

  bool
  operator== (const Space& x, const Space& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.structure () == y.structure ()))
      return false;

    if (!(x.basedOn () == y.basedOn ()))
      return false;

    return true;
  }

  bool
  operator!= (const Space& x, const Space& y)
  {
    return !(x == y);
  }

  // SpaceStructure
  //

  SpaceStructure::
  SpaceStructure ()
  : ::xml_schema::type (),
    xSpacing_ (this),
    ySpacing_ (this),
    zSpacing_ (this),
    xStart_ (xStart_default_value (), this),
    yStart_ (yStart_default_value (), this),
    zStart_ (zStart_default_value (), this)
  {
  }

  SpaceStructure::
  SpaceStructure (const SpaceStructure& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    xSpacing_ (x.xSpacing_, f, this),
    ySpacing_ (x.ySpacing_, f, this),
    zSpacing_ (x.zSpacing_, f, this),
    xStart_ (x.xStart_, f, this),
    yStart_ (x.yStart_, f, this),
    zStart_ (x.zStart_, f, this)
  {
  }

  SpaceStructure::
  SpaceStructure (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    xSpacing_ (this),
    ySpacing_ (this),
    zSpacing_ (this),
    xStart_ (this),
    yStart_ (this),
    zStart_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void SpaceStructure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "xSpacing" && n.namespace_ ().empty ())
      {
        this->xSpacing_.set (xSpacing_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ySpacing" && n.namespace_ ().empty ())
      {
        this->ySpacing_.set (ySpacing_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "zSpacing" && n.namespace_ ().empty ())
      {
        this->zSpacing_.set (zSpacing_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "xStart" && n.namespace_ ().empty ())
      {
        this->xStart_.set (xStart_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "yStart" && n.namespace_ ().empty ())
      {
        this->yStart_.set (yStart_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "zStart" && n.namespace_ ().empty ())
      {
        this->zStart_.set (zStart_traits::create (i, f, this));
        continue;
      }
    }

    if (!xStart_.present ())
    {
      this->xStart_.set (xStart_default_value ());
    }

    if (!yStart_.present ())
    {
      this->yStart_.set (yStart_default_value ());
    }

    if (!zStart_.present ())
    {
      this->zStart_.set (zStart_default_value ());
    }
  }

  SpaceStructure* SpaceStructure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SpaceStructure (*this, f, c);
  }

  SpaceStructure& SpaceStructure::
  operator= (const SpaceStructure& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->xSpacing_ = x.xSpacing_;
      this->ySpacing_ = x.ySpacing_;
      this->zSpacing_ = x.zSpacing_;
      this->xStart_ = x.xStart_;
      this->yStart_ = x.yStart_;
      this->zStart_ = x.zStart_;
    }

    return *this;
  }

  SpaceStructure::
  ~SpaceStructure ()
  {
  }

  bool
  operator== (const SpaceStructure& x, const SpaceStructure& y)
  {
    if (!(x.xSpacing () == y.xSpacing ()))
      return false;

    if (!(x.ySpacing () == y.ySpacing ()))
      return false;

    if (!(x.zSpacing () == y.zSpacing ()))
      return false;

    if (!(x.xStart () == y.xStart ()))
      return false;

    if (!(x.yStart () == y.yStart ()))
      return false;

    if (!(x.zStart () == y.zStart ()))
      return false;

    return true;
  }

  bool
  operator!= (const SpaceStructure& x, const SpaceStructure& y)
  {
    return !(x == y);
  }

  // allowedSpaces
  //

  allowedSpaces::
  allowedSpaces (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_allowedSpaces_convert ();
  }

  allowedSpaces::
  allowedSpaces (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_allowedSpaces_convert ();
  }

  allowedSpaces::
  allowedSpaces (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_allowedSpaces_convert ();
  }

  allowedSpaces* allowedSpaces::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class allowedSpaces (*this, f, c);
  }

  allowedSpaces::value allowedSpaces::
  _xsd_allowedSpaces_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_allowedSpaces_literals_);
    const value* i (::std::lower_bound (
                      _xsd_allowedSpaces_indexes_,
                      _xsd_allowedSpaces_indexes_ + 6,
                      *this,
                      c));

    if (i == _xsd_allowedSpaces_indexes_ + 6 || _xsd_allowedSpaces_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const allowedSpaces::
  _xsd_allowedSpaces_literals_[6] =
  {
    "Euclidean_1D",
    "Euclidean_2D",
    "Euclidean_3D",
    "Grid_1D",
    "Grid_2D",
    "Grid_3D"
  };

  const allowedSpaces::value allowedSpaces::
  _xsd_allowedSpaces_indexes_[6] =
  {
    ::neuroml2::allowedSpaces::Euclidean_1D,
    ::neuroml2::allowedSpaces::Euclidean_2D,
    ::neuroml2::allowedSpaces::Euclidean_3D,
    ::neuroml2::allowedSpaces::Grid_1D,
    ::neuroml2::allowedSpaces::Grid_2D,
    ::neuroml2::allowedSpaces::Grid_3D
  };

  // Region
  //

  Region::
  Region (const id_type& id)
  : ::neuroml2::Base (id),
    space_ (this)
  {
  }

  Region::
  Region (const Region& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    space_ (x.space_, f, this)
  {
  }

  Region::
  Region (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    space_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Region::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "space" && n.namespace_ ().empty ())
      {
        this->space_.set (space_traits::create (i, f, this));
        continue;
      }
    }
  }

  Region* Region::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Region (*this, f, c);
  }

  Region& Region::
  operator= (const Region& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->space_ = x.space_;
    }

    return *this;
  }

  Region::
  ~Region ()
  {
  }

  bool
  operator== (const Region& x, const Region& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.space () == y.space ()))
      return false;

    return true;
  }

  bool
  operator!= (const Region& x, const Region& y)
  {
    return !(x == y);
  }

  // Population
  //

  Population::
  Population (const id_type& id,
              const component_type& component)
  : ::neuroml2::Standalone (id),
    layout_ (this),
    instance_ (this),
    component_ (component, this),
    size_ (this),
    type_ (this),
    extracellularProperties_ (this)
  {
  }

  Population::
  Population (const Population& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    layout_ (x.layout_, f, this),
    instance_ (x.instance_, f, this),
    component_ (x.component_, f, this),
    size_ (x.size_, f, this),
    type_ (x.type_, f, this),
    extracellularProperties_ (x.extracellularProperties_, f, this)
  {
  }

  Population::
  Population (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    layout_ (this),
    instance_ (this),
    component_ (this),
    size_ (this),
    type_ (this),
    extracellularProperties_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Population::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // layout
      //
      if (n.name () == "layout" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< layout_type > r (
          layout_traits::create (i, f, this));

        if (!this->layout_)
        {
          this->layout_.set (::std::move (r));
          continue;
        }
      }

      // instance
      //
      if (n.name () == "instance" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< instance_type > r (
          instance_traits::create (i, f, this));

        this->instance_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "component" && n.namespace_ ().empty ())
      {
        this->component_.set (component_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "size" && n.namespace_ ().empty ())
      {
        this->size_.set (size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "extracellularProperties" && n.namespace_ ().empty ())
      {
        this->extracellularProperties_.set (extracellularProperties_traits::create (i, f, this));
        continue;
      }
    }

    if (!component_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "component",
        "");
    }
  }

  Population* Population::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Population (*this, f, c);
  }

  Population& Population::
  operator= (const Population& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->layout_ = x.layout_;
      this->instance_ = x.instance_;
      this->component_ = x.component_;
      this->size_ = x.size_;
      this->type_ = x.type_;
      this->extracellularProperties_ = x.extracellularProperties_;
    }

    return *this;
  }

  Population::
  ~Population ()
  {
  }

  bool
  operator== (const Population& x, const Population& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.layout () == y.layout ()))
      return false;

    if (!(x.instance () == y.instance ()))
      return false;

    if (!(x.component () == y.component ()))
      return false;

    if (!(x.size () == y.size ()))
      return false;

    if (!(x.type () == y.type ()))
      return false;

    if (!(x.extracellularProperties () == y.extracellularProperties ()))
      return false;

    return true;
  }

  bool
  operator!= (const Population& x, const Population& y)
  {
    return !(x == y);
  }

  // populationTypes
  //

  populationTypes::
  populationTypes (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_populationTypes_convert ();
  }

  populationTypes::
  populationTypes (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_populationTypes_convert ();
  }

  populationTypes::
  populationTypes (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_populationTypes_convert ();
  }

  populationTypes* populationTypes::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class populationTypes (*this, f, c);
  }

  populationTypes::value populationTypes::
  _xsd_populationTypes_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_populationTypes_literals_);
    const value* i (::std::lower_bound (
                      _xsd_populationTypes_indexes_,
                      _xsd_populationTypes_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_populationTypes_indexes_ + 2 || _xsd_populationTypes_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const populationTypes::
  _xsd_populationTypes_literals_[2] =
  {
    "population",
    "populationList"
  };

  const populationTypes::value populationTypes::
  _xsd_populationTypes_indexes_[2] =
  {
    ::neuroml2::populationTypes::population,
    ::neuroml2::populationTypes::populationList
  };

  // Layout
  //

  Layout::
  Layout ()
  : ::xml_schema::type (),
    random_ (this),
    grid_ (this),
    unstructured_ (this),
    space_ (this)
  {
  }

  Layout::
  Layout (const Layout& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    random_ (x.random_, f, this),
    grid_ (x.grid_, f, this),
    unstructured_ (x.unstructured_, f, this),
    space_ (x.space_, f, this)
  {
  }

  Layout::
  Layout (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    random_ (this),
    grid_ (this),
    unstructured_ (this),
    space_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Layout::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // random
      //
      if (n.name () == "random" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< random_type > r (
          random_traits::create (i, f, this));

        if (!this->random_)
        {
          this->random_.set (::std::move (r));
          continue;
        }
      }

      // grid
      //
      if (n.name () == "grid" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< grid_type > r (
          grid_traits::create (i, f, this));

        if (!this->grid_)
        {
          this->grid_.set (::std::move (r));
          continue;
        }
      }

      // unstructured
      //
      if (n.name () == "unstructured" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< unstructured_type > r (
          unstructured_traits::create (i, f, this));

        if (!this->unstructured_)
        {
          this->unstructured_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "space" && n.namespace_ ().empty ())
      {
        this->space_.set (space_traits::create (i, f, this));
        continue;
      }
    }
  }

  Layout* Layout::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Layout (*this, f, c);
  }

  Layout& Layout::
  operator= (const Layout& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->random_ = x.random_;
      this->grid_ = x.grid_;
      this->unstructured_ = x.unstructured_;
      this->space_ = x.space_;
    }

    return *this;
  }

  Layout::
  ~Layout ()
  {
  }

  bool
  operator== (const Layout& x, const Layout& y)
  {
    if (!(x.random () == y.random ()))
      return false;

    if (!(x.grid () == y.grid ()))
      return false;

    if (!(x.unstructured () == y.unstructured ()))
      return false;

    if (!(x.space () == y.space ()))
      return false;

    return true;
  }

  bool
  operator!= (const Layout& x, const Layout& y)
  {
    return !(x == y);
  }

  // UnstructuredLayout
  //

  UnstructuredLayout::
  UnstructuredLayout ()
  : ::xml_schema::type (),
    number_ (this)
  {
  }

  UnstructuredLayout::
  UnstructuredLayout (const UnstructuredLayout& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    number_ (x.number_, f, this)
  {
  }

  UnstructuredLayout::
  UnstructuredLayout (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    number_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void UnstructuredLayout::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }
    }
  }

  UnstructuredLayout* UnstructuredLayout::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class UnstructuredLayout (*this, f, c);
  }

  UnstructuredLayout& UnstructuredLayout::
  operator= (const UnstructuredLayout& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->number_ = x.number_;
    }

    return *this;
  }

  UnstructuredLayout::
  ~UnstructuredLayout ()
  {
  }

  bool
  operator== (const UnstructuredLayout& x, const UnstructuredLayout& y)
  {
    if (!(x.number () == y.number ()))
      return false;

    return true;
  }

  bool
  operator!= (const UnstructuredLayout& x, const UnstructuredLayout& y)
  {
    return !(x == y);
  }

  // RandomLayout
  //

  RandomLayout::
  RandomLayout ()
  : ::xml_schema::type (),
    number_ (this),
    region_ (this)
  {
  }

  RandomLayout::
  RandomLayout (const RandomLayout& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    number_ (x.number_, f, this),
    region_ (x.region_, f, this)
  {
  }

  RandomLayout::
  RandomLayout (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    number_ (this),
    region_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void RandomLayout::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "region" && n.namespace_ ().empty ())
      {
        this->region_.set (region_traits::create (i, f, this));
        continue;
      }
    }
  }

  RandomLayout* RandomLayout::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RandomLayout (*this, f, c);
  }

  RandomLayout& RandomLayout::
  operator= (const RandomLayout& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->number_ = x.number_;
      this->region_ = x.region_;
    }

    return *this;
  }

  RandomLayout::
  ~RandomLayout ()
  {
  }

  bool
  operator== (const RandomLayout& x, const RandomLayout& y)
  {
    if (!(x.number () == y.number ()))
      return false;

    if (!(x.region () == y.region ()))
      return false;

    return true;
  }

  bool
  operator!= (const RandomLayout& x, const RandomLayout& y)
  {
    return !(x == y);
  }

  // GridLayout
  //

  GridLayout::
  GridLayout ()
  : ::xml_schema::type (),
    xSize_ (this),
    ySize_ (this),
    zSize_ (this)
  {
  }

  GridLayout::
  GridLayout (const GridLayout& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    xSize_ (x.xSize_, f, this),
    ySize_ (x.ySize_, f, this),
    zSize_ (x.zSize_, f, this)
  {
  }

  GridLayout::
  GridLayout (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    xSize_ (this),
    ySize_ (this),
    zSize_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void GridLayout::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "xSize" && n.namespace_ ().empty ())
      {
        this->xSize_.set (xSize_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ySize" && n.namespace_ ().empty ())
      {
        this->ySize_.set (ySize_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "zSize" && n.namespace_ ().empty ())
      {
        this->zSize_.set (zSize_traits::create (i, f, this));
        continue;
      }
    }
  }

  GridLayout* GridLayout::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class GridLayout (*this, f, c);
  }

  GridLayout& GridLayout::
  operator= (const GridLayout& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->xSize_ = x.xSize_;
      this->ySize_ = x.ySize_;
      this->zSize_ = x.zSize_;
    }

    return *this;
  }

  GridLayout::
  ~GridLayout ()
  {
  }

  bool
  operator== (const GridLayout& x, const GridLayout& y)
  {
    if (!(x.xSize () == y.xSize ()))
      return false;

    if (!(x.ySize () == y.ySize ()))
      return false;

    if (!(x.zSize () == y.zSize ()))
      return false;

    return true;
  }

  bool
  operator!= (const GridLayout& x, const GridLayout& y)
  {
    return !(x == y);
  }

  // Instance
  //

  Instance::
  Instance (const location_type& location)
  : ::xml_schema::type (),
    location_ (location, this),
    id_ (this),
    i_ (this),
    j_ (this),
    k_ (this)
  {
  }

  Instance::
  Instance (::std::unique_ptr< location_type > location)
  : ::xml_schema::type (),
    location_ (std::move (location), this),
    id_ (this),
    i_ (this),
    j_ (this),
    k_ (this)
  {
  }

  Instance::
  Instance (const Instance& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    location_ (x.location_, f, this),
    id_ (x.id_, f, this),
    i_ (x.i_, f, this),
    j_ (x.j_, f, this),
    k_ (x.k_, f, this)
  {
  }

  Instance::
  Instance (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    location_ (this),
    id_ (this),
    i_ (this),
    j_ (this),
    k_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Instance::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // location
      //
      if (n.name () == "location" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< location_type > r (
          location_traits::create (i, f, this));

        if (!location_.present ())
        {
          this->location_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!location_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "location",
        "http://www.neuroml.org/schema/neuroml2");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "i" && n.namespace_ ().empty ())
      {
        this->i_.set (i_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "j" && n.namespace_ ().empty ())
      {
        this->j_.set (j_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "k" && n.namespace_ ().empty ())
      {
        this->k_.set (k_traits::create (i, f, this));
        continue;
      }
    }
  }

  Instance* Instance::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Instance (*this, f, c);
  }

  Instance& Instance::
  operator= (const Instance& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->location_ = x.location_;
      this->id_ = x.id_;
      this->i_ = x.i_;
      this->j_ = x.j_;
      this->k_ = x.k_;
    }

    return *this;
  }

  Instance::
  ~Instance ()
  {
  }

  bool
  operator== (const Instance& x, const Instance& y)
  {
    if (!(x.location () == y.location ()))
      return false;

    if (!(x.id () == y.id ()))
      return false;

    if (!(x.i () == y.i ()))
      return false;

    if (!(x.j () == y.j ()))
      return false;

    if (!(x.k () == y.k ()))
      return false;

    return true;
  }

  bool
  operator!= (const Instance& x, const Instance& y)
  {
    return !(x == y);
  }

  // Location
  //

  Location::
  Location (const x_type& x,
            const y_type& y,
            const z_type& z)
  : ::xml_schema::type (),
    x_ (x, this),
    y_ (y, this),
    z_ (z, this)
  {
  }

  Location::
  Location (const Location& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this),
    z_ (x.z_, f, this)
  {
  }

  Location::
  Location (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    x_ (this),
    y_ (this),
    z_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Location::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "y" && n.namespace_ ().empty ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "z" && n.namespace_ ().empty ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "x",
        "");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "y",
        "");
    }

    if (!z_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "z",
        "");
    }
  }

  Location* Location::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Location (*this, f, c);
  }

  Location& Location::
  operator= (const Location& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->x_ = x.x_;
      this->y_ = x.y_;
      this->z_ = x.z_;
    }

    return *this;
  }

  Location::
  ~Location ()
  {
  }

  bool
  operator== (const Location& x, const Location& y)
  {
    if (!(x.x () == y.x ()))
      return false;

    if (!(x.y () == y.y ()))
      return false;

    if (!(x.z () == y.z ()))
      return false;

    return true;
  }

  bool
  operator!= (const Location& x, const Location& y)
  {
    return !(x == y);
  }

  // CellSet
  //

  CellSet::
  CellSet (const id_type& id,
           const select_type& select)
  : ::neuroml2::Base (id),
    select_ (select, this)
  {
  }

  CellSet::
  CellSet (const CellSet& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    select_ (x.select_, f, this)
  {
  }

  CellSet::
  CellSet (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    select_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void CellSet::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "select" && n.namespace_ ().empty ())
      {
        this->select_.set (select_traits::create (i, f, this));
        continue;
      }
    }

    if (!select_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "select",
        "");
    }
  }

  CellSet* CellSet::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CellSet (*this, f, c);
  }

  CellSet& CellSet::
  operator= (const CellSet& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->select_ = x.select_;
    }

    return *this;
  }

  CellSet::
  ~CellSet ()
  {
  }

  bool
  operator== (const CellSet& x, const CellSet& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.select () == y.select ()))
      return false;

    return true;
  }

  bool
  operator!= (const CellSet& x, const CellSet& y)
  {
    return !(x == y);
  }

  // SynapticConnection
  //

  SynapticConnection::
  SynapticConnection (const from_type& from,
                      const to_type& to,
                      const synapse_type& synapse)
  : ::xml_schema::type (),
    from_ (from, this),
    to_ (to, this),
    synapse_ (synapse, this),
    destination_ (this)
  {
  }

  SynapticConnection::
  SynapticConnection (const SynapticConnection& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    from_ (x.from_, f, this),
    to_ (x.to_, f, this),
    synapse_ (x.synapse_, f, this),
    destination_ (x.destination_, f, this)
  {
  }

  SynapticConnection::
  SynapticConnection (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    from_ (this),
    to_ (this),
    synapse_ (this),
    destination_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void SynapticConnection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "from" && n.namespace_ ().empty ())
      {
        this->from_.set (from_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "to" && n.namespace_ ().empty ())
      {
        this->to_.set (to_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "synapse" && n.namespace_ ().empty ())
      {
        this->synapse_.set (synapse_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "destination" && n.namespace_ ().empty ())
      {
        this->destination_.set (destination_traits::create (i, f, this));
        continue;
      }
    }

    if (!from_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "from",
        "");
    }

    if (!to_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "to",
        "");
    }

    if (!synapse_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "synapse",
        "");
    }
  }

  SynapticConnection* SynapticConnection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SynapticConnection (*this, f, c);
  }

  SynapticConnection& SynapticConnection::
  operator= (const SynapticConnection& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->from_ = x.from_;
      this->to_ = x.to_;
      this->synapse_ = x.synapse_;
      this->destination_ = x.destination_;
    }

    return *this;
  }

  SynapticConnection::
  ~SynapticConnection ()
  {
  }

  bool
  operator== (const SynapticConnection& x, const SynapticConnection& y)
  {
    if (!(x.from () == y.from ()))
      return false;

    if (!(x.to () == y.to ()))
      return false;

    if (!(x.synapse () == y.synapse ()))
      return false;

    if (!(x.destination () == y.destination ()))
      return false;

    return true;
  }

  bool
  operator!= (const SynapticConnection& x, const SynapticConnection& y)
  {
    return !(x == y);
  }

  // BaseProjection
  //

  BaseProjection::
  BaseProjection (const id_type& id,
                  const presynapticPopulation_type& presynapticPopulation,
                  const postsynapticPopulation_type& postsynapticPopulation)
  : ::neuroml2::Base (id),
    presynapticPopulation_ (presynapticPopulation, this),
    postsynapticPopulation_ (postsynapticPopulation, this)
  {
  }

  BaseProjection::
  BaseProjection (const BaseProjection& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    presynapticPopulation_ (x.presynapticPopulation_, f, this),
    postsynapticPopulation_ (x.postsynapticPopulation_, f, this)
  {
  }

  BaseProjection::
  BaseProjection (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    presynapticPopulation_ (this),
    postsynapticPopulation_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void BaseProjection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "presynapticPopulation" && n.namespace_ ().empty ())
      {
        this->presynapticPopulation_.set (presynapticPopulation_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "postsynapticPopulation" && n.namespace_ ().empty ())
      {
        this->postsynapticPopulation_.set (postsynapticPopulation_traits::create (i, f, this));
        continue;
      }
    }

    if (!presynapticPopulation_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "presynapticPopulation",
        "");
    }

    if (!postsynapticPopulation_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "postsynapticPopulation",
        "");
    }
  }

  BaseProjection* BaseProjection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BaseProjection (*this, f, c);
  }

  BaseProjection& BaseProjection::
  operator= (const BaseProjection& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->presynapticPopulation_ = x.presynapticPopulation_;
      this->postsynapticPopulation_ = x.postsynapticPopulation_;
    }

    return *this;
  }

  BaseProjection::
  ~BaseProjection ()
  {
  }

  bool
  operator== (const BaseProjection& x, const BaseProjection& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.presynapticPopulation () == y.presynapticPopulation ()))
      return false;

    if (!(x.postsynapticPopulation () == y.postsynapticPopulation ()))
      return false;

    return true;
  }

  bool
  operator!= (const BaseProjection& x, const BaseProjection& y)
  {
    return !(x == y);
  }

  // Projection
  //

  Projection::
  Projection (const id_type& id,
              const presynapticPopulation_type& presynapticPopulation,
              const postsynapticPopulation_type& postsynapticPopulation,
              const synapse_type& synapse)
  : ::neuroml2::BaseProjection (id,
                                presynapticPopulation,
                                postsynapticPopulation),
    connection_ (this),
    connectionWD_ (this),
    synapse_ (synapse, this)
  {
  }

  Projection::
  Projection (const Projection& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::neuroml2::BaseProjection (x, f, c),
    connection_ (x.connection_, f, this),
    connectionWD_ (x.connectionWD_, f, this),
    synapse_ (x.synapse_, f, this)
  {
  }

  Projection::
  Projection (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::neuroml2::BaseProjection (e, f | ::xml_schema::flags::base, c),
    connection_ (this),
    connectionWD_ (this),
    synapse_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Projection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseProjection::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // connection
      //
      if (n.name () == "connection" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< connection_type > r (
          connection_traits::create (i, f, this));

        this->connection_.push_back (::std::move (r));
        continue;
      }

      // connectionWD
      //
      if (n.name () == "connectionWD" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< connectionWD_type > r (
          connectionWD_traits::create (i, f, this));

        this->connectionWD_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "synapse" && n.namespace_ ().empty ())
      {
        this->synapse_.set (synapse_traits::create (i, f, this));
        continue;
      }
    }

    if (!synapse_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "synapse",
        "");
    }
  }

  Projection* Projection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Projection (*this, f, c);
  }

  Projection& Projection::
  operator= (const Projection& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseProjection& > (*this) = x;
      this->connection_ = x.connection_;
      this->connectionWD_ = x.connectionWD_;
      this->synapse_ = x.synapse_;
    }

    return *this;
  }

  Projection::
  ~Projection ()
  {
  }

  bool
  operator== (const Projection& x, const Projection& y)
  {
    if (!(static_cast< const ::neuroml2::BaseProjection& > (x) ==
          static_cast< const ::neuroml2::BaseProjection& > (y)))
      return false;

    if (!(x.connection () == y.connection ()))
      return false;

    if (!(x.connectionWD () == y.connectionWD ()))
      return false;

    if (!(x.synapse () == y.synapse ()))
      return false;

    return true;
  }

  bool
  operator!= (const Projection& x, const Projection& y)
  {
    return !(x == y);
  }

  // BaseConnection
  //

  BaseConnection::
  BaseConnection (const id_type& id)
  : ::neuroml2::BaseNonNegativeIntegerId (id)
  {
  }

  BaseConnection::
  BaseConnection (const BaseConnection& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::neuroml2::BaseNonNegativeIntegerId (x, f, c)
  {
  }

  BaseConnection::
  BaseConnection (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::neuroml2::BaseNonNegativeIntegerId (e, f, c)
  {
  }

  BaseConnection* BaseConnection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BaseConnection (*this, f, c);
  }

  BaseConnection::
  ~BaseConnection ()
  {
  }

  // BaseConnectionOldFormat
  //

  BaseConnectionOldFormat::
  BaseConnectionOldFormat (const id_type& id,
                           const preCellId_type& preCellId,
                           const postCellId_type& postCellId)
  : ::neuroml2::BaseConnection (id),
    preCellId_ (preCellId, this),
    preSegmentId_ (preSegmentId_default_value (), this),
    preFractionAlong_ (preFractionAlong_default_value (), this),
    postCellId_ (postCellId, this),
    postSegmentId_ (postSegmentId_default_value (), this),
    postFractionAlong_ (postFractionAlong_default_value (), this)
  {
  }

  BaseConnectionOldFormat::
  BaseConnectionOldFormat (const BaseConnectionOldFormat& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::neuroml2::BaseConnection (x, f, c),
    preCellId_ (x.preCellId_, f, this),
    preSegmentId_ (x.preSegmentId_, f, this),
    preFractionAlong_ (x.preFractionAlong_, f, this),
    postCellId_ (x.postCellId_, f, this),
    postSegmentId_ (x.postSegmentId_, f, this),
    postFractionAlong_ (x.postFractionAlong_, f, this)
  {
  }

  BaseConnectionOldFormat::
  BaseConnectionOldFormat (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::neuroml2::BaseConnection (e, f | ::xml_schema::flags::base, c),
    preCellId_ (this),
    preSegmentId_ (this),
    preFractionAlong_ (this),
    postCellId_ (this),
    postSegmentId_ (this),
    postFractionAlong_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void BaseConnectionOldFormat::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseConnection::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "preCellId" && n.namespace_ ().empty ())
      {
        this->preCellId_.set (preCellId_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "preSegmentId" && n.namespace_ ().empty ())
      {
        this->preSegmentId_.set (preSegmentId_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "preFractionAlong" && n.namespace_ ().empty ())
      {
        this->preFractionAlong_.set (preFractionAlong_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "postCellId" && n.namespace_ ().empty ())
      {
        this->postCellId_.set (postCellId_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "postSegmentId" && n.namespace_ ().empty ())
      {
        this->postSegmentId_.set (postSegmentId_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "postFractionAlong" && n.namespace_ ().empty ())
      {
        this->postFractionAlong_.set (postFractionAlong_traits::create (i, f, this));
        continue;
      }
    }

    if (!preCellId_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "preCellId",
        "");
    }

    if (!preSegmentId_.present ())
    {
      this->preSegmentId_.set (preSegmentId_default_value ());
    }

    if (!preFractionAlong_.present ())
    {
      this->preFractionAlong_.set (preFractionAlong_default_value ());
    }

    if (!postCellId_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "postCellId",
        "");
    }

    if (!postSegmentId_.present ())
    {
      this->postSegmentId_.set (postSegmentId_default_value ());
    }

    if (!postFractionAlong_.present ())
    {
      this->postFractionAlong_.set (postFractionAlong_default_value ());
    }
  }

  BaseConnectionOldFormat* BaseConnectionOldFormat::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BaseConnectionOldFormat (*this, f, c);
  }

  BaseConnectionOldFormat& BaseConnectionOldFormat::
  operator= (const BaseConnectionOldFormat& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseConnection& > (*this) = x;
      this->preCellId_ = x.preCellId_;
      this->preSegmentId_ = x.preSegmentId_;
      this->preFractionAlong_ = x.preFractionAlong_;
      this->postCellId_ = x.postCellId_;
      this->postSegmentId_ = x.postSegmentId_;
      this->postFractionAlong_ = x.postFractionAlong_;
    }

    return *this;
  }

  BaseConnectionOldFormat::
  ~BaseConnectionOldFormat ()
  {
  }

  bool
  operator== (const BaseConnectionOldFormat& x, const BaseConnectionOldFormat& y)
  {
    if (!(static_cast< const ::neuroml2::BaseConnection& > (x) ==
          static_cast< const ::neuroml2::BaseConnection& > (y)))
      return false;

    if (!(x.preCellId () == y.preCellId ()))
      return false;

    if (!(x.preSegmentId () == y.preSegmentId ()))
      return false;

    if (!(x.preFractionAlong () == y.preFractionAlong ()))
      return false;

    if (!(x.postCellId () == y.postCellId ()))
      return false;

    if (!(x.postSegmentId () == y.postSegmentId ()))
      return false;

    if (!(x.postFractionAlong () == y.postFractionAlong ()))
      return false;

    return true;
  }

  bool
  operator!= (const BaseConnectionOldFormat& x, const BaseConnectionOldFormat& y)
  {
    return !(x == y);
  }

  // BaseConnectionNewFormat
  //

  BaseConnectionNewFormat::
  BaseConnectionNewFormat (const id_type& id,
                           const preCell_type& preCell,
                           const postCell_type& postCell)
  : ::neuroml2::BaseConnection (id),
    preCell_ (preCell, this),
    preSegment_ (preSegment_default_value (), this),
    preFractionAlong_ (preFractionAlong_default_value (), this),
    postCell_ (postCell, this),
    postSegment_ (postSegment_default_value (), this),
    postFractionAlong_ (postFractionAlong_default_value (), this)
  {
  }

  BaseConnectionNewFormat::
  BaseConnectionNewFormat (const BaseConnectionNewFormat& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::neuroml2::BaseConnection (x, f, c),
    preCell_ (x.preCell_, f, this),
    preSegment_ (x.preSegment_, f, this),
    preFractionAlong_ (x.preFractionAlong_, f, this),
    postCell_ (x.postCell_, f, this),
    postSegment_ (x.postSegment_, f, this),
    postFractionAlong_ (x.postFractionAlong_, f, this)
  {
  }

  BaseConnectionNewFormat::
  BaseConnectionNewFormat (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::neuroml2::BaseConnection (e, f | ::xml_schema::flags::base, c),
    preCell_ (this),
    preSegment_ (this),
    preFractionAlong_ (this),
    postCell_ (this),
    postSegment_ (this),
    postFractionAlong_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void BaseConnectionNewFormat::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseConnection::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "preCell" && n.namespace_ ().empty ())
      {
        this->preCell_.set (preCell_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "preSegment" && n.namespace_ ().empty ())
      {
        this->preSegment_.set (preSegment_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "preFractionAlong" && n.namespace_ ().empty ())
      {
        this->preFractionAlong_.set (preFractionAlong_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "postCell" && n.namespace_ ().empty ())
      {
        this->postCell_.set (postCell_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "postSegment" && n.namespace_ ().empty ())
      {
        this->postSegment_.set (postSegment_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "postFractionAlong" && n.namespace_ ().empty ())
      {
        this->postFractionAlong_.set (postFractionAlong_traits::create (i, f, this));
        continue;
      }
    }

    if (!preCell_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "preCell",
        "");
    }

    if (!preSegment_.present ())
    {
      this->preSegment_.set (preSegment_default_value ());
    }

    if (!preFractionAlong_.present ())
    {
      this->preFractionAlong_.set (preFractionAlong_default_value ());
    }

    if (!postCell_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "postCell",
        "");
    }

    if (!postSegment_.present ())
    {
      this->postSegment_.set (postSegment_default_value ());
    }

    if (!postFractionAlong_.present ())
    {
      this->postFractionAlong_.set (postFractionAlong_default_value ());
    }
  }

  BaseConnectionNewFormat* BaseConnectionNewFormat::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BaseConnectionNewFormat (*this, f, c);
  }

  BaseConnectionNewFormat& BaseConnectionNewFormat::
  operator= (const BaseConnectionNewFormat& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseConnection& > (*this) = x;
      this->preCell_ = x.preCell_;
      this->preSegment_ = x.preSegment_;
      this->preFractionAlong_ = x.preFractionAlong_;
      this->postCell_ = x.postCell_;
      this->postSegment_ = x.postSegment_;
      this->postFractionAlong_ = x.postFractionAlong_;
    }

    return *this;
  }

  BaseConnectionNewFormat::
  ~BaseConnectionNewFormat ()
  {
  }

  bool
  operator== (const BaseConnectionNewFormat& x, const BaseConnectionNewFormat& y)
  {
    if (!(static_cast< const ::neuroml2::BaseConnection& > (x) ==
          static_cast< const ::neuroml2::BaseConnection& > (y)))
      return false;

    if (!(x.preCell () == y.preCell ()))
      return false;

    if (!(x.preSegment () == y.preSegment ()))
      return false;

    if (!(x.preFractionAlong () == y.preFractionAlong ()))
      return false;

    if (!(x.postCell () == y.postCell ()))
      return false;

    if (!(x.postSegment () == y.postSegment ()))
      return false;

    if (!(x.postFractionAlong () == y.postFractionAlong ()))
      return false;

    return true;
  }

  bool
  operator!= (const BaseConnectionNewFormat& x, const BaseConnectionNewFormat& y)
  {
    return !(x == y);
  }

  // Connection_base
  //

  Connection_base::
  Connection_base (const id_type& id,
                   const preCellId_type& preCellId,
                   const postCellId_type& postCellId)
  : ::neuroml2::BaseConnectionOldFormat (id,
                                         preCellId,
                                         postCellId)
  {
  }

  Connection_base::
  Connection_base (const Connection_base& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::neuroml2::BaseConnectionOldFormat (x, f, c)
  {
  }

  Connection_base::
  Connection_base (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::neuroml2::BaseConnectionOldFormat (e, f, c)
  {
  }

  Connection_base* Connection_base::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Connection_base (*this, f, c);
  }

  Connection_base::
  ~Connection_base ()
  {
  }

  // ConnectionWD
  //

  ConnectionWD::
  ConnectionWD (const id_type& id,
                const preCellId_type& preCellId,
                const postCellId_type& postCellId,
                const weight_type& weight,
                const delay_type& delay)
  : ::neuroml2::BaseConnectionOldFormat (id,
                                         preCellId,
                                         postCellId),
    weight_ (weight, this),
    delay_ (delay, this)
  {
  }

  ConnectionWD::
  ConnectionWD (const ConnectionWD& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::neuroml2::BaseConnectionOldFormat (x, f, c),
    weight_ (x.weight_, f, this),
    delay_ (x.delay_, f, this)
  {
  }

  ConnectionWD::
  ConnectionWD (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::neuroml2::BaseConnectionOldFormat (e, f | ::xml_schema::flags::base, c),
    weight_ (this),
    delay_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ConnectionWD::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseConnectionOldFormat::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "weight" && n.namespace_ ().empty ())
      {
        this->weight_.set (weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "delay" && n.namespace_ ().empty ())
      {
        this->delay_.set (delay_traits::create (i, f, this));
        continue;
      }
    }

    if (!weight_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "weight",
        "");
    }

    if (!delay_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "delay",
        "");
    }
  }

  ConnectionWD* ConnectionWD::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConnectionWD (*this, f, c);
  }

  ConnectionWD& ConnectionWD::
  operator= (const ConnectionWD& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseConnectionOldFormat& > (*this) = x;
      this->weight_ = x.weight_;
      this->delay_ = x.delay_;
    }

    return *this;
  }

  ConnectionWD::
  ~ConnectionWD ()
  {
  }

  bool
  operator== (const ConnectionWD& x, const ConnectionWD& y)
  {
    if (!(static_cast< const ::neuroml2::BaseConnectionOldFormat& > (x) ==
          static_cast< const ::neuroml2::BaseConnectionOldFormat& > (y)))
      return false;

    if (!(x.weight () == y.weight ()))
      return false;

    if (!(x.delay () == y.delay ()))
      return false;

    return true;
  }

  bool
  operator!= (const ConnectionWD& x, const ConnectionWD& y)
  {
    return !(x == y);
  }

  // ElectricalProjection
  //

  ElectricalProjection::
  ElectricalProjection (const id_type& id,
                        const presynapticPopulation_type& presynapticPopulation,
                        const postsynapticPopulation_type& postsynapticPopulation)
  : ::neuroml2::BaseProjection (id,
                                presynapticPopulation,
                                postsynapticPopulation),
    electricalConnection_ (this),
    electricalConnectionInstance_ (this),
    electricalConnectionInstanceW_ (this)
  {
  }

  ElectricalProjection::
  ElectricalProjection (const ElectricalProjection& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::neuroml2::BaseProjection (x, f, c),
    electricalConnection_ (x.electricalConnection_, f, this),
    electricalConnectionInstance_ (x.electricalConnectionInstance_, f, this),
    electricalConnectionInstanceW_ (x.electricalConnectionInstanceW_, f, this)
  {
  }

  ElectricalProjection::
  ElectricalProjection (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::neuroml2::BaseProjection (e, f | ::xml_schema::flags::base, c),
    electricalConnection_ (this),
    electricalConnectionInstance_ (this),
    electricalConnectionInstanceW_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ElectricalProjection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseProjection::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // electricalConnection
      //
      if (n.name () == "electricalConnection" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< electricalConnection_type > r (
          electricalConnection_traits::create (i, f, this));

        this->electricalConnection_.push_back (::std::move (r));
        continue;
      }

      // electricalConnectionInstance
      //
      if (n.name () == "electricalConnectionInstance" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< electricalConnectionInstance_type > r (
          electricalConnectionInstance_traits::create (i, f, this));

        this->electricalConnectionInstance_.push_back (::std::move (r));
        continue;
      }

      // electricalConnectionInstanceW
      //
      if (n.name () == "electricalConnectionInstanceW" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< electricalConnectionInstanceW_type > r (
          electricalConnectionInstanceW_traits::create (i, f, this));

        this->electricalConnectionInstanceW_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ElectricalProjection* ElectricalProjection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ElectricalProjection (*this, f, c);
  }

  ElectricalProjection& ElectricalProjection::
  operator= (const ElectricalProjection& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseProjection& > (*this) = x;
      this->electricalConnection_ = x.electricalConnection_;
      this->electricalConnectionInstance_ = x.electricalConnectionInstance_;
      this->electricalConnectionInstanceW_ = x.electricalConnectionInstanceW_;
    }

    return *this;
  }

  ElectricalProjection::
  ~ElectricalProjection ()
  {
  }

  bool
  operator== (const ElectricalProjection& x, const ElectricalProjection& y)
  {
    if (!(static_cast< const ::neuroml2::BaseProjection& > (x) ==
          static_cast< const ::neuroml2::BaseProjection& > (y)))
      return false;

    if (!(x.electricalConnection () == y.electricalConnection ()))
      return false;

    if (!(x.electricalConnectionInstance () == y.electricalConnectionInstance ()))
      return false;

    if (!(x.electricalConnectionInstanceW () == y.electricalConnectionInstanceW ()))
      return false;

    return true;
  }

  bool
  operator!= (const ElectricalProjection& x, const ElectricalProjection& y)
  {
    return !(x == y);
  }

  // ElectricalConnection
  //

  ElectricalConnection::
  ElectricalConnection (const id_type& id,
                        const preCell_type& preCell,
                        const postCell_type& postCell,
                        const synapse_type& synapse)
  : ::neuroml2::BaseConnectionNewFormat (id,
                                         preCell,
                                         postCell),
    synapse_ (synapse, this)
  {
  }

  ElectricalConnection::
  ElectricalConnection (const ElectricalConnection& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::neuroml2::BaseConnectionNewFormat (x, f, c),
    synapse_ (x.synapse_, f, this)
  {
  }

  ElectricalConnection::
  ElectricalConnection (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::neuroml2::BaseConnectionNewFormat (e, f | ::xml_schema::flags::base, c),
    synapse_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ElectricalConnection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseConnectionNewFormat::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "synapse" && n.namespace_ ().empty ())
      {
        this->synapse_.set (synapse_traits::create (i, f, this));
        continue;
      }
    }

    if (!synapse_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "synapse",
        "");
    }
  }

  ElectricalConnection* ElectricalConnection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ElectricalConnection (*this, f, c);
  }

  ElectricalConnection& ElectricalConnection::
  operator= (const ElectricalConnection& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseConnectionNewFormat& > (*this) = x;
      this->synapse_ = x.synapse_;
    }

    return *this;
  }

  ElectricalConnection::
  ~ElectricalConnection ()
  {
  }

  bool
  operator== (const ElectricalConnection& x, const ElectricalConnection& y)
  {
    if (!(static_cast< const ::neuroml2::BaseConnectionNewFormat& > (x) ==
          static_cast< const ::neuroml2::BaseConnectionNewFormat& > (y)))
      return false;

    if (!(x.synapse () == y.synapse ()))
      return false;

    return true;
  }

  bool
  operator!= (const ElectricalConnection& x, const ElectricalConnection& y)
  {
    return !(x == y);
  }

  // ElectricalConnectionInstance
  //

  ElectricalConnectionInstance::
  ElectricalConnectionInstance (const id_type& id,
                                const preCell_type& preCell,
                                const postCell_type& postCell,
                                const synapse_type& synapse)
  : ::neuroml2::ElectricalConnection (id,
                                      preCell,
                                      postCell,
                                      synapse)
  {
  }

  ElectricalConnectionInstance::
  ElectricalConnectionInstance (const ElectricalConnectionInstance& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::neuroml2::ElectricalConnection (x, f, c)
  {
  }

  ElectricalConnectionInstance::
  ElectricalConnectionInstance (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::neuroml2::ElectricalConnection (e, f, c)
  {
  }

  ElectricalConnectionInstance* ElectricalConnectionInstance::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ElectricalConnectionInstance (*this, f, c);
  }

  ElectricalConnectionInstance::
  ~ElectricalConnectionInstance ()
  {
  }

  // ElectricalConnectionInstanceW
  //

  ElectricalConnectionInstanceW::
  ElectricalConnectionInstanceW (const id_type& id,
                                 const preCell_type& preCell,
                                 const postCell_type& postCell,
                                 const synapse_type& synapse,
                                 const weight_type& weight)
  : ::neuroml2::ElectricalConnectionInstance (id,
                                              preCell,
                                              postCell,
                                              synapse),
    weight_ (weight, this)
  {
  }

  ElectricalConnectionInstanceW::
  ElectricalConnectionInstanceW (const ElectricalConnectionInstanceW& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::neuroml2::ElectricalConnectionInstance (x, f, c),
    weight_ (x.weight_, f, this)
  {
  }

  ElectricalConnectionInstanceW::
  ElectricalConnectionInstanceW (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::neuroml2::ElectricalConnectionInstance (e, f | ::xml_schema::flags::base, c),
    weight_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ElectricalConnectionInstanceW::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::ElectricalConnectionInstance::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "weight" && n.namespace_ ().empty ())
      {
        this->weight_.set (weight_traits::create (i, f, this));
        continue;
      }
    }

    if (!weight_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "weight",
        "");
    }
  }

  ElectricalConnectionInstanceW* ElectricalConnectionInstanceW::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ElectricalConnectionInstanceW (*this, f, c);
  }

  ElectricalConnectionInstanceW& ElectricalConnectionInstanceW::
  operator= (const ElectricalConnectionInstanceW& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::ElectricalConnectionInstance& > (*this) = x;
      this->weight_ = x.weight_;
    }

    return *this;
  }

  ElectricalConnectionInstanceW::
  ~ElectricalConnectionInstanceW ()
  {
  }

  bool
  operator== (const ElectricalConnectionInstanceW& x, const ElectricalConnectionInstanceW& y)
  {
    if (!(static_cast< const ::neuroml2::ElectricalConnectionInstance& > (x) ==
          static_cast< const ::neuroml2::ElectricalConnectionInstance& > (y)))
      return false;

    if (!(x.weight () == y.weight ()))
      return false;

    return true;
  }

  bool
  operator!= (const ElectricalConnectionInstanceW& x, const ElectricalConnectionInstanceW& y)
  {
    return !(x == y);
  }

  // ContinuousProjection
  //

  ContinuousProjection::
  ContinuousProjection (const id_type& id,
                        const presynapticPopulation_type& presynapticPopulation,
                        const postsynapticPopulation_type& postsynapticPopulation)
  : ::neuroml2::BaseProjection (id,
                                presynapticPopulation,
                                postsynapticPopulation),
    continuousConnection_ (this),
    continuousConnectionInstance_ (this),
    continuousConnectionInstanceW_ (this)
  {
  }

  ContinuousProjection::
  ContinuousProjection (const ContinuousProjection& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::neuroml2::BaseProjection (x, f, c),
    continuousConnection_ (x.continuousConnection_, f, this),
    continuousConnectionInstance_ (x.continuousConnectionInstance_, f, this),
    continuousConnectionInstanceW_ (x.continuousConnectionInstanceW_, f, this)
  {
  }

  ContinuousProjection::
  ContinuousProjection (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::neuroml2::BaseProjection (e, f | ::xml_schema::flags::base, c),
    continuousConnection_ (this),
    continuousConnectionInstance_ (this),
    continuousConnectionInstanceW_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ContinuousProjection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseProjection::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // continuousConnection
      //
      if (n.name () == "continuousConnection" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< continuousConnection_type > r (
          continuousConnection_traits::create (i, f, this));

        this->continuousConnection_.push_back (::std::move (r));
        continue;
      }

      // continuousConnectionInstance
      //
      if (n.name () == "continuousConnectionInstance" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< continuousConnectionInstance_type > r (
          continuousConnectionInstance_traits::create (i, f, this));

        this->continuousConnectionInstance_.push_back (::std::move (r));
        continue;
      }

      // continuousConnectionInstanceW
      //
      if (n.name () == "continuousConnectionInstanceW" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< continuousConnectionInstanceW_type > r (
          continuousConnectionInstanceW_traits::create (i, f, this));

        this->continuousConnectionInstanceW_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ContinuousProjection* ContinuousProjection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ContinuousProjection (*this, f, c);
  }

  ContinuousProjection& ContinuousProjection::
  operator= (const ContinuousProjection& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseProjection& > (*this) = x;
      this->continuousConnection_ = x.continuousConnection_;
      this->continuousConnectionInstance_ = x.continuousConnectionInstance_;
      this->continuousConnectionInstanceW_ = x.continuousConnectionInstanceW_;
    }

    return *this;
  }

  ContinuousProjection::
  ~ContinuousProjection ()
  {
  }

  bool
  operator== (const ContinuousProjection& x, const ContinuousProjection& y)
  {
    if (!(static_cast< const ::neuroml2::BaseProjection& > (x) ==
          static_cast< const ::neuroml2::BaseProjection& > (y)))
      return false;

    if (!(x.continuousConnection () == y.continuousConnection ()))
      return false;

    if (!(x.continuousConnectionInstance () == y.continuousConnectionInstance ()))
      return false;

    if (!(x.continuousConnectionInstanceW () == y.continuousConnectionInstanceW ()))
      return false;

    return true;
  }

  bool
  operator!= (const ContinuousProjection& x, const ContinuousProjection& y)
  {
    return !(x == y);
  }

  // ContinuousConnection
  //

  ContinuousConnection::
  ContinuousConnection (const id_type& id,
                        const preCell_type& preCell,
                        const postCell_type& postCell,
                        const preComponent_type& preComponent,
                        const postComponent_type& postComponent)
  : ::neuroml2::BaseConnectionNewFormat (id,
                                         preCell,
                                         postCell),
    preComponent_ (preComponent, this),
    postComponent_ (postComponent, this)
  {
  }

  ContinuousConnection::
  ContinuousConnection (const ContinuousConnection& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::neuroml2::BaseConnectionNewFormat (x, f, c),
    preComponent_ (x.preComponent_, f, this),
    postComponent_ (x.postComponent_, f, this)
  {
  }

  ContinuousConnection::
  ContinuousConnection (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::neuroml2::BaseConnectionNewFormat (e, f | ::xml_schema::flags::base, c),
    preComponent_ (this),
    postComponent_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ContinuousConnection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseConnectionNewFormat::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "preComponent" && n.namespace_ ().empty ())
      {
        this->preComponent_.set (preComponent_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "postComponent" && n.namespace_ ().empty ())
      {
        this->postComponent_.set (postComponent_traits::create (i, f, this));
        continue;
      }
    }

    if (!preComponent_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "preComponent",
        "");
    }

    if (!postComponent_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "postComponent",
        "");
    }
  }

  ContinuousConnection* ContinuousConnection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ContinuousConnection (*this, f, c);
  }

  ContinuousConnection& ContinuousConnection::
  operator= (const ContinuousConnection& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseConnectionNewFormat& > (*this) = x;
      this->preComponent_ = x.preComponent_;
      this->postComponent_ = x.postComponent_;
    }

    return *this;
  }

  ContinuousConnection::
  ~ContinuousConnection ()
  {
  }

  bool
  operator== (const ContinuousConnection& x, const ContinuousConnection& y)
  {
    if (!(static_cast< const ::neuroml2::BaseConnectionNewFormat& > (x) ==
          static_cast< const ::neuroml2::BaseConnectionNewFormat& > (y)))
      return false;

    if (!(x.preComponent () == y.preComponent ()))
      return false;

    if (!(x.postComponent () == y.postComponent ()))
      return false;

    return true;
  }

  bool
  operator!= (const ContinuousConnection& x, const ContinuousConnection& y)
  {
    return !(x == y);
  }

  // ContinuousConnectionInstance
  //

  ContinuousConnectionInstance::
  ContinuousConnectionInstance (const id_type& id,
                                const preCell_type& preCell,
                                const postCell_type& postCell,
                                const preComponent_type& preComponent,
                                const postComponent_type& postComponent)
  : ::neuroml2::ContinuousConnection (id,
                                      preCell,
                                      postCell,
                                      preComponent,
                                      postComponent)
  {
  }

  ContinuousConnectionInstance::
  ContinuousConnectionInstance (const ContinuousConnectionInstance& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::neuroml2::ContinuousConnection (x, f, c)
  {
  }

  ContinuousConnectionInstance::
  ContinuousConnectionInstance (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::neuroml2::ContinuousConnection (e, f, c)
  {
  }

  ContinuousConnectionInstance* ContinuousConnectionInstance::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ContinuousConnectionInstance (*this, f, c);
  }

  ContinuousConnectionInstance::
  ~ContinuousConnectionInstance ()
  {
  }

  // ContinuousConnectionInstanceW
  //

  ContinuousConnectionInstanceW::
  ContinuousConnectionInstanceW (const id_type& id,
                                 const preCell_type& preCell,
                                 const postCell_type& postCell,
                                 const preComponent_type& preComponent,
                                 const postComponent_type& postComponent,
                                 const weight_type& weight)
  : ::neuroml2::ContinuousConnectionInstance (id,
                                              preCell,
                                              postCell,
                                              preComponent,
                                              postComponent),
    weight_ (weight, this)
  {
  }

  ContinuousConnectionInstanceW::
  ContinuousConnectionInstanceW (const ContinuousConnectionInstanceW& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::neuroml2::ContinuousConnectionInstance (x, f, c),
    weight_ (x.weight_, f, this)
  {
  }

  ContinuousConnectionInstanceW::
  ContinuousConnectionInstanceW (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::neuroml2::ContinuousConnectionInstance (e, f | ::xml_schema::flags::base, c),
    weight_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ContinuousConnectionInstanceW::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::ContinuousConnectionInstance::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "weight" && n.namespace_ ().empty ())
      {
        this->weight_.set (weight_traits::create (i, f, this));
        continue;
      }
    }

    if (!weight_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "weight",
        "");
    }
  }

  ContinuousConnectionInstanceW* ContinuousConnectionInstanceW::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ContinuousConnectionInstanceW (*this, f, c);
  }

  ContinuousConnectionInstanceW& ContinuousConnectionInstanceW::
  operator= (const ContinuousConnectionInstanceW& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::ContinuousConnectionInstance& > (*this) = x;
      this->weight_ = x.weight_;
    }

    return *this;
  }

  ContinuousConnectionInstanceW::
  ~ContinuousConnectionInstanceW ()
  {
  }

  bool
  operator== (const ContinuousConnectionInstanceW& x, const ContinuousConnectionInstanceW& y)
  {
    if (!(static_cast< const ::neuroml2::ContinuousConnectionInstance& > (x) ==
          static_cast< const ::neuroml2::ContinuousConnectionInstance& > (y)))
      return false;

    if (!(x.weight () == y.weight ()))
      return false;

    return true;
  }

  bool
  operator!= (const ContinuousConnectionInstanceW& x, const ContinuousConnectionInstanceW& y)
  {
    return !(x == y);
  }

  // ExplicitInput
  //

  ExplicitInput::
  ExplicitInput (const target_type& target,
                 const input_type& input)
  : ::xml_schema::type (),
    target_ (target, this),
    input_ (input, this),
    destination_ (this)
  {
  }

  ExplicitInput::
  ExplicitInput (const ExplicitInput& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    target_ (x.target_, f, this),
    input_ (x.input_, f, this),
    destination_ (x.destination_, f, this)
  {
  }

  ExplicitInput::
  ExplicitInput (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    target_ (this),
    input_ (this),
    destination_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ExplicitInput::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "target" && n.namespace_ ().empty ())
      {
        this->target_.set (target_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "input" && n.namespace_ ().empty ())
      {
        this->input_.set (input_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "destination" && n.namespace_ ().empty ())
      {
        this->destination_.set (destination_traits::create (i, f, this));
        continue;
      }
    }

    if (!target_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "target",
        "");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "input",
        "");
    }
  }

  ExplicitInput* ExplicitInput::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ExplicitInput (*this, f, c);
  }

  ExplicitInput& ExplicitInput::
  operator= (const ExplicitInput& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->target_ = x.target_;
      this->input_ = x.input_;
      this->destination_ = x.destination_;
    }

    return *this;
  }

  ExplicitInput::
  ~ExplicitInput ()
  {
  }

  bool
  operator== (const ExplicitInput& x, const ExplicitInput& y)
  {
    if (!(x.target () == y.target ()))
      return false;

    if (!(x.input () == y.input ()))
      return false;

    if (!(x.destination () == y.destination ()))
      return false;

    return true;
  }

  bool
  operator!= (const ExplicitInput& x, const ExplicitInput& y)
  {
    return !(x == y);
  }

  // InputList
  //

  InputList::
  InputList (const id_type& id,
             const population_type& population,
             const component_type& component)
  : ::neuroml2::Base (id),
    input_ (this),
    inputW_ (this),
    population_ (population, this),
    component_ (component, this)
  {
  }

  InputList::
  InputList (const InputList& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::neuroml2::Base (x, f, c),
    input_ (x.input_, f, this),
    inputW_ (x.inputW_, f, this),
    population_ (x.population_, f, this),
    component_ (x.component_, f, this)
  {
  }

  InputList::
  InputList (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::neuroml2::Base (e, f | ::xml_schema::flags::base, c),
    input_ (this),
    inputW_ (this),
    population_ (this),
    component_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void InputList::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< input_type > r (
          input_traits::create (i, f, this));

        this->input_.push_back (::std::move (r));
        continue;
      }

      // inputW
      //
      if (n.name () == "inputW" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< inputW_type > r (
          inputW_traits::create (i, f, this));

        this->inputW_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "population" && n.namespace_ ().empty ())
      {
        this->population_.set (population_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "component" && n.namespace_ ().empty ())
      {
        this->component_.set (component_traits::create (i, f, this));
        continue;
      }
    }

    if (!population_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "population",
        "");
    }

    if (!component_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "component",
        "");
    }
  }

  InputList* InputList::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InputList (*this, f, c);
  }

  InputList& InputList::
  operator= (const InputList& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Base& > (*this) = x;
      this->input_ = x.input_;
      this->inputW_ = x.inputW_;
      this->population_ = x.population_;
      this->component_ = x.component_;
    }

    return *this;
  }

  InputList::
  ~InputList ()
  {
  }

  bool
  operator== (const InputList& x, const InputList& y)
  {
    if (!(static_cast< const ::neuroml2::Base& > (x) ==
          static_cast< const ::neuroml2::Base& > (y)))
      return false;

    if (!(x.input () == y.input ()))
      return false;

    if (!(x.inputW () == y.inputW ()))
      return false;

    if (!(x.population () == y.population ()))
      return false;

    if (!(x.component () == y.component ()))
      return false;

    return true;
  }

  bool
  operator!= (const InputList& x, const InputList& y)
  {
    return !(x == y);
  }

  // Input
  //

  Input::
  Input (const id_type& id,
         const target_type& target,
         const destination_type& destination)
  : ::xml_schema::type (),
    id_ (id, this),
    target_ (target, this),
    destination_ (destination, this),
    segmentId_ (this),
    fractionAlong_ (this)
  {
  }

  Input::
  Input (const Input& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this),
    target_ (x.target_, f, this),
    destination_ (x.destination_, f, this),
    segmentId_ (x.segmentId_, f, this),
    fractionAlong_ (x.fractionAlong_, f, this)
  {
  }

  Input::
  Input (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (this),
    target_ (this),
    destination_ (this),
    segmentId_ (this),
    fractionAlong_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Input::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "target" && n.namespace_ ().empty ())
      {
        this->target_.set (target_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "destination" && n.namespace_ ().empty ())
      {
        this->destination_.set (destination_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "segmentId" && n.namespace_ ().empty ())
      {
        this->segmentId_.set (segmentId_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "fractionAlong" && n.namespace_ ().empty ())
      {
        this->fractionAlong_.set (fractionAlong_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!target_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "target",
        "");
    }

    if (!destination_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "destination",
        "");
    }
  }

  Input* Input::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Input (*this, f, c);
  }

  Input& Input::
  operator= (const Input& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->id_ = x.id_;
      this->target_ = x.target_;
      this->destination_ = x.destination_;
      this->segmentId_ = x.segmentId_;
      this->fractionAlong_ = x.fractionAlong_;
    }

    return *this;
  }

  Input::
  ~Input ()
  {
  }

  bool
  operator== (const Input& x, const Input& y)
  {
    if (!(x.id () == y.id ()))
      return false;

    if (!(x.target () == y.target ()))
      return false;

    if (!(x.destination () == y.destination ()))
      return false;

    if (!(x.segmentId () == y.segmentId ()))
      return false;

    if (!(x.fractionAlong () == y.fractionAlong ()))
      return false;

    return true;
  }

  bool
  operator!= (const Input& x, const Input& y)
  {
    return !(x == y);
  }

  // InputW
  //

  InputW::
  InputW (const id_type& id,
          const target_type& target,
          const destination_type& destination,
          const weight_type& weight)
  : ::neuroml2::Input (id,
                       target,
                       destination),
    weight_ (weight, this)
  {
  }

  InputW::
  InputW (const InputW& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::neuroml2::Input (x, f, c),
    weight_ (x.weight_, f, this)
  {
  }

  InputW::
  InputW (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::neuroml2::Input (e, f | ::xml_schema::flags::base, c),
    weight_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void InputW::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Input::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "weight" && n.namespace_ ().empty ())
      {
        this->weight_.set (weight_traits::create (i, f, this));
        continue;
      }
    }

    if (!weight_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "weight",
        "");
    }
  }

  InputW* InputW::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InputW (*this, f, c);
  }

  InputW& InputW::
  operator= (const InputW& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Input& > (*this) = x;
      this->weight_ = x.weight_;
    }

    return *this;
  }

  InputW::
  ~InputW ()
  {
  }

  bool
  operator== (const InputW& x, const InputW& y)
  {
    if (!(static_cast< const ::neuroml2::Input& > (x) ==
          static_cast< const ::neuroml2::Input& > (y)))
      return false;

    if (!(x.weight () == y.weight ()))
      return false;

    return true;
  }

  bool
  operator!= (const InputW& x, const InputW& y)
  {
    return !(x == y);
  }

  // basePyNNCell
  //

  basePyNNCell::
  basePyNNCell (const id_type& id,
                const cm_type& cm,
                const i_offset_type& i_offset,
                const tau_syn_E_type& tau_syn_E,
                const tau_syn_I_type& tau_syn_I,
                const v_init_type& v_init)
  : ::neuroml2::BaseCell (id),
    cm_ (cm, this),
    i_offset_ (i_offset, this),
    tau_syn_E_ (tau_syn_E, this),
    tau_syn_I_ (tau_syn_I, this),
    v_init_ (v_init, this)
  {
  }

  basePyNNCell::
  basePyNNCell (const basePyNNCell& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::neuroml2::BaseCell (x, f, c),
    cm_ (x.cm_, f, this),
    i_offset_ (x.i_offset_, f, this),
    tau_syn_E_ (x.tau_syn_E_, f, this),
    tau_syn_I_ (x.tau_syn_I_, f, this),
    v_init_ (x.v_init_, f, this)
  {
  }

  basePyNNCell::
  basePyNNCell (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::neuroml2::BaseCell (e, f | ::xml_schema::flags::base, c),
    cm_ (this),
    i_offset_ (this),
    tau_syn_E_ (this),
    tau_syn_I_ (this),
    v_init_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void basePyNNCell::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseCell::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "cm" && n.namespace_ ().empty ())
      {
        this->cm_.set (cm_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "i_offset" && n.namespace_ ().empty ())
      {
        this->i_offset_.set (i_offset_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "tau_syn_E" && n.namespace_ ().empty ())
      {
        this->tau_syn_E_.set (tau_syn_E_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "tau_syn_I" && n.namespace_ ().empty ())
      {
        this->tau_syn_I_.set (tau_syn_I_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "v_init" && n.namespace_ ().empty ())
      {
        this->v_init_.set (v_init_traits::create (i, f, this));
        continue;
      }
    }

    if (!cm_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "cm",
        "");
    }

    if (!i_offset_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "i_offset",
        "");
    }

    if (!tau_syn_E_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "tau_syn_E",
        "");
    }

    if (!tau_syn_I_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "tau_syn_I",
        "");
    }

    if (!v_init_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "v_init",
        "");
    }
  }

  basePyNNCell* basePyNNCell::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class basePyNNCell (*this, f, c);
  }

  basePyNNCell& basePyNNCell::
  operator= (const basePyNNCell& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseCell& > (*this) = x;
      this->cm_ = x.cm_;
      this->i_offset_ = x.i_offset_;
      this->tau_syn_E_ = x.tau_syn_E_;
      this->tau_syn_I_ = x.tau_syn_I_;
      this->v_init_ = x.v_init_;
    }

    return *this;
  }

  basePyNNCell::
  ~basePyNNCell ()
  {
  }

  bool
  operator== (const basePyNNCell& x, const basePyNNCell& y)
  {
    if (!(static_cast< const ::neuroml2::BaseCell& > (x) ==
          static_cast< const ::neuroml2::BaseCell& > (y)))
      return false;

    if (!(x.cm () == y.cm ()))
      return false;

    if (!(x.i_offset () == y.i_offset ()))
      return false;

    if (!(x.tau_syn_E () == y.tau_syn_E ()))
      return false;

    if (!(x.tau_syn_I () == y.tau_syn_I ()))
      return false;

    if (!(x.v_init () == y.v_init ()))
      return false;

    return true;
  }

  bool
  operator!= (const basePyNNCell& x, const basePyNNCell& y)
  {
    return !(x == y);
  }

  // basePyNNIaFCell
  //

  basePyNNIaFCell::
  basePyNNIaFCell (const id_type& id,
                   const cm_type& cm,
                   const i_offset_type& i_offset,
                   const tau_syn_E_type& tau_syn_E,
                   const tau_syn_I_type& tau_syn_I,
                   const v_init_type& v_init,
                   const tau_m_type& tau_m,
                   const tau_refrac_type& tau_refrac,
                   const v_reset_type& v_reset,
                   const v_rest_type& v_rest,
                   const v_thresh_type& v_thresh)
  : ::neuroml2::basePyNNCell (id,
                              cm,
                              i_offset,
                              tau_syn_E,
                              tau_syn_I,
                              v_init),
    tau_m_ (tau_m, this),
    tau_refrac_ (tau_refrac, this),
    v_reset_ (v_reset, this),
    v_rest_ (v_rest, this),
    v_thresh_ (v_thresh, this)
  {
  }

  basePyNNIaFCell::
  basePyNNIaFCell (const basePyNNIaFCell& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::neuroml2::basePyNNCell (x, f, c),
    tau_m_ (x.tau_m_, f, this),
    tau_refrac_ (x.tau_refrac_, f, this),
    v_reset_ (x.v_reset_, f, this),
    v_rest_ (x.v_rest_, f, this),
    v_thresh_ (x.v_thresh_, f, this)
  {
  }

  basePyNNIaFCell::
  basePyNNIaFCell (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::neuroml2::basePyNNCell (e, f | ::xml_schema::flags::base, c),
    tau_m_ (this),
    tau_refrac_ (this),
    v_reset_ (this),
    v_rest_ (this),
    v_thresh_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void basePyNNIaFCell::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::basePyNNCell::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "tau_m" && n.namespace_ ().empty ())
      {
        this->tau_m_.set (tau_m_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "tau_refrac" && n.namespace_ ().empty ())
      {
        this->tau_refrac_.set (tau_refrac_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "v_reset" && n.namespace_ ().empty ())
      {
        this->v_reset_.set (v_reset_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "v_rest" && n.namespace_ ().empty ())
      {
        this->v_rest_.set (v_rest_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "v_thresh" && n.namespace_ ().empty ())
      {
        this->v_thresh_.set (v_thresh_traits::create (i, f, this));
        continue;
      }
    }

    if (!tau_m_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "tau_m",
        "");
    }

    if (!tau_refrac_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "tau_refrac",
        "");
    }

    if (!v_reset_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "v_reset",
        "");
    }

    if (!v_rest_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "v_rest",
        "");
    }

    if (!v_thresh_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "v_thresh",
        "");
    }
  }

  basePyNNIaFCell* basePyNNIaFCell::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class basePyNNIaFCell (*this, f, c);
  }

  basePyNNIaFCell& basePyNNIaFCell::
  operator= (const basePyNNIaFCell& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::basePyNNCell& > (*this) = x;
      this->tau_m_ = x.tau_m_;
      this->tau_refrac_ = x.tau_refrac_;
      this->v_reset_ = x.v_reset_;
      this->v_rest_ = x.v_rest_;
      this->v_thresh_ = x.v_thresh_;
    }

    return *this;
  }

  basePyNNIaFCell::
  ~basePyNNIaFCell ()
  {
  }

  bool
  operator== (const basePyNNIaFCell& x, const basePyNNIaFCell& y)
  {
    if (!(static_cast< const ::neuroml2::basePyNNCell& > (x) ==
          static_cast< const ::neuroml2::basePyNNCell& > (y)))
      return false;

    if (!(x.tau_m () == y.tau_m ()))
      return false;

    if (!(x.tau_refrac () == y.tau_refrac ()))
      return false;

    if (!(x.v_reset () == y.v_reset ()))
      return false;

    if (!(x.v_rest () == y.v_rest ()))
      return false;

    if (!(x.v_thresh () == y.v_thresh ()))
      return false;

    return true;
  }

  bool
  operator!= (const basePyNNIaFCell& x, const basePyNNIaFCell& y)
  {
    return !(x == y);
  }

  // basePyNNIaFCondCell
  //

  basePyNNIaFCondCell::
  basePyNNIaFCondCell (const id_type& id,
                       const cm_type& cm,
                       const i_offset_type& i_offset,
                       const tau_syn_E_type& tau_syn_E,
                       const tau_syn_I_type& tau_syn_I,
                       const v_init_type& v_init,
                       const tau_m_type& tau_m,
                       const tau_refrac_type& tau_refrac,
                       const v_reset_type& v_reset,
                       const v_rest_type& v_rest,
                       const v_thresh_type& v_thresh,
                       const e_rev_E_type& e_rev_E,
                       const e_rev_I_type& e_rev_I)
  : ::neuroml2::basePyNNIaFCell (id,
                                 cm,
                                 i_offset,
                                 tau_syn_E,
                                 tau_syn_I,
                                 v_init,
                                 tau_m,
                                 tau_refrac,
                                 v_reset,
                                 v_rest,
                                 v_thresh),
    e_rev_E_ (e_rev_E, this),
    e_rev_I_ (e_rev_I, this)
  {
  }

  basePyNNIaFCondCell::
  basePyNNIaFCondCell (const basePyNNIaFCondCell& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::neuroml2::basePyNNIaFCell (x, f, c),
    e_rev_E_ (x.e_rev_E_, f, this),
    e_rev_I_ (x.e_rev_I_, f, this)
  {
  }

  basePyNNIaFCondCell::
  basePyNNIaFCondCell (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::neuroml2::basePyNNIaFCell (e, f | ::xml_schema::flags::base, c),
    e_rev_E_ (this),
    e_rev_I_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void basePyNNIaFCondCell::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::basePyNNIaFCell::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "e_rev_E" && n.namespace_ ().empty ())
      {
        this->e_rev_E_.set (e_rev_E_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "e_rev_I" && n.namespace_ ().empty ())
      {
        this->e_rev_I_.set (e_rev_I_traits::create (i, f, this));
        continue;
      }
    }

    if (!e_rev_E_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "e_rev_E",
        "");
    }

    if (!e_rev_I_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "e_rev_I",
        "");
    }
  }

  basePyNNIaFCondCell* basePyNNIaFCondCell::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class basePyNNIaFCondCell (*this, f, c);
  }

  basePyNNIaFCondCell& basePyNNIaFCondCell::
  operator= (const basePyNNIaFCondCell& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::basePyNNIaFCell& > (*this) = x;
      this->e_rev_E_ = x.e_rev_E_;
      this->e_rev_I_ = x.e_rev_I_;
    }

    return *this;
  }

  basePyNNIaFCondCell::
  ~basePyNNIaFCondCell ()
  {
  }

  bool
  operator== (const basePyNNIaFCondCell& x, const basePyNNIaFCondCell& y)
  {
    if (!(static_cast< const ::neuroml2::basePyNNIaFCell& > (x) ==
          static_cast< const ::neuroml2::basePyNNIaFCell& > (y)))
      return false;

    if (!(x.e_rev_E () == y.e_rev_E ()))
      return false;

    if (!(x.e_rev_I () == y.e_rev_I ()))
      return false;

    return true;
  }

  bool
  operator!= (const basePyNNIaFCondCell& x, const basePyNNIaFCondCell& y)
  {
    return !(x == y);
  }

  // IF_curr_alpha
  //

  IF_curr_alpha::
  IF_curr_alpha (const id_type& id,
                 const cm_type& cm,
                 const i_offset_type& i_offset,
                 const tau_syn_E_type& tau_syn_E,
                 const tau_syn_I_type& tau_syn_I,
                 const v_init_type& v_init,
                 const tau_m_type& tau_m,
                 const tau_refrac_type& tau_refrac,
                 const v_reset_type& v_reset,
                 const v_rest_type& v_rest,
                 const v_thresh_type& v_thresh)
  : ::neuroml2::basePyNNIaFCell (id,
                                 cm,
                                 i_offset,
                                 tau_syn_E,
                                 tau_syn_I,
                                 v_init,
                                 tau_m,
                                 tau_refrac,
                                 v_reset,
                                 v_rest,
                                 v_thresh)
  {
  }

  IF_curr_alpha::
  IF_curr_alpha (const IF_curr_alpha& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::basePyNNIaFCell (x, f, c)
  {
  }

  IF_curr_alpha::
  IF_curr_alpha (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::basePyNNIaFCell (e, f, c)
  {
  }

  IF_curr_alpha* IF_curr_alpha::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IF_curr_alpha (*this, f, c);
  }

  IF_curr_alpha::
  ~IF_curr_alpha ()
  {
  }

  // IF_curr_exp
  //

  IF_curr_exp::
  IF_curr_exp (const id_type& id,
               const cm_type& cm,
               const i_offset_type& i_offset,
               const tau_syn_E_type& tau_syn_E,
               const tau_syn_I_type& tau_syn_I,
               const v_init_type& v_init,
               const tau_m_type& tau_m,
               const tau_refrac_type& tau_refrac,
               const v_reset_type& v_reset,
               const v_rest_type& v_rest,
               const v_thresh_type& v_thresh)
  : ::neuroml2::basePyNNIaFCell (id,
                                 cm,
                                 i_offset,
                                 tau_syn_E,
                                 tau_syn_I,
                                 v_init,
                                 tau_m,
                                 tau_refrac,
                                 v_reset,
                                 v_rest,
                                 v_thresh)
  {
  }

  IF_curr_exp::
  IF_curr_exp (const IF_curr_exp& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::neuroml2::basePyNNIaFCell (x, f, c)
  {
  }

  IF_curr_exp::
  IF_curr_exp (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::neuroml2::basePyNNIaFCell (e, f, c)
  {
  }

  IF_curr_exp* IF_curr_exp::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IF_curr_exp (*this, f, c);
  }

  IF_curr_exp::
  ~IF_curr_exp ()
  {
  }

  // IF_cond_alpha
  //

  IF_cond_alpha::
  IF_cond_alpha (const id_type& id,
                 const cm_type& cm,
                 const i_offset_type& i_offset,
                 const tau_syn_E_type& tau_syn_E,
                 const tau_syn_I_type& tau_syn_I,
                 const v_init_type& v_init,
                 const tau_m_type& tau_m,
                 const tau_refrac_type& tau_refrac,
                 const v_reset_type& v_reset,
                 const v_rest_type& v_rest,
                 const v_thresh_type& v_thresh,
                 const e_rev_E_type& e_rev_E,
                 const e_rev_I_type& e_rev_I)
  : ::neuroml2::basePyNNIaFCondCell (id,
                                     cm,
                                     i_offset,
                                     tau_syn_E,
                                     tau_syn_I,
                                     v_init,
                                     tau_m,
                                     tau_refrac,
                                     v_reset,
                                     v_rest,
                                     v_thresh,
                                     e_rev_E,
                                     e_rev_I)
  {
  }

  IF_cond_alpha::
  IF_cond_alpha (const IF_cond_alpha& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::basePyNNIaFCondCell (x, f, c)
  {
  }

  IF_cond_alpha::
  IF_cond_alpha (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::neuroml2::basePyNNIaFCondCell (e, f, c)
  {
  }

  IF_cond_alpha* IF_cond_alpha::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IF_cond_alpha (*this, f, c);
  }

  IF_cond_alpha::
  ~IF_cond_alpha ()
  {
  }

  // IF_cond_exp
  //

  IF_cond_exp::
  IF_cond_exp (const id_type& id,
               const cm_type& cm,
               const i_offset_type& i_offset,
               const tau_syn_E_type& tau_syn_E,
               const tau_syn_I_type& tau_syn_I,
               const v_init_type& v_init,
               const tau_m_type& tau_m,
               const tau_refrac_type& tau_refrac,
               const v_reset_type& v_reset,
               const v_rest_type& v_rest,
               const v_thresh_type& v_thresh,
               const e_rev_E_type& e_rev_E,
               const e_rev_I_type& e_rev_I)
  : ::neuroml2::basePyNNIaFCondCell (id,
                                     cm,
                                     i_offset,
                                     tau_syn_E,
                                     tau_syn_I,
                                     v_init,
                                     tau_m,
                                     tau_refrac,
                                     v_reset,
                                     v_rest,
                                     v_thresh,
                                     e_rev_E,
                                     e_rev_I)
  {
  }

  IF_cond_exp::
  IF_cond_exp (const IF_cond_exp& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::neuroml2::basePyNNIaFCondCell (x, f, c)
  {
  }

  IF_cond_exp::
  IF_cond_exp (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::neuroml2::basePyNNIaFCondCell (e, f, c)
  {
  }

  IF_cond_exp* IF_cond_exp::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IF_cond_exp (*this, f, c);
  }

  IF_cond_exp::
  ~IF_cond_exp ()
  {
  }

  // EIF_cond_exp_isfa_ista
  //

  EIF_cond_exp_isfa_ista::
  EIF_cond_exp_isfa_ista (const id_type& id,
                          const cm_type& cm,
                          const i_offset_type& i_offset,
                          const tau_syn_E_type& tau_syn_E,
                          const tau_syn_I_type& tau_syn_I,
                          const v_init_type& v_init,
                          const tau_m_type& tau_m,
                          const tau_refrac_type& tau_refrac,
                          const v_reset_type& v_reset,
                          const v_rest_type& v_rest,
                          const v_thresh_type& v_thresh,
                          const e_rev_E_type& e_rev_E,
                          const e_rev_I_type& e_rev_I,
                          const a_type& a,
                          const b_type& b,
                          const delta_T_type& delta_T,
                          const tau_w_type& tau_w,
                          const v_spike_type& v_spike)
  : ::neuroml2::basePyNNIaFCondCell (id,
                                     cm,
                                     i_offset,
                                     tau_syn_E,
                                     tau_syn_I,
                                     v_init,
                                     tau_m,
                                     tau_refrac,
                                     v_reset,
                                     v_rest,
                                     v_thresh,
                                     e_rev_E,
                                     e_rev_I),
    a_ (a, this),
    b_ (b, this),
    delta_T_ (delta_T, this),
    tau_w_ (tau_w, this),
    v_spike_ (v_spike, this)
  {
  }

  EIF_cond_exp_isfa_ista::
  EIF_cond_exp_isfa_ista (const EIF_cond_exp_isfa_ista& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::neuroml2::basePyNNIaFCondCell (x, f, c),
    a_ (x.a_, f, this),
    b_ (x.b_, f, this),
    delta_T_ (x.delta_T_, f, this),
    tau_w_ (x.tau_w_, f, this),
    v_spike_ (x.v_spike_, f, this)
  {
  }

  EIF_cond_exp_isfa_ista::
  EIF_cond_exp_isfa_ista (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::neuroml2::basePyNNIaFCondCell (e, f | ::xml_schema::flags::base, c),
    a_ (this),
    b_ (this),
    delta_T_ (this),
    tau_w_ (this),
    v_spike_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void EIF_cond_exp_isfa_ista::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::basePyNNIaFCondCell::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "a" && n.namespace_ ().empty ())
      {
        this->a_.set (a_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "b" && n.namespace_ ().empty ())
      {
        this->b_.set (b_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "delta_T" && n.namespace_ ().empty ())
      {
        this->delta_T_.set (delta_T_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "tau_w" && n.namespace_ ().empty ())
      {
        this->tau_w_.set (tau_w_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "v_spike" && n.namespace_ ().empty ())
      {
        this->v_spike_.set (v_spike_traits::create (i, f, this));
        continue;
      }
    }

    if (!a_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "a",
        "");
    }

    if (!b_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "b",
        "");
    }

    if (!delta_T_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "delta_T",
        "");
    }

    if (!tau_w_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "tau_w",
        "");
    }

    if (!v_spike_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "v_spike",
        "");
    }
  }

  EIF_cond_exp_isfa_ista* EIF_cond_exp_isfa_ista::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EIF_cond_exp_isfa_ista (*this, f, c);
  }

  EIF_cond_exp_isfa_ista& EIF_cond_exp_isfa_ista::
  operator= (const EIF_cond_exp_isfa_ista& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::basePyNNIaFCondCell& > (*this) = x;
      this->a_ = x.a_;
      this->b_ = x.b_;
      this->delta_T_ = x.delta_T_;
      this->tau_w_ = x.tau_w_;
      this->v_spike_ = x.v_spike_;
    }

    return *this;
  }

  EIF_cond_exp_isfa_ista::
  ~EIF_cond_exp_isfa_ista ()
  {
  }

  bool
  operator== (const EIF_cond_exp_isfa_ista& x, const EIF_cond_exp_isfa_ista& y)
  {
    if (!(static_cast< const ::neuroml2::basePyNNIaFCondCell& > (x) ==
          static_cast< const ::neuroml2::basePyNNIaFCondCell& > (y)))
      return false;

    if (!(x.a () == y.a ()))
      return false;

    if (!(x.b () == y.b ()))
      return false;

    if (!(x.delta_T () == y.delta_T ()))
      return false;

    if (!(x.tau_w () == y.tau_w ()))
      return false;

    if (!(x.v_spike () == y.v_spike ()))
      return false;

    return true;
  }

  bool
  operator!= (const EIF_cond_exp_isfa_ista& x, const EIF_cond_exp_isfa_ista& y)
  {
    return !(x == y);
  }

  // EIF_cond_alpha_isfa_ista
  //

  EIF_cond_alpha_isfa_ista::
  EIF_cond_alpha_isfa_ista (const id_type& id,
                            const cm_type& cm,
                            const i_offset_type& i_offset,
                            const tau_syn_E_type& tau_syn_E,
                            const tau_syn_I_type& tau_syn_I,
                            const v_init_type& v_init,
                            const tau_m_type& tau_m,
                            const tau_refrac_type& tau_refrac,
                            const v_reset_type& v_reset,
                            const v_rest_type& v_rest,
                            const v_thresh_type& v_thresh,
                            const e_rev_E_type& e_rev_E,
                            const e_rev_I_type& e_rev_I,
                            const a_type& a,
                            const b_type& b,
                            const delta_T_type& delta_T,
                            const tau_w_type& tau_w,
                            const v_spike_type& v_spike)
  : ::neuroml2::EIF_cond_exp_isfa_ista (id,
                                        cm,
                                        i_offset,
                                        tau_syn_E,
                                        tau_syn_I,
                                        v_init,
                                        tau_m,
                                        tau_refrac,
                                        v_reset,
                                        v_rest,
                                        v_thresh,
                                        e_rev_E,
                                        e_rev_I,
                                        a,
                                        b,
                                        delta_T,
                                        tau_w,
                                        v_spike)
  {
  }

  EIF_cond_alpha_isfa_ista::
  EIF_cond_alpha_isfa_ista (const EIF_cond_alpha_isfa_ista& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::neuroml2::EIF_cond_exp_isfa_ista (x, f, c)
  {
  }

  EIF_cond_alpha_isfa_ista::
  EIF_cond_alpha_isfa_ista (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::neuroml2::EIF_cond_exp_isfa_ista (e, f, c)
  {
  }

  EIF_cond_alpha_isfa_ista* EIF_cond_alpha_isfa_ista::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EIF_cond_alpha_isfa_ista (*this, f, c);
  }

  EIF_cond_alpha_isfa_ista::
  ~EIF_cond_alpha_isfa_ista ()
  {
  }

  // HH_cond_exp
  //

  HH_cond_exp::
  HH_cond_exp (const id_type& id,
               const cm_type& cm,
               const i_offset_type& i_offset,
               const tau_syn_E_type& tau_syn_E,
               const tau_syn_I_type& tau_syn_I,
               const v_init_type& v_init,
               const v_offset_type& v_offset,
               const e_rev_E_type& e_rev_E,
               const e_rev_I_type& e_rev_I,
               const e_rev_K_type& e_rev_K,
               const e_rev_Na_type& e_rev_Na,
               const e_rev_leak_type& e_rev_leak,
               const g_leak_type& g_leak,
               const gbar_K_type& gbar_K,
               const gbar_Na_type& gbar_Na)
  : ::neuroml2::basePyNNCell (id,
                              cm,
                              i_offset,
                              tau_syn_E,
                              tau_syn_I,
                              v_init),
    v_offset_ (v_offset, this),
    e_rev_E_ (e_rev_E, this),
    e_rev_I_ (e_rev_I, this),
    e_rev_K_ (e_rev_K, this),
    e_rev_Na_ (e_rev_Na, this),
    e_rev_leak_ (e_rev_leak, this),
    g_leak_ (g_leak, this),
    gbar_K_ (gbar_K, this),
    gbar_Na_ (gbar_Na, this)
  {
  }

  HH_cond_exp::
  HH_cond_exp (const HH_cond_exp& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::neuroml2::basePyNNCell (x, f, c),
    v_offset_ (x.v_offset_, f, this),
    e_rev_E_ (x.e_rev_E_, f, this),
    e_rev_I_ (x.e_rev_I_, f, this),
    e_rev_K_ (x.e_rev_K_, f, this),
    e_rev_Na_ (x.e_rev_Na_, f, this),
    e_rev_leak_ (x.e_rev_leak_, f, this),
    g_leak_ (x.g_leak_, f, this),
    gbar_K_ (x.gbar_K_, f, this),
    gbar_Na_ (x.gbar_Na_, f, this)
  {
  }

  HH_cond_exp::
  HH_cond_exp (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::neuroml2::basePyNNCell (e, f | ::xml_schema::flags::base, c),
    v_offset_ (this),
    e_rev_E_ (this),
    e_rev_I_ (this),
    e_rev_K_ (this),
    e_rev_Na_ (this),
    e_rev_leak_ (this),
    g_leak_ (this),
    gbar_K_ (this),
    gbar_Na_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void HH_cond_exp::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::basePyNNCell::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "v_offset" && n.namespace_ ().empty ())
      {
        this->v_offset_.set (v_offset_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "e_rev_E" && n.namespace_ ().empty ())
      {
        this->e_rev_E_.set (e_rev_E_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "e_rev_I" && n.namespace_ ().empty ())
      {
        this->e_rev_I_.set (e_rev_I_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "e_rev_K" && n.namespace_ ().empty ())
      {
        this->e_rev_K_.set (e_rev_K_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "e_rev_Na" && n.namespace_ ().empty ())
      {
        this->e_rev_Na_.set (e_rev_Na_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "e_rev_leak" && n.namespace_ ().empty ())
      {
        this->e_rev_leak_.set (e_rev_leak_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "g_leak" && n.namespace_ ().empty ())
      {
        this->g_leak_.set (g_leak_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "gbar_K" && n.namespace_ ().empty ())
      {
        this->gbar_K_.set (gbar_K_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "gbar_Na" && n.namespace_ ().empty ())
      {
        this->gbar_Na_.set (gbar_Na_traits::create (i, f, this));
        continue;
      }
    }

    if (!v_offset_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "v_offset",
        "");
    }

    if (!e_rev_E_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "e_rev_E",
        "");
    }

    if (!e_rev_I_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "e_rev_I",
        "");
    }

    if (!e_rev_K_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "e_rev_K",
        "");
    }

    if (!e_rev_Na_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "e_rev_Na",
        "");
    }

    if (!e_rev_leak_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "e_rev_leak",
        "");
    }

    if (!g_leak_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "g_leak",
        "");
    }

    if (!gbar_K_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "gbar_K",
        "");
    }

    if (!gbar_Na_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "gbar_Na",
        "");
    }
  }

  HH_cond_exp* HH_cond_exp::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class HH_cond_exp (*this, f, c);
  }

  HH_cond_exp& HH_cond_exp::
  operator= (const HH_cond_exp& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::basePyNNCell& > (*this) = x;
      this->v_offset_ = x.v_offset_;
      this->e_rev_E_ = x.e_rev_E_;
      this->e_rev_I_ = x.e_rev_I_;
      this->e_rev_K_ = x.e_rev_K_;
      this->e_rev_Na_ = x.e_rev_Na_;
      this->e_rev_leak_ = x.e_rev_leak_;
      this->g_leak_ = x.g_leak_;
      this->gbar_K_ = x.gbar_K_;
      this->gbar_Na_ = x.gbar_Na_;
    }

    return *this;
  }

  HH_cond_exp::
  ~HH_cond_exp ()
  {
  }

  bool
  operator== (const HH_cond_exp& x, const HH_cond_exp& y)
  {
    if (!(static_cast< const ::neuroml2::basePyNNCell& > (x) ==
          static_cast< const ::neuroml2::basePyNNCell& > (y)))
      return false;

    if (!(x.v_offset () == y.v_offset ()))
      return false;

    if (!(x.e_rev_E () == y.e_rev_E ()))
      return false;

    if (!(x.e_rev_I () == y.e_rev_I ()))
      return false;

    if (!(x.e_rev_K () == y.e_rev_K ()))
      return false;

    if (!(x.e_rev_Na () == y.e_rev_Na ()))
      return false;

    if (!(x.e_rev_leak () == y.e_rev_leak ()))
      return false;

    if (!(x.g_leak () == y.g_leak ()))
      return false;

    if (!(x.gbar_K () == y.gbar_K ()))
      return false;

    if (!(x.gbar_Na () == y.gbar_Na ()))
      return false;

    return true;
  }

  bool
  operator!= (const HH_cond_exp& x, const HH_cond_exp& y)
  {
    return !(x == y);
  }

  // BasePynnSynapse
  //

  BasePynnSynapse::
  BasePynnSynapse (const id_type& id,
                   const tau_syn_type& tau_syn)
  : ::neuroml2::BaseSynapse (id),
    tau_syn_ (tau_syn, this)
  {
  }

  BasePynnSynapse::
  BasePynnSynapse (const BasePynnSynapse& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::neuroml2::BaseSynapse (x, f, c),
    tau_syn_ (x.tau_syn_, f, this)
  {
  }

  BasePynnSynapse::
  BasePynnSynapse (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::neuroml2::BaseSynapse (e, f | ::xml_schema::flags::base, c),
    tau_syn_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void BasePynnSynapse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BaseSynapse::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "tau_syn" && n.namespace_ ().empty ())
      {
        this->tau_syn_.set (tau_syn_traits::create (i, f, this));
        continue;
      }
    }

    if (!tau_syn_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "tau_syn",
        "");
    }
  }

  BasePynnSynapse* BasePynnSynapse::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BasePynnSynapse (*this, f, c);
  }

  BasePynnSynapse& BasePynnSynapse::
  operator= (const BasePynnSynapse& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BaseSynapse& > (*this) = x;
      this->tau_syn_ = x.tau_syn_;
    }

    return *this;
  }

  BasePynnSynapse::
  ~BasePynnSynapse ()
  {
  }

  bool
  operator== (const BasePynnSynapse& x, const BasePynnSynapse& y)
  {
    if (!(static_cast< const ::neuroml2::BaseSynapse& > (x) ==
          static_cast< const ::neuroml2::BaseSynapse& > (y)))
      return false;

    if (!(x.tau_syn () == y.tau_syn ()))
      return false;

    return true;
  }

  bool
  operator!= (const BasePynnSynapse& x, const BasePynnSynapse& y)
  {
    return !(x == y);
  }

  // ExpCondSynapse
  //

  ExpCondSynapse::
  ExpCondSynapse (const id_type& id,
                  const tau_syn_type& tau_syn,
                  const e_rev_type& e_rev)
  : ::neuroml2::BasePynnSynapse (id,
                                 tau_syn),
    e_rev_ (e_rev, this)
  {
  }

  ExpCondSynapse::
  ExpCondSynapse (const ExpCondSynapse& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::neuroml2::BasePynnSynapse (x, f, c),
    e_rev_ (x.e_rev_, f, this)
  {
  }

  ExpCondSynapse::
  ExpCondSynapse (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::neuroml2::BasePynnSynapse (e, f | ::xml_schema::flags::base, c),
    e_rev_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ExpCondSynapse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BasePynnSynapse::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "e_rev" && n.namespace_ ().empty ())
      {
        this->e_rev_.set (e_rev_traits::create (i, f, this));
        continue;
      }
    }

    if (!e_rev_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "e_rev",
        "");
    }
  }

  ExpCondSynapse* ExpCondSynapse::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ExpCondSynapse (*this, f, c);
  }

  ExpCondSynapse& ExpCondSynapse::
  operator= (const ExpCondSynapse& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BasePynnSynapse& > (*this) = x;
      this->e_rev_ = x.e_rev_;
    }

    return *this;
  }

  ExpCondSynapse::
  ~ExpCondSynapse ()
  {
  }

  bool
  operator== (const ExpCondSynapse& x, const ExpCondSynapse& y)
  {
    if (!(static_cast< const ::neuroml2::BasePynnSynapse& > (x) ==
          static_cast< const ::neuroml2::BasePynnSynapse& > (y)))
      return false;

    if (!(x.e_rev () == y.e_rev ()))
      return false;

    return true;
  }

  bool
  operator!= (const ExpCondSynapse& x, const ExpCondSynapse& y)
  {
    return !(x == y);
  }

  // AlphaCondSynapse
  //

  AlphaCondSynapse::
  AlphaCondSynapse (const id_type& id,
                    const tau_syn_type& tau_syn,
                    const e_rev_type& e_rev)
  : ::neuroml2::BasePynnSynapse (id,
                                 tau_syn),
    e_rev_ (e_rev, this)
  {
  }

  AlphaCondSynapse::
  AlphaCondSynapse (const AlphaCondSynapse& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::neuroml2::BasePynnSynapse (x, f, c),
    e_rev_ (x.e_rev_, f, this)
  {
  }

  AlphaCondSynapse::
  AlphaCondSynapse (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::neuroml2::BasePynnSynapse (e, f | ::xml_schema::flags::base, c),
    e_rev_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AlphaCondSynapse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::BasePynnSynapse::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "e_rev" && n.namespace_ ().empty ())
      {
        this->e_rev_.set (e_rev_traits::create (i, f, this));
        continue;
      }
    }

    if (!e_rev_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "e_rev",
        "");
    }
  }

  AlphaCondSynapse* AlphaCondSynapse::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AlphaCondSynapse (*this, f, c);
  }

  AlphaCondSynapse& AlphaCondSynapse::
  operator= (const AlphaCondSynapse& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::BasePynnSynapse& > (*this) = x;
      this->e_rev_ = x.e_rev_;
    }

    return *this;
  }

  AlphaCondSynapse::
  ~AlphaCondSynapse ()
  {
  }

  bool
  operator== (const AlphaCondSynapse& x, const AlphaCondSynapse& y)
  {
    if (!(static_cast< const ::neuroml2::BasePynnSynapse& > (x) ==
          static_cast< const ::neuroml2::BasePynnSynapse& > (y)))
      return false;

    if (!(x.e_rev () == y.e_rev ()))
      return false;

    return true;
  }

  bool
  operator!= (const AlphaCondSynapse& x, const AlphaCondSynapse& y)
  {
    return !(x == y);
  }

  // ExpCurrSynapse
  //

  ExpCurrSynapse::
  ExpCurrSynapse (const id_type& id,
                  const tau_syn_type& tau_syn)
  : ::neuroml2::BasePynnSynapse (id,
                                 tau_syn)
  {
  }

  ExpCurrSynapse::
  ExpCurrSynapse (const ExpCurrSynapse& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::neuroml2::BasePynnSynapse (x, f, c)
  {
  }

  ExpCurrSynapse::
  ExpCurrSynapse (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::neuroml2::BasePynnSynapse (e, f, c)
  {
  }

  ExpCurrSynapse* ExpCurrSynapse::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ExpCurrSynapse (*this, f, c);
  }

  ExpCurrSynapse::
  ~ExpCurrSynapse ()
  {
  }

  // AlphaCurrSynapse
  //

  AlphaCurrSynapse::
  AlphaCurrSynapse (const id_type& id,
                    const tau_syn_type& tau_syn)
  : ::neuroml2::BasePynnSynapse (id,
                                 tau_syn)
  {
  }

  AlphaCurrSynapse::
  AlphaCurrSynapse (const AlphaCurrSynapse& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::neuroml2::BasePynnSynapse (x, f, c)
  {
  }

  AlphaCurrSynapse::
  AlphaCurrSynapse (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::neuroml2::BasePynnSynapse (e, f, c)
  {
  }

  AlphaCurrSynapse* AlphaCurrSynapse::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AlphaCurrSynapse (*this, f, c);
  }

  AlphaCurrSynapse::
  ~AlphaCurrSynapse ()
  {
  }

  // SpikeSourcePoisson
  //

  SpikeSourcePoisson::
  SpikeSourcePoisson (const id_type& id,
                      const start_type& start,
                      const duration_type& duration,
                      const rate_type& rate)
  : ::neuroml2::Standalone (id),
    start_ (start, this),
    duration_ (duration, this),
    rate_ (rate, this)
  {
  }

  SpikeSourcePoisson::
  SpikeSourcePoisson (const SpikeSourcePoisson& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::neuroml2::Standalone (x, f, c),
    start_ (x.start_, f, this),
    duration_ (x.duration_, f, this),
    rate_ (x.rate_, f, this)
  {
  }

  SpikeSourcePoisson::
  SpikeSourcePoisson (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::neuroml2::Standalone (e, f | ::xml_schema::flags::base, c),
    start_ (this),
    duration_ (this),
    rate_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SpikeSourcePoisson::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::neuroml2::Standalone::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "start" && n.namespace_ ().empty ())
      {
        this->start_.set (start_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "duration" && n.namespace_ ().empty ())
      {
        this->duration_.set (duration_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "rate" && n.namespace_ ().empty ())
      {
        this->rate_.set (rate_traits::create (i, f, this));
        continue;
      }
    }

    if (!start_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "start",
        "");
    }

    if (!duration_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "duration",
        "");
    }

    if (!rate_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "rate",
        "");
    }
  }

  SpikeSourcePoisson* SpikeSourcePoisson::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SpikeSourcePoisson (*this, f, c);
  }

  SpikeSourcePoisson& SpikeSourcePoisson::
  operator= (const SpikeSourcePoisson& x)
  {
    if (this != &x)
    {
      static_cast< ::neuroml2::Standalone& > (*this) = x;
      this->start_ = x.start_;
      this->duration_ = x.duration_;
      this->rate_ = x.rate_;
    }

    return *this;
  }

  SpikeSourcePoisson::
  ~SpikeSourcePoisson ()
  {
  }

  bool
  operator== (const SpikeSourcePoisson& x, const SpikeSourcePoisson& y)
  {
    if (!(static_cast< const ::neuroml2::Standalone& > (x) ==
          static_cast< const ::neuroml2::Standalone& > (y)))
      return false;

    if (!(x.start () == y.start ()))
      return false;

    if (!(x.duration () == y.duration ()))
      return false;

    if (!(x.rate () == y.rate ()))
      return false;

    return true;
  }

  bool
  operator!= (const SpikeSourcePoisson& x, const SpikeSourcePoisson& y)
  {
    return !(x == y);
  }
}

#include <ostream>

namespace neuroml2
{
  ::std::ostream&
  operator<< (::std::ostream& o, const NmlId& i)
  {
    o << static_cast< const ::xml_schema::string& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Nml2Quantity& i)
  {
    o << static_cast< const ::xml_schema::string& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Nml2Quantity_none& i)
  {
    o << static_cast< const ::xml_schema::string& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Nml2Quantity_voltage& i)
  {
    o << static_cast< const ::xml_schema::string& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Nml2Quantity_length& i)
  {
    o << static_cast< const ::xml_schema::string& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Nml2Quantity_resistance& i)
  {
    o << static_cast< const ::xml_schema::string& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Nml2Quantity_resistivity& i)
  {
    o << static_cast< const ::xml_schema::string& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Nml2Quantity_conductance& i)
  {
    o << static_cast< const ::xml_schema::string& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Nml2Quantity_conductanceDensity& i)
  {
    o << static_cast< const ::xml_schema::string& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Nml2Quantity_permeability& i)
  {
    o << static_cast< const ::xml_schema::string& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Nml2Quantity_time& i)
  {
    o << static_cast< const ::xml_schema::string& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Nml2Quantity_pertime& i)
  {
    o << static_cast< const ::xml_schema::string& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Nml2Quantity_capacitance& i)
  {
    o << static_cast< const ::xml_schema::string& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Nml2Quantity_specificCapacitance& i)
  {
    o << static_cast< const ::xml_schema::string& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Nml2Quantity_concentration& i)
  {
    o << static_cast< const ::xml_schema::string& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Nml2Quantity_current& i)
  {
    o << static_cast< const ::xml_schema::string& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Nml2Quantity_currentDensity& i)
  {
    o << static_cast< const ::xml_schema::string& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Nml2Quantity_temperature& i)
  {
    o << static_cast< const ::xml_schema::string& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Nml2Quantity_rhoFactor& i)
  {
    o << static_cast< const ::xml_schema::string& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Nml2Quantity_conductancePerVoltage& i)
  {
    o << static_cast< const ::xml_schema::string& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const MetaId& i)
  {
    o << static_cast< const ::xml_schema::string& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const NeuroLexId& i)
  {
    o << static_cast< const ::xml_schema::string& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const NonNegativeInteger& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const PositiveInteger& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DoubleGreaterThanZero& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ZeroOrOne& i)
  {
    return o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Notes& i)
  {
    o << static_cast< const ::xml_schema::string& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Property& i)
  {
    o << ::std::endl << "tag: " << i.tag ();
    o << ::std::endl << "value: " << i.value ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Annotation&)
  {
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ComponentType& i)
  {
    for (ComponentType::Property_const_iterator
         b (i.Property ().begin ()), e (i.Property ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "Property: " << *b;
    }

    for (ComponentType::Parameter_const_iterator
         b (i.Parameter ().begin ()), e (i.Parameter ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "Parameter: " << *b;
    }

    for (ComponentType::Constant_const_iterator
         b (i.Constant ().begin ()), e (i.Constant ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "Constant: " << *b;
    }

    for (ComponentType::Exposure_const_iterator
         b (i.Exposure ().begin ()), e (i.Exposure ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "Exposure: " << *b;
    }

    for (ComponentType::Requirement_const_iterator
         b (i.Requirement ().begin ()), e (i.Requirement ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "Requirement: " << *b;
    }

    for (ComponentType::InstanceRequirement_const_iterator
         b (i.InstanceRequirement ().begin ()), e (i.InstanceRequirement ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "InstanceRequirement: " << *b;
    }

    for (ComponentType::Dynamics_const_iterator
         b (i.Dynamics ().begin ()), e (i.Dynamics ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "Dynamics: " << *b;
    }

    o << ::std::endl << "name: " << i.name ();
    if (i.extends ())
    {
      o << ::std::endl << "extends: " << *i.extends ();
    }

    if (i.description ())
    {
      o << ::std::endl << "description: " << *i.description ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Constant& i)
  {
    o << ::std::endl << "name: " << i.name ();
    o << ::std::endl << "dimension: " << i.dimension ();
    o << ::std::endl << "value: " << i.value ();
    if (i.description ())
    {
      o << ::std::endl << "description: " << *i.description ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Exposure& i)
  {
    o << ::std::endl << "name: " << i.name ();
    o << ::std::endl << "dimension: " << i.dimension ();
    if (i.description ())
    {
      o << ::std::endl << "description: " << *i.description ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const NamedDimensionalType& i)
  {
    o << ::std::endl << "name: " << i.name ();
    o << ::std::endl << "dimension: " << i.dimension ();
    if (i.description ())
    {
      o << ::std::endl << "description: " << *i.description ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const NamedDimensionalVariable& i)
  {
    o << ::std::endl << "name: " << i.name ();
    o << ::std::endl << "dimension: " << i.dimension ();
    if (i.description ())
    {
      o << ::std::endl << "description: " << *i.description ();
    }

    if (i.exposure ())
    {
      o << ::std::endl << "exposure: " << *i.exposure ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Parameter& i)
  {
    o << static_cast< const ::neuroml2::NamedDimensionalType& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const LEMS_Property& i)
  {
    o << static_cast< const ::neuroml2::NamedDimensionalType& > (i);

    if (i.defaultValue ())
    {
      o << ::std::endl << "defaultValue: " << *i.defaultValue ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Requirement& i)
  {
    o << static_cast< const ::neuroml2::NamedDimensionalType& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const InstanceRequirement& i)
  {
    o << ::std::endl << "name: " << i.name ();
    o << ::std::endl << "type: " << i.type ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Dynamics& i)
  {
    for (Dynamics::StateVariable_const_iterator
         b (i.StateVariable ().begin ()), e (i.StateVariable ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "StateVariable: " << *b;
    }

    for (Dynamics::DerivedVariable_const_iterator
         b (i.DerivedVariable ().begin ()), e (i.DerivedVariable ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "DerivedVariable: " << *b;
    }

    for (Dynamics::ConditionalDerivedVariable_const_iterator
         b (i.ConditionalDerivedVariable ().begin ()), e (i.ConditionalDerivedVariable ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "ConditionalDerivedVariable: " << *b;
    }

    for (Dynamics::TimeDerivative_const_iterator
         b (i.TimeDerivative ().begin ()), e (i.TimeDerivative ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "TimeDerivative: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DerivedVariable& i)
  {
    o << static_cast< const ::neuroml2::NamedDimensionalVariable& > (i);

    if (i.value ())
    {
      o << ::std::endl << "value: " << *i.value ();
    }

    if (i.select ())
    {
      o << ::std::endl << "select: " << *i.select ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const StateVariable& i)
  {
    o << static_cast< const ::neuroml2::NamedDimensionalVariable& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ConditionalDerivedVariable& i)
  {
    o << static_cast< const ::neuroml2::NamedDimensionalVariable& > (i);

    for (ConditionalDerivedVariable::Case_const_iterator
         b (i.Case ().begin ()), e (i.Case ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "Case: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Case& i)
  {
    if (i.condition ())
    {
      o << ::std::endl << "condition: " << *i.condition ();
    }

    o << ::std::endl << "value: " << i.value ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const TimeDerivative& i)
  {
    o << ::std::endl << "variable: " << i.variable ();
    o << ::std::endl << "value: " << i.value ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ZeroToOne& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const BaseWithoutId& i)
  {
    if (i.neuroLexId ())
    {
      o << ::std::endl << "neuroLexId: " << *i.neuroLexId ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Base& i)
  {
    o << static_cast< const ::neuroml2::BaseWithoutId& > (i);

    o << ::std::endl << "id: " << i.id ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Standalone& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    if (i.notes ())
    {
      o << ::std::endl << "notes: " << *i.notes ();
    }

    for (Standalone::property_const_iterator
         b (i.property ().begin ()), e (i.property ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "property: " << *b;
    }

    if (i.annotation ())
    {
      o << ::std::endl << "annotation: " << *i.annotation ();
    }

    if (i.metaid ())
    {
      o << ::std::endl << "metaid: " << *i.metaid ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const NeuroMLDocument_base& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    for (NeuroMLDocument_base::include_const_iterator
         b (i.include ().begin ()), e (i.include ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "include: " << *b;
    }

    for (NeuroMLDocument_base::extracellularProperties_const_iterator
         b (i.extracellularProperties ().begin ()), e (i.extracellularProperties ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "extracellularProperties: " << *b;
    }

    for (NeuroMLDocument_base::intracellularProperties_const_iterator
         b (i.intracellularProperties ().begin ()), e (i.intracellularProperties ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "intracellularProperties: " << *b;
    }

    for (NeuroMLDocument_base::morphology_const_iterator
         b (i.morphology ().begin ()), e (i.morphology ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "morphology: " << *b;
    }

    for (NeuroMLDocument_base::ionChannel_const_iterator
         b (i.ionChannel ().begin ()), e (i.ionChannel ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "ionChannel: " << *b;
    }

    for (NeuroMLDocument_base::ionChannelHH_const_iterator
         b (i.ionChannelHH ().begin ()), e (i.ionChannelHH ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "ionChannelHH: " << *b;
    }

    for (NeuroMLDocument_base::ionChannelVShift_const_iterator
         b (i.ionChannelVShift ().begin ()), e (i.ionChannelVShift ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "ionChannelVShift: " << *b;
    }

    for (NeuroMLDocument_base::ionChannelKS_const_iterator
         b (i.ionChannelKS ().begin ()), e (i.ionChannelKS ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "ionChannelKS: " << *b;
    }

    for (NeuroMLDocument_base::decayingPoolConcentrationModel_const_iterator
         b (i.decayingPoolConcentrationModel ().begin ()), e (i.decayingPoolConcentrationModel ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "decayingPoolConcentrationModel: " << *b;
    }

    for (NeuroMLDocument_base::fixedFactorConcentrationModel_const_iterator
         b (i.fixedFactorConcentrationModel ().begin ()), e (i.fixedFactorConcentrationModel ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "fixedFactorConcentrationModel: " << *b;
    }

    for (NeuroMLDocument_base::alphaCurrentSynapse_const_iterator
         b (i.alphaCurrentSynapse ().begin ()), e (i.alphaCurrentSynapse ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "alphaCurrentSynapse: " << *b;
    }

    for (NeuroMLDocument_base::alphaSynapse_const_iterator
         b (i.alphaSynapse ().begin ()), e (i.alphaSynapse ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "alphaSynapse: " << *b;
    }

    for (NeuroMLDocument_base::expOneSynapse_const_iterator
         b (i.expOneSynapse ().begin ()), e (i.expOneSynapse ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "expOneSynapse: " << *b;
    }

    for (NeuroMLDocument_base::expTwoSynapse_const_iterator
         b (i.expTwoSynapse ().begin ()), e (i.expTwoSynapse ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "expTwoSynapse: " << *b;
    }

    for (NeuroMLDocument_base::expThreeSynapse_const_iterator
         b (i.expThreeSynapse ().begin ()), e (i.expThreeSynapse ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "expThreeSynapse: " << *b;
    }

    for (NeuroMLDocument_base::blockingPlasticSynapse_const_iterator
         b (i.blockingPlasticSynapse ().begin ()), e (i.blockingPlasticSynapse ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "blockingPlasticSynapse: " << *b;
    }

    for (NeuroMLDocument_base::doubleSynapse_const_iterator
         b (i.doubleSynapse ().begin ()), e (i.doubleSynapse ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "doubleSynapse: " << *b;
    }

    for (NeuroMLDocument_base::gapJunction_const_iterator
         b (i.gapJunction ().begin ()), e (i.gapJunction ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "gapJunction: " << *b;
    }

    for (NeuroMLDocument_base::silentSynapse_const_iterator
         b (i.silentSynapse ().begin ()), e (i.silentSynapse ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "silentSynapse: " << *b;
    }

    for (NeuroMLDocument_base::linearGradedSynapse_const_iterator
         b (i.linearGradedSynapse ().begin ()), e (i.linearGradedSynapse ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "linearGradedSynapse: " << *b;
    }

    for (NeuroMLDocument_base::gradedSynapse_const_iterator
         b (i.gradedSynapse ().begin ()), e (i.gradedSynapse ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "gradedSynapse: " << *b;
    }

    for (NeuroMLDocument_base::biophysicalProperties_const_iterator
         b (i.biophysicalProperties ().begin ()), e (i.biophysicalProperties ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "biophysicalProperties: " << *b;
    }

    for (NeuroMLDocument_base::cell_const_iterator
         b (i.cell ().begin ()), e (i.cell ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "cell: " << *b;
    }

    for (NeuroMLDocument_base::cell2CaPools_const_iterator
         b (i.cell2CaPools ().begin ()), e (i.cell2CaPools ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "cell2CaPools: " << *b;
    }

    for (NeuroMLDocument_base::baseCell_const_iterator
         b (i.baseCell ().begin ()), e (i.baseCell ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "baseCell: " << *b;
    }

    for (NeuroMLDocument_base::iafTauCell_const_iterator
         b (i.iafTauCell ().begin ()), e (i.iafTauCell ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "iafTauCell: " << *b;
    }

    for (NeuroMLDocument_base::iafTauRefCell_const_iterator
         b (i.iafTauRefCell ().begin ()), e (i.iafTauRefCell ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "iafTauRefCell: " << *b;
    }

    for (NeuroMLDocument_base::iafCell_const_iterator
         b (i.iafCell ().begin ()), e (i.iafCell ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "iafCell: " << *b;
    }

    for (NeuroMLDocument_base::iafRefCell_const_iterator
         b (i.iafRefCell ().begin ()), e (i.iafRefCell ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "iafRefCell: " << *b;
    }

    for (NeuroMLDocument_base::izhikevichCell_const_iterator
         b (i.izhikevichCell ().begin ()), e (i.izhikevichCell ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "izhikevichCell: " << *b;
    }

    for (NeuroMLDocument_base::izhikevich2007Cell_const_iterator
         b (i.izhikevich2007Cell ().begin ()), e (i.izhikevich2007Cell ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "izhikevich2007Cell: " << *b;
    }

    for (NeuroMLDocument_base::adExIaFCell_const_iterator
         b (i.adExIaFCell ().begin ()), e (i.adExIaFCell ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "adExIaFCell: " << *b;
    }

    for (NeuroMLDocument_base::fitzHughNagumoCell_const_iterator
         b (i.fitzHughNagumoCell ().begin ()), e (i.fitzHughNagumoCell ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "fitzHughNagumoCell: " << *b;
    }

    for (NeuroMLDocument_base::fitzHughNagumo1969Cell_const_iterator
         b (i.fitzHughNagumo1969Cell ().begin ()), e (i.fitzHughNagumo1969Cell ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "fitzHughNagumo1969Cell: " << *b;
    }

    for (NeuroMLDocument_base::pinskyRinzelCA3Cell_const_iterator
         b (i.pinskyRinzelCA3Cell ().begin ()), e (i.pinskyRinzelCA3Cell ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "pinskyRinzelCA3Cell: " << *b;
    }

    for (NeuroMLDocument_base::pulseGenerator_const_iterator
         b (i.pulseGenerator ().begin ()), e (i.pulseGenerator ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "pulseGenerator: " << *b;
    }

    for (NeuroMLDocument_base::pulseGeneratorDL_const_iterator
         b (i.pulseGeneratorDL ().begin ()), e (i.pulseGeneratorDL ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "pulseGeneratorDL: " << *b;
    }

    for (NeuroMLDocument_base::sineGenerator_const_iterator
         b (i.sineGenerator ().begin ()), e (i.sineGenerator ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "sineGenerator: " << *b;
    }

    for (NeuroMLDocument_base::sineGeneratorDL_const_iterator
         b (i.sineGeneratorDL ().begin ()), e (i.sineGeneratorDL ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "sineGeneratorDL: " << *b;
    }

    for (NeuroMLDocument_base::rampGenerator_const_iterator
         b (i.rampGenerator ().begin ()), e (i.rampGenerator ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "rampGenerator: " << *b;
    }

    for (NeuroMLDocument_base::rampGeneratorDL_const_iterator
         b (i.rampGeneratorDL ().begin ()), e (i.rampGeneratorDL ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "rampGeneratorDL: " << *b;
    }

    for (NeuroMLDocument_base::compoundInput_const_iterator
         b (i.compoundInput ().begin ()), e (i.compoundInput ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "compoundInput: " << *b;
    }

    for (NeuroMLDocument_base::compoundInputDL_const_iterator
         b (i.compoundInputDL ().begin ()), e (i.compoundInputDL ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "compoundInputDL: " << *b;
    }

    for (NeuroMLDocument_base::voltageClamp_const_iterator
         b (i.voltageClamp ().begin ()), e (i.voltageClamp ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "voltageClamp: " << *b;
    }

    for (NeuroMLDocument_base::voltageClampTriple_const_iterator
         b (i.voltageClampTriple ().begin ()), e (i.voltageClampTriple ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "voltageClampTriple: " << *b;
    }

    for (NeuroMLDocument_base::spikeArray_const_iterator
         b (i.spikeArray ().begin ()), e (i.spikeArray ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "spikeArray: " << *b;
    }

    for (NeuroMLDocument_base::timedSynapticInput_const_iterator
         b (i.timedSynapticInput ().begin ()), e (i.timedSynapticInput ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "timedSynapticInput: " << *b;
    }

    for (NeuroMLDocument_base::spikeGenerator_const_iterator
         b (i.spikeGenerator ().begin ()), e (i.spikeGenerator ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "spikeGenerator: " << *b;
    }

    for (NeuroMLDocument_base::spikeGeneratorRandom_const_iterator
         b (i.spikeGeneratorRandom ().begin ()), e (i.spikeGeneratorRandom ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "spikeGeneratorRandom: " << *b;
    }

    for (NeuroMLDocument_base::spikeGeneratorPoisson_const_iterator
         b (i.spikeGeneratorPoisson ().begin ()), e (i.spikeGeneratorPoisson ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "spikeGeneratorPoisson: " << *b;
    }

    for (NeuroMLDocument_base::spikeGeneratorRefPoisson_const_iterator
         b (i.spikeGeneratorRefPoisson ().begin ()), e (i.spikeGeneratorRefPoisson ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "spikeGeneratorRefPoisson: " << *b;
    }

    for (NeuroMLDocument_base::poissonFiringSynapse_const_iterator
         b (i.poissonFiringSynapse ().begin ()), e (i.poissonFiringSynapse ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "poissonFiringSynapse: " << *b;
    }

    for (NeuroMLDocument_base::transientPoissonFiringSynapse_const_iterator
         b (i.transientPoissonFiringSynapse ().begin ()), e (i.transientPoissonFiringSynapse ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "transientPoissonFiringSynapse: " << *b;
    }

    for (NeuroMLDocument_base::IF_curr_alpha_const_iterator
         b (i.IF_curr_alpha ().begin ()), e (i.IF_curr_alpha ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "IF_curr_alpha: " << *b;
    }

    for (NeuroMLDocument_base::IF_curr_exp_const_iterator
         b (i.IF_curr_exp ().begin ()), e (i.IF_curr_exp ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "IF_curr_exp: " << *b;
    }

    for (NeuroMLDocument_base::IF_cond_alpha_const_iterator
         b (i.IF_cond_alpha ().begin ()), e (i.IF_cond_alpha ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "IF_cond_alpha: " << *b;
    }

    for (NeuroMLDocument_base::IF_cond_exp_const_iterator
         b (i.IF_cond_exp ().begin ()), e (i.IF_cond_exp ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "IF_cond_exp: " << *b;
    }

    for (NeuroMLDocument_base::EIF_cond_exp_isfa_ista_const_iterator
         b (i.EIF_cond_exp_isfa_ista ().begin ()), e (i.EIF_cond_exp_isfa_ista ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "EIF_cond_exp_isfa_ista: " << *b;
    }

    for (NeuroMLDocument_base::EIF_cond_alpha_isfa_ista_const_iterator
         b (i.EIF_cond_alpha_isfa_ista ().begin ()), e (i.EIF_cond_alpha_isfa_ista ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "EIF_cond_alpha_isfa_ista: " << *b;
    }

    for (NeuroMLDocument_base::HH_cond_exp_const_iterator
         b (i.HH_cond_exp ().begin ()), e (i.HH_cond_exp ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "HH_cond_exp: " << *b;
    }

    for (NeuroMLDocument_base::expCondSynapse_const_iterator
         b (i.expCondSynapse ().begin ()), e (i.expCondSynapse ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "expCondSynapse: " << *b;
    }

    for (NeuroMLDocument_base::alphaCondSynapse_const_iterator
         b (i.alphaCondSynapse ().begin ()), e (i.alphaCondSynapse ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "alphaCondSynapse: " << *b;
    }

    for (NeuroMLDocument_base::expCurrSynapse_const_iterator
         b (i.expCurrSynapse ().begin ()), e (i.expCurrSynapse ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "expCurrSynapse: " << *b;
    }

    for (NeuroMLDocument_base::alphaCurrSynapse_const_iterator
         b (i.alphaCurrSynapse ().begin ()), e (i.alphaCurrSynapse ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "alphaCurrSynapse: " << *b;
    }

    for (NeuroMLDocument_base::SpikeSourcePoisson_const_iterator
         b (i.SpikeSourcePoisson ().begin ()), e (i.SpikeSourcePoisson ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "SpikeSourcePoisson: " << *b;
    }

    for (NeuroMLDocument_base::network_const_iterator
         b (i.network ().begin ()), e (i.network ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "network: " << *b;
    }

    for (NeuroMLDocument_base::ComponentType_const_iterator
         b (i.ComponentType ().begin ()), e (i.ComponentType ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "ComponentType: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const IncludeType& i)
  {
    o << ::std::endl << "href: " << i.href ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const IonChannelScalable& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    for (IonChannelScalable::q10ConductanceScaling_const_iterator
         b (i.q10ConductanceScaling ().begin ()), e (i.q10ConductanceScaling ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "q10ConductanceScaling: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const IonChannelKS& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    for (IonChannelKS::gateKS_const_iterator
         b (i.gateKS ().begin ()), e (i.gateKS ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "gateKS: " << *b;
    }

    if (i.species ())
    {
      o << ::std::endl << "species: " << *i.species ();
    }

    if (i.conductance ())
    {
      o << ::std::endl << "conductance: " << *i.conductance ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const IonChannel& i)
  {
    o << static_cast< const ::neuroml2::IonChannelScalable& > (i);

    for (IonChannel::gate_const_iterator
         b (i.gate ().begin ()), e (i.gate ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "gate: " << *b;
    }

    for (IonChannel::gateHHrates_const_iterator
         b (i.gateHHrates ().begin ()), e (i.gateHHrates ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "gateHHrates: " << *b;
    }

    for (IonChannel::gateHHratesTau_const_iterator
         b (i.gateHHratesTau ().begin ()), e (i.gateHHratesTau ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "gateHHratesTau: " << *b;
    }

    for (IonChannel::gateHHtauInf_const_iterator
         b (i.gateHHtauInf ().begin ()), e (i.gateHHtauInf ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "gateHHtauInf: " << *b;
    }

    for (IonChannel::gateHHratesInf_const_iterator
         b (i.gateHHratesInf ().begin ()), e (i.gateHHratesInf ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "gateHHratesInf: " << *b;
    }

    for (IonChannel::gateHHratesTauInf_const_iterator
         b (i.gateHHratesTauInf ().begin ()), e (i.gateHHratesTauInf ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "gateHHratesTauInf: " << *b;
    }

    for (IonChannel::gateHHInstantaneous_const_iterator
         b (i.gateHHInstantaneous ().begin ()), e (i.gateHHInstantaneous ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "gateHHInstantaneous: " << *b;
    }

    for (IonChannel::gateFractional_const_iterator
         b (i.gateFractional ().begin ()), e (i.gateFractional ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "gateFractional: " << *b;
    }

    if (i.species ())
    {
      o << ::std::endl << "species: " << *i.species ();
    }

    if (i.type ())
    {
      o << ::std::endl << "type: " << *i.type ();
    }

    if (i.conductance ())
    {
      o << ::std::endl << "conductance: " << *i.conductance ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const IonChannelHH& i)
  {
    o << static_cast< const ::neuroml2::IonChannel& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const IonChannelVShift& i)
  {
    o << static_cast< const ::neuroml2::IonChannel& > (i);

    o << ::std::endl << "vShift: " << i.vShift ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, channelTypes::value i)
  {
    return o << channelTypes::_xsd_channelTypes_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const channelTypes& i)
  {
    return o << static_cast< const ::xml_schema::string& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Q10ConductanceScaling& i)
  {
    o << ::std::endl << "q10Factor: " << i.q10Factor ();
    o << ::std::endl << "experimentalTemp: " << i.experimentalTemp ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, gateTypes::value i)
  {
    return o << gateTypes::_xsd_gateTypes_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const gateTypes& i)
  {
    return o << static_cast< const ::xml_schema::string& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ClosedState& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const OpenState& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ForwardTransition& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    o << ::std::endl << "from: " << i.from ();
    o << ::std::endl << "to: " << i.to ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ReverseTransition& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    o << ::std::endl << "from: " << i.from ();
    o << ::std::endl << "to: " << i.to ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const TauInfTransition& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    o << ::std::endl << "steadyState: " << i.steadyState ();
    o << ::std::endl << "timeCourse: " << i.timeCourse ();
    o << ::std::endl << "from: " << i.from ();
    o << ::std::endl << "to: " << i.to ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const GateKS& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    if (i.notes ())
    {
      o << ::std::endl << "notes: " << *i.notes ();
    }

    if (i.q10Settings ())
    {
      o << ::std::endl << "q10Settings: " << *i.q10Settings ();
    }

    for (GateKS::closedState_const_iterator
         b (i.closedState ().begin ()), e (i.closedState ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "closedState: " << *b;
    }

    for (GateKS::openState_const_iterator
         b (i.openState ().begin ()), e (i.openState ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "openState: " << *b;
    }

    for (GateKS::forwardTransition_const_iterator
         b (i.forwardTransition ().begin ()), e (i.forwardTransition ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "forwardTransition: " << *b;
    }

    for (GateKS::reverseTransition_const_iterator
         b (i.reverseTransition ().begin ()), e (i.reverseTransition ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "reverseTransition: " << *b;
    }

    for (GateKS::tauInfTransition_const_iterator
         b (i.tauInfTransition ().begin ()), e (i.tauInfTransition ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "tauInfTransition: " << *b;
    }

    o << ::std::endl << "instances: " << i.instances ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const GateHHUndetermined& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    if (i.notes ())
    {
      o << ::std::endl << "notes: " << *i.notes ();
    }

    if (i.q10Settings ())
    {
      o << ::std::endl << "q10Settings: " << *i.q10Settings ();
    }

    if (i.forwardRate ())
    {
      o << ::std::endl << "forwardRate: " << *i.forwardRate ();
    }

    if (i.reverseRate ())
    {
      o << ::std::endl << "reverseRate: " << *i.reverseRate ();
    }

    if (i.timeCourse ())
    {
      o << ::std::endl << "timeCourse: " << *i.timeCourse ();
    }

    if (i.steadyState ())
    {
      o << ::std::endl << "steadyState: " << *i.steadyState ();
    }

    for (GateHHUndetermined::subGate_const_iterator
         b (i.subGate ().begin ()), e (i.subGate ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "subGate: " << *b;
    }

    o << ::std::endl << "instances: " << i.instances ();
    o << ::std::endl << "type: " << i.type ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const GateHHRates& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    if (i.notes ())
    {
      o << ::std::endl << "notes: " << *i.notes ();
    }

    if (i.q10Settings ())
    {
      o << ::std::endl << "q10Settings: " << *i.q10Settings ();
    }

    o << ::std::endl << "forwardRate: " << i.forwardRate ();
    o << ::std::endl << "reverseRate: " << i.reverseRate ();
    o << ::std::endl << "instances: " << i.instances ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const GateHHTauInf& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    if (i.notes ())
    {
      o << ::std::endl << "notes: " << *i.notes ();
    }

    if (i.q10Settings ())
    {
      o << ::std::endl << "q10Settings: " << *i.q10Settings ();
    }

    o << ::std::endl << "timeCourse: " << i.timeCourse ();
    o << ::std::endl << "steadyState: " << i.steadyState ();
    o << ::std::endl << "instances: " << i.instances ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const GateHHRatesTauInf& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    if (i.notes ())
    {
      o << ::std::endl << "notes: " << *i.notes ();
    }

    if (i.q10Settings ())
    {
      o << ::std::endl << "q10Settings: " << *i.q10Settings ();
    }

    o << ::std::endl << "forwardRate: " << i.forwardRate ();
    o << ::std::endl << "reverseRate: " << i.reverseRate ();
    o << ::std::endl << "timeCourse: " << i.timeCourse ();
    o << ::std::endl << "steadyState: " << i.steadyState ();
    o << ::std::endl << "instances: " << i.instances ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const GateHHRatesTau& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    if (i.notes ())
    {
      o << ::std::endl << "notes: " << *i.notes ();
    }

    if (i.q10Settings ())
    {
      o << ::std::endl << "q10Settings: " << *i.q10Settings ();
    }

    o << ::std::endl << "forwardRate: " << i.forwardRate ();
    o << ::std::endl << "reverseRate: " << i.reverseRate ();
    o << ::std::endl << "timeCourse: " << i.timeCourse ();
    o << ::std::endl << "instances: " << i.instances ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const GateHHRatesInf& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    if (i.notes ())
    {
      o << ::std::endl << "notes: " << *i.notes ();
    }

    if (i.q10Settings ())
    {
      o << ::std::endl << "q10Settings: " << *i.q10Settings ();
    }

    o << ::std::endl << "forwardRate: " << i.forwardRate ();
    o << ::std::endl << "reverseRate: " << i.reverseRate ();
    o << ::std::endl << "steadyState: " << i.steadyState ();
    o << ::std::endl << "instances: " << i.instances ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const GateHHInstantaneous& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    if (i.notes ())
    {
      o << ::std::endl << "notes: " << *i.notes ();
    }

    o << ::std::endl << "steadyState: " << i.steadyState ();
    o << ::std::endl << "instances: " << i.instances ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const GateFractional& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    if (i.notes ())
    {
      o << ::std::endl << "notes: " << *i.notes ();
    }

    if (i.q10Settings ())
    {
      o << ::std::endl << "q10Settings: " << *i.q10Settings ();
    }

    for (GateFractional::subGate_const_iterator
         b (i.subGate ().begin ()), e (i.subGate ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "subGate: " << *b;
    }

    o << ::std::endl << "instances: " << i.instances ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const GateFractionalSubgate& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    if (i.notes ())
    {
      o << ::std::endl << "notes: " << *i.notes ();
    }

    if (i.q10Settings ())
    {
      o << ::std::endl << "q10Settings: " << *i.q10Settings ();
    }

    o << ::std::endl << "steadyState: " << i.steadyState ();
    o << ::std::endl << "timeCourse: " << i.timeCourse ();
    o << ::std::endl << "fractionalConductance: " << i.fractionalConductance ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Q10Settings& i)
  {
    o << ::std::endl << "type: " << i.type ();
    if (i.fixedQ10 ())
    {
      o << ::std::endl << "fixedQ10: " << *i.fixedQ10 ();
    }

    if (i.q10Factor ())
    {
      o << ::std::endl << "q10Factor: " << *i.q10Factor ();
    }

    if (i.experimentalTemp ())
    {
      o << ::std::endl << "experimentalTemp: " << *i.experimentalTemp ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const HHRate& i)
  {
    o << ::std::endl << "type: " << i.type ();
    if (i.rate ())
    {
      o << ::std::endl << "rate: " << *i.rate ();
    }

    if (i.midpoint ())
    {
      o << ::std::endl << "midpoint: " << *i.midpoint ();
    }

    if (i.scale ())
    {
      o << ::std::endl << "scale: " << *i.scale ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const HHVariable& i)
  {
    o << ::std::endl << "type: " << i.type ();
    if (i.rate ())
    {
      o << ::std::endl << "rate: " << *i.rate ();
    }

    if (i.midpoint ())
    {
      o << ::std::endl << "midpoint: " << *i.midpoint ();
    }

    if (i.scale ())
    {
      o << ::std::endl << "scale: " << *i.scale ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const HHTime& i)
  {
    o << ::std::endl << "type: " << i.type ();
    if (i.rate ())
    {
      o << ::std::endl << "rate: " << *i.rate ();
    }

    if (i.midpoint ())
    {
      o << ::std::endl << "midpoint: " << *i.midpoint ();
    }

    if (i.scale ())
    {
      o << ::std::endl << "scale: " << *i.scale ();
    }

    if (i.tau ())
    {
      o << ::std::endl << "tau: " << *i.tau ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DecayingPoolConcentrationModel& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    o << ::std::endl << "ion: " << i.ion ();
    o << ::std::endl << "restingConc: " << i.restingConc ();
    o << ::std::endl << "decayConstant: " << i.decayConstant ();
    o << ::std::endl << "shellThickness: " << i.shellThickness ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const FixedFactorConcentrationModel& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    o << ::std::endl << "ion: " << i.ion ();
    o << ::std::endl << "restingConc: " << i.restingConc ();
    o << ::std::endl << "decayConstant: " << i.decayConstant ();
    o << ::std::endl << "rho: " << i.rho ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const BaseSynapse& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const BaseVoltageDepSynapse& i)
  {
    o << static_cast< const ::neuroml2::BaseSynapse& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const BaseCurrentBasedSynapse& i)
  {
    o << static_cast< const ::neuroml2::BaseSynapse& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const BaseConductanceBasedSynapse& i)
  {
    o << static_cast< const ::neuroml2::BaseVoltageDepSynapse& > (i);

    o << ::std::endl << "gbase: " << i.gbase ();
    o << ::std::endl << "erev: " << i.erev ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const BaseConductanceBasedSynapseTwo& i)
  {
    o << static_cast< const ::neuroml2::BaseVoltageDepSynapse& > (i);

    o << ::std::endl << "gbase1: " << i.gbase1 ();
    o << ::std::endl << "gbase2: " << i.gbase2 ();
    o << ::std::endl << "erev: " << i.erev ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const GapJunction& i)
  {
    o << static_cast< const ::neuroml2::BaseSynapse& > (i);

    o << ::std::endl << "conductance: " << i.conductance ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SilentSynapse& i)
  {
    o << static_cast< const ::neuroml2::BaseSynapse& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const LinearGradedSynapse& i)
  {
    o << static_cast< const ::neuroml2::BaseSynapse& > (i);

    o << ::std::endl << "conductance: " << i.conductance ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const GradedSynapse& i)
  {
    o << static_cast< const ::neuroml2::BaseSynapse& > (i);

    o << ::std::endl << "conductance: " << i.conductance ();
    o << ::std::endl << "delta: " << i.delta ();
    o << ::std::endl << "Vth: " << i.Vth ();
    o << ::std::endl << "k: " << i.k ();
    o << ::std::endl << "erev: " << i.erev ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const AlphaCurrentSynapse& i)
  {
    o << static_cast< const ::neuroml2::BaseCurrentBasedSynapse& > (i);

    o << ::std::endl << "tau: " << i.tau ();
    o << ::std::endl << "ibase: " << i.ibase ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const AlphaSynapse& i)
  {
    o << static_cast< const ::neuroml2::BaseConductanceBasedSynapse& > (i);

    o << ::std::endl << "tau: " << i.tau ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ExpOneSynapse& i)
  {
    o << static_cast< const ::neuroml2::BaseConductanceBasedSynapse& > (i);

    o << ::std::endl << "tauDecay: " << i.tauDecay ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ExpTwoSynapse& i)
  {
    o << static_cast< const ::neuroml2::BaseConductanceBasedSynapse& > (i);

    o << ::std::endl << "tauDecay: " << i.tauDecay ();
    o << ::std::endl << "tauRise: " << i.tauRise ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ExpThreeSynapse& i)
  {
    o << static_cast< const ::neuroml2::BaseConductanceBasedSynapseTwo& > (i);

    o << ::std::endl << "tauDecay1: " << i.tauDecay1 ();
    o << ::std::endl << "tauDecay2: " << i.tauDecay2 ();
    o << ::std::endl << "tauRise: " << i.tauRise ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DoubleSynapse& i)
  {
    o << static_cast< const ::neuroml2::BaseVoltageDepSynapse& > (i);

    o << ::std::endl << "synapse1: " << i.synapse1 ();
    o << ::std::endl << "synapse2: " << i.synapse2 ();
    o << ::std::endl << "synapse1Path: " << i.synapse1Path ();
    o << ::std::endl << "synapse2Path: " << i.synapse2Path ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const BlockingPlasticSynapse& i)
  {
    o << static_cast< const ::neuroml2::ExpTwoSynapse& > (i);

    if (i.plasticityMechanism ())
    {
      o << ::std::endl << "plasticityMechanism: " << *i.plasticityMechanism ();
    }

    if (i.blockMechanism ())
    {
      o << ::std::endl << "blockMechanism: " << *i.blockMechanism ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, BlockTypes::value i)
  {
    return o << BlockTypes::_xsd_BlockTypes_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const BlockTypes& i)
  {
    return o << static_cast< const ::xml_schema::string& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const BlockMechanism& i)
  {
    o << ::std::endl << "type: " << i.type ();
    o << ::std::endl << "species: " << i.species ();
    o << ::std::endl << "blockConcentration: " << i.blockConcentration ();
    o << ::std::endl << "scalingConc: " << i.scalingConc ();
    o << ::std::endl << "scalingVolt: " << i.scalingVolt ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, PlasticityTypes::value i)
  {
    return o << PlasticityTypes::_xsd_PlasticityTypes_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const PlasticityTypes& i)
  {
    return o << static_cast< const ::xml_schema::string& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const PlasticityMechanism& i)
  {
    o << ::std::endl << "type: " << i.type ();
    o << ::std::endl << "initReleaseProb: " << i.initReleaseProb ();
    o << ::std::endl << "tauRec: " << i.tauRec ();
    if (i.tauFac ())
    {
      o << ::std::endl << "tauFac: " << *i.tauFac ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const BaseCell& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const IafTauCell& i)
  {
    o << static_cast< const ::neuroml2::BaseCell& > (i);

    o << ::std::endl << "leakReversal: " << i.leakReversal ();
    o << ::std::endl << "thresh: " << i.thresh ();
    o << ::std::endl << "reset: " << i.reset ();
    o << ::std::endl << "tau: " << i.tau ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const IafTauRefCell& i)
  {
    o << static_cast< const ::neuroml2::IafTauCell& > (i);

    o << ::std::endl << "refract: " << i.refract ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const IafCell& i)
  {
    o << static_cast< const ::neuroml2::BaseCell& > (i);

    o << ::std::endl << "leakReversal: " << i.leakReversal ();
    o << ::std::endl << "thresh: " << i.thresh ();
    o << ::std::endl << "reset: " << i.reset ();
    o << ::std::endl << "C: " << i.C ();
    o << ::std::endl << "leakConductance: " << i.leakConductance ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const IafRefCell& i)
  {
    o << static_cast< const ::neuroml2::IafCell& > (i);

    o << ::std::endl << "refract: " << i.refract ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const IzhikevichCell& i)
  {
    o << static_cast< const ::neuroml2::BaseCell& > (i);

    o << ::std::endl << "v0: " << i.v0 ();
    o << ::std::endl << "thresh: " << i.thresh ();
    o << ::std::endl << "a: " << i.a ();
    o << ::std::endl << "b: " << i.b ();
    o << ::std::endl << "c: " << i.c ();
    o << ::std::endl << "d: " << i.d ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const BaseCellMembPotCap& i)
  {
    o << static_cast< const ::neuroml2::BaseCell& > (i);

    o << ::std::endl << "C: " << i.C ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Izhikevich2007Cell& i)
  {
    o << static_cast< const ::neuroml2::BaseCellMembPotCap& > (i);

    o << ::std::endl << "v0: " << i.v0 ();
    o << ::std::endl << "k: " << i.k ();
    o << ::std::endl << "vr: " << i.vr ();
    o << ::std::endl << "vt: " << i.vt ();
    o << ::std::endl << "vpeak: " << i.vpeak ();
    o << ::std::endl << "a: " << i.a ();
    o << ::std::endl << "b: " << i.b ();
    o << ::std::endl << "c: " << i.c ();
    o << ::std::endl << "d: " << i.d ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const AdExIaFCell& i)
  {
    o << static_cast< const ::neuroml2::BaseCellMembPotCap& > (i);

    o << ::std::endl << "gL: " << i.gL ();
    o << ::std::endl << "EL: " << i.EL ();
    o << ::std::endl << "reset: " << i.reset ();
    o << ::std::endl << "VT: " << i.VT ();
    o << ::std::endl << "thresh: " << i.thresh ();
    o << ::std::endl << "delT: " << i.delT ();
    o << ::std::endl << "tauw: " << i.tauw ();
    o << ::std::endl << "refract: " << i.refract ();
    o << ::std::endl << "a: " << i.a ();
    o << ::std::endl << "b: " << i.b ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const FitzHughNagumoCell& i)
  {
    o << static_cast< const ::neuroml2::BaseCell& > (i);

    o << ::std::endl << "I: " << i.I ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const FitzHughNagumo1969Cell& i)
  {
    o << static_cast< const ::neuroml2::BaseCell& > (i);

    o << ::std::endl << "a: " << i.a ();
    o << ::std::endl << "b: " << i.b ();
    o << ::std::endl << "I: " << i.I ();
    o << ::std::endl << "phi: " << i.phi ();
    o << ::std::endl << "V0: " << i.V0 ();
    o << ::std::endl << "W0: " << i.W0 ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const PinskyRinzelCA3Cell& i)
  {
    o << static_cast< const ::neuroml2::BaseCell& > (i);

    o << ::std::endl << "iSoma: " << i.iSoma ();
    o << ::std::endl << "iDend: " << i.iDend ();
    o << ::std::endl << "gc: " << i.gc ();
    o << ::std::endl << "gLs: " << i.gLs ();
    o << ::std::endl << "gLd: " << i.gLd ();
    o << ::std::endl << "gNa: " << i.gNa ();
    o << ::std::endl << "gKdr: " << i.gKdr ();
    o << ::std::endl << "gCa: " << i.gCa ();
    o << ::std::endl << "gKahp: " << i.gKahp ();
    o << ::std::endl << "gKC: " << i.gKC ();
    o << ::std::endl << "gNmda: " << i.gNmda ();
    o << ::std::endl << "gAmpa: " << i.gAmpa ();
    o << ::std::endl << "eNa: " << i.eNa ();
    o << ::std::endl << "eCa: " << i.eCa ();
    o << ::std::endl << "eK: " << i.eK ();
    o << ::std::endl << "eL: " << i.eL ();
    o << ::std::endl << "qd0: " << i.qd0 ();
    o << ::std::endl << "pp: " << i.pp ();
    o << ::std::endl << "alphac: " << i.alphac ();
    o << ::std::endl << "betac: " << i.betac ();
    o << ::std::endl << "cm: " << i.cm ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Cell& i)
  {
    o << static_cast< const ::neuroml2::BaseCell& > (i);

    if (i.morphology ())
    {
      o << ::std::endl << "morphology: " << *i.morphology ();
    }

    if (i.biophysicalProperties ())
    {
      o << ::std::endl << "biophysicalProperties: " << *i.biophysicalProperties ();
    }

    if (i.morphology1 ())
    {
      o << ::std::endl << "morphology: " << *i.morphology1 ();
    }

    if (i.biophysicalProperties1 ())
    {
      o << ::std::endl << "biophysicalProperties: " << *i.biophysicalProperties1 ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Cell2CaPools& i)
  {
    o << static_cast< const ::neuroml2::Cell& > (i);

    if (i.biophysicalProperties2CaPools ())
    {
      o << ::std::endl << "biophysicalProperties2CaPools: " << *i.biophysicalProperties2CaPools ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Morphology_base& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    for (Morphology_base::segment_const_iterator
         b (i.segment ().begin ()), e (i.segment ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "segment: " << *b;
    }

    for (Morphology_base::segmentGroup_const_iterator
         b (i.segmentGroup ().begin ()), e (i.segmentGroup ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "segmentGroup: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const BaseNonNegativeIntegerId& i)
  {
    o << static_cast< const ::neuroml2::BaseWithoutId& > (i);

    o << ::std::endl << "id: " << i.id ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Segment_base& i)
  {
    o << static_cast< const ::neuroml2::BaseNonNegativeIntegerId& > (i);

    if (i.parent ())
    {
      o << ::std::endl << "parent: " << *i.parent ();
    }

    if (i.proximal ())
    {
      o << ::std::endl << "proximal: " << *i.proximal ();
    }

    o << ::std::endl << "distal: " << i.distal ();
    if (i.name ())
    {
      o << ::std::endl << "name: " << *i.name ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SegmentParent& i)
  {
    o << ::std::endl << "segment: " << i.segment ();
    o << ::std::endl << "fractionAlong: " << i.fractionAlong ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Point3DWithDiam& i)
  {
    o << ::std::endl << "x: " << i.x ();
    o << ::std::endl << "y: " << i.y ();
    o << ::std::endl << "z: " << i.z ();
    o << ::std::endl << "diameter: " << i.diameter ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SegmentGroup& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    if (i.notes ())
    {
      o << ::std::endl << "notes: " << *i.notes ();
    }

    for (SegmentGroup::property_const_iterator
         b (i.property ().begin ()), e (i.property ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "property: " << *b;
    }

    if (i.annotation ())
    {
      o << ::std::endl << "annotation: " << *i.annotation ();
    }

    for (SegmentGroup::member_const_iterator
         b (i.member ().begin ()), e (i.member ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "member: " << *b;
    }

    for (SegmentGroup::include_const_iterator
         b (i.include ().begin ()), e (i.include ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "include: " << *b;
    }

    for (SegmentGroup::path_const_iterator
         b (i.path ().begin ()), e (i.path ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "path: " << *b;
    }

    for (SegmentGroup::subTree_const_iterator
         b (i.subTree ().begin ()), e (i.subTree ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "subTree: " << *b;
    }

    for (SegmentGroup::inhomogeneousParameter_const_iterator
         b (i.inhomogeneousParameter ().begin ()), e (i.inhomogeneousParameter ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "inhomogeneousParameter: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const InhomogeneousParameter& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    if (i.proximal ())
    {
      o << ::std::endl << "proximal: " << *i.proximal ();
    }

    if (i.distal ())
    {
      o << ::std::endl << "distal: " << *i.distal ();
    }

    o << ::std::endl << "variable: " << i.variable ();
    o << ::std::endl << "metric: " << i.metric ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, Metric::value i)
  {
    return o << Metric::_xsd_Metric_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Metric& i)
  {
    return o << static_cast< const ::xml_schema::string& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ProximalDetails& i)
  {
    o << ::std::endl << "translationStart: " << i.translationStart ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DistalDetails& i)
  {
    o << ::std::endl << "normalizationEnd: " << i.normalizationEnd ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Member& i)
  {
    o << ::std::endl << "segment: " << i.segment ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Include& i)
  {
    o << ::std::endl << "segmentGroup: " << i.segmentGroup ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Path& i)
  {
    if (i.from ())
    {
      o << ::std::endl << "from: " << *i.from ();
    }

    if (i.to ())
    {
      o << ::std::endl << "to: " << *i.to ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SubTree& i)
  {
    if (i.from ())
    {
      o << ::std::endl << "from: " << *i.from ();
    }

    if (i.to ())
    {
      o << ::std::endl << "to: " << *i.to ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SegmentEndPoint& i)
  {
    o << ::std::endl << "segment: " << i.segment ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const BiophysicalProperties& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    o << ::std::endl << "membraneProperties: " << i.membraneProperties ();
    if (i.intracellularProperties ())
    {
      o << ::std::endl << "intracellularProperties: " << *i.intracellularProperties ();
    }

    if (i.extracellularProperties ())
    {
      o << ::std::endl << "extracellularProperties: " << *i.extracellularProperties ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const BiophysicalProperties2CaPools& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    o << ::std::endl << "membraneProperties2CaPools: " << i.membraneProperties2CaPools ();
    if (i.intracellularProperties2CaPools ())
    {
      o << ::std::endl << "intracellularProperties2CaPools: " << *i.intracellularProperties2CaPools ();
    }

    if (i.extracellularProperties ())
    {
      o << ::std::endl << "extracellularProperties: " << *i.extracellularProperties ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const MembraneProperties& i)
  {
    for (MembraneProperties::channelPopulation_const_iterator
         b (i.channelPopulation ().begin ()), e (i.channelPopulation ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "channelPopulation: " << *b;
    }

    for (MembraneProperties::channelDensity_const_iterator
         b (i.channelDensity ().begin ()), e (i.channelDensity ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "channelDensity: " << *b;
    }

    for (MembraneProperties::channelDensityVShift_const_iterator
         b (i.channelDensityVShift ().begin ()), e (i.channelDensityVShift ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "channelDensityVShift: " << *b;
    }

    for (MembraneProperties::channelDensityNernst_const_iterator
         b (i.channelDensityNernst ().begin ()), e (i.channelDensityNernst ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "channelDensityNernst: " << *b;
    }

    for (MembraneProperties::channelDensityGHK_const_iterator
         b (i.channelDensityGHK ().begin ()), e (i.channelDensityGHK ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "channelDensityGHK: " << *b;
    }

    for (MembraneProperties::channelDensityGHK2_const_iterator
         b (i.channelDensityGHK2 ().begin ()), e (i.channelDensityGHK2 ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "channelDensityGHK2: " << *b;
    }

    for (MembraneProperties::channelDensityNonUniform_const_iterator
         b (i.channelDensityNonUniform ().begin ()), e (i.channelDensityNonUniform ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "channelDensityNonUniform: " << *b;
    }

    for (MembraneProperties::channelDensityNonUniformNernst_const_iterator
         b (i.channelDensityNonUniformNernst ().begin ()), e (i.channelDensityNonUniformNernst ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "channelDensityNonUniformNernst: " << *b;
    }

    for (MembraneProperties::channelDensityNonUniformGHK_const_iterator
         b (i.channelDensityNonUniformGHK ().begin ()), e (i.channelDensityNonUniformGHK ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "channelDensityNonUniformGHK: " << *b;
    }

    for (MembraneProperties::spikeThresh_const_iterator
         b (i.spikeThresh ().begin ()), e (i.spikeThresh ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "spikeThresh: " << *b;
    }

    for (MembraneProperties::specificCapacitance_const_iterator
         b (i.specificCapacitance ().begin ()), e (i.specificCapacitance ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "specificCapacitance: " << *b;
    }

    for (MembraneProperties::initMembPotential_const_iterator
         b (i.initMembPotential ().begin ()), e (i.initMembPotential ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "initMembPotential: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const MembraneProperties2CaPools& i)
  {
    o << static_cast< const ::neuroml2::MembraneProperties& > (i);

    for (MembraneProperties2CaPools::channelDensityNernstCa2_const_iterator
         b (i.channelDensityNernstCa2 ().begin ()), e (i.channelDensityNernstCa2 ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "channelDensityNernstCa2: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SpikeThresh& i)
  {
    o << ::std::endl << "value: " << i.value ();
    o << ::std::endl << "segmentGroup: " << i.segmentGroup ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SpecificCapacitance& i)
  {
    o << ::std::endl << "value: " << i.value ();
    o << ::std::endl << "segmentGroup: " << i.segmentGroup ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const InitMembPotential& i)
  {
    o << ::std::endl << "value: " << i.value ();
    o << ::std::endl << "segmentGroup: " << i.segmentGroup ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Resistivity& i)
  {
    o << ::std::endl << "value: " << i.value ();
    o << ::std::endl << "segmentGroup: " << i.segmentGroup ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ChannelPopulation& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    for (ChannelPopulation::variableParameter_const_iterator
         b (i.variableParameter ().begin ()), e (i.variableParameter ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "variableParameter: " << *b;
    }

    o << ::std::endl << "ionChannel: " << i.ionChannel ();
    o << ::std::endl << "number: " << i.number ();
    o << ::std::endl << "erev: " << i.erev ();
    o << ::std::endl << "segmentGroup: " << i.segmentGroup ();
    if (i.segment ())
    {
      o << ::std::endl << "segment: " << *i.segment ();
    }

    o << ::std::endl << "ion: " << i.ion ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ChannelDensityNonUniform& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    for (ChannelDensityNonUniform::variableParameter_const_iterator
         b (i.variableParameter ().begin ()), e (i.variableParameter ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "variableParameter: " << *b;
    }

    o << ::std::endl << "ionChannel: " << i.ionChannel ();
    o << ::std::endl << "erev: " << i.erev ();
    o << ::std::endl << "ion: " << i.ion ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ChannelDensityNonUniformNernst& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    for (ChannelDensityNonUniformNernst::variableParameter_const_iterator
         b (i.variableParameter ().begin ()), e (i.variableParameter ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "variableParameter: " << *b;
    }

    o << ::std::endl << "ionChannel: " << i.ionChannel ();
    o << ::std::endl << "ion: " << i.ion ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ChannelDensityNonUniformGHK& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    for (ChannelDensityNonUniformGHK::variableParameter_const_iterator
         b (i.variableParameter ().begin ()), e (i.variableParameter ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "variableParameter: " << *b;
    }

    o << ::std::endl << "ionChannel: " << i.ionChannel ();
    o << ::std::endl << "ion: " << i.ion ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ChannelDensity& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    for (ChannelDensity::variableParameter_const_iterator
         b (i.variableParameter ().begin ()), e (i.variableParameter ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "variableParameter: " << *b;
    }

    o << ::std::endl << "ionChannel: " << i.ionChannel ();
    if (i.condDensity ())
    {
      o << ::std::endl << "condDensity: " << *i.condDensity ();
    }

    o << ::std::endl << "erev: " << i.erev ();
    o << ::std::endl << "segmentGroup: " << i.segmentGroup ();
    if (i.segment ())
    {
      o << ::std::endl << "segment: " << *i.segment ();
    }

    o << ::std::endl << "ion: " << i.ion ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ChannelDensityVShift& i)
  {
    o << static_cast< const ::neuroml2::ChannelDensity& > (i);

    o << ::std::endl << "vShift: " << i.vShift ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ChannelDensityNernst& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    for (ChannelDensityNernst::variableParameter_const_iterator
         b (i.variableParameter ().begin ()), e (i.variableParameter ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "variableParameter: " << *b;
    }

    o << ::std::endl << "ionChannel: " << i.ionChannel ();
    if (i.condDensity ())
    {
      o << ::std::endl << "condDensity: " << *i.condDensity ();
    }

    o << ::std::endl << "segmentGroup: " << i.segmentGroup ();
    if (i.segment ())
    {
      o << ::std::endl << "segment: " << *i.segment ();
    }

    o << ::std::endl << "ion: " << i.ion ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ChannelDensityNernstCa2& i)
  {
    o << static_cast< const ::neuroml2::ChannelDensityNernst& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ChannelDensityGHK& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    o << ::std::endl << "ionChannel: " << i.ionChannel ();
    o << ::std::endl << "permeability: " << i.permeability ();
    o << ::std::endl << "segmentGroup: " << i.segmentGroup ();
    if (i.segment ())
    {
      o << ::std::endl << "segment: " << *i.segment ();
    }

    o << ::std::endl << "ion: " << i.ion ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ChannelDensityGHK2& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    o << ::std::endl << "ionChannel: " << i.ionChannel ();
    if (i.condDensity ())
    {
      o << ::std::endl << "condDensity: " << *i.condDensity ();
    }

    o << ::std::endl << "segmentGroup: " << i.segmentGroup ();
    if (i.segment ())
    {
      o << ::std::endl << "segment: " << *i.segment ();
    }

    o << ::std::endl << "ion: " << i.ion ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VariableParameter& i)
  {
    if (i.inhomogeneousValue ())
    {
      o << ::std::endl << "inhomogeneousValue: " << *i.inhomogeneousValue ();
    }

    o << ::std::endl << "parameter: " << i.parameter ();
    o << ::std::endl << "segmentGroup: " << i.segmentGroup ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const InhomogeneousValue& i)
  {
    o << ::std::endl << "inhomogeneousParameter: " << i.inhomogeneousParameter ();
    o << ::std::endl << "value: " << i.value ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Species& i)
  {
    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "concentrationModel: " << i.concentrationModel ();
    if (i.ion ())
    {
      o << ::std::endl << "ion: " << *i.ion ();
    }

    o << ::std::endl << "initialConcentration: " << i.initialConcentration ();
    o << ::std::endl << "initialExtConcentration: " << i.initialExtConcentration ();
    o << ::std::endl << "segmentGroup: " << i.segmentGroup ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ConcentrationModel_D& i)
  {
    o << static_cast< const ::neuroml2::DecayingPoolConcentrationModel& > (i);

    o << ::std::endl << "type: " << i.type ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const IntracellularProperties& i)
  {
    for (IntracellularProperties::species_const_iterator
         b (i.species ().begin ()), e (i.species ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "species: " << *b;
    }

    for (IntracellularProperties::resistivity_const_iterator
         b (i.resistivity ().begin ()), e (i.resistivity ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "resistivity: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const IntracellularProperties2CaPools& i)
  {
    o << static_cast< const ::neuroml2::IntracellularProperties& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ExtracellularProperties& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    for (ExtracellularProperties::species_const_iterator
         b (i.species ().begin ()), e (i.species ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "species: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ExtracellularPropertiesLocal& i)
  {
    for (ExtracellularPropertiesLocal::species_const_iterator
         b (i.species ().begin ()), e (i.species ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "species: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ReactionScheme& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    o << ::std::endl << "source: " << i.source ();
    o << ::std::endl << "type: " << i.type ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const PulseGenerator& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    o << ::std::endl << "delay: " << i.delay ();
    o << ::std::endl << "duration: " << i.duration ();
    o << ::std::endl << "amplitude: " << i.amplitude ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const PulseGeneratorDL& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    o << ::std::endl << "delay: " << i.delay ();
    o << ::std::endl << "duration: " << i.duration ();
    o << ::std::endl << "amplitude: " << i.amplitude ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SineGenerator& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    o << ::std::endl << "delay: " << i.delay ();
    o << ::std::endl << "phase: " << i.phase ();
    o << ::std::endl << "duration: " << i.duration ();
    o << ::std::endl << "amplitude: " << i.amplitude ();
    o << ::std::endl << "period: " << i.period ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SineGeneratorDL& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    o << ::std::endl << "delay: " << i.delay ();
    o << ::std::endl << "phase: " << i.phase ();
    o << ::std::endl << "duration: " << i.duration ();
    o << ::std::endl << "amplitude: " << i.amplitude ();
    o << ::std::endl << "period: " << i.period ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const RampGenerator& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    o << ::std::endl << "delay: " << i.delay ();
    o << ::std::endl << "duration: " << i.duration ();
    o << ::std::endl << "startAmplitude: " << i.startAmplitude ();
    o << ::std::endl << "finishAmplitude: " << i.finishAmplitude ();
    o << ::std::endl << "baselineAmplitude: " << i.baselineAmplitude ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const RampGeneratorDL& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    o << ::std::endl << "delay: " << i.delay ();
    o << ::std::endl << "duration: " << i.duration ();
    o << ::std::endl << "startAmplitude: " << i.startAmplitude ();
    o << ::std::endl << "finishAmplitude: " << i.finishAmplitude ();
    o << ::std::endl << "baselineAmplitude: " << i.baselineAmplitude ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const CompoundInput& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    for (CompoundInput::pulseGenerator_const_iterator
         b (i.pulseGenerator ().begin ()), e (i.pulseGenerator ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "pulseGenerator: " << *b;
    }

    for (CompoundInput::sineGenerator_const_iterator
         b (i.sineGenerator ().begin ()), e (i.sineGenerator ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "sineGenerator: " << *b;
    }

    for (CompoundInput::rampGenerator_const_iterator
         b (i.rampGenerator ().begin ()), e (i.rampGenerator ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "rampGenerator: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const CompoundInputDL& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    for (CompoundInputDL::pulseGeneratorDL_const_iterator
         b (i.pulseGeneratorDL ().begin ()), e (i.pulseGeneratorDL ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "pulseGeneratorDL: " << *b;
    }

    for (CompoundInputDL::sineGeneratorDL_const_iterator
         b (i.sineGeneratorDL ().begin ()), e (i.sineGeneratorDL ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "sineGeneratorDL: " << *b;
    }

    for (CompoundInputDL::rampGeneratorDL_const_iterator
         b (i.rampGeneratorDL ().begin ()), e (i.rampGeneratorDL ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "rampGeneratorDL: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VoltageClamp& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    o << ::std::endl << "delay: " << i.delay ();
    o << ::std::endl << "duration: " << i.duration ();
    o << ::std::endl << "targetVoltage: " << i.targetVoltage ();
    o << ::std::endl << "simpleSeriesResistance: " << i.simpleSeriesResistance ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VoltageClampTriple& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    o << ::std::endl << "active: " << i.active ();
    o << ::std::endl << "delay: " << i.delay ();
    o << ::std::endl << "duration: " << i.duration ();
    o << ::std::endl << "conditioningVoltage: " << i.conditioningVoltage ();
    o << ::std::endl << "testingVoltage: " << i.testingVoltage ();
    o << ::std::endl << "returnVoltage: " << i.returnVoltage ();
    o << ::std::endl << "simpleSeriesResistance: " << i.simpleSeriesResistance ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Spike& i)
  {
    o << static_cast< const ::neuroml2::BaseNonNegativeIntegerId& > (i);

    o << ::std::endl << "time: " << i.time ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SpikeArray& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    for (SpikeArray::spike_const_iterator
         b (i.spike ().begin ()), e (i.spike ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "spike: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const TimedSynapticInput& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    for (TimedSynapticInput::spike_const_iterator
         b (i.spike ().begin ()), e (i.spike ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "spike: " << *b;
    }

    o << ::std::endl << "synapse: " << i.synapse ();
    o << ::std::endl << "spikeTarget: " << i.spikeTarget ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SpikeGenerator& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    o << ::std::endl << "period: " << i.period ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SpikeGeneratorRandom& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    o << ::std::endl << "maxISI: " << i.maxISI ();
    o << ::std::endl << "minISI: " << i.minISI ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SpikeGeneratorPoisson& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    o << ::std::endl << "averageRate: " << i.averageRate ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SpikeGeneratorRefPoisson& i)
  {
    o << static_cast< const ::neuroml2::SpikeGeneratorPoisson& > (i);

    o << ::std::endl << "minimumISI: " << i.minimumISI ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const PoissonFiringSynapse& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    o << ::std::endl << "averageRate: " << i.averageRate ();
    o << ::std::endl << "synapse: " << i.synapse ();
    o << ::std::endl << "spikeTarget: " << i.spikeTarget ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const TransientPoissonFiringSynapse& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    o << ::std::endl << "averageRate: " << i.averageRate ();
    o << ::std::endl << "delay: " << i.delay ();
    o << ::std::endl << "duration: " << i.duration ();
    o << ::std::endl << "synapse: " << i.synapse ();
    o << ::std::endl << "spikeTarget: " << i.spikeTarget ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Network& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    for (Network::space_const_iterator
         b (i.space ().begin ()), e (i.space ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "space: " << *b;
    }

    for (Network::region_const_iterator
         b (i.region ().begin ()), e (i.region ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "region: " << *b;
    }

    for (Network::extracellularProperties_const_iterator
         b (i.extracellularProperties ().begin ()), e (i.extracellularProperties ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "extracellularProperties: " << *b;
    }

    for (Network::population_const_iterator
         b (i.population ().begin ()), e (i.population ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "population: " << *b;
    }

    for (Network::cellSet_const_iterator
         b (i.cellSet ().begin ()), e (i.cellSet ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "cellSet: " << *b;
    }

    for (Network::synapticConnection_const_iterator
         b (i.synapticConnection ().begin ()), e (i.synapticConnection ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "synapticConnection: " << *b;
    }

    for (Network::projection_const_iterator
         b (i.projection ().begin ()), e (i.projection ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "projection: " << *b;
    }

    for (Network::electricalProjection_const_iterator
         b (i.electricalProjection ().begin ()), e (i.electricalProjection ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "electricalProjection: " << *b;
    }

    for (Network::continuousProjection_const_iterator
         b (i.continuousProjection ().begin ()), e (i.continuousProjection ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "continuousProjection: " << *b;
    }

    for (Network::explicitInput_const_iterator
         b (i.explicitInput ().begin ()), e (i.explicitInput ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "explicitInput: " << *b;
    }

    for (Network::inputList_const_iterator
         b (i.inputList ().begin ()), e (i.inputList ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "inputList: " << *b;
    }

    if (i.type ())
    {
      o << ::std::endl << "type: " << *i.type ();
    }

    if (i.temperature ())
    {
      o << ::std::endl << "temperature: " << *i.temperature ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, networkTypes::value i)
  {
    return o << networkTypes::_xsd_networkTypes_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const networkTypes& i)
  {
    return o << static_cast< const ::xml_schema::string& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Space& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    if (i.structure ())
    {
      o << ::std::endl << "structure: " << *i.structure ();
    }

    if (i.basedOn ())
    {
      o << ::std::endl << "basedOn: " << *i.basedOn ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SpaceStructure& i)
  {
    if (i.xSpacing ())
    {
      o << ::std::endl << "xSpacing: " << *i.xSpacing ();
    }

    if (i.ySpacing ())
    {
      o << ::std::endl << "ySpacing: " << *i.ySpacing ();
    }

    if (i.zSpacing ())
    {
      o << ::std::endl << "zSpacing: " << *i.zSpacing ();
    }

    o << ::std::endl << "xStart: " << i.xStart ();
    o << ::std::endl << "yStart: " << i.yStart ();
    o << ::std::endl << "zStart: " << i.zStart ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, allowedSpaces::value i)
  {
    return o << allowedSpaces::_xsd_allowedSpaces_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const allowedSpaces& i)
  {
    return o << static_cast< const ::xml_schema::string& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Region& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    if (i.space ())
    {
      o << ::std::endl << "space: " << *i.space ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Population& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    if (i.layout ())
    {
      o << ::std::endl << "layout: " << *i.layout ();
    }

    for (Population::instance_const_iterator
         b (i.instance ().begin ()), e (i.instance ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "instance: " << *b;
    }

    o << ::std::endl << "component: " << i.component ();
    if (i.size ())
    {
      o << ::std::endl << "size: " << *i.size ();
    }

    if (i.type ())
    {
      o << ::std::endl << "type: " << *i.type ();
    }

    if (i.extracellularProperties ())
    {
      o << ::std::endl << "extracellularProperties: " << *i.extracellularProperties ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, populationTypes::value i)
  {
    return o << populationTypes::_xsd_populationTypes_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const populationTypes& i)
  {
    return o << static_cast< const ::xml_schema::string& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Layout& i)
  {
    if (i.random ())
    {
      o << ::std::endl << "random: " << *i.random ();
    }

    if (i.grid ())
    {
      o << ::std::endl << "grid: " << *i.grid ();
    }

    if (i.unstructured ())
    {
      o << ::std::endl << "unstructured: " << *i.unstructured ();
    }

    if (i.space ())
    {
      o << ::std::endl << "space: " << *i.space ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const UnstructuredLayout& i)
  {
    if (i.number ())
    {
      o << ::std::endl << "number: " << *i.number ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const RandomLayout& i)
  {
    if (i.number ())
    {
      o << ::std::endl << "number: " << *i.number ();
    }

    if (i.region ())
    {
      o << ::std::endl << "region: " << *i.region ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const GridLayout& i)
  {
    if (i.xSize ())
    {
      o << ::std::endl << "xSize: " << *i.xSize ();
    }

    if (i.ySize ())
    {
      o << ::std::endl << "ySize: " << *i.ySize ();
    }

    if (i.zSize ())
    {
      o << ::std::endl << "zSize: " << *i.zSize ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Instance& i)
  {
    o << ::std::endl << "location: " << i.location ();
    if (i.id ())
    {
      o << ::std::endl << "id: " << *i.id ();
    }

    if (i.i ())
    {
      o << ::std::endl << "i: " << *i.i ();
    }

    if (i.j ())
    {
      o << ::std::endl << "j: " << *i.j ();
    }

    if (i.k ())
    {
      o << ::std::endl << "k: " << *i.k ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Location& i)
  {
    o << ::std::endl << "x: " << i.x ();
    o << ::std::endl << "y: " << i.y ();
    o << ::std::endl << "z: " << i.z ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const CellSet& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    o << ::std::endl << "select: " << i.select ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SynapticConnection& i)
  {
    o << ::std::endl << "from: " << i.from ();
    o << ::std::endl << "to: " << i.to ();
    o << ::std::endl << "synapse: " << i.synapse ();
    if (i.destination ())
    {
      o << ::std::endl << "destination: " << *i.destination ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const BaseProjection& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    o << ::std::endl << "presynapticPopulation: " << i.presynapticPopulation ();
    o << ::std::endl << "postsynapticPopulation: " << i.postsynapticPopulation ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Projection& i)
  {
    o << static_cast< const ::neuroml2::BaseProjection& > (i);

    for (Projection::connection_const_iterator
         b (i.connection ().begin ()), e (i.connection ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "connection: " << *b;
    }

    for (Projection::connectionWD_const_iterator
         b (i.connectionWD ().begin ()), e (i.connectionWD ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "connectionWD: " << *b;
    }

    o << ::std::endl << "synapse: " << i.synapse ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const BaseConnection& i)
  {
    o << static_cast< const ::neuroml2::BaseNonNegativeIntegerId& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const BaseConnectionOldFormat& i)
  {
    o << static_cast< const ::neuroml2::BaseConnection& > (i);

    o << ::std::endl << "preCellId: " << i.preCellId ();
    o << ::std::endl << "preSegmentId: " << i.preSegmentId ();
    o << ::std::endl << "preFractionAlong: " << i.preFractionAlong ();
    o << ::std::endl << "postCellId: " << i.postCellId ();
    o << ::std::endl << "postSegmentId: " << i.postSegmentId ();
    o << ::std::endl << "postFractionAlong: " << i.postFractionAlong ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const BaseConnectionNewFormat& i)
  {
    o << static_cast< const ::neuroml2::BaseConnection& > (i);

    o << ::std::endl << "preCell: " << i.preCell ();
    o << ::std::endl << "preSegment: " << i.preSegment ();
    o << ::std::endl << "preFractionAlong: " << i.preFractionAlong ();
    o << ::std::endl << "postCell: " << i.postCell ();
    o << ::std::endl << "postSegment: " << i.postSegment ();
    o << ::std::endl << "postFractionAlong: " << i.postFractionAlong ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Connection_base& i)
  {
    o << static_cast< const ::neuroml2::BaseConnectionOldFormat& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ConnectionWD& i)
  {
    o << static_cast< const ::neuroml2::BaseConnectionOldFormat& > (i);

    o << ::std::endl << "weight: " << i.weight ();
    o << ::std::endl << "delay: " << i.delay ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ElectricalProjection& i)
  {
    o << static_cast< const ::neuroml2::BaseProjection& > (i);

    for (ElectricalProjection::electricalConnection_const_iterator
         b (i.electricalConnection ().begin ()), e (i.electricalConnection ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "electricalConnection: " << *b;
    }

    for (ElectricalProjection::electricalConnectionInstance_const_iterator
         b (i.electricalConnectionInstance ().begin ()), e (i.electricalConnectionInstance ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "electricalConnectionInstance: " << *b;
    }

    for (ElectricalProjection::electricalConnectionInstanceW_const_iterator
         b (i.electricalConnectionInstanceW ().begin ()), e (i.electricalConnectionInstanceW ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "electricalConnectionInstanceW: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ElectricalConnection& i)
  {
    o << static_cast< const ::neuroml2::BaseConnectionNewFormat& > (i);

    o << ::std::endl << "synapse: " << i.synapse ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ElectricalConnectionInstance& i)
  {
    o << static_cast< const ::neuroml2::ElectricalConnection& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ElectricalConnectionInstanceW& i)
  {
    o << static_cast< const ::neuroml2::ElectricalConnectionInstance& > (i);

    o << ::std::endl << "weight: " << i.weight ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ContinuousProjection& i)
  {
    o << static_cast< const ::neuroml2::BaseProjection& > (i);

    for (ContinuousProjection::continuousConnection_const_iterator
         b (i.continuousConnection ().begin ()), e (i.continuousConnection ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "continuousConnection: " << *b;
    }

    for (ContinuousProjection::continuousConnectionInstance_const_iterator
         b (i.continuousConnectionInstance ().begin ()), e (i.continuousConnectionInstance ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "continuousConnectionInstance: " << *b;
    }

    for (ContinuousProjection::continuousConnectionInstanceW_const_iterator
         b (i.continuousConnectionInstanceW ().begin ()), e (i.continuousConnectionInstanceW ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "continuousConnectionInstanceW: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ContinuousConnection& i)
  {
    o << static_cast< const ::neuroml2::BaseConnectionNewFormat& > (i);

    o << ::std::endl << "preComponent: " << i.preComponent ();
    o << ::std::endl << "postComponent: " << i.postComponent ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ContinuousConnectionInstance& i)
  {
    o << static_cast< const ::neuroml2::ContinuousConnection& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ContinuousConnectionInstanceW& i)
  {
    o << static_cast< const ::neuroml2::ContinuousConnectionInstance& > (i);

    o << ::std::endl << "weight: " << i.weight ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ExplicitInput& i)
  {
    o << ::std::endl << "target: " << i.target ();
    o << ::std::endl << "input: " << i.input ();
    if (i.destination ())
    {
      o << ::std::endl << "destination: " << *i.destination ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const InputList& i)
  {
    o << static_cast< const ::neuroml2::Base& > (i);

    for (InputList::input_const_iterator
         b (i.input ().begin ()), e (i.input ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "input: " << *b;
    }

    for (InputList::inputW_const_iterator
         b (i.inputW ().begin ()), e (i.inputW ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "inputW: " << *b;
    }

    o << ::std::endl << "population: " << i.population ();
    o << ::std::endl << "component: " << i.component ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Input& i)
  {
    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "target: " << i.target ();
    o << ::std::endl << "destination: " << i.destination ();
    if (i.segmentId ())
    {
      o << ::std::endl << "segmentId: " << *i.segmentId ();
    }

    if (i.fractionAlong ())
    {
      o << ::std::endl << "fractionAlong: " << *i.fractionAlong ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const InputW& i)
  {
    o << static_cast< const ::neuroml2::Input& > (i);

    o << ::std::endl << "weight: " << i.weight ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const basePyNNCell& i)
  {
    o << static_cast< const ::neuroml2::BaseCell& > (i);

    o << ::std::endl << "cm: " << i.cm ();
    o << ::std::endl << "i_offset: " << i.i_offset ();
    o << ::std::endl << "tau_syn_E: " << i.tau_syn_E ();
    o << ::std::endl << "tau_syn_I: " << i.tau_syn_I ();
    o << ::std::endl << "v_init: " << i.v_init ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const basePyNNIaFCell& i)
  {
    o << static_cast< const ::neuroml2::basePyNNCell& > (i);

    o << ::std::endl << "tau_m: " << i.tau_m ();
    o << ::std::endl << "tau_refrac: " << i.tau_refrac ();
    o << ::std::endl << "v_reset: " << i.v_reset ();
    o << ::std::endl << "v_rest: " << i.v_rest ();
    o << ::std::endl << "v_thresh: " << i.v_thresh ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const basePyNNIaFCondCell& i)
  {
    o << static_cast< const ::neuroml2::basePyNNIaFCell& > (i);

    o << ::std::endl << "e_rev_E: " << i.e_rev_E ();
    o << ::std::endl << "e_rev_I: " << i.e_rev_I ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const IF_curr_alpha& i)
  {
    o << static_cast< const ::neuroml2::basePyNNIaFCell& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const IF_curr_exp& i)
  {
    o << static_cast< const ::neuroml2::basePyNNIaFCell& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const IF_cond_alpha& i)
  {
    o << static_cast< const ::neuroml2::basePyNNIaFCondCell& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const IF_cond_exp& i)
  {
    o << static_cast< const ::neuroml2::basePyNNIaFCondCell& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const EIF_cond_exp_isfa_ista& i)
  {
    o << static_cast< const ::neuroml2::basePyNNIaFCondCell& > (i);

    o << ::std::endl << "a: " << i.a ();
    o << ::std::endl << "b: " << i.b ();
    o << ::std::endl << "delta_T: " << i.delta_T ();
    o << ::std::endl << "tau_w: " << i.tau_w ();
    o << ::std::endl << "v_spike: " << i.v_spike ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const EIF_cond_alpha_isfa_ista& i)
  {
    o << static_cast< const ::neuroml2::EIF_cond_exp_isfa_ista& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const HH_cond_exp& i)
  {
    o << static_cast< const ::neuroml2::basePyNNCell& > (i);

    o << ::std::endl << "v_offset: " << i.v_offset ();
    o << ::std::endl << "e_rev_E: " << i.e_rev_E ();
    o << ::std::endl << "e_rev_I: " << i.e_rev_I ();
    o << ::std::endl << "e_rev_K: " << i.e_rev_K ();
    o << ::std::endl << "e_rev_Na: " << i.e_rev_Na ();
    o << ::std::endl << "e_rev_leak: " << i.e_rev_leak ();
    o << ::std::endl << "g_leak: " << i.g_leak ();
    o << ::std::endl << "gbar_K: " << i.gbar_K ();
    o << ::std::endl << "gbar_Na: " << i.gbar_Na ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const BasePynnSynapse& i)
  {
    o << static_cast< const ::neuroml2::BaseSynapse& > (i);

    o << ::std::endl << "tau_syn: " << i.tau_syn ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ExpCondSynapse& i)
  {
    o << static_cast< const ::neuroml2::BasePynnSynapse& > (i);

    o << ::std::endl << "e_rev: " << i.e_rev ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const AlphaCondSynapse& i)
  {
    o << static_cast< const ::neuroml2::BasePynnSynapse& > (i);

    o << ::std::endl << "e_rev: " << i.e_rev ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ExpCurrSynapse& i)
  {
    o << static_cast< const ::neuroml2::BasePynnSynapse& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const AlphaCurrSynapse& i)
  {
    o << static_cast< const ::neuroml2::BasePynnSynapse& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SpikeSourcePoisson& i)
  {
    o << static_cast< const ::neuroml2::Standalone& > (i);

    o << ::std::endl << "start: " << i.start ();
    o << ::std::endl << "duration: " << i.duration ();
    o << ::std::endl << "rate: " << i.rate ();
    return o;
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace neuroml2
{
  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::neuroml2::NeuroMLDocument > (
      ::neuroml2::neuroml (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::neuroml2::NeuroMLDocument > (
      ::neuroml2::neuroml (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::neuroml2::NeuroMLDocument > (
      ::neuroml2::neuroml (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::neuroml2::neuroml (isrc, f, p);
  }

  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::neuroml2::neuroml (isrc, h, f, p);
  }

  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::neuroml2::neuroml (isrc, h, f, p);
  }

  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::neuroml2::neuroml (isrc, f, p);
  }

  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::neuroml2::neuroml (isrc, h, f, p);
  }

  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::neuroml2::neuroml (isrc, h, f, p);
  }

  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::neuroml2::NeuroMLDocument > (
      ::neuroml2::neuroml (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::neuroml2::NeuroMLDocument > (
      ::neuroml2::neuroml (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::neuroml2::NeuroMLDocument > (
      ::neuroml2::neuroml (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (const ::xercesc::DOMDocument& doc,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::neuroml2::NeuroMLDocument > (
        ::neuroml2::neuroml (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "neuroml" &&
        n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
    {
      ::std::unique_ptr< ::neuroml2::NeuroMLDocument > r (
        ::xsd::cxx::tree::traits< ::neuroml2::NeuroMLDocument, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "neuroml",
      "http://www.neuroml.org/schema/neuroml2");
  }

  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "neuroml" &&
        n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
    {
      ::std::unique_ptr< ::neuroml2::NeuroMLDocument > r (
        ::xsd::cxx::tree::traits< ::neuroml2::NeuroMLDocument, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "neuroml",
      "http://www.neuroml.org/schema/neuroml2");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace neuroml2
{
  void
  operator<< (::xercesc::DOMElement& e, const NmlId& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const NmlId& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const NmlId& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Nml2Quantity& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Nml2Quantity& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Nml2Quantity& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Nml2Quantity_none& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Nml2Quantity_none& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Nml2Quantity_none& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Nml2Quantity_voltage& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Nml2Quantity_voltage& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Nml2Quantity_voltage& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Nml2Quantity_length& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Nml2Quantity_length& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Nml2Quantity_length& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Nml2Quantity_resistance& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Nml2Quantity_resistance& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Nml2Quantity_resistance& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Nml2Quantity_resistivity& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Nml2Quantity_resistivity& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Nml2Quantity_resistivity& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Nml2Quantity_conductance& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Nml2Quantity_conductance& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Nml2Quantity_conductance& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Nml2Quantity_conductanceDensity& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Nml2Quantity_conductanceDensity& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Nml2Quantity_conductanceDensity& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Nml2Quantity_permeability& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Nml2Quantity_permeability& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Nml2Quantity_permeability& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Nml2Quantity_time& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Nml2Quantity_time& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Nml2Quantity_time& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Nml2Quantity_pertime& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Nml2Quantity_pertime& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Nml2Quantity_pertime& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Nml2Quantity_capacitance& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Nml2Quantity_capacitance& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Nml2Quantity_capacitance& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Nml2Quantity_specificCapacitance& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Nml2Quantity_specificCapacitance& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Nml2Quantity_specificCapacitance& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Nml2Quantity_concentration& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Nml2Quantity_concentration& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Nml2Quantity_concentration& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Nml2Quantity_current& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Nml2Quantity_current& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Nml2Quantity_current& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Nml2Quantity_currentDensity& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Nml2Quantity_currentDensity& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Nml2Quantity_currentDensity& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Nml2Quantity_temperature& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Nml2Quantity_temperature& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Nml2Quantity_temperature& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Nml2Quantity_rhoFactor& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Nml2Quantity_rhoFactor& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Nml2Quantity_rhoFactor& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Nml2Quantity_conductancePerVoltage& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Nml2Quantity_conductancePerVoltage& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Nml2Quantity_conductancePerVoltage& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const MetaId& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const MetaId& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const MetaId& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const NeuroLexId& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const NeuroLexId& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const NeuroLexId& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const NonNegativeInteger& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const NonNegativeInteger& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const NonNegativeInteger& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const PositiveInteger& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const PositiveInteger& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const PositiveInteger& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const DoubleGreaterThanZero& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const DoubleGreaterThanZero& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const DoubleGreaterThanZero& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ZeroOrOne& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const ZeroOrOne& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const ZeroOrOne& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Notes& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Notes& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Notes& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Property& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // tag
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "tag",
          e));

      a << i.tag ();
    }

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << i.value ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Annotation& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ComponentType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Property
    //
    for (ComponentType::Property_const_iterator
         b (i.Property ().begin ()), n (i.Property ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Property",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // Parameter
    //
    for (ComponentType::Parameter_const_iterator
         b (i.Parameter ().begin ()), n (i.Parameter ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Parameter",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // Constant
    //
    for (ComponentType::Constant_const_iterator
         b (i.Constant ().begin ()), n (i.Constant ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Constant",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // Exposure
    //
    for (ComponentType::Exposure_const_iterator
         b (i.Exposure ().begin ()), n (i.Exposure ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Exposure",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // Requirement
    //
    for (ComponentType::Requirement_const_iterator
         b (i.Requirement ().begin ()), n (i.Requirement ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Requirement",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // InstanceRequirement
    //
    for (ComponentType::InstanceRequirement_const_iterator
         b (i.InstanceRequirement ().begin ()), n (i.InstanceRequirement ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "InstanceRequirement",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // Dynamics
    //
    for (ComponentType::Dynamics_const_iterator
         b (i.Dynamics ().begin ()), n (i.Dynamics ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Dynamics",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // extends
    //
    if (i.extends ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "extends",
          e));

      a << *i.extends ();
    }

    // description
    //
    if (i.description ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "description",
          e));

      a << *i.description ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Constant& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // dimension
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "dimension",
          e));

      a << i.dimension ();
    }

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << i.value ();
    }

    // description
    //
    if (i.description ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "description",
          e));

      a << *i.description ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Exposure& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // dimension
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "dimension",
          e));

      a << i.dimension ();
    }

    // description
    //
    if (i.description ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "description",
          e));

      a << *i.description ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const NamedDimensionalType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // dimension
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "dimension",
          e));

      a << i.dimension ();
    }

    // description
    //
    if (i.description ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "description",
          e));

      a << *i.description ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const NamedDimensionalVariable& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // dimension
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "dimension",
          e));

      a << i.dimension ();
    }

    // description
    //
    if (i.description ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "description",
          e));

      a << *i.description ();
    }

    // exposure
    //
    if (i.exposure ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "exposure",
          e));

      a << *i.exposure ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Parameter& i)
  {
    e << static_cast< const ::neuroml2::NamedDimensionalType& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const LEMS_Property& i)
  {
    e << static_cast< const ::neuroml2::NamedDimensionalType& > (i);

    // defaultValue
    //
    if (i.defaultValue ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "defaultValue",
          e));

      a << ::xml_schema::as_double(*i.defaultValue ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Requirement& i)
  {
    e << static_cast< const ::neuroml2::NamedDimensionalType& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const InstanceRequirement& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Dynamics& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // StateVariable
    //
    for (Dynamics::StateVariable_const_iterator
         b (i.StateVariable ().begin ()), n (i.StateVariable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "StateVariable",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // DerivedVariable
    //
    for (Dynamics::DerivedVariable_const_iterator
         b (i.DerivedVariable ().begin ()), n (i.DerivedVariable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DerivedVariable",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // ConditionalDerivedVariable
    //
    for (Dynamics::ConditionalDerivedVariable_const_iterator
         b (i.ConditionalDerivedVariable ().begin ()), n (i.ConditionalDerivedVariable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ConditionalDerivedVariable",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // TimeDerivative
    //
    for (Dynamics::TimeDerivative_const_iterator
         b (i.TimeDerivative ().begin ()), n (i.TimeDerivative ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TimeDerivative",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DerivedVariable& i)
  {
    e << static_cast< const ::neuroml2::NamedDimensionalVariable& > (i);

    // value
    //
    if (i.value ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << *i.value ();
    }

    // select
    //
    if (i.select ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "select",
          e));

      a << *i.select ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const StateVariable& i)
  {
    e << static_cast< const ::neuroml2::NamedDimensionalVariable& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ConditionalDerivedVariable& i)
  {
    e << static_cast< const ::neuroml2::NamedDimensionalVariable& > (i);

    // Case
    //
    for (ConditionalDerivedVariable::Case_const_iterator
         b (i.Case ().begin ()), n (i.Case ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Case",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Case& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // condition
    //
    if (i.condition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "condition",
          e));

      a << *i.condition ();
    }

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << i.value ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TimeDerivative& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // variable
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "variable",
          e));

      a << i.variable ();
    }

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << i.value ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ZeroToOne& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const ZeroToOne& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const ZeroToOne& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);
  }

  void
  neuroml (::std::ostream& o,
           const ::neuroml2::NeuroMLDocument& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::neuroml2::neuroml (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  neuroml (::std::ostream& o,
           const ::neuroml2::NeuroMLDocument& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::neuroml2::neuroml (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  neuroml (::std::ostream& o,
           const ::neuroml2::NeuroMLDocument& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::neuroml2::neuroml (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  neuroml (::xercesc::XMLFormatTarget& t,
           const ::neuroml2::NeuroMLDocument& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::neuroml2::neuroml (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  neuroml (::xercesc::XMLFormatTarget& t,
           const ::neuroml2::NeuroMLDocument& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::neuroml2::neuroml (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  neuroml (::xercesc::XMLFormatTarget& t,
           const ::neuroml2::NeuroMLDocument& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::neuroml2::neuroml (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  neuroml (::xercesc::DOMDocument& d,
           const ::neuroml2::NeuroMLDocument& s,
           ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "neuroml" &&
        n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "neuroml",
        "http://www.neuroml.org/schema/neuroml2");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  neuroml (const ::neuroml2::NeuroMLDocument& s,
           const ::xml_schema::namespace_infomap& m,
           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "neuroml",
        "http://www.neuroml.org/schema/neuroml2",
        m, f));

    ::neuroml2::neuroml (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const BaseWithoutId& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // neuroLexId
    //
    if (i.neuroLexId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "neuroLexId",
          e));

      a << *i.neuroLexId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Base& i)
  {
    e << static_cast< const ::neuroml2::BaseWithoutId& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Standalone& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // notes
    //
    if (i.notes ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "notes",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.notes ();
    }

    // property
    //
    for (Standalone::property_const_iterator
         b (i.property ().begin ()), n (i.property ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "property",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // annotation
    //
    if (i.annotation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "annotation",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.annotation ();
    }

    // metaid
    //
    if (i.metaid ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "metaid",
          e));

      a << *i.metaid ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const NeuroMLDocument_base& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // include
    //
    for (NeuroMLDocument_base::include_const_iterator
         b (i.include ().begin ()), n (i.include ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "include",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // extracellularProperties
    //
    for (NeuroMLDocument_base::extracellularProperties_const_iterator
         b (i.extracellularProperties ().begin ()), n (i.extracellularProperties ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "extracellularProperties",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // intracellularProperties
    //
    for (NeuroMLDocument_base::intracellularProperties_const_iterator
         b (i.intracellularProperties ().begin ()), n (i.intracellularProperties ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "intracellularProperties",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // morphology
    //
    for (NeuroMLDocument_base::morphology_const_iterator
         b (i.morphology ().begin ()), n (i.morphology ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "morphology",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // ionChannel
    //
    for (NeuroMLDocument_base::ionChannel_const_iterator
         b (i.ionChannel ().begin ()), n (i.ionChannel ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ionChannel",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // ionChannelHH
    //
    for (NeuroMLDocument_base::ionChannelHH_const_iterator
         b (i.ionChannelHH ().begin ()), n (i.ionChannelHH ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ionChannelHH",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // ionChannelVShift
    //
    for (NeuroMLDocument_base::ionChannelVShift_const_iterator
         b (i.ionChannelVShift ().begin ()), n (i.ionChannelVShift ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ionChannelVShift",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // ionChannelKS
    //
    for (NeuroMLDocument_base::ionChannelKS_const_iterator
         b (i.ionChannelKS ().begin ()), n (i.ionChannelKS ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ionChannelKS",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // decayingPoolConcentrationModel
    //
    for (NeuroMLDocument_base::decayingPoolConcentrationModel_const_iterator
         b (i.decayingPoolConcentrationModel ().begin ()), n (i.decayingPoolConcentrationModel ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "decayingPoolConcentrationModel",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // fixedFactorConcentrationModel
    //
    for (NeuroMLDocument_base::fixedFactorConcentrationModel_const_iterator
         b (i.fixedFactorConcentrationModel ().begin ()), n (i.fixedFactorConcentrationModel ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "fixedFactorConcentrationModel",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // alphaCurrentSynapse
    //
    for (NeuroMLDocument_base::alphaCurrentSynapse_const_iterator
         b (i.alphaCurrentSynapse ().begin ()), n (i.alphaCurrentSynapse ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "alphaCurrentSynapse",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // alphaSynapse
    //
    for (NeuroMLDocument_base::alphaSynapse_const_iterator
         b (i.alphaSynapse ().begin ()), n (i.alphaSynapse ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "alphaSynapse",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // expOneSynapse
    //
    for (NeuroMLDocument_base::expOneSynapse_const_iterator
         b (i.expOneSynapse ().begin ()), n (i.expOneSynapse ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "expOneSynapse",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // expTwoSynapse
    //
    for (NeuroMLDocument_base::expTwoSynapse_const_iterator
         b (i.expTwoSynapse ().begin ()), n (i.expTwoSynapse ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "expTwoSynapse",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // expThreeSynapse
    //
    for (NeuroMLDocument_base::expThreeSynapse_const_iterator
         b (i.expThreeSynapse ().begin ()), n (i.expThreeSynapse ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "expThreeSynapse",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // blockingPlasticSynapse
    //
    for (NeuroMLDocument_base::blockingPlasticSynapse_const_iterator
         b (i.blockingPlasticSynapse ().begin ()), n (i.blockingPlasticSynapse ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "blockingPlasticSynapse",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // doubleSynapse
    //
    for (NeuroMLDocument_base::doubleSynapse_const_iterator
         b (i.doubleSynapse ().begin ()), n (i.doubleSynapse ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "doubleSynapse",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // gapJunction
    //
    for (NeuroMLDocument_base::gapJunction_const_iterator
         b (i.gapJunction ().begin ()), n (i.gapJunction ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "gapJunction",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // silentSynapse
    //
    for (NeuroMLDocument_base::silentSynapse_const_iterator
         b (i.silentSynapse ().begin ()), n (i.silentSynapse ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "silentSynapse",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // linearGradedSynapse
    //
    for (NeuroMLDocument_base::linearGradedSynapse_const_iterator
         b (i.linearGradedSynapse ().begin ()), n (i.linearGradedSynapse ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "linearGradedSynapse",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // gradedSynapse
    //
    for (NeuroMLDocument_base::gradedSynapse_const_iterator
         b (i.gradedSynapse ().begin ()), n (i.gradedSynapse ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "gradedSynapse",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // biophysicalProperties
    //
    for (NeuroMLDocument_base::biophysicalProperties_const_iterator
         b (i.biophysicalProperties ().begin ()), n (i.biophysicalProperties ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "biophysicalProperties",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // cell
    //
    for (NeuroMLDocument_base::cell_const_iterator
         b (i.cell ().begin ()), n (i.cell ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cell",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // cell2CaPools
    //
    for (NeuroMLDocument_base::cell2CaPools_const_iterator
         b (i.cell2CaPools ().begin ()), n (i.cell2CaPools ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cell2CaPools",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // baseCell
    //
    for (NeuroMLDocument_base::baseCell_const_iterator
         b (i.baseCell ().begin ()), n (i.baseCell ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "baseCell",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // iafTauCell
    //
    for (NeuroMLDocument_base::iafTauCell_const_iterator
         b (i.iafTauCell ().begin ()), n (i.iafTauCell ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "iafTauCell",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // iafTauRefCell
    //
    for (NeuroMLDocument_base::iafTauRefCell_const_iterator
         b (i.iafTauRefCell ().begin ()), n (i.iafTauRefCell ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "iafTauRefCell",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // iafCell
    //
    for (NeuroMLDocument_base::iafCell_const_iterator
         b (i.iafCell ().begin ()), n (i.iafCell ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "iafCell",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // iafRefCell
    //
    for (NeuroMLDocument_base::iafRefCell_const_iterator
         b (i.iafRefCell ().begin ()), n (i.iafRefCell ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "iafRefCell",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // izhikevichCell
    //
    for (NeuroMLDocument_base::izhikevichCell_const_iterator
         b (i.izhikevichCell ().begin ()), n (i.izhikevichCell ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "izhikevichCell",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // izhikevich2007Cell
    //
    for (NeuroMLDocument_base::izhikevich2007Cell_const_iterator
         b (i.izhikevich2007Cell ().begin ()), n (i.izhikevich2007Cell ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "izhikevich2007Cell",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // adExIaFCell
    //
    for (NeuroMLDocument_base::adExIaFCell_const_iterator
         b (i.adExIaFCell ().begin ()), n (i.adExIaFCell ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "adExIaFCell",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // fitzHughNagumoCell
    //
    for (NeuroMLDocument_base::fitzHughNagumoCell_const_iterator
         b (i.fitzHughNagumoCell ().begin ()), n (i.fitzHughNagumoCell ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "fitzHughNagumoCell",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // fitzHughNagumo1969Cell
    //
    for (NeuroMLDocument_base::fitzHughNagumo1969Cell_const_iterator
         b (i.fitzHughNagumo1969Cell ().begin ()), n (i.fitzHughNagumo1969Cell ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "fitzHughNagumo1969Cell",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // pinskyRinzelCA3Cell
    //
    for (NeuroMLDocument_base::pinskyRinzelCA3Cell_const_iterator
         b (i.pinskyRinzelCA3Cell ().begin ()), n (i.pinskyRinzelCA3Cell ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "pinskyRinzelCA3Cell",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // pulseGenerator
    //
    for (NeuroMLDocument_base::pulseGenerator_const_iterator
         b (i.pulseGenerator ().begin ()), n (i.pulseGenerator ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "pulseGenerator",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // pulseGeneratorDL
    //
    for (NeuroMLDocument_base::pulseGeneratorDL_const_iterator
         b (i.pulseGeneratorDL ().begin ()), n (i.pulseGeneratorDL ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "pulseGeneratorDL",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // sineGenerator
    //
    for (NeuroMLDocument_base::sineGenerator_const_iterator
         b (i.sineGenerator ().begin ()), n (i.sineGenerator ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sineGenerator",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // sineGeneratorDL
    //
    for (NeuroMLDocument_base::sineGeneratorDL_const_iterator
         b (i.sineGeneratorDL ().begin ()), n (i.sineGeneratorDL ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sineGeneratorDL",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // rampGenerator
    //
    for (NeuroMLDocument_base::rampGenerator_const_iterator
         b (i.rampGenerator ().begin ()), n (i.rampGenerator ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rampGenerator",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // rampGeneratorDL
    //
    for (NeuroMLDocument_base::rampGeneratorDL_const_iterator
         b (i.rampGeneratorDL ().begin ()), n (i.rampGeneratorDL ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rampGeneratorDL",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // compoundInput
    //
    for (NeuroMLDocument_base::compoundInput_const_iterator
         b (i.compoundInput ().begin ()), n (i.compoundInput ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "compoundInput",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // compoundInputDL
    //
    for (NeuroMLDocument_base::compoundInputDL_const_iterator
         b (i.compoundInputDL ().begin ()), n (i.compoundInputDL ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "compoundInputDL",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // voltageClamp
    //
    for (NeuroMLDocument_base::voltageClamp_const_iterator
         b (i.voltageClamp ().begin ()), n (i.voltageClamp ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "voltageClamp",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // voltageClampTriple
    //
    for (NeuroMLDocument_base::voltageClampTriple_const_iterator
         b (i.voltageClampTriple ().begin ()), n (i.voltageClampTriple ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "voltageClampTriple",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // spikeArray
    //
    for (NeuroMLDocument_base::spikeArray_const_iterator
         b (i.spikeArray ().begin ()), n (i.spikeArray ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "spikeArray",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // timedSynapticInput
    //
    for (NeuroMLDocument_base::timedSynapticInput_const_iterator
         b (i.timedSynapticInput ().begin ()), n (i.timedSynapticInput ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timedSynapticInput",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // spikeGenerator
    //
    for (NeuroMLDocument_base::spikeGenerator_const_iterator
         b (i.spikeGenerator ().begin ()), n (i.spikeGenerator ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "spikeGenerator",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // spikeGeneratorRandom
    //
    for (NeuroMLDocument_base::spikeGeneratorRandom_const_iterator
         b (i.spikeGeneratorRandom ().begin ()), n (i.spikeGeneratorRandom ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "spikeGeneratorRandom",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // spikeGeneratorPoisson
    //
    for (NeuroMLDocument_base::spikeGeneratorPoisson_const_iterator
         b (i.spikeGeneratorPoisson ().begin ()), n (i.spikeGeneratorPoisson ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "spikeGeneratorPoisson",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // spikeGeneratorRefPoisson
    //
    for (NeuroMLDocument_base::spikeGeneratorRefPoisson_const_iterator
         b (i.spikeGeneratorRefPoisson ().begin ()), n (i.spikeGeneratorRefPoisson ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "spikeGeneratorRefPoisson",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // poissonFiringSynapse
    //
    for (NeuroMLDocument_base::poissonFiringSynapse_const_iterator
         b (i.poissonFiringSynapse ().begin ()), n (i.poissonFiringSynapse ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "poissonFiringSynapse",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // transientPoissonFiringSynapse
    //
    for (NeuroMLDocument_base::transientPoissonFiringSynapse_const_iterator
         b (i.transientPoissonFiringSynapse ().begin ()), n (i.transientPoissonFiringSynapse ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "transientPoissonFiringSynapse",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // IF_curr_alpha
    //
    for (NeuroMLDocument_base::IF_curr_alpha_const_iterator
         b (i.IF_curr_alpha ().begin ()), n (i.IF_curr_alpha ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "IF_curr_alpha",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // IF_curr_exp
    //
    for (NeuroMLDocument_base::IF_curr_exp_const_iterator
         b (i.IF_curr_exp ().begin ()), n (i.IF_curr_exp ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "IF_curr_exp",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // IF_cond_alpha
    //
    for (NeuroMLDocument_base::IF_cond_alpha_const_iterator
         b (i.IF_cond_alpha ().begin ()), n (i.IF_cond_alpha ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "IF_cond_alpha",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // IF_cond_exp
    //
    for (NeuroMLDocument_base::IF_cond_exp_const_iterator
         b (i.IF_cond_exp ().begin ()), n (i.IF_cond_exp ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "IF_cond_exp",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // EIF_cond_exp_isfa_ista
    //
    for (NeuroMLDocument_base::EIF_cond_exp_isfa_ista_const_iterator
         b (i.EIF_cond_exp_isfa_ista ().begin ()), n (i.EIF_cond_exp_isfa_ista ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EIF_cond_exp_isfa_ista",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // EIF_cond_alpha_isfa_ista
    //
    for (NeuroMLDocument_base::EIF_cond_alpha_isfa_ista_const_iterator
         b (i.EIF_cond_alpha_isfa_ista ().begin ()), n (i.EIF_cond_alpha_isfa_ista ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EIF_cond_alpha_isfa_ista",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // HH_cond_exp
    //
    for (NeuroMLDocument_base::HH_cond_exp_const_iterator
         b (i.HH_cond_exp ().begin ()), n (i.HH_cond_exp ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HH_cond_exp",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // expCondSynapse
    //
    for (NeuroMLDocument_base::expCondSynapse_const_iterator
         b (i.expCondSynapse ().begin ()), n (i.expCondSynapse ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "expCondSynapse",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // alphaCondSynapse
    //
    for (NeuroMLDocument_base::alphaCondSynapse_const_iterator
         b (i.alphaCondSynapse ().begin ()), n (i.alphaCondSynapse ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "alphaCondSynapse",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // expCurrSynapse
    //
    for (NeuroMLDocument_base::expCurrSynapse_const_iterator
         b (i.expCurrSynapse ().begin ()), n (i.expCurrSynapse ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "expCurrSynapse",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // alphaCurrSynapse
    //
    for (NeuroMLDocument_base::alphaCurrSynapse_const_iterator
         b (i.alphaCurrSynapse ().begin ()), n (i.alphaCurrSynapse ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "alphaCurrSynapse",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // SpikeSourcePoisson
    //
    for (NeuroMLDocument_base::SpikeSourcePoisson_const_iterator
         b (i.SpikeSourcePoisson ().begin ()), n (i.SpikeSourcePoisson ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SpikeSourcePoisson",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // network
    //
    for (NeuroMLDocument_base::network_const_iterator
         b (i.network ().begin ()), n (i.network ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "network",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // ComponentType
    //
    for (NeuroMLDocument_base::ComponentType_const_iterator
         b (i.ComponentType ().begin ()), n (i.ComponentType ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ComponentType",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const IncludeType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // href
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "href",
          e));

      a << i.href ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const IonChannelScalable& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // q10ConductanceScaling
    //
    for (IonChannelScalable::q10ConductanceScaling_const_iterator
         b (i.q10ConductanceScaling ().begin ()), n (i.q10ConductanceScaling ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "q10ConductanceScaling",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const IonChannelKS& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // gateKS
    //
    for (IonChannelKS::gateKS_const_iterator
         b (i.gateKS ().begin ()), n (i.gateKS ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "gateKS",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // species
    //
    if (i.species ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "species",
          e));

      a << *i.species ();
    }

    // conductance
    //
    if (i.conductance ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "conductance",
          e));

      a << *i.conductance ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const IonChannel& i)
  {
    e << static_cast< const ::neuroml2::IonChannelScalable& > (i);

    // gate
    //
    for (IonChannel::gate_const_iterator
         b (i.gate ().begin ()), n (i.gate ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "gate",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // gateHHrates
    //
    for (IonChannel::gateHHrates_const_iterator
         b (i.gateHHrates ().begin ()), n (i.gateHHrates ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "gateHHrates",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // gateHHratesTau
    //
    for (IonChannel::gateHHratesTau_const_iterator
         b (i.gateHHratesTau ().begin ()), n (i.gateHHratesTau ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "gateHHratesTau",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // gateHHtauInf
    //
    for (IonChannel::gateHHtauInf_const_iterator
         b (i.gateHHtauInf ().begin ()), n (i.gateHHtauInf ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "gateHHtauInf",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // gateHHratesInf
    //
    for (IonChannel::gateHHratesInf_const_iterator
         b (i.gateHHratesInf ().begin ()), n (i.gateHHratesInf ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "gateHHratesInf",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // gateHHratesTauInf
    //
    for (IonChannel::gateHHratesTauInf_const_iterator
         b (i.gateHHratesTauInf ().begin ()), n (i.gateHHratesTauInf ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "gateHHratesTauInf",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // gateHHInstantaneous
    //
    for (IonChannel::gateHHInstantaneous_const_iterator
         b (i.gateHHInstantaneous ().begin ()), n (i.gateHHInstantaneous ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "gateHHInstantaneous",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // gateFractional
    //
    for (IonChannel::gateFractional_const_iterator
         b (i.gateFractional ().begin ()), n (i.gateFractional ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "gateFractional",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // species
    //
    if (i.species ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "species",
          e));

      a << *i.species ();
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << *i.type ();
    }

    // conductance
    //
    if (i.conductance ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "conductance",
          e));

      a << *i.conductance ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const IonChannelHH& i)
  {
    e << static_cast< const ::neuroml2::IonChannel& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const IonChannelVShift& i)
  {
    e << static_cast< const ::neuroml2::IonChannel& > (i);

    // vShift
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "vShift",
          e));

      a << i.vShift ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const channelTypes& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const channelTypes& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const channelTypes& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Q10ConductanceScaling& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // q10Factor
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "q10Factor",
          e));

      a << i.q10Factor ();
    }

    // experimentalTemp
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "experimentalTemp",
          e));

      a << i.experimentalTemp ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const gateTypes& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const gateTypes& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const gateTypes& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ClosedState& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const OpenState& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ForwardTransition& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // from
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "from",
          e));

      a << i.from ();
    }

    // to
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "to",
          e));

      a << i.to ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReverseTransition& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // from
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "from",
          e));

      a << i.from ();
    }

    // to
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "to",
          e));

      a << i.to ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TauInfTransition& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // steadyState
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "steadyState",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << i.steadyState ();
    }

    // timeCourse
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timeCourse",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << i.timeCourse ();
    }

    // from
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "from",
          e));

      a << i.from ();
    }

    // to
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "to",
          e));

      a << i.to ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GateKS& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // notes
    //
    if (i.notes ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "notes",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.notes ();
    }

    // q10Settings
    //
    if (i.q10Settings ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "q10Settings",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.q10Settings ();
    }

    // closedState
    //
    for (GateKS::closedState_const_iterator
         b (i.closedState ().begin ()), n (i.closedState ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "closedState",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // openState
    //
    for (GateKS::openState_const_iterator
         b (i.openState ().begin ()), n (i.openState ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "openState",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // forwardTransition
    //
    for (GateKS::forwardTransition_const_iterator
         b (i.forwardTransition ().begin ()), n (i.forwardTransition ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "forwardTransition",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // reverseTransition
    //
    for (GateKS::reverseTransition_const_iterator
         b (i.reverseTransition ().begin ()), n (i.reverseTransition ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "reverseTransition",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // tauInfTransition
    //
    for (GateKS::tauInfTransition_const_iterator
         b (i.tauInfTransition ().begin ()), n (i.tauInfTransition ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "tauInfTransition",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // instances
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "instances",
          e));

      a << i.instances ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GateHHUndetermined& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // notes
    //
    if (i.notes ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "notes",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.notes ();
    }

    // q10Settings
    //
    if (i.q10Settings ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "q10Settings",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.q10Settings ();
    }

    // forwardRate
    //
    if (i.forwardRate ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "forwardRate",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.forwardRate ();
    }

    // reverseRate
    //
    if (i.reverseRate ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "reverseRate",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.reverseRate ();
    }

    // timeCourse
    //
    if (i.timeCourse ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timeCourse",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.timeCourse ();
    }

    // steadyState
    //
    if (i.steadyState ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "steadyState",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.steadyState ();
    }

    // subGate
    //
    for (GateHHUndetermined::subGate_const_iterator
         b (i.subGate ().begin ()), n (i.subGate ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "subGate",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // instances
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "instances",
          e));

      a << i.instances ();
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GateHHRates& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // notes
    //
    if (i.notes ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "notes",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.notes ();
    }

    // q10Settings
    //
    if (i.q10Settings ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "q10Settings",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.q10Settings ();
    }

    // forwardRate
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "forwardRate",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << i.forwardRate ();
    }

    // reverseRate
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "reverseRate",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << i.reverseRate ();
    }

    // instances
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "instances",
          e));

      a << i.instances ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GateHHTauInf& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // notes
    //
    if (i.notes ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "notes",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.notes ();
    }

    // q10Settings
    //
    if (i.q10Settings ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "q10Settings",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.q10Settings ();
    }

    // timeCourse
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timeCourse",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << i.timeCourse ();
    }

    // steadyState
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "steadyState",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << i.steadyState ();
    }

    // instances
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "instances",
          e));

      a << i.instances ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GateHHRatesTauInf& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // notes
    //
    if (i.notes ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "notes",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.notes ();
    }

    // q10Settings
    //
    if (i.q10Settings ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "q10Settings",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.q10Settings ();
    }

    // forwardRate
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "forwardRate",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << i.forwardRate ();
    }

    // reverseRate
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "reverseRate",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << i.reverseRate ();
    }

    // timeCourse
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timeCourse",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << i.timeCourse ();
    }

    // steadyState
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "steadyState",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << i.steadyState ();
    }

    // instances
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "instances",
          e));

      a << i.instances ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GateHHRatesTau& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // notes
    //
    if (i.notes ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "notes",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.notes ();
    }

    // q10Settings
    //
    if (i.q10Settings ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "q10Settings",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.q10Settings ();
    }

    // forwardRate
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "forwardRate",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << i.forwardRate ();
    }

    // reverseRate
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "reverseRate",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << i.reverseRate ();
    }

    // timeCourse
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timeCourse",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << i.timeCourse ();
    }

    // instances
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "instances",
          e));

      a << i.instances ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GateHHRatesInf& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // notes
    //
    if (i.notes ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "notes",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.notes ();
    }

    // q10Settings
    //
    if (i.q10Settings ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "q10Settings",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.q10Settings ();
    }

    // forwardRate
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "forwardRate",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << i.forwardRate ();
    }

    // reverseRate
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "reverseRate",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << i.reverseRate ();
    }

    // steadyState
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "steadyState",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << i.steadyState ();
    }

    // instances
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "instances",
          e));

      a << i.instances ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GateHHInstantaneous& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // notes
    //
    if (i.notes ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "notes",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.notes ();
    }

    // steadyState
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "steadyState",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << i.steadyState ();
    }

    // instances
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "instances",
          e));

      a << i.instances ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GateFractional& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // notes
    //
    if (i.notes ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "notes",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.notes ();
    }

    // q10Settings
    //
    if (i.q10Settings ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "q10Settings",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.q10Settings ();
    }

    // subGate
    //
    for (GateFractional::subGate_const_iterator
         b (i.subGate ().begin ()), n (i.subGate ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "subGate",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // instances
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "instances",
          e));

      a << i.instances ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GateFractionalSubgate& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // notes
    //
    if (i.notes ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "notes",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.notes ();
    }

    // q10Settings
    //
    if (i.q10Settings ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "q10Settings",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.q10Settings ();
    }

    // steadyState
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "steadyState",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << i.steadyState ();
    }

    // timeCourse
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timeCourse",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << i.timeCourse ();
    }

    // fractionalConductance
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "fractionalConductance",
          e));

      a << i.fractionalConductance ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Q10Settings& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }

    // fixedQ10
    //
    if (i.fixedQ10 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "fixedQ10",
          e));

      a << *i.fixedQ10 ();
    }

    // q10Factor
    //
    if (i.q10Factor ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "q10Factor",
          e));

      a << *i.q10Factor ();
    }

    // experimentalTemp
    //
    if (i.experimentalTemp ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "experimentalTemp",
          e));

      a << *i.experimentalTemp ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const HHRate& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }

    // rate
    //
    if (i.rate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "rate",
          e));

      a << *i.rate ();
    }

    // midpoint
    //
    if (i.midpoint ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "midpoint",
          e));

      a << *i.midpoint ();
    }

    // scale
    //
    if (i.scale ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "scale",
          e));

      a << *i.scale ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const HHVariable& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }

    // rate
    //
    if (i.rate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "rate",
          e));

      a << *i.rate ();
    }

    // midpoint
    //
    if (i.midpoint ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "midpoint",
          e));

      a << *i.midpoint ();
    }

    // scale
    //
    if (i.scale ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "scale",
          e));

      a << *i.scale ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const HHTime& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }

    // rate
    //
    if (i.rate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "rate",
          e));

      a << *i.rate ();
    }

    // midpoint
    //
    if (i.midpoint ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "midpoint",
          e));

      a << *i.midpoint ();
    }

    // scale
    //
    if (i.scale ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "scale",
          e));

      a << *i.scale ();
    }

    // tau
    //
    if (i.tau ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "tau",
          e));

      a << *i.tau ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DecayingPoolConcentrationModel& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // ion
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ion",
          e));

      a << i.ion ();
    }

    // restingConc
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "restingConc",
          e));

      a << i.restingConc ();
    }

    // decayConstant
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "decayConstant",
          e));

      a << i.decayConstant ();
    }

    // shellThickness
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shellThickness",
          e));

      a << i.shellThickness ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const FixedFactorConcentrationModel& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // ion
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ion",
          e));

      a << i.ion ();
    }

    // restingConc
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "restingConc",
          e));

      a << i.restingConc ();
    }

    // decayConstant
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "decayConstant",
          e));

      a << i.decayConstant ();
    }

    // rho
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "rho",
          e));

      a << i.rho ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BaseSynapse& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const BaseVoltageDepSynapse& i)
  {
    e << static_cast< const ::neuroml2::BaseSynapse& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const BaseCurrentBasedSynapse& i)
  {
    e << static_cast< const ::neuroml2::BaseSynapse& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const BaseConductanceBasedSynapse& i)
  {
    e << static_cast< const ::neuroml2::BaseVoltageDepSynapse& > (i);

    // gbase
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "gbase",
          e));

      a << i.gbase ();
    }

    // erev
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "erev",
          e));

      a << i.erev ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BaseConductanceBasedSynapseTwo& i)
  {
    e << static_cast< const ::neuroml2::BaseVoltageDepSynapse& > (i);

    // gbase1
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "gbase1",
          e));

      a << i.gbase1 ();
    }

    // gbase2
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "gbase2",
          e));

      a << i.gbase2 ();
    }

    // erev
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "erev",
          e));

      a << i.erev ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GapJunction& i)
  {
    e << static_cast< const ::neuroml2::BaseSynapse& > (i);

    // conductance
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "conductance",
          e));

      a << i.conductance ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SilentSynapse& i)
  {
    e << static_cast< const ::neuroml2::BaseSynapse& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const LinearGradedSynapse& i)
  {
    e << static_cast< const ::neuroml2::BaseSynapse& > (i);

    // conductance
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "conductance",
          e));

      a << i.conductance ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GradedSynapse& i)
  {
    e << static_cast< const ::neuroml2::BaseSynapse& > (i);

    // conductance
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "conductance",
          e));

      a << i.conductance ();
    }

    // delta
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "delta",
          e));

      a << i.delta ();
    }

    // Vth
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Vth",
          e));

      a << i.Vth ();
    }

    // k
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "k",
          e));

      a << i.k ();
    }

    // erev
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "erev",
          e));

      a << i.erev ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AlphaCurrentSynapse& i)
  {
    e << static_cast< const ::neuroml2::BaseCurrentBasedSynapse& > (i);

    // tau
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "tau",
          e));

      a << i.tau ();
    }

    // ibase
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ibase",
          e));

      a << i.ibase ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AlphaSynapse& i)
  {
    e << static_cast< const ::neuroml2::BaseConductanceBasedSynapse& > (i);

    // tau
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "tau",
          e));

      a << i.tau ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ExpOneSynapse& i)
  {
    e << static_cast< const ::neuroml2::BaseConductanceBasedSynapse& > (i);

    // tauDecay
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "tauDecay",
          e));

      a << i.tauDecay ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ExpTwoSynapse& i)
  {
    e << static_cast< const ::neuroml2::BaseConductanceBasedSynapse& > (i);

    // tauDecay
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "tauDecay",
          e));

      a << i.tauDecay ();
    }

    // tauRise
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "tauRise",
          e));

      a << i.tauRise ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ExpThreeSynapse& i)
  {
    e << static_cast< const ::neuroml2::BaseConductanceBasedSynapseTwo& > (i);

    // tauDecay1
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "tauDecay1",
          e));

      a << i.tauDecay1 ();
    }

    // tauDecay2
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "tauDecay2",
          e));

      a << i.tauDecay2 ();
    }

    // tauRise
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "tauRise",
          e));

      a << i.tauRise ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DoubleSynapse& i)
  {
    e << static_cast< const ::neuroml2::BaseVoltageDepSynapse& > (i);

    // synapse1
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "synapse1",
          e));

      a << i.synapse1 ();
    }

    // synapse2
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "synapse2",
          e));

      a << i.synapse2 ();
    }

    // synapse1Path
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "synapse1Path",
          e));

      a << i.synapse1Path ();
    }

    // synapse2Path
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "synapse2Path",
          e));

      a << i.synapse2Path ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BlockingPlasticSynapse& i)
  {
    e << static_cast< const ::neuroml2::ExpTwoSynapse& > (i);

    // plasticityMechanism
    //
    if (i.plasticityMechanism ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "plasticityMechanism",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.plasticityMechanism ();
    }

    // blockMechanism
    //
    if (i.blockMechanism ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "blockMechanism",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.blockMechanism ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BlockTypes& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const BlockTypes& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const BlockTypes& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const BlockMechanism& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }

    // species
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "species",
          e));

      a << i.species ();
    }

    // blockConcentration
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "blockConcentration",
          e));

      a << i.blockConcentration ();
    }

    // scalingConc
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "scalingConc",
          e));

      a << i.scalingConc ();
    }

    // scalingVolt
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "scalingVolt",
          e));

      a << i.scalingVolt ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PlasticityTypes& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const PlasticityTypes& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const PlasticityTypes& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const PlasticityMechanism& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }

    // initReleaseProb
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "initReleaseProb",
          e));

      a << i.initReleaseProb ();
    }

    // tauRec
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "tauRec",
          e));

      a << i.tauRec ();
    }

    // tauFac
    //
    if (i.tauFac ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "tauFac",
          e));

      a << *i.tauFac ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BaseCell& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const IafTauCell& i)
  {
    e << static_cast< const ::neuroml2::BaseCell& > (i);

    // leakReversal
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "leakReversal",
          e));

      a << i.leakReversal ();
    }

    // thresh
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "thresh",
          e));

      a << i.thresh ();
    }

    // reset
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "reset",
          e));

      a << i.reset ();
    }

    // tau
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "tau",
          e));

      a << i.tau ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const IafTauRefCell& i)
  {
    e << static_cast< const ::neuroml2::IafTauCell& > (i);

    // refract
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "refract",
          e));

      a << i.refract ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const IafCell& i)
  {
    e << static_cast< const ::neuroml2::BaseCell& > (i);

    // leakReversal
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "leakReversal",
          e));

      a << i.leakReversal ();
    }

    // thresh
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "thresh",
          e));

      a << i.thresh ();
    }

    // reset
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "reset",
          e));

      a << i.reset ();
    }

    // C
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "C",
          e));

      a << i.C ();
    }

    // leakConductance
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "leakConductance",
          e));

      a << i.leakConductance ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const IafRefCell& i)
  {
    e << static_cast< const ::neuroml2::IafCell& > (i);

    // refract
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "refract",
          e));

      a << i.refract ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const IzhikevichCell& i)
  {
    e << static_cast< const ::neuroml2::BaseCell& > (i);

    // v0
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "v0",
          e));

      a << i.v0 ();
    }

    // thresh
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "thresh",
          e));

      a << i.thresh ();
    }

    // a
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "a",
          e));

      a << i.a ();
    }

    // b
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "b",
          e));

      a << i.b ();
    }

    // c
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "c",
          e));

      a << i.c ();
    }

    // d
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "d",
          e));

      a << i.d ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BaseCellMembPotCap& i)
  {
    e << static_cast< const ::neuroml2::BaseCell& > (i);

    // C
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "C",
          e));

      a << i.C ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Izhikevich2007Cell& i)
  {
    e << static_cast< const ::neuroml2::BaseCellMembPotCap& > (i);

    // v0
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "v0",
          e));

      a << i.v0 ();
    }

    // k
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "k",
          e));

      a << i.k ();
    }

    // vr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "vr",
          e));

      a << i.vr ();
    }

    // vt
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "vt",
          e));

      a << i.vt ();
    }

    // vpeak
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "vpeak",
          e));

      a << i.vpeak ();
    }

    // a
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "a",
          e));

      a << i.a ();
    }

    // b
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "b",
          e));

      a << i.b ();
    }

    // c
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "c",
          e));

      a << i.c ();
    }

    // d
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "d",
          e));

      a << i.d ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AdExIaFCell& i)
  {
    e << static_cast< const ::neuroml2::BaseCellMembPotCap& > (i);

    // gL
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "gL",
          e));

      a << i.gL ();
    }

    // EL
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "EL",
          e));

      a << i.EL ();
    }

    // reset
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "reset",
          e));

      a << i.reset ();
    }

    // VT
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "VT",
          e));

      a << i.VT ();
    }

    // thresh
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "thresh",
          e));

      a << i.thresh ();
    }

    // delT
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "delT",
          e));

      a << i.delT ();
    }

    // tauw
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "tauw",
          e));

      a << i.tauw ();
    }

    // refract
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "refract",
          e));

      a << i.refract ();
    }

    // a
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "a",
          e));

      a << i.a ();
    }

    // b
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "b",
          e));

      a << i.b ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const FitzHughNagumoCell& i)
  {
    e << static_cast< const ::neuroml2::BaseCell& > (i);

    // I
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "I",
          e));

      a << i.I ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const FitzHughNagumo1969Cell& i)
  {
    e << static_cast< const ::neuroml2::BaseCell& > (i);

    // a
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "a",
          e));

      a << i.a ();
    }

    // b
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "b",
          e));

      a << i.b ();
    }

    // I
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "I",
          e));

      a << i.I ();
    }

    // phi
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "phi",
          e));

      a << i.phi ();
    }

    // V0
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "V0",
          e));

      a << i.V0 ();
    }

    // W0
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "W0",
          e));

      a << i.W0 ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PinskyRinzelCA3Cell& i)
  {
    e << static_cast< const ::neuroml2::BaseCell& > (i);

    // iSoma
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "iSoma",
          e));

      a << i.iSoma ();
    }

    // iDend
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "iDend",
          e));

      a << i.iDend ();
    }

    // gc
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "gc",
          e));

      a << i.gc ();
    }

    // gLs
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "gLs",
          e));

      a << i.gLs ();
    }

    // gLd
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "gLd",
          e));

      a << i.gLd ();
    }

    // gNa
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "gNa",
          e));

      a << i.gNa ();
    }

    // gKdr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "gKdr",
          e));

      a << i.gKdr ();
    }

    // gCa
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "gCa",
          e));

      a << i.gCa ();
    }

    // gKahp
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "gKahp",
          e));

      a << i.gKahp ();
    }

    // gKC
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "gKC",
          e));

      a << i.gKC ();
    }

    // gNmda
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "gNmda",
          e));

      a << i.gNmda ();
    }

    // gAmpa
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "gAmpa",
          e));

      a << i.gAmpa ();
    }

    // eNa
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eNa",
          e));

      a << i.eNa ();
    }

    // eCa
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eCa",
          e));

      a << i.eCa ();
    }

    // eK
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eK",
          e));

      a << i.eK ();
    }

    // eL
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eL",
          e));

      a << i.eL ();
    }

    // qd0
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "qd0",
          e));

      a << i.qd0 ();
    }

    // pp
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "pp",
          e));

      a << i.pp ();
    }

    // alphac
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "alphac",
          e));

      a << i.alphac ();
    }

    // betac
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "betac",
          e));

      a << i.betac ();
    }

    // cm
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "cm",
          e));

      a << i.cm ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Cell& i)
  {
    e << static_cast< const ::neuroml2::BaseCell& > (i);

    // morphology
    //
    if (i.morphology ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "morphology",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.morphology ();
    }

    // biophysicalProperties
    //
    if (i.biophysicalProperties ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "biophysicalProperties",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.biophysicalProperties ();
    }

    // morphology
    //
    if (i.morphology1 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "morphology",
          e));

      a << *i.morphology1 ();
    }

    // biophysicalProperties
    //
    if (i.biophysicalProperties1 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "biophysicalProperties",
          e));

      a << *i.biophysicalProperties1 ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Cell2CaPools& i)
  {
    e << static_cast< const ::neuroml2::Cell& > (i);

    // biophysicalProperties2CaPools
    //
    if (i.biophysicalProperties2CaPools ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "biophysicalProperties2CaPools",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.biophysicalProperties2CaPools ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Morphology_base& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // segment
    //
    for (Morphology_base::segment_const_iterator
         b (i.segment ().begin ()), n (i.segment ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "segment",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // segmentGroup
    //
    for (Morphology_base::segmentGroup_const_iterator
         b (i.segmentGroup ().begin ()), n (i.segmentGroup ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "segmentGroup",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BaseNonNegativeIntegerId& i)
  {
    e << static_cast< const ::neuroml2::BaseWithoutId& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Segment_base& i)
  {
    e << static_cast< const ::neuroml2::BaseNonNegativeIntegerId& > (i);

    // parent
    //
    if (i.parent ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parent",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.parent ();
    }

    // proximal
    //
    if (i.proximal ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "proximal",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.proximal ();
    }

    // distal
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "distal",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << i.distal ();
    }

    // name
    //
    if (i.name ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.name ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SegmentParent& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // segment
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "segment",
          e));

      a << i.segment ();
    }

    // fractionAlong
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "fractionAlong",
          e));

      a << i.fractionAlong ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Point3DWithDiam& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // x
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "x",
          e));

      a << ::xml_schema::as_double(i.x ());
    }

    // y
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "y",
          e));

      a << ::xml_schema::as_double(i.y ());
    }

    // z
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "z",
          e));

      a << ::xml_schema::as_double(i.z ());
    }

    // diameter
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "diameter",
          e));

      a << i.diameter ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SegmentGroup& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // notes
    //
    if (i.notes ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "notes",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.notes ();
    }

    // property
    //
    for (SegmentGroup::property_const_iterator
         b (i.property ().begin ()), n (i.property ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "property",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // annotation
    //
    if (i.annotation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "annotation",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.annotation ();
    }

    // member
    //
    for (SegmentGroup::member_const_iterator
         b (i.member ().begin ()), n (i.member ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "member",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // include
    //
    for (SegmentGroup::include_const_iterator
         b (i.include ().begin ()), n (i.include ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "include",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // path
    //
    for (SegmentGroup::path_const_iterator
         b (i.path ().begin ()), n (i.path ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "path",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // subTree
    //
    for (SegmentGroup::subTree_const_iterator
         b (i.subTree ().begin ()), n (i.subTree ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "subTree",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // inhomogeneousParameter
    //
    for (SegmentGroup::inhomogeneousParameter_const_iterator
         b (i.inhomogeneousParameter ().begin ()), n (i.inhomogeneousParameter ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "inhomogeneousParameter",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InhomogeneousParameter& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // proximal
    //
    if (i.proximal ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "proximal",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.proximal ();
    }

    // distal
    //
    if (i.distal ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "distal",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.distal ();
    }

    // variable
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "variable",
          e));

      a << i.variable ();
    }

    // metric
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "metric",
          e));

      a << i.metric ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Metric& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Metric& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Metric& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ProximalDetails& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // translationStart
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "translationStart",
          e));

      a << ::xml_schema::as_double(i.translationStart ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DistalDetails& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // normalizationEnd
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "normalizationEnd",
          e));

      a << ::xml_schema::as_double(i.normalizationEnd ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Member& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // segment
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "segment",
          e));

      a << i.segment ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Include& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // segmentGroup
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "segmentGroup",
          e));

      a << i.segmentGroup ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Path& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // from
    //
    if (i.from ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "from",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.from ();
    }

    // to
    //
    if (i.to ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "to",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.to ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SubTree& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // from
    //
    if (i.from ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "from",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.from ();
    }

    // to
    //
    if (i.to ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "to",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.to ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SegmentEndPoint& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // segment
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "segment",
          e));

      a << i.segment ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BiophysicalProperties& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // membraneProperties
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "membraneProperties",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << i.membraneProperties ();
    }

    // intracellularProperties
    //
    if (i.intracellularProperties ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "intracellularProperties",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.intracellularProperties ();
    }

    // extracellularProperties
    //
    if (i.extracellularProperties ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "extracellularProperties",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.extracellularProperties ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BiophysicalProperties2CaPools& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // membraneProperties2CaPools
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "membraneProperties2CaPools",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << i.membraneProperties2CaPools ();
    }

    // intracellularProperties2CaPools
    //
    if (i.intracellularProperties2CaPools ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "intracellularProperties2CaPools",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.intracellularProperties2CaPools ();
    }

    // extracellularProperties
    //
    if (i.extracellularProperties ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "extracellularProperties",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.extracellularProperties ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MembraneProperties& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // channelPopulation
    //
    for (MembraneProperties::channelPopulation_const_iterator
         b (i.channelPopulation ().begin ()), n (i.channelPopulation ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "channelPopulation",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // channelDensity
    //
    for (MembraneProperties::channelDensity_const_iterator
         b (i.channelDensity ().begin ()), n (i.channelDensity ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "channelDensity",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // channelDensityVShift
    //
    for (MembraneProperties::channelDensityVShift_const_iterator
         b (i.channelDensityVShift ().begin ()), n (i.channelDensityVShift ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "channelDensityVShift",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // channelDensityNernst
    //
    for (MembraneProperties::channelDensityNernst_const_iterator
         b (i.channelDensityNernst ().begin ()), n (i.channelDensityNernst ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "channelDensityNernst",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // channelDensityGHK
    //
    for (MembraneProperties::channelDensityGHK_const_iterator
         b (i.channelDensityGHK ().begin ()), n (i.channelDensityGHK ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "channelDensityGHK",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // channelDensityGHK2
    //
    for (MembraneProperties::channelDensityGHK2_const_iterator
         b (i.channelDensityGHK2 ().begin ()), n (i.channelDensityGHK2 ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "channelDensityGHK2",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // channelDensityNonUniform
    //
    for (MembraneProperties::channelDensityNonUniform_const_iterator
         b (i.channelDensityNonUniform ().begin ()), n (i.channelDensityNonUniform ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "channelDensityNonUniform",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // channelDensityNonUniformNernst
    //
    for (MembraneProperties::channelDensityNonUniformNernst_const_iterator
         b (i.channelDensityNonUniformNernst ().begin ()), n (i.channelDensityNonUniformNernst ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "channelDensityNonUniformNernst",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // channelDensityNonUniformGHK
    //
    for (MembraneProperties::channelDensityNonUniformGHK_const_iterator
         b (i.channelDensityNonUniformGHK ().begin ()), n (i.channelDensityNonUniformGHK ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "channelDensityNonUniformGHK",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // spikeThresh
    //
    for (MembraneProperties::spikeThresh_const_iterator
         b (i.spikeThresh ().begin ()), n (i.spikeThresh ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "spikeThresh",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // specificCapacitance
    //
    for (MembraneProperties::specificCapacitance_const_iterator
         b (i.specificCapacitance ().begin ()), n (i.specificCapacitance ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "specificCapacitance",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // initMembPotential
    //
    for (MembraneProperties::initMembPotential_const_iterator
         b (i.initMembPotential ().begin ()), n (i.initMembPotential ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "initMembPotential",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MembraneProperties2CaPools& i)
  {
    e << static_cast< const ::neuroml2::MembraneProperties& > (i);

    // channelDensityNernstCa2
    //
    for (MembraneProperties2CaPools::channelDensityNernstCa2_const_iterator
         b (i.channelDensityNernstCa2 ().begin ()), n (i.channelDensityNernstCa2 ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "channelDensityNernstCa2",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpikeThresh& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << i.value ();
    }

    // segmentGroup
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "segmentGroup",
          e));

      a << i.segmentGroup ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpecificCapacitance& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << i.value ();
    }

    // segmentGroup
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "segmentGroup",
          e));

      a << i.segmentGroup ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InitMembPotential& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << i.value ();
    }

    // segmentGroup
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "segmentGroup",
          e));

      a << i.segmentGroup ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Resistivity& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << i.value ();
    }

    // segmentGroup
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "segmentGroup",
          e));

      a << i.segmentGroup ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ChannelPopulation& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // variableParameter
    //
    for (ChannelPopulation::variableParameter_const_iterator
         b (i.variableParameter ().begin ()), n (i.variableParameter ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variableParameter",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // ionChannel
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ionChannel",
          e));

      a << i.ionChannel ();
    }

    // number
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "number",
          e));

      a << i.number ();
    }

    // erev
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "erev",
          e));

      a << i.erev ();
    }

    // segmentGroup
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "segmentGroup",
          e));

      a << i.segmentGroup ();
    }

    // segment
    //
    if (i.segment ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "segment",
          e));

      a << *i.segment ();
    }

    // ion
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ion",
          e));

      a << i.ion ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ChannelDensityNonUniform& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // variableParameter
    //
    for (ChannelDensityNonUniform::variableParameter_const_iterator
         b (i.variableParameter ().begin ()), n (i.variableParameter ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variableParameter",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // ionChannel
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ionChannel",
          e));

      a << i.ionChannel ();
    }

    // erev
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "erev",
          e));

      a << i.erev ();
    }

    // ion
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ion",
          e));

      a << i.ion ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ChannelDensityNonUniformNernst& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // variableParameter
    //
    for (ChannelDensityNonUniformNernst::variableParameter_const_iterator
         b (i.variableParameter ().begin ()), n (i.variableParameter ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variableParameter",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // ionChannel
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ionChannel",
          e));

      a << i.ionChannel ();
    }

    // ion
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ion",
          e));

      a << i.ion ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ChannelDensityNonUniformGHK& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // variableParameter
    //
    for (ChannelDensityNonUniformGHK::variableParameter_const_iterator
         b (i.variableParameter ().begin ()), n (i.variableParameter ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variableParameter",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // ionChannel
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ionChannel",
          e));

      a << i.ionChannel ();
    }

    // ion
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ion",
          e));

      a << i.ion ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ChannelDensity& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // variableParameter
    //
    for (ChannelDensity::variableParameter_const_iterator
         b (i.variableParameter ().begin ()), n (i.variableParameter ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variableParameter",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // ionChannel
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ionChannel",
          e));

      a << i.ionChannel ();
    }

    // condDensity
    //
    if (i.condDensity ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "condDensity",
          e));

      a << *i.condDensity ();
    }

    // erev
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "erev",
          e));

      a << i.erev ();
    }

    // segmentGroup
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "segmentGroup",
          e));

      a << i.segmentGroup ();
    }

    // segment
    //
    if (i.segment ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "segment",
          e));

      a << *i.segment ();
    }

    // ion
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ion",
          e));

      a << i.ion ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ChannelDensityVShift& i)
  {
    e << static_cast< const ::neuroml2::ChannelDensity& > (i);

    // vShift
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "vShift",
          e));

      a << i.vShift ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ChannelDensityNernst& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // variableParameter
    //
    for (ChannelDensityNernst::variableParameter_const_iterator
         b (i.variableParameter ().begin ()), n (i.variableParameter ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variableParameter",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // ionChannel
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ionChannel",
          e));

      a << i.ionChannel ();
    }

    // condDensity
    //
    if (i.condDensity ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "condDensity",
          e));

      a << *i.condDensity ();
    }

    // segmentGroup
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "segmentGroup",
          e));

      a << i.segmentGroup ();
    }

    // segment
    //
    if (i.segment ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "segment",
          e));

      a << *i.segment ();
    }

    // ion
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ion",
          e));

      a << i.ion ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ChannelDensityNernstCa2& i)
  {
    e << static_cast< const ::neuroml2::ChannelDensityNernst& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ChannelDensityGHK& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // ionChannel
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ionChannel",
          e));

      a << i.ionChannel ();
    }

    // permeability
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "permeability",
          e));

      a << i.permeability ();
    }

    // segmentGroup
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "segmentGroup",
          e));

      a << i.segmentGroup ();
    }

    // segment
    //
    if (i.segment ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "segment",
          e));

      a << *i.segment ();
    }

    // ion
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ion",
          e));

      a << i.ion ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ChannelDensityGHK2& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // ionChannel
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ionChannel",
          e));

      a << i.ionChannel ();
    }

    // condDensity
    //
    if (i.condDensity ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "condDensity",
          e));

      a << *i.condDensity ();
    }

    // segmentGroup
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "segmentGroup",
          e));

      a << i.segmentGroup ();
    }

    // segment
    //
    if (i.segment ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "segment",
          e));

      a << *i.segment ();
    }

    // ion
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ion",
          e));

      a << i.ion ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VariableParameter& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // inhomogeneousValue
    //
    if (i.inhomogeneousValue ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "inhomogeneousValue",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.inhomogeneousValue ();
    }

    // parameter
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "parameter",
          e));

      a << i.parameter ();
    }

    // segmentGroup
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "segmentGroup",
          e));

      a << i.segmentGroup ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InhomogeneousValue& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // inhomogeneousParameter
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "inhomogeneousParameter",
          e));

      a << i.inhomogeneousParameter ();
    }

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << i.value ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Species& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // concentrationModel
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "concentrationModel",
          e));

      a << i.concentrationModel ();
    }

    // ion
    //
    if (i.ion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ion",
          e));

      a << *i.ion ();
    }

    // initialConcentration
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "initialConcentration",
          e));

      a << i.initialConcentration ();
    }

    // initialExtConcentration
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "initialExtConcentration",
          e));

      a << i.initialExtConcentration ();
    }

    // segmentGroup
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "segmentGroup",
          e));

      a << i.segmentGroup ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ConcentrationModel_D& i)
  {
    e << static_cast< const ::neuroml2::DecayingPoolConcentrationModel& > (i);

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const IntracellularProperties& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // species
    //
    for (IntracellularProperties::species_const_iterator
         b (i.species ().begin ()), n (i.species ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "species",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // resistivity
    //
    for (IntracellularProperties::resistivity_const_iterator
         b (i.resistivity ().begin ()), n (i.resistivity ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "resistivity",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const IntracellularProperties2CaPools& i)
  {
    e << static_cast< const ::neuroml2::IntracellularProperties& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ExtracellularProperties& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // species
    //
    for (ExtracellularProperties::species_const_iterator
         b (i.species ().begin ()), n (i.species ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "species",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ExtracellularPropertiesLocal& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // species
    //
    for (ExtracellularPropertiesLocal::species_const_iterator
         b (i.species ().begin ()), n (i.species ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "species",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReactionScheme& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // source
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "source",
          e));

      a << i.source ();
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PulseGenerator& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // delay
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "delay",
          e));

      a << i.delay ();
    }

    // duration
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "duration",
          e));

      a << i.duration ();
    }

    // amplitude
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "amplitude",
          e));

      a << i.amplitude ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PulseGeneratorDL& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // delay
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "delay",
          e));

      a << i.delay ();
    }

    // duration
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "duration",
          e));

      a << i.duration ();
    }

    // amplitude
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "amplitude",
          e));

      a << i.amplitude ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SineGenerator& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // delay
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "delay",
          e));

      a << i.delay ();
    }

    // phase
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "phase",
          e));

      a << i.phase ();
    }

    // duration
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "duration",
          e));

      a << i.duration ();
    }

    // amplitude
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "amplitude",
          e));

      a << i.amplitude ();
    }

    // period
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "period",
          e));

      a << i.period ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SineGeneratorDL& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // delay
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "delay",
          e));

      a << i.delay ();
    }

    // phase
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "phase",
          e));

      a << i.phase ();
    }

    // duration
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "duration",
          e));

      a << i.duration ();
    }

    // amplitude
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "amplitude",
          e));

      a << i.amplitude ();
    }

    // period
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "period",
          e));

      a << i.period ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RampGenerator& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // delay
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "delay",
          e));

      a << i.delay ();
    }

    // duration
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "duration",
          e));

      a << i.duration ();
    }

    // startAmplitude
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startAmplitude",
          e));

      a << i.startAmplitude ();
    }

    // finishAmplitude
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "finishAmplitude",
          e));

      a << i.finishAmplitude ();
    }

    // baselineAmplitude
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "baselineAmplitude",
          e));

      a << i.baselineAmplitude ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RampGeneratorDL& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // delay
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "delay",
          e));

      a << i.delay ();
    }

    // duration
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "duration",
          e));

      a << i.duration ();
    }

    // startAmplitude
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startAmplitude",
          e));

      a << i.startAmplitude ();
    }

    // finishAmplitude
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "finishAmplitude",
          e));

      a << i.finishAmplitude ();
    }

    // baselineAmplitude
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "baselineAmplitude",
          e));

      a << i.baselineAmplitude ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CompoundInput& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // pulseGenerator
    //
    for (CompoundInput::pulseGenerator_const_iterator
         b (i.pulseGenerator ().begin ()), n (i.pulseGenerator ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "pulseGenerator",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // sineGenerator
    //
    for (CompoundInput::sineGenerator_const_iterator
         b (i.sineGenerator ().begin ()), n (i.sineGenerator ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sineGenerator",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // rampGenerator
    //
    for (CompoundInput::rampGenerator_const_iterator
         b (i.rampGenerator ().begin ()), n (i.rampGenerator ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rampGenerator",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CompoundInputDL& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // pulseGeneratorDL
    //
    for (CompoundInputDL::pulseGeneratorDL_const_iterator
         b (i.pulseGeneratorDL ().begin ()), n (i.pulseGeneratorDL ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "pulseGeneratorDL",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // sineGeneratorDL
    //
    for (CompoundInputDL::sineGeneratorDL_const_iterator
         b (i.sineGeneratorDL ().begin ()), n (i.sineGeneratorDL ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sineGeneratorDL",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // rampGeneratorDL
    //
    for (CompoundInputDL::rampGeneratorDL_const_iterator
         b (i.rampGeneratorDL ().begin ()), n (i.rampGeneratorDL ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rampGeneratorDL",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VoltageClamp& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // delay
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "delay",
          e));

      a << i.delay ();
    }

    // duration
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "duration",
          e));

      a << i.duration ();
    }

    // targetVoltage
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "targetVoltage",
          e));

      a << i.targetVoltage ();
    }

    // simpleSeriesResistance
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "simpleSeriesResistance",
          e));

      a << i.simpleSeriesResistance ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VoltageClampTriple& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // active
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "active",
          e));

      a << i.active ();
    }

    // delay
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "delay",
          e));

      a << i.delay ();
    }

    // duration
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "duration",
          e));

      a << i.duration ();
    }

    // conditioningVoltage
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "conditioningVoltage",
          e));

      a << i.conditioningVoltage ();
    }

    // testingVoltage
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "testingVoltage",
          e));

      a << i.testingVoltage ();
    }

    // returnVoltage
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "returnVoltage",
          e));

      a << i.returnVoltage ();
    }

    // simpleSeriesResistance
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "simpleSeriesResistance",
          e));

      a << i.simpleSeriesResistance ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Spike& i)
  {
    e << static_cast< const ::neuroml2::BaseNonNegativeIntegerId& > (i);

    // time
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "time",
          e));

      a << i.time ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpikeArray& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // spike
    //
    for (SpikeArray::spike_const_iterator
         b (i.spike ().begin ()), n (i.spike ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "spike",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TimedSynapticInput& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // spike
    //
    for (TimedSynapticInput::spike_const_iterator
         b (i.spike ().begin ()), n (i.spike ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "spike",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // synapse
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "synapse",
          e));

      a << i.synapse ();
    }

    // spikeTarget
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "spikeTarget",
          e));

      a << i.spikeTarget ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpikeGenerator& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // period
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "period",
          e));

      a << i.period ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpikeGeneratorRandom& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // maxISI
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxISI",
          e));

      a << i.maxISI ();
    }

    // minISI
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "minISI",
          e));

      a << i.minISI ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpikeGeneratorPoisson& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // averageRate
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "averageRate",
          e));

      a << i.averageRate ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpikeGeneratorRefPoisson& i)
  {
    e << static_cast< const ::neuroml2::SpikeGeneratorPoisson& > (i);

    // minimumISI
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "minimumISI",
          e));

      a << i.minimumISI ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PoissonFiringSynapse& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // averageRate
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "averageRate",
          e));

      a << i.averageRate ();
    }

    // synapse
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "synapse",
          e));

      a << i.synapse ();
    }

    // spikeTarget
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "spikeTarget",
          e));

      a << i.spikeTarget ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TransientPoissonFiringSynapse& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // averageRate
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "averageRate",
          e));

      a << i.averageRate ();
    }

    // delay
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "delay",
          e));

      a << i.delay ();
    }

    // duration
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "duration",
          e));

      a << i.duration ();
    }

    // synapse
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "synapse",
          e));

      a << i.synapse ();
    }

    // spikeTarget
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "spikeTarget",
          e));

      a << i.spikeTarget ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Network& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // space
    //
    for (Network::space_const_iterator
         b (i.space ().begin ()), n (i.space ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "space",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // region
    //
    for (Network::region_const_iterator
         b (i.region ().begin ()), n (i.region ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "region",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // extracellularProperties
    //
    for (Network::extracellularProperties_const_iterator
         b (i.extracellularProperties ().begin ()), n (i.extracellularProperties ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "extracellularProperties",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // population
    //
    for (Network::population_const_iterator
         b (i.population ().begin ()), n (i.population ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "population",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // cellSet
    //
    for (Network::cellSet_const_iterator
         b (i.cellSet ().begin ()), n (i.cellSet ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cellSet",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // synapticConnection
    //
    for (Network::synapticConnection_const_iterator
         b (i.synapticConnection ().begin ()), n (i.synapticConnection ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "synapticConnection",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // projection
    //
    for (Network::projection_const_iterator
         b (i.projection ().begin ()), n (i.projection ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "projection",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // electricalProjection
    //
    for (Network::electricalProjection_const_iterator
         b (i.electricalProjection ().begin ()), n (i.electricalProjection ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "electricalProjection",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // continuousProjection
    //
    for (Network::continuousProjection_const_iterator
         b (i.continuousProjection ().begin ()), n (i.continuousProjection ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "continuousProjection",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // explicitInput
    //
    for (Network::explicitInput_const_iterator
         b (i.explicitInput ().begin ()), n (i.explicitInput ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "explicitInput",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // inputList
    //
    for (Network::inputList_const_iterator
         b (i.inputList ().begin ()), n (i.inputList ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "inputList",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << *i.type ();
    }

    // temperature
    //
    if (i.temperature ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "temperature",
          e));

      a << *i.temperature ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const networkTypes& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const networkTypes& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const networkTypes& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Space& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // structure
    //
    if (i.structure ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "structure",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.structure ();
    }

    // basedOn
    //
    if (i.basedOn ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "basedOn",
          e));

      a << *i.basedOn ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpaceStructure& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // xSpacing
    //
    if (i.xSpacing ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "xSpacing",
          e));

      a << *i.xSpacing ();
    }

    // ySpacing
    //
    if (i.ySpacing ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ySpacing",
          e));

      a << *i.ySpacing ();
    }

    // zSpacing
    //
    if (i.zSpacing ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "zSpacing",
          e));

      a << *i.zSpacing ();
    }

    // xStart
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "xStart",
          e));

      a << i.xStart ();
    }

    // yStart
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "yStart",
          e));

      a << i.yStart ();
    }

    // zStart
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "zStart",
          e));

      a << i.zStart ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const allowedSpaces& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const allowedSpaces& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const allowedSpaces& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Region& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // space
    //
    if (i.space ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "space",
          e));

      a << *i.space ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Population& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // layout
    //
    if (i.layout ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "layout",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.layout ();
    }

    // instance
    //
    for (Population::instance_const_iterator
         b (i.instance ().begin ()), n (i.instance ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "instance",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // component
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "component",
          e));

      a << i.component ();
    }

    // size
    //
    if (i.size ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "size",
          e));

      a << *i.size ();
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << *i.type ();
    }

    // extracellularProperties
    //
    if (i.extracellularProperties ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "extracellularProperties",
          e));

      a << *i.extracellularProperties ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const populationTypes& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const populationTypes& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const populationTypes& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Layout& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // random
    //
    if (i.random ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "random",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.random ();
    }

    // grid
    //
    if (i.grid ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "grid",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.grid ();
    }

    // unstructured
    //
    if (i.unstructured ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "unstructured",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *i.unstructured ();
    }

    // space
    //
    if (i.space ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "space",
          e));

      a << *i.space ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const UnstructuredLayout& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // number
    //
    if (i.number ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "number",
          e));

      a << *i.number ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RandomLayout& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // number
    //
    if (i.number ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "number",
          e));

      a << *i.number ();
    }

    // region
    //
    if (i.region ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "region",
          e));

      a << *i.region ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GridLayout& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // xSize
    //
    if (i.xSize ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "xSize",
          e));

      a << *i.xSize ();
    }

    // ySize
    //
    if (i.ySize ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ySize",
          e));

      a << *i.ySize ();
    }

    // zSize
    //
    if (i.zSize ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "zSize",
          e));

      a << *i.zSize ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Instance& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // location
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "location",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << i.location ();
    }

    // id
    //
    if (i.id ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << *i.id ();
    }

    // i
    //
    if (i.i ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "i",
          e));

      a << *i.i ();
    }

    // j
    //
    if (i.j ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "j",
          e));

      a << *i.j ();
    }

    // k
    //
    if (i.k ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "k",
          e));

      a << *i.k ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Location& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // x
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "x",
          e));

      a << i.x ();
    }

    // y
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "y",
          e));

      a << i.y ();
    }

    // z
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "z",
          e));

      a << i.z ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CellSet& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // select
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "select",
          e));

      a << i.select ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SynapticConnection& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // from
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "from",
          e));

      a << i.from ();
    }

    // to
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "to",
          e));

      a << i.to ();
    }

    // synapse
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "synapse",
          e));

      a << i.synapse ();
    }

    // destination
    //
    if (i.destination ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "destination",
          e));

      a << *i.destination ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BaseProjection& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // presynapticPopulation
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "presynapticPopulation",
          e));

      a << i.presynapticPopulation ();
    }

    // postsynapticPopulation
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "postsynapticPopulation",
          e));

      a << i.postsynapticPopulation ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Projection& i)
  {
    e << static_cast< const ::neuroml2::BaseProjection& > (i);

    // connection
    //
    for (Projection::connection_const_iterator
         b (i.connection ().begin ()), n (i.connection ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "connection",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // connectionWD
    //
    for (Projection::connectionWD_const_iterator
         b (i.connectionWD ().begin ()), n (i.connectionWD ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "connectionWD",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // synapse
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "synapse",
          e));

      a << i.synapse ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BaseConnection& i)
  {
    e << static_cast< const ::neuroml2::BaseNonNegativeIntegerId& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const BaseConnectionOldFormat& i)
  {
    e << static_cast< const ::neuroml2::BaseConnection& > (i);

    // preCellId
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "preCellId",
          e));

      a << i.preCellId ();
    }

    // preSegmentId
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "preSegmentId",
          e));

      a << i.preSegmentId ();
    }

    // preFractionAlong
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "preFractionAlong",
          e));

      a << i.preFractionAlong ();
    }

    // postCellId
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "postCellId",
          e));

      a << i.postCellId ();
    }

    // postSegmentId
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "postSegmentId",
          e));

      a << i.postSegmentId ();
    }

    // postFractionAlong
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "postFractionAlong",
          e));

      a << i.postFractionAlong ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BaseConnectionNewFormat& i)
  {
    e << static_cast< const ::neuroml2::BaseConnection& > (i);

    // preCell
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "preCell",
          e));

      a << i.preCell ();
    }

    // preSegment
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "preSegment",
          e));

      a << i.preSegment ();
    }

    // preFractionAlong
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "preFractionAlong",
          e));

      a << i.preFractionAlong ();
    }

    // postCell
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "postCell",
          e));

      a << i.postCell ();
    }

    // postSegment
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "postSegment",
          e));

      a << i.postSegment ();
    }

    // postFractionAlong
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "postFractionAlong",
          e));

      a << i.postFractionAlong ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Connection_base& i)
  {
    e << static_cast< const ::neuroml2::BaseConnectionOldFormat& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ConnectionWD& i)
  {
    e << static_cast< const ::neuroml2::BaseConnectionOldFormat& > (i);

    // weight
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "weight",
          e));

      a << i.weight ();
    }

    // delay
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "delay",
          e));

      a << i.delay ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ElectricalProjection& i)
  {
    e << static_cast< const ::neuroml2::BaseProjection& > (i);

    // electricalConnection
    //
    for (ElectricalProjection::electricalConnection_const_iterator
         b (i.electricalConnection ().begin ()), n (i.electricalConnection ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "electricalConnection",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // electricalConnectionInstance
    //
    for (ElectricalProjection::electricalConnectionInstance_const_iterator
         b (i.electricalConnectionInstance ().begin ()), n (i.electricalConnectionInstance ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "electricalConnectionInstance",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // electricalConnectionInstanceW
    //
    for (ElectricalProjection::electricalConnectionInstanceW_const_iterator
         b (i.electricalConnectionInstanceW ().begin ()), n (i.electricalConnectionInstanceW ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "electricalConnectionInstanceW",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ElectricalConnection& i)
  {
    e << static_cast< const ::neuroml2::BaseConnectionNewFormat& > (i);

    // synapse
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "synapse",
          e));

      a << i.synapse ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ElectricalConnectionInstance& i)
  {
    e << static_cast< const ::neuroml2::ElectricalConnection& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ElectricalConnectionInstanceW& i)
  {
    e << static_cast< const ::neuroml2::ElectricalConnectionInstance& > (i);

    // weight
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "weight",
          e));

      a << i.weight ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ContinuousProjection& i)
  {
    e << static_cast< const ::neuroml2::BaseProjection& > (i);

    // continuousConnection
    //
    for (ContinuousProjection::continuousConnection_const_iterator
         b (i.continuousConnection ().begin ()), n (i.continuousConnection ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "continuousConnection",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // continuousConnectionInstance
    //
    for (ContinuousProjection::continuousConnectionInstance_const_iterator
         b (i.continuousConnectionInstance ().begin ()), n (i.continuousConnectionInstance ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "continuousConnectionInstance",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // continuousConnectionInstanceW
    //
    for (ContinuousProjection::continuousConnectionInstanceW_const_iterator
         b (i.continuousConnectionInstanceW ().begin ()), n (i.continuousConnectionInstanceW ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "continuousConnectionInstanceW",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ContinuousConnection& i)
  {
    e << static_cast< const ::neuroml2::BaseConnectionNewFormat& > (i);

    // preComponent
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "preComponent",
          e));

      a << i.preComponent ();
    }

    // postComponent
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "postComponent",
          e));

      a << i.postComponent ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ContinuousConnectionInstance& i)
  {
    e << static_cast< const ::neuroml2::ContinuousConnection& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ContinuousConnectionInstanceW& i)
  {
    e << static_cast< const ::neuroml2::ContinuousConnectionInstance& > (i);

    // weight
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "weight",
          e));

      a << i.weight ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ExplicitInput& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // target
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "target",
          e));

      a << i.target ();
    }

    // input
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "input",
          e));

      a << i.input ();
    }

    // destination
    //
    if (i.destination ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "destination",
          e));

      a << *i.destination ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InputList& i)
  {
    e << static_cast< const ::neuroml2::Base& > (i);

    // input
    //
    for (InputList::input_const_iterator
         b (i.input ().begin ()), n (i.input ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // inputW
    //
    for (InputList::inputW_const_iterator
         b (i.inputW ().begin ()), n (i.inputW ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "inputW",
          "http://www.neuroml.org/schema/neuroml2",
          e));

      s << *b;
    }

    // population
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "population",
          e));

      a << i.population ();
    }

    // component
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "component",
          e));

      a << i.component ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Input& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // target
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "target",
          e));

      a << i.target ();
    }

    // destination
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "destination",
          e));

      a << i.destination ();
    }

    // segmentId
    //
    if (i.segmentId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "segmentId",
          e));

      a << *i.segmentId ();
    }

    // fractionAlong
    //
    if (i.fractionAlong ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "fractionAlong",
          e));

      a << *i.fractionAlong ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InputW& i)
  {
    e << static_cast< const ::neuroml2::Input& > (i);

    // weight
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "weight",
          e));

      a << i.weight ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const basePyNNCell& i)
  {
    e << static_cast< const ::neuroml2::BaseCell& > (i);

    // cm
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "cm",
          e));

      a << i.cm ();
    }

    // i_offset
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "i_offset",
          e));

      a << i.i_offset ();
    }

    // tau_syn_E
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "tau_syn_E",
          e));

      a << i.tau_syn_E ();
    }

    // tau_syn_I
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "tau_syn_I",
          e));

      a << i.tau_syn_I ();
    }

    // v_init
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "v_init",
          e));

      a << i.v_init ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const basePyNNIaFCell& i)
  {
    e << static_cast< const ::neuroml2::basePyNNCell& > (i);

    // tau_m
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "tau_m",
          e));

      a << i.tau_m ();
    }

    // tau_refrac
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "tau_refrac",
          e));

      a << i.tau_refrac ();
    }

    // v_reset
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "v_reset",
          e));

      a << i.v_reset ();
    }

    // v_rest
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "v_rest",
          e));

      a << i.v_rest ();
    }

    // v_thresh
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "v_thresh",
          e));

      a << i.v_thresh ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const basePyNNIaFCondCell& i)
  {
    e << static_cast< const ::neuroml2::basePyNNIaFCell& > (i);

    // e_rev_E
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "e_rev_E",
          e));

      a << i.e_rev_E ();
    }

    // e_rev_I
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "e_rev_I",
          e));

      a << i.e_rev_I ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const IF_curr_alpha& i)
  {
    e << static_cast< const ::neuroml2::basePyNNIaFCell& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const IF_curr_exp& i)
  {
    e << static_cast< const ::neuroml2::basePyNNIaFCell& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const IF_cond_alpha& i)
  {
    e << static_cast< const ::neuroml2::basePyNNIaFCondCell& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const IF_cond_exp& i)
  {
    e << static_cast< const ::neuroml2::basePyNNIaFCondCell& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const EIF_cond_exp_isfa_ista& i)
  {
    e << static_cast< const ::neuroml2::basePyNNIaFCondCell& > (i);

    // a
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "a",
          e));

      a << i.a ();
    }

    // b
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "b",
          e));

      a << i.b ();
    }

    // delta_T
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "delta_T",
          e));

      a << i.delta_T ();
    }

    // tau_w
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "tau_w",
          e));

      a << i.tau_w ();
    }

    // v_spike
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "v_spike",
          e));

      a << i.v_spike ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const EIF_cond_alpha_isfa_ista& i)
  {
    e << static_cast< const ::neuroml2::EIF_cond_exp_isfa_ista& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const HH_cond_exp& i)
  {
    e << static_cast< const ::neuroml2::basePyNNCell& > (i);

    // v_offset
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "v_offset",
          e));

      a << i.v_offset ();
    }

    // e_rev_E
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "e_rev_E",
          e));

      a << i.e_rev_E ();
    }

    // e_rev_I
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "e_rev_I",
          e));

      a << i.e_rev_I ();
    }

    // e_rev_K
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "e_rev_K",
          e));

      a << i.e_rev_K ();
    }

    // e_rev_Na
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "e_rev_Na",
          e));

      a << i.e_rev_Na ();
    }

    // e_rev_leak
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "e_rev_leak",
          e));

      a << i.e_rev_leak ();
    }

    // g_leak
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "g_leak",
          e));

      a << i.g_leak ();
    }

    // gbar_K
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "gbar_K",
          e));

      a << i.gbar_K ();
    }

    // gbar_Na
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "gbar_Na",
          e));

      a << i.gbar_Na ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BasePynnSynapse& i)
  {
    e << static_cast< const ::neuroml2::BaseSynapse& > (i);

    // tau_syn
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "tau_syn",
          e));

      a << i.tau_syn ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ExpCondSynapse& i)
  {
    e << static_cast< const ::neuroml2::BasePynnSynapse& > (i);

    // e_rev
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "e_rev",
          e));

      a << i.e_rev ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AlphaCondSynapse& i)
  {
    e << static_cast< const ::neuroml2::BasePynnSynapse& > (i);

    // e_rev
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "e_rev",
          e));

      a << i.e_rev ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ExpCurrSynapse& i)
  {
    e << static_cast< const ::neuroml2::BasePynnSynapse& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const AlphaCurrSynapse& i)
  {
    e << static_cast< const ::neuroml2::BasePynnSynapse& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpikeSourcePoisson& i)
  {
    e << static_cast< const ::neuroml2::Standalone& > (i);

    // start
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "start",
          e));

      a << i.start ();
    }

    // duration
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "duration",
          e));

      a << i.duration ();
    }

    // rate
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "rate",
          e));

      a << i.rate ();
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
// LCOV_EXCL_STOP
//
// End epilogue.

