// Copyright (c) 2005-2017 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from NeuroML_v2.2.xsd.
 */

#ifndef NEUROML_API_SCHEMA_NEURO_ML_V2_2_HXX
#define NEUROML_API_SCHEMA_NEURO_ML_V2_2_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
// LCOV_EXCL_START
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4009911L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema
{
  // anyType and anySimpleType.
  //

  /**
   * @brief C++ type corresponding to the anyType XML Schema
   * built-in type.
   */

  /**
   * @brief C++ type corresponding to the anySimpleType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;

  /**
   * @brief Alias for the anyType type.
   */


  // 8-bit
  //

  /**
   * @brief C++ type corresponding to the byte XML Schema
   * built-in type.
   */
  typedef signed char byte;

  /**
   * @brief C++ type corresponding to the unsignedByte XML Schema
   * built-in type.
   */
  typedef unsigned char unsigned_byte;


  // 16-bit
  //

  /**
   * @brief C++ type corresponding to the short XML Schema
   * built-in type.
   */
  typedef short short_;

  /**
   * @brief C++ type corresponding to the unsignedShort XML Schema
   * built-in type.
   */
  typedef unsigned short unsigned_short;


  // 32-bit
  //

  /**
   * @brief C++ type corresponding to the int XML Schema
   * built-in type.
   */
  typedef int int_;

  /**
   * @brief C++ type corresponding to the unsignedInt XML Schema
   * built-in type.
   */
  typedef unsigned int unsigned_int;


  // 64-bit
  //

  /**
   * @brief C++ type corresponding to the long XML Schema
   * built-in type.
   */
  typedef long long long_;

  /**
   * @brief C++ type corresponding to the unsignedLong XML Schema
   * built-in type.
   */
  typedef unsigned long long unsigned_long;


  // Supposed to be arbitrary-length integral types.
  //

  /**
   * @brief C++ type corresponding to the integer XML Schema
   * built-in type.
   */
  typedef long long integer;

  /**
   * @brief C++ type corresponding to the nonPositiveInteger XML Schema
   * built-in type.
   */
  typedef long long non_positive_integer;

  /**
   * @brief C++ type corresponding to the nonNegativeInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long non_negative_integer;

  /**
   * @brief C++ type corresponding to the positiveInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long positive_integer;

  /**
   * @brief C++ type corresponding to the negativeInteger XML Schema
   * built-in type.
   */
  typedef long long negative_integer;


  // Boolean.
  //

  /**
   * @brief C++ type corresponding to the boolean XML Schema
   * built-in type.
   */
  typedef bool boolean;


  // Floating-point types.
  //

  /**
   * @brief C++ type corresponding to the float XML Schema
   * built-in type.
   */
  typedef float float_;

  /**
   * @brief C++ type corresponding to the double XML Schema
   * built-in type.
   */
  typedef double double_;

  /**
   * @brief C++ type corresponding to the decimal XML Schema
   * built-in type.
   */
  typedef double decimal;


  // String types.
  //

  /**
   * @brief C++ type corresponding to the string XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::string< char, simple_type > string;

  /**
   * @brief C++ type corresponding to the normalizedString XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;

  /**
   * @brief C++ type corresponding to the token XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;

  /**
   * @brief C++ type corresponding to the Name XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::name< char, token > name;

  /**
   * @brief C++ type corresponding to the NMTOKEN XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;

  /**
   * @brief C++ type corresponding to the NMTOKENS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;

  /**
   * @brief C++ type corresponding to the NCName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;

  /**
   * @brief C++ type corresponding to the language XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::language< char, token > language;


  // ID/IDREF.
  //

  /**
   * @brief C++ type corresponding to the ID XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::id< char, ncname > id;

  /**
   * @brief C++ type corresponding to the IDREF XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;

  /**
   * @brief C++ type corresponding to the IDREFS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;


  // URI.
  //

  /**
   * @brief C++ type corresponding to the anyURI XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;


  // Qualified name.
  //

  /**
   * @brief C++ type corresponding to the QName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;


  // Binary.
  //

  /**
   * @brief Binary buffer type.
   */
  typedef ::xsd::cxx::tree::buffer< char > buffer;

  /**
   * @brief C++ type corresponding to the base64Binary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;

  /**
   * @brief C++ type corresponding to the hexBinary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;


  // Date/time.
  //

  /**
   * @brief Time zone type.
   */
  typedef ::xsd::cxx::tree::time_zone time_zone;

  /**
   * @brief C++ type corresponding to the date XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date< char, simple_type > date;

  /**
   * @brief C++ type corresponding to the dateTime XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;

  /**
   * @brief C++ type corresponding to the duration XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;

  /**
   * @brief C++ type corresponding to the gDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;

  /**
   * @brief C++ type corresponding to the gMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;

  /**
   * @brief C++ type corresponding to the gMonthDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;

  /**
   * @brief C++ type corresponding to the gYear XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;

  /**
   * @brief C++ type corresponding to the gYearMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;

  /**
   * @brief C++ type corresponding to the time XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::time< char, simple_type > time;


  // Entity.
  //

  /**
   * @brief C++ type corresponding to the ENTITY XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;

  /**
   * @brief C++ type corresponding to the ENTITIES XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;



  /**
   * @brief Content order sequence entry.
   */
  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  /**
   * @brief Namespace serialization information.
   */
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;

  /**
   * @brief Namespace serialization information map.
   */
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;

  /**
   * @brief List serialization stream.
   */
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;

  /**
   * @brief Serialization wrapper for the %double type.
   */
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;

  /**
   * @brief Serialization wrapper for the %decimal type.
   */
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;

  /**
   * @brief Simple type facet.
   */
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //

  /**
   * @brief Parsing and serialization flags.
   */
  typedef ::xsd::cxx::tree::flags flags;

  /**
   * @brief Parsing properties.
   */
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //

  /**
   * @brief Error severity.
   */
  typedef ::xsd::cxx::tree::severity severity;

  /**
   * @brief Error condition.
   */
  typedef ::xsd::cxx::tree::error< char > error;

  /**
   * @brief List of %error conditions.
   */
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //

  /**
   * @brief Root of the C++/Tree %exception hierarchy.
   */
  typedef ::xsd::cxx::tree::exception< char > exception;

  /**
   * @brief Exception indicating that the size argument exceeds
   * the capacity argument.
   */
  typedef ::xsd::cxx::tree::bounds< char > bounds;

  /**
   * @brief Exception indicating that a duplicate ID value
   * was encountered in the object model.
   */
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;

  /**
   * @brief Exception indicating a parsing failure.
   */
  typedef ::xsd::cxx::tree::parsing< char > parsing;

  /**
   * @brief Exception indicating that an expected element
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;

  /**
   * @brief Exception indicating that an unexpected element
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;

  /**
   * @brief Exception indicating that an expected attribute
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;

  /**
   * @brief Exception indicating that an unexpected enumerator
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;

  /**
   * @brief Exception indicating that the text content was
   * expected for an element.
   */
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;

  /**
   * @brief Exception indicating that a prefix-namespace
   * mapping was not provided.
   */
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  /**
   * @brief Exception indicating a serialization failure.
   */
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  /**
   * @brief Error handler callback interface.
   */
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  /**
   * @brief DOM interaction.
   */
  namespace dom
  {
    /**
     * @brief Automatic pointer for DOMDocument.
     */
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    /**
     * @brief DOM user data key for back pointers to tree nodes.
     */
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace neuroml2
{
  class NmlId;
  class Nml2Quantity;
  class Nml2Quantity_none;
  class Nml2Quantity_voltage;
  class Nml2Quantity_length;
  class Nml2Quantity_resistance;
  class Nml2Quantity_resistivity;
  class Nml2Quantity_conductance;
  class Nml2Quantity_conductanceDensity;
  class Nml2Quantity_permeability;
  class Nml2Quantity_time;
  class Nml2Quantity_pertime;
  class Nml2Quantity_capacitance;
  class Nml2Quantity_specificCapacitance;
  class Nml2Quantity_concentration;
  class Nml2Quantity_current;
  class Nml2Quantity_currentDensity;
  class Nml2Quantity_temperature;
  class Nml2Quantity_rhoFactor;
  class Nml2Quantity_conductancePerVoltage;
  class MetaId;
  class NeuroLexId;
  class NonNegativeInteger;
  class PositiveInteger;
  class DoubleGreaterThanZero;
  class ZeroOrOne;
  class Notes;
  class Property;
  class Annotation;
  class ComponentType;
  class Constant;
  class Exposure;
  class NamedDimensionalType;
  class NamedDimensionalVariable;
  class Parameter;
  class LEMS_Property;
  class Requirement;
  class InstanceRequirement;
  class Dynamics;
  class DerivedVariable;
  class StateVariable;
  class ConditionalDerivedVariable;
  class Case;
  class TimeDerivative;
  class ZeroToOne;
  class BaseWithoutId;
  class Base;
  class Standalone;
  class NeuroMLDocument_base;
  class NeuroMLDocument;
  class IncludeType;
  class IonChannelScalable;
  class IonChannelKS;
  class IonChannel;
  class IonChannelHH;
  class IonChannelVShift;
  class channelTypes;
  class Q10ConductanceScaling;
  class gateTypes;
  class ClosedState;
  class OpenState;
  class ForwardTransition;
  class ReverseTransition;
  class TauInfTransition;
  class GateKS;
  class GateHHUndetermined;
  class GateHHRates;
  class GateHHTauInf;
  class GateHHRatesTauInf;
  class GateHHRatesTau;
  class GateHHRatesInf;
  class GateHHInstantaneous;
  class GateFractional;
  class GateFractionalSubgate;
  class Q10Settings;
  class HHRate;
  class HHVariable;
  class HHTime;
  class DecayingPoolConcentrationModel;
  class FixedFactorConcentrationModel;
  class BaseSynapse;
  class BaseVoltageDepSynapse;
  class BaseCurrentBasedSynapse;
  class BaseConductanceBasedSynapse;
  class BaseConductanceBasedSynapseTwo;
  class GapJunction;
  class SilentSynapse;
  class LinearGradedSynapse;
  class GradedSynapse;
  class AlphaCurrentSynapse;
  class AlphaSynapse;
  class ExpOneSynapse;
  class ExpTwoSynapse;
  class ExpThreeSynapse;
  class DoubleSynapse;
  class BlockingPlasticSynapse;
  class BlockTypes;
  class BlockMechanism;
  class PlasticityTypes;
  class PlasticityMechanism;
  class BaseCell;
  class IafTauCell;
  class IafTauRefCell;
  class IafCell;
  class IafRefCell;
  class IzhikevichCell;
  class BaseCellMembPotCap;
  class Izhikevich2007Cell;
  class AdExIaFCell;
  class FitzHughNagumoCell;
  class FitzHughNagumo1969Cell;
  class PinskyRinzelCA3Cell;
  class Cell;
  class Cell2CaPools;
  class Morphology_base;
  class Morphology;
  class BaseNonNegativeIntegerId;
  class Segment_base;
  class Segment;
  class SegmentParent;
  class Point3DWithDiam;
  class SegmentGroup;
  class InhomogeneousParameter;
  class Metric;
  class ProximalDetails;
  class DistalDetails;
  class Member;
  class Include;
  class Path;
  class SubTree;
  class SegmentEndPoint;
  class BiophysicalProperties;
  class BiophysicalProperties2CaPools;
  class MembraneProperties;
  class MembraneProperties2CaPools;
  class SpikeThresh;
  class SpecificCapacitance;
  class InitMembPotential;
  class Resistivity;
  class ChannelPopulation;
  class ChannelDensityNonUniform;
  class ChannelDensityNonUniformNernst;
  class ChannelDensityNonUniformGHK;
  class ChannelDensity;
  class ChannelDensityVShift;
  class ChannelDensityNernst;
  class ChannelDensityNernstCa2;
  class ChannelDensityGHK;
  class ChannelDensityGHK2;
  class VariableParameter;
  class InhomogeneousValue;
  class Species;
  class ConcentrationModel_D;
  class IntracellularProperties;
  class IntracellularProperties2CaPools;
  class ExtracellularProperties;
  class ExtracellularPropertiesLocal;
  class ReactionScheme;
  class PulseGenerator;
  class PulseGeneratorDL;
  class SineGenerator;
  class SineGeneratorDL;
  class RampGenerator;
  class RampGeneratorDL;
  class CompoundInput;
  class CompoundInputDL;
  class VoltageClamp;
  class VoltageClampTriple;
  class Spike;
  class SpikeArray;
  class TimedSynapticInput;
  class SpikeGenerator;
  class SpikeGeneratorRandom;
  class SpikeGeneratorPoisson;
  class SpikeGeneratorRefPoisson;
  class PoissonFiringSynapse;
  class TransientPoissonFiringSynapse;
  class Network;
  class networkTypes;
  class Space;
  class SpaceStructure;
  class allowedSpaces;
  class Region;
  class Population;
  class populationTypes;
  class Layout;
  class UnstructuredLayout;
  class RandomLayout;
  class GridLayout;
  class Instance;
  class Location;
  class CellSet;
  class SynapticConnection;
  class BaseProjection;
  class Projection;
  class BaseConnection;
  class BaseConnectionOldFormat;
  class BaseConnectionNewFormat;
  class Connection_base;
  class Connection;
  class ConnectionWD;
  class ElectricalProjection;
  class ElectricalConnection;
  class ElectricalConnectionInstance;
  class ElectricalConnectionInstanceW;
  class ContinuousProjection;
  class ContinuousConnection;
  class ContinuousConnectionInstance;
  class ContinuousConnectionInstanceW;
  class ExplicitInput;
  class InputList;
  class Input;
  class InputW;
  class basePyNNCell;
  class basePyNNIaFCell;
  class basePyNNIaFCondCell;
  class IF_curr_alpha;
  class IF_curr_exp;
  class IF_cond_alpha;
  class IF_cond_exp;
  class EIF_cond_exp_isfa_ista;
  class EIF_cond_alpha_isfa_ista;
  class HH_cond_exp;
  class BasePynnSynapse;
  class ExpCondSynapse;
  class AlphaCondSynapse;
  class ExpCurrSynapse;
  class AlphaCurrSynapse;
  class SpikeSourcePoisson;
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

/**
 * @brief C++ namespace for the %http://www.neuroml.org/schema/neuroml2
 * schema namespace.
 */
namespace neuroml2
{
  /**
   * @brief Class corresponding to the %NmlId schema type.
   *
   * An id attribute for elements which need to be identified uniquely
   * (normally just within their parent element).
   *
   * @nosubgrouping
   */
  class NmlId: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    NmlId ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    NmlId (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    NmlId (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NmlId (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NmlId (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NmlId (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NmlId (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NmlId (const NmlId& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NmlId*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NmlId ();
  };

  /**
   * @brief Class corresponding to the %Nml2Quantity schema type.
   *
   * A value for a physical quantity in NeuroML 2, e.g. 20, -60.0mV or 5nA
   *
   * @nosubgrouping
   */
  class Nml2Quantity: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Nml2Quantity ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Nml2Quantity (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Nml2Quantity (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Nml2Quantity (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Nml2Quantity (const Nml2Quantity& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Nml2Quantity*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Nml2Quantity ();
  };

  /**
   * @brief Class corresponding to the %Nml2Quantity_none schema type.
   *
   * @nosubgrouping
   */
  class Nml2Quantity_none: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Nml2Quantity_none ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Nml2Quantity_none (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Nml2Quantity_none (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Nml2Quantity_none (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_none (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_none (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_none (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Nml2Quantity_none (const Nml2Quantity_none& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Nml2Quantity_none*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Nml2Quantity_none ();
  };

  /**
   * @brief Class corresponding to the %Nml2Quantity_voltage schema type.
   *
   * @nosubgrouping
   */
  class Nml2Quantity_voltage: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Nml2Quantity_voltage ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Nml2Quantity_voltage (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Nml2Quantity_voltage (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Nml2Quantity_voltage (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_voltage (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_voltage (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_voltage (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Nml2Quantity_voltage (const Nml2Quantity_voltage& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Nml2Quantity_voltage*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Nml2Quantity_voltage ();
  };

  /**
   * @brief Class corresponding to the %Nml2Quantity_length schema type.
   *
   * @nosubgrouping
   */
  class Nml2Quantity_length: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Nml2Quantity_length ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Nml2Quantity_length (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Nml2Quantity_length (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Nml2Quantity_length (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_length (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_length (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_length (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Nml2Quantity_length (const Nml2Quantity_length& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Nml2Quantity_length*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Nml2Quantity_length ();
  };

  /**
   * @brief Class corresponding to the %Nml2Quantity_resistance schema type.
   *
   * @nosubgrouping
   */
  class Nml2Quantity_resistance: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Nml2Quantity_resistance ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Nml2Quantity_resistance (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Nml2Quantity_resistance (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Nml2Quantity_resistance (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_resistance (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_resistance (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_resistance (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Nml2Quantity_resistance (const Nml2Quantity_resistance& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Nml2Quantity_resistance*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Nml2Quantity_resistance ();
  };

  /**
   * @brief Class corresponding to the %Nml2Quantity_resistivity schema type.
   *
   * @nosubgrouping
   */
  class Nml2Quantity_resistivity: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Nml2Quantity_resistivity ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Nml2Quantity_resistivity (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Nml2Quantity_resistivity (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Nml2Quantity_resistivity (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_resistivity (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_resistivity (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_resistivity (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Nml2Quantity_resistivity (const Nml2Quantity_resistivity& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Nml2Quantity_resistivity*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Nml2Quantity_resistivity ();
  };

  /**
   * @brief Class corresponding to the %Nml2Quantity_conductance schema type.
   *
   * @nosubgrouping
   */
  class Nml2Quantity_conductance: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Nml2Quantity_conductance ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Nml2Quantity_conductance (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Nml2Quantity_conductance (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Nml2Quantity_conductance (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_conductance (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_conductance (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_conductance (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Nml2Quantity_conductance (const Nml2Quantity_conductance& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Nml2Quantity_conductance*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Nml2Quantity_conductance ();
  };

  /**
   * @brief Class corresponding to the %Nml2Quantity_conductanceDensity schema type.
   *
   * @nosubgrouping
   */
  class Nml2Quantity_conductanceDensity: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Nml2Quantity_conductanceDensity ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Nml2Quantity_conductanceDensity (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Nml2Quantity_conductanceDensity (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Nml2Quantity_conductanceDensity (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_conductanceDensity (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_conductanceDensity (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_conductanceDensity (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Nml2Quantity_conductanceDensity (const Nml2Quantity_conductanceDensity& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Nml2Quantity_conductanceDensity*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Nml2Quantity_conductanceDensity ();
  };

  /**
   * @brief Class corresponding to the %Nml2Quantity_permeability schema type.
   *
   * @nosubgrouping
   */
  class Nml2Quantity_permeability: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Nml2Quantity_permeability ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Nml2Quantity_permeability (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Nml2Quantity_permeability (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Nml2Quantity_permeability (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_permeability (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_permeability (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_permeability (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Nml2Quantity_permeability (const Nml2Quantity_permeability& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Nml2Quantity_permeability*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Nml2Quantity_permeability ();
  };

  /**
   * @brief Class corresponding to the %Nml2Quantity_time schema type.
   *
   * @nosubgrouping
   */
  class Nml2Quantity_time: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Nml2Quantity_time ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Nml2Quantity_time (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Nml2Quantity_time (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Nml2Quantity_time (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_time (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_time (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_time (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Nml2Quantity_time (const Nml2Quantity_time& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Nml2Quantity_time*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Nml2Quantity_time ();
  };

  /**
   * @brief Class corresponding to the %Nml2Quantity_pertime schema type.
   *
   * @nosubgrouping
   */
  class Nml2Quantity_pertime: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Nml2Quantity_pertime ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Nml2Quantity_pertime (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Nml2Quantity_pertime (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Nml2Quantity_pertime (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_pertime (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_pertime (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_pertime (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Nml2Quantity_pertime (const Nml2Quantity_pertime& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Nml2Quantity_pertime*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Nml2Quantity_pertime ();
  };

  /**
   * @brief Class corresponding to the %Nml2Quantity_capacitance schema type.
   *
   * @nosubgrouping
   */
  class Nml2Quantity_capacitance: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Nml2Quantity_capacitance ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Nml2Quantity_capacitance (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Nml2Quantity_capacitance (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Nml2Quantity_capacitance (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_capacitance (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_capacitance (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_capacitance (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Nml2Quantity_capacitance (const Nml2Quantity_capacitance& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Nml2Quantity_capacitance*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Nml2Quantity_capacitance ();
  };

  /**
   * @brief Class corresponding to the %Nml2Quantity_specificCapacitance schema type.
   *
   * @nosubgrouping
   */
  class Nml2Quantity_specificCapacitance: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Nml2Quantity_specificCapacitance ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Nml2Quantity_specificCapacitance (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Nml2Quantity_specificCapacitance (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Nml2Quantity_specificCapacitance (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_specificCapacitance (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_specificCapacitance (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_specificCapacitance (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Nml2Quantity_specificCapacitance (const Nml2Quantity_specificCapacitance& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Nml2Quantity_specificCapacitance*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Nml2Quantity_specificCapacitance ();
  };

  /**
   * @brief Class corresponding to the %Nml2Quantity_concentration schema type.
   *
   * @nosubgrouping
   */
  class Nml2Quantity_concentration: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Nml2Quantity_concentration ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Nml2Quantity_concentration (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Nml2Quantity_concentration (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Nml2Quantity_concentration (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_concentration (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_concentration (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_concentration (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Nml2Quantity_concentration (const Nml2Quantity_concentration& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Nml2Quantity_concentration*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Nml2Quantity_concentration ();
  };

  /**
   * @brief Class corresponding to the %Nml2Quantity_current schema type.
   *
   * @nosubgrouping
   */
  class Nml2Quantity_current: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Nml2Quantity_current ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Nml2Quantity_current (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Nml2Quantity_current (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Nml2Quantity_current (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_current (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_current (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_current (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Nml2Quantity_current (const Nml2Quantity_current& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Nml2Quantity_current*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Nml2Quantity_current ();
  };

  /**
   * @brief Class corresponding to the %Nml2Quantity_currentDensity schema type.
   *
   * @nosubgrouping
   */
  class Nml2Quantity_currentDensity: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Nml2Quantity_currentDensity ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Nml2Quantity_currentDensity (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Nml2Quantity_currentDensity (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Nml2Quantity_currentDensity (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_currentDensity (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_currentDensity (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_currentDensity (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Nml2Quantity_currentDensity (const Nml2Quantity_currentDensity& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Nml2Quantity_currentDensity*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Nml2Quantity_currentDensity ();
  };

  /**
   * @brief Class corresponding to the %Nml2Quantity_temperature schema type.
   *
   * @nosubgrouping
   */
  class Nml2Quantity_temperature: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Nml2Quantity_temperature ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Nml2Quantity_temperature (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Nml2Quantity_temperature (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Nml2Quantity_temperature (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_temperature (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_temperature (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_temperature (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Nml2Quantity_temperature (const Nml2Quantity_temperature& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Nml2Quantity_temperature*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Nml2Quantity_temperature ();
  };

  /**
   * @brief Class corresponding to the %Nml2Quantity_rhoFactor schema type.
   *
   * @nosubgrouping
   */
  class Nml2Quantity_rhoFactor: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Nml2Quantity_rhoFactor ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Nml2Quantity_rhoFactor (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Nml2Quantity_rhoFactor (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Nml2Quantity_rhoFactor (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_rhoFactor (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_rhoFactor (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_rhoFactor (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Nml2Quantity_rhoFactor (const Nml2Quantity_rhoFactor& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Nml2Quantity_rhoFactor*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Nml2Quantity_rhoFactor ();
  };

  /**
   * @brief Class corresponding to the %Nml2Quantity_conductancePerVoltage schema type.
   *
   * @nosubgrouping
   */
  class Nml2Quantity_conductancePerVoltage: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Nml2Quantity_conductancePerVoltage ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Nml2Quantity_conductancePerVoltage (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Nml2Quantity_conductancePerVoltage (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Nml2Quantity_conductancePerVoltage (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_conductancePerVoltage (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_conductancePerVoltage (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nml2Quantity_conductancePerVoltage (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Nml2Quantity_conductancePerVoltage (const Nml2Quantity_conductancePerVoltage& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Nml2Quantity_conductancePerVoltage*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Nml2Quantity_conductancePerVoltage ();
  };

  /**
   * @brief Class corresponding to the %MetaId schema type.
   *
   * An id string for pointing to an entry in an annotation element related
   * to a MIRIAM resource. Based on metaid of SBML
   *
   * @nosubgrouping
   */
  class MetaId: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    MetaId ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    MetaId (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    MetaId (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MetaId (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MetaId (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MetaId (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MetaId (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MetaId (const MetaId& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MetaId*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MetaId ();
  };

  /**
   * @brief Class corresponding to the %NeuroLexId schema type.
   *
   * An id string for pointing to an entry in the NeuroLex ontology. Use of
   * this attribute is a shorthand for a full
   * RDF based reference to the MIRIAM Resource urn:miriam:neurolex, with
   * an bqbiol:is qualifier
   *
   * @nosubgrouping
   */
  class NeuroLexId: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    NeuroLexId ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    NeuroLexId (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    NeuroLexId (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NeuroLexId (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NeuroLexId (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NeuroLexId (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NeuroLexId (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NeuroLexId (const NeuroLexId& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NeuroLexId*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NeuroLexId ();
  };

  /**
   * @brief Class corresponding to the %NonNegativeInteger schema type.
   *
   * An attribute useful as id of segments, connections, etc: integer >=0
   * only!
   *
   * @nosubgrouping
   */
  class NonNegativeInteger: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NonNegativeInteger (const ::xml_schema::non_negative_integer&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NonNegativeInteger (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NonNegativeInteger (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NonNegativeInteger (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NonNegativeInteger (const NonNegativeInteger& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NonNegativeInteger*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NonNegativeInteger ();
  };

  /**
   * @brief Class corresponding to the %PositiveInteger schema type.
   *
   * Integer >=1 only!
   *
   * @nosubgrouping
   */
  class PositiveInteger: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PositiveInteger (const ::xml_schema::positive_integer&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PositiveInteger (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PositiveInteger (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PositiveInteger (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PositiveInteger (const PositiveInteger& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PositiveInteger*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PositiveInteger ();
  };

  /**
   * @brief Class corresponding to the %DoubleGreaterThanZero schema type.
   *
   * Double >0 only
   *
   * @nosubgrouping
   */
  class DoubleGreaterThanZero: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DoubleGreaterThanZero (const ::xml_schema::double_&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DoubleGreaterThanZero (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DoubleGreaterThanZero (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DoubleGreaterThanZero (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DoubleGreaterThanZero (const DoubleGreaterThanZero& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DoubleGreaterThanZero*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DoubleGreaterThanZero ();
  };

  /**
   * @brief Enumeration class corresponding to the %ZeroOrOne
   * schema type.
   *
   * Value which is either 0 or 1
   */
  class ZeroOrOne: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
  {
    public:
    /**
     * @brief Create an instance from a fundamental type value.
     *
     * @param v A fundamental type value.
     */
    ZeroOrOne (::xml_schema::double_ v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ZeroOrOne (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ZeroOrOne (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ZeroOrOne (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ZeroOrOne (const ZeroOrOne& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ZeroOrOne*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;
  };

  /**
   * @brief Class corresponding to the %Notes schema type.
   *
   * Textual human readable notes related to the element in question. It's
   * useful to put these into
   * the NeuroML files instead of XML comments, as the notes can be
   * extracted and repeated in the files to which the NeuroML is mapped.
   *
   * @nosubgrouping
   */
  class Notes: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Notes ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Notes (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Notes (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Notes (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Notes (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Notes (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Notes (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Notes (const Notes& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Notes*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Notes ();
  };

  /**
   * @brief Class corresponding to the %Property schema type.
   *
   * A property ( a **tag**  and **value**  pair ), which can be on any 
   * **baseStandalone**  either as a direct child, or within an 
   * **Annotation** . Generally something which helps the visual display or
   * facilitates simulation of a Component, but is not a core physiological
   * property. Common examples include: **numberInternalDivisions,** 
   * equivalent of nseg in NEURON; **radius,**  for a radius to use in
   * graphical displays for abstract cells ( i. e. without defined
   * morphologies ); **color,**  the color to use for a  **Population**  or
   * **populationList**  of cells; **recommended_dt_ms,**  the recommended
   * timestep to use for simulating a  **Network** ,
   * **recommended_duration_ms**  the recommended duration to use when
   * running a  **Network**
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name tag
     *
     * @brief Accessor and modifier functions for the %tag
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string tag_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< tag_type, char > tag_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const tag_type&
    tag () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    tag_type&
    tag ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    tag (const tag_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    tag (::std::unique_ptr< tag_type > p);

    //@}

    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string value_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const value_type&
    value () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    value_type&
    value ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    value (const value_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    value (::std::unique_ptr< value_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Property (const tag_type&,
              const value_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Property (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Property (const Property& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Property*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Property&
    operator= (const Property& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Property ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< tag_type > tag_;
    ::xsd::cxx::tree::one< value_type > value_;

    //@endcond
  };

  bool
  operator== (const Property&, const Property&);

  bool
  operator!= (const Property&, const Property&);


  /**
   * @brief Class corresponding to the %Annotation schema type.
   *
   * A structured annotation containing metadata, specifically RDF or 
   * **property**  elements
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Annotation ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Annotation (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Annotation (const Annotation& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Annotation*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Annotation ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:

    //@endcond
  };

  bool
  operator== (const Annotation&, const Annotation&);

  bool
  operator!= (const Annotation&, const Annotation&);


  /**
   * @brief Class corresponding to the %ComponentType schema type.
   *
   * Contains an extension to NeuroML by creating custom LEMS
  ComponentType. *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name Property
     *
     * @brief Accessor and modifier functions for the %Property
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::LEMS_Property Property_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< Property_type > Property_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef Property_sequence::iterator Property_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef Property_sequence::const_iterator Property_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Property_type, char > Property_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const Property_sequence&
    Property () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    Property_sequence&
    Property ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    Property (const Property_sequence& s);

    //@}

    /**
     * @name Parameter
     *
     * @brief Accessor and modifier functions for the %Parameter
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Parameter Parameter_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< Parameter_type > Parameter_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef Parameter_sequence::iterator Parameter_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef Parameter_sequence::const_iterator Parameter_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Parameter_type, char > Parameter_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const Parameter_sequence&
    Parameter () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    Parameter_sequence&
    Parameter ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    Parameter (const Parameter_sequence& s);

    //@}

    /**
     * @name Constant
     *
     * @brief Accessor and modifier functions for the %Constant
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Constant Constant_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< Constant_type > Constant_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef Constant_sequence::iterator Constant_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef Constant_sequence::const_iterator Constant_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Constant_type, char > Constant_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const Constant_sequence&
    Constant () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    Constant_sequence&
    Constant ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    Constant (const Constant_sequence& s);

    //@}

    /**
     * @name Exposure
     *
     * @brief Accessor and modifier functions for the %Exposure
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Exposure Exposure_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< Exposure_type > Exposure_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef Exposure_sequence::iterator Exposure_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef Exposure_sequence::const_iterator Exposure_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Exposure_type, char > Exposure_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const Exposure_sequence&
    Exposure () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    Exposure_sequence&
    Exposure ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    Exposure (const Exposure_sequence& s);

    //@}

    /**
     * @name Requirement
     *
     * @brief Accessor and modifier functions for the %Requirement
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Requirement Requirement_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< Requirement_type > Requirement_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef Requirement_sequence::iterator Requirement_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef Requirement_sequence::const_iterator Requirement_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Requirement_type, char > Requirement_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const Requirement_sequence&
    Requirement () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    Requirement_sequence&
    Requirement ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    Requirement (const Requirement_sequence& s);

    //@}

    /**
     * @name InstanceRequirement
     *
     * @brief Accessor and modifier functions for the %InstanceRequirement
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::InstanceRequirement InstanceRequirement_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< InstanceRequirement_type > InstanceRequirement_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef InstanceRequirement_sequence::iterator InstanceRequirement_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef InstanceRequirement_sequence::const_iterator InstanceRequirement_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InstanceRequirement_type, char > InstanceRequirement_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const InstanceRequirement_sequence&
    InstanceRequirement () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    InstanceRequirement_sequence&
    InstanceRequirement ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    InstanceRequirement (const InstanceRequirement_sequence& s);

    //@}

    /**
     * @name Dynamics
     *
     * @brief Accessor and modifier functions for the %Dynamics
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Dynamics Dynamics_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< Dynamics_type > Dynamics_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef Dynamics_sequence::iterator Dynamics_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef Dynamics_sequence::const_iterator Dynamics_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Dynamics_type, char > Dynamics_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const Dynamics_sequence&
    Dynamics () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    Dynamics_sequence&
    Dynamics ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    Dynamics (const Dynamics_sequence& s);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string name_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const name_type&
    name () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    name_type&
    name ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    name (const name_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    name (::std::unique_ptr< name_type > p);

    //@}

    /**
     * @name extends
     *
     * @brief Accessor and modifier functions for the %extends
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string extends_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< extends_type > extends_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< extends_type, char > extends_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const extends_optional&
    extends () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    extends_optional&
    extends ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    extends (const extends_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    extends (const extends_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    extends (::std::unique_ptr< extends_type > p);

    //@}

    /**
     * @name description
     *
     * @brief Accessor and modifier functions for the %description
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string description_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< description_type > description_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const description_optional&
    description () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    description_optional&
    description ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    description (const description_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    description (const description_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    description (::std::unique_ptr< description_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ComponentType (const name_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ComponentType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ComponentType (const ComponentType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ComponentType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ComponentType&
    operator= (const ComponentType& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ComponentType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Property_sequence Property_;
    Parameter_sequence Parameter_;
    Constant_sequence Constant_;
    Exposure_sequence Exposure_;
    Requirement_sequence Requirement_;
    InstanceRequirement_sequence InstanceRequirement_;
    Dynamics_sequence Dynamics_;
    ::xsd::cxx::tree::one< name_type > name_;
    extends_optional extends_;
    description_optional description_;

    //@endcond
  };

  bool
  operator== (const ComponentType&, const ComponentType&);

  bool
  operator!= (const ComponentType&, const ComponentType&);


  /**
   * @brief Class corresponding to the %Constant schema type.
   *
   * LEMS ComponentType for Constant.
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string name_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const name_type&
    name () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    name_type&
    name ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    name (const name_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    name (::std::unique_ptr< name_type > p);

    //@}

    /**
     * @name dimension
     *
     * @brief Accessor and modifier functions for the %dimension
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string dimension_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< dimension_type, char > dimension_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const dimension_type&
    dimension () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    dimension_type&
    dimension ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    dimension (const dimension_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    dimension (::std::unique_ptr< dimension_type > p);

    //@}

    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity value_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const value_type&
    value () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    value_type&
    value ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    value (const value_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    value (::std::unique_ptr< value_type > p);

    //@}

    /**
     * @name description
     *
     * @brief Accessor and modifier functions for the %description
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string description_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< description_type > description_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const description_optional&
    description () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    description_optional&
    description ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    description (const description_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    description (const description_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    description (::std::unique_ptr< description_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Constant (const name_type&,
              const dimension_type&,
              const value_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Constant (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Constant (const Constant& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Constant*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Constant&
    operator= (const Constant& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Constant ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< name_type > name_;
    ::xsd::cxx::tree::one< dimension_type > dimension_;
    ::xsd::cxx::tree::one< value_type > value_;
    description_optional description_;

    //@endcond
  };

  bool
  operator== (const Constant&, const Constant&);

  bool
  operator!= (const Constant&, const Constant&);


  /**
   * @brief Class corresponding to the %Exposure schema type.
   *
   * LEMS Exposure (ComponentType property)
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string name_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const name_type&
    name () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    name_type&
    name ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    name (const name_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    name (::std::unique_ptr< name_type > p);

    //@}

    /**
     * @name dimension
     *
     * @brief Accessor and modifier functions for the %dimension
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string dimension_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< dimension_type, char > dimension_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const dimension_type&
    dimension () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    dimension_type&
    dimension ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    dimension (const dimension_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    dimension (::std::unique_ptr< dimension_type > p);

    //@}

    /**
     * @name description
     *
     * @brief Accessor and modifier functions for the %description
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string description_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< description_type > description_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const description_optional&
    description () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    description_optional&
    description ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    description (const description_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    description (const description_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    description (::std::unique_ptr< description_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Exposure (const name_type&,
              const dimension_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Exposure (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Exposure (const Exposure& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Exposure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Exposure&
    operator= (const Exposure& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Exposure ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< name_type > name_;
    ::xsd::cxx::tree::one< dimension_type > dimension_;
    description_optional description_;

    //@endcond
  };

  bool
  operator== (const Exposure&, const Exposure&);

  bool
  operator!= (const Exposure&, const Exposure&);


  /**
   * @brief Class corresponding to the %NamedDimensionalType schema type.
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string name_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const name_type&
    name () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    name_type&
    name ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    name (const name_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    name (::std::unique_ptr< name_type > p);

    //@}

    /**
     * @name dimension
     *
     * @brief Accessor and modifier functions for the %dimension
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string dimension_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< dimension_type, char > dimension_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const dimension_type&
    dimension () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    dimension_type&
    dimension ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    dimension (const dimension_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    dimension (::std::unique_ptr< dimension_type > p);

    //@}

    /**
     * @name description
     *
     * @brief Accessor and modifier functions for the %description
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string description_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< description_type > description_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const description_optional&
    description () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    description_optional&
    description ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    description (const description_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    description (const description_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    description (::std::unique_ptr< description_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NamedDimensionalType (const name_type&,
                          const dimension_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NamedDimensionalType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NamedDimensionalType (const NamedDimensionalType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NamedDimensionalType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NamedDimensionalType&
    operator= (const NamedDimensionalType& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NamedDimensionalType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< name_type > name_;
    ::xsd::cxx::tree::one< dimension_type > dimension_;
    description_optional description_;

    //@endcond
  };

  bool
  operator== (const NamedDimensionalType&, const NamedDimensionalType&);

  bool
  operator!= (const NamedDimensionalType&, const NamedDimensionalType&);


  /**
   * @brief Class corresponding to the %NamedDimensionalVariable schema type.
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string name_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const name_type&
    name () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    name_type&
    name ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    name (const name_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    name (::std::unique_ptr< name_type > p);

    //@}

    /**
     * @name dimension
     *
     * @brief Accessor and modifier functions for the %dimension
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string dimension_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< dimension_type, char > dimension_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const dimension_type&
    dimension () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    dimension_type&
    dimension ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    dimension (const dimension_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    dimension (::std::unique_ptr< dimension_type > p);

    //@}

    /**
     * @name description
     *
     * @brief Accessor and modifier functions for the %description
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string description_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< description_type > description_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const description_optional&
    description () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    description_optional&
    description ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    description (const description_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    description (const description_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    description (::std::unique_ptr< description_type > p);

    //@}

    /**
     * @name exposure
     *
     * @brief Accessor and modifier functions for the %exposure
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string exposure_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< exposure_type > exposure_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< exposure_type, char > exposure_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const exposure_optional&
    exposure () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    exposure_optional&
    exposure ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    exposure (const exposure_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    exposure (const exposure_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    exposure (::std::unique_ptr< exposure_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NamedDimensionalVariable (const name_type&,
                              const dimension_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NamedDimensionalVariable (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NamedDimensionalVariable (const NamedDimensionalVariable& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NamedDimensionalVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NamedDimensionalVariable&
    operator= (const NamedDimensionalVariable& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NamedDimensionalVariable ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< name_type > name_;
    ::xsd::cxx::tree::one< dimension_type > dimension_;
    description_optional description_;
    exposure_optional exposure_;

    //@endcond
  };

  bool
  operator== (const NamedDimensionalVariable&, const NamedDimensionalVariable&);

  bool
  operator!= (const NamedDimensionalVariable&, const NamedDimensionalVariable&);


  /**
   * @brief Class corresponding to the %Parameter schema type.
   *
   * @nosubgrouping
   */
  class Parameter: public ::neuroml2::NamedDimensionalType
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Parameter (const name_type&,
               const dimension_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Parameter (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Parameter (const Parameter& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Parameter*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Parameter ();
  };

  /**
   * @brief Class corresponding to the %LEMS_Property schema type.
   *
   * @nosubgrouping
   */
  class LEMS_Property: public ::neuroml2::NamedDimensionalType
  {
    public:
    /**
     * @name defaultValue
     *
     * @brief Accessor and modifier functions for the %defaultValue
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::double_ defaultValue_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< defaultValue_type > defaultValue_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< defaultValue_type, char, ::xsd::cxx::tree::schema_type::double_ > defaultValue_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const defaultValue_optional&
    defaultValue () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    defaultValue_optional&
    defaultValue ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    defaultValue (const defaultValue_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    defaultValue (const defaultValue_optional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LEMS_Property (const name_type&,
                   const dimension_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LEMS_Property (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LEMS_Property (const LEMS_Property& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LEMS_Property*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LEMS_Property&
    operator= (const LEMS_Property& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LEMS_Property ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    defaultValue_optional defaultValue_;

    //@endcond
  };

  bool
  operator== (const LEMS_Property&, const LEMS_Property&);

  bool
  operator!= (const LEMS_Property&, const LEMS_Property&);


  /**
   * @brief Class corresponding to the %Requirement schema type.
   *
   * @nosubgrouping
   */
  class Requirement: public ::neuroml2::NamedDimensionalType
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Requirement (const name_type&,
                 const dimension_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Requirement (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Requirement (const Requirement& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Requirement*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Requirement ();
  };

  /**
   * @brief Class corresponding to the %InstanceRequirement schema type.
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string name_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const name_type&
    name () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    name_type&
    name ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    name (const name_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    name (::std::unique_ptr< name_type > p);

    //@}

    /**
     * @name type
     *
     * @brief Accessor and modifier functions for the %type
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string type_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const type_type&
    type () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    type_type&
    type ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    type (const type_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    type (::std::unique_ptr< type_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InstanceRequirement (const name_type&,
                         const type_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InstanceRequirement (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InstanceRequirement (const InstanceRequirement& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InstanceRequirement*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InstanceRequirement&
    operator= (const InstanceRequirement& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InstanceRequirement ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< name_type > name_;
    ::xsd::cxx::tree::one< type_type > type_;

    //@endcond
  };

  bool
  operator== (const InstanceRequirement&, const InstanceRequirement&);

  bool
  operator!= (const InstanceRequirement&, const InstanceRequirement&);


  /**
   * @brief Class corresponding to the %Dynamics schema type.
   *
   * LEMS ComponentType for Dynamics
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name StateVariable
     *
     * @brief Accessor and modifier functions for the %StateVariable
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::StateVariable StateVariable_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< StateVariable_type > StateVariable_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef StateVariable_sequence::iterator StateVariable_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef StateVariable_sequence::const_iterator StateVariable_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StateVariable_type, char > StateVariable_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const StateVariable_sequence&
    StateVariable () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    StateVariable_sequence&
    StateVariable ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    StateVariable (const StateVariable_sequence& s);

    //@}

    /**
     * @name DerivedVariable
     *
     * @brief Accessor and modifier functions for the %DerivedVariable
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::DerivedVariable DerivedVariable_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< DerivedVariable_type > DerivedVariable_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef DerivedVariable_sequence::iterator DerivedVariable_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef DerivedVariable_sequence::const_iterator DerivedVariable_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DerivedVariable_type, char > DerivedVariable_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const DerivedVariable_sequence&
    DerivedVariable () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    DerivedVariable_sequence&
    DerivedVariable ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    DerivedVariable (const DerivedVariable_sequence& s);

    //@}

    /**
     * @name ConditionalDerivedVariable
     *
     * @brief Accessor and modifier functions for the %ConditionalDerivedVariable
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ConditionalDerivedVariable ConditionalDerivedVariable_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ConditionalDerivedVariable_type > ConditionalDerivedVariable_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef ConditionalDerivedVariable_sequence::iterator ConditionalDerivedVariable_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ConditionalDerivedVariable_sequence::const_iterator ConditionalDerivedVariable_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ConditionalDerivedVariable_type, char > ConditionalDerivedVariable_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ConditionalDerivedVariable_sequence&
    ConditionalDerivedVariable () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ConditionalDerivedVariable_sequence&
    ConditionalDerivedVariable ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    ConditionalDerivedVariable (const ConditionalDerivedVariable_sequence& s);

    //@}

    /**
     * @name TimeDerivative
     *
     * @brief Accessor and modifier functions for the %TimeDerivative
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::TimeDerivative TimeDerivative_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< TimeDerivative_type > TimeDerivative_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef TimeDerivative_sequence::iterator TimeDerivative_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef TimeDerivative_sequence::const_iterator TimeDerivative_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimeDerivative_type, char > TimeDerivative_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const TimeDerivative_sequence&
    TimeDerivative () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    TimeDerivative_sequence&
    TimeDerivative ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    TimeDerivative (const TimeDerivative_sequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Dynamics ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Dynamics (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Dynamics (const Dynamics& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Dynamics*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Dynamics&
    operator= (const Dynamics& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Dynamics ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    StateVariable_sequence StateVariable_;
    DerivedVariable_sequence DerivedVariable_;
    ConditionalDerivedVariable_sequence ConditionalDerivedVariable_;
    TimeDerivative_sequence TimeDerivative_;

    //@endcond
  };

  bool
  operator== (const Dynamics&, const Dynamics&);

  bool
  operator!= (const Dynamics&, const Dynamics&);


  /**
   * @brief Class corresponding to the %DerivedVariable schema type.
   *
   * LEMS ComponentType for DerivedVariable
   *
   * @nosubgrouping
   */
  class DerivedVariable: public ::neuroml2::NamedDimensionalVariable
  {
    public:
    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string value_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< value_type > value_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const value_optional&
    value () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    value_optional&
    value ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    value (const value_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    value (const value_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    value (::std::unique_ptr< value_type > p);

    //@}

    /**
     * @name select
     *
     * @brief Accessor and modifier functions for the %select
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string select_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< select_type > select_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< select_type, char > select_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const select_optional&
    select () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    select_optional&
    select ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    select (const select_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    select (const select_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    select (::std::unique_ptr< select_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DerivedVariable (const name_type&,
                     const dimension_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DerivedVariable (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DerivedVariable (const DerivedVariable& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DerivedVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DerivedVariable&
    operator= (const DerivedVariable& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DerivedVariable ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    value_optional value_;
    select_optional select_;

    //@endcond
  };

  bool
  operator== (const DerivedVariable&, const DerivedVariable&);

  bool
  operator!= (const DerivedVariable&, const DerivedVariable&);


  /**
   * @brief Class corresponding to the %StateVariable schema type.
   *
   * @nosubgrouping
   */
  class StateVariable: public ::neuroml2::NamedDimensionalVariable
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    StateVariable (const name_type&,
                   const dimension_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    StateVariable (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    StateVariable (const StateVariable& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual StateVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~StateVariable ();
  };

  /**
   * @brief Class corresponding to the %ConditionalDerivedVariable schema type.
   *
   * @nosubgrouping
   */
  class ConditionalDerivedVariable: public ::neuroml2::NamedDimensionalVariable
  {
    public:
    /**
     * @name Case
     *
     * @brief Accessor and modifier functions for the %Case
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Case Case_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< Case_type > Case_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef Case_sequence::iterator Case_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef Case_sequence::const_iterator Case_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Case_type, char > Case_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const Case_sequence&
    Case () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    Case_sequence&
    Case ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    Case (const Case_sequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ConditionalDerivedVariable (const name_type&,
                                const dimension_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ConditionalDerivedVariable (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ConditionalDerivedVariable (const ConditionalDerivedVariable& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ConditionalDerivedVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ConditionalDerivedVariable&
    operator= (const ConditionalDerivedVariable& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ConditionalDerivedVariable ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Case_sequence Case_;

    //@endcond
  };

  bool
  operator== (const ConditionalDerivedVariable&, const ConditionalDerivedVariable&);

  bool
  operator!= (const ConditionalDerivedVariable&, const ConditionalDerivedVariable&);


  /**
   * @brief Class corresponding to the %Case schema type.
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name condition
     *
     * @brief Accessor and modifier functions for the %condition
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string condition_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< condition_type > condition_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< condition_type, char > condition_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const condition_optional&
    condition () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    condition_optional&
    condition ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    condition (const condition_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    condition (const condition_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    condition (::std::unique_ptr< condition_type > p);

    //@}

    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string value_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const value_type&
    value () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    value_type&
    value ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    value (const value_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    value (::std::unique_ptr< value_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Case (const value_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Case (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Case (const Case& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Case*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Case&
    operator= (const Case& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Case ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    condition_optional condition_;
    ::xsd::cxx::tree::one< value_type > value_;

    //@endcond
  };

  bool
  operator== (const Case&, const Case&);

  bool
  operator!= (const Case&, const Case&);


  /**
   * @brief Class corresponding to the %TimeDerivative schema type.
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name variable
     *
     * @brief Accessor and modifier functions for the %variable
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string variable_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< variable_type, char > variable_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const variable_type&
    variable () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    variable_type&
    variable ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    variable (const variable_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    variable (::std::unique_ptr< variable_type > p);

    //@}

    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string value_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const value_type&
    value () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    value_type&
    value ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    value (const value_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    value (::std::unique_ptr< value_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TimeDerivative (const variable_type&,
                    const value_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimeDerivative (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimeDerivative (const TimeDerivative& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TimeDerivative*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimeDerivative&
    operator= (const TimeDerivative& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TimeDerivative ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< variable_type > variable_;
    ::xsd::cxx::tree::one< value_type > value_;

    //@endcond
  };

  bool
  operator== (const TimeDerivative&, const TimeDerivative&);

  bool
  operator!= (const TimeDerivative&, const TimeDerivative&);


  /**
   * @brief Class corresponding to the %ZeroToOne schema type.
   *
   * Float value restricted to between 1 and 0
   *
   * @nosubgrouping
   */
  class ZeroToOne: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ZeroToOne (const ::xml_schema::float_&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ZeroToOne (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ZeroToOne (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ZeroToOne (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ZeroToOne (const ZeroToOne& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ZeroToOne*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ZeroToOne ();
  };

  /**
   * @brief Class corresponding to the %BaseWithoutId schema type.
   *
   * Base element without ID specified *yet*, e.g. for an element with a
   * particular requirement on its id which does not comply with NmlId
   * (e.g. Segment needs nonNegativeInteger).
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name neuroLexId
     *
     * @brief Accessor and modifier functions for the %neuroLexId
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NeuroLexId neuroLexId_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< neuroLexId_type > neuroLexId_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< neuroLexId_type, char > neuroLexId_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const neuroLexId_optional&
    neuroLexId () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    neuroLexId_optional&
    neuroLexId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    neuroLexId (const neuroLexId_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    neuroLexId (const neuroLexId_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    neuroLexId (::std::unique_ptr< neuroLexId_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BaseWithoutId ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BaseWithoutId (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BaseWithoutId (const BaseWithoutId& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BaseWithoutId*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BaseWithoutId&
    operator= (const BaseWithoutId& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BaseWithoutId ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    neuroLexId_optional neuroLexId_;

    //@endcond
  };

  bool
  operator== (const BaseWithoutId&, const BaseWithoutId&);

  bool
  operator!= (const BaseWithoutId&, const BaseWithoutId&);


  /**
   * @brief Class corresponding to the %Base schema type.
   *
   * Anything which can have a unique (within its parent) id of the form
   * NmlId (spaceless combination of letters, numbers and underscore).
   *
   * @nosubgrouping
   */
  class Base: public ::neuroml2::BaseWithoutId
  {
    public:
    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId id_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const id_type&
    id () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    id_type&
    id ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    id (const id_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    id (::std::unique_ptr< id_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Base (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Base (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Base (const Base& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Base*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Base&
    operator= (const Base& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Base ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< id_type > id_;

    //@endcond
  };

  bool
  operator== (const Base&, const Base&);

  bool
  operator!= (const Base&, const Base&);


  /**
   * @brief Class corresponding to the %Standalone schema type.
   *
   * Elements which can stand alone and be referenced by id, e.g. cell,
   * morphology.
   *
   * @nosubgrouping
   */
  class Standalone: public ::neuroml2::Base
  {
    public:
    /**
     * @name notes
     *
     * @brief Accessor and modifier functions for the %notes
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Notes notes_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< notes_type > notes_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< notes_type, char > notes_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const notes_optional&
    notes () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    notes_optional&
    notes ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    notes (const notes_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    notes (const notes_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    notes (::std::unique_ptr< notes_type > p);

    //@}

    /**
     * @name property
     *
     * @brief Accessor and modifier functions for the %property
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Property property_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< property_type > property_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef property_sequence::iterator property_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef property_sequence::const_iterator property_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< property_type, char > property_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const property_sequence&
    property () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    property_sequence&
    property ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    property (const property_sequence& s);

    //@}

    /**
     * @name annotation
     *
     * @brief Accessor and modifier functions for the %annotation
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Annotation annotation_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< annotation_type > annotation_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< annotation_type, char > annotation_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const annotation_optional&
    annotation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    annotation_optional&
    annotation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    annotation (const annotation_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    annotation (const annotation_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    annotation (::std::unique_ptr< annotation_type > p);

    //@}

    /**
     * @name metaid
     *
     * @brief Accessor and modifier functions for the %metaid
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::MetaId metaid_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< metaid_type > metaid_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< metaid_type, char > metaid_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const metaid_optional&
    metaid () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    metaid_optional&
    metaid ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    metaid (const metaid_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    metaid (const metaid_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    metaid (::std::unique_ptr< metaid_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Standalone (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Standalone (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Standalone (const Standalone& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Standalone*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Standalone&
    operator= (const Standalone& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Standalone ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    notes_optional notes_;
    property_sequence property_;
    annotation_optional annotation_;
    metaid_optional metaid_;

    //@endcond
  };

  bool
  operator== (const Standalone&, const Standalone&);

  bool
  operator!= (const Standalone&, const Standalone&);


  /**
   * @brief Class corresponding to the %NeuroMLDocument schema type.
   *
   * @nosubgrouping
   */
  class NeuroMLDocument_base: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name include
     *
     * @brief Accessor and modifier functions for the %include
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::IncludeType include_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef include_sequence::iterator include_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef include_sequence::const_iterator include_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const include_sequence&
    include () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    include_sequence&
    include ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    include (const include_sequence& s);

    //@}

    /**
     * @name extracellularProperties
     *
     * @brief Accessor and modifier functions for the %extracellularProperties
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ExtracellularProperties extracellularProperties_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< extracellularProperties_type > extracellularProperties_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef extracellularProperties_sequence::iterator extracellularProperties_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef extracellularProperties_sequence::const_iterator extracellularProperties_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< extracellularProperties_type, char > extracellularProperties_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const extracellularProperties_sequence&
    extracellularProperties () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    extracellularProperties_sequence&
    extracellularProperties ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    extracellularProperties (const extracellularProperties_sequence& s);

    //@}

    /**
     * @name intracellularProperties
     *
     * @brief Accessor and modifier functions for the %intracellularProperties
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::IntracellularProperties intracellularProperties_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< intracellularProperties_type > intracellularProperties_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef intracellularProperties_sequence::iterator intracellularProperties_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef intracellularProperties_sequence::const_iterator intracellularProperties_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< intracellularProperties_type, char > intracellularProperties_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const intracellularProperties_sequence&
    intracellularProperties () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    intracellularProperties_sequence&
    intracellularProperties ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    intracellularProperties (const intracellularProperties_sequence& s);

    //@}

    /**
     * @name morphology
     *
     * @brief Accessor and modifier functions for the %morphology
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Morphology morphology_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< morphology_type > morphology_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef morphology_sequence::iterator morphology_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef morphology_sequence::const_iterator morphology_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< morphology_type, char > morphology_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const morphology_sequence&
    morphology () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    morphology_sequence&
    morphology ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    morphology (const morphology_sequence& s);

    //@}

    /**
     * @name ionChannel
     *
     * @brief Accessor and modifier functions for the %ionChannel
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::IonChannel ionChannel_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ionChannel_type > ionChannel_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef ionChannel_sequence::iterator ionChannel_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ionChannel_sequence::const_iterator ionChannel_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ionChannel_type, char > ionChannel_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ionChannel_sequence&
    ionChannel () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ionChannel_sequence&
    ionChannel ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    ionChannel (const ionChannel_sequence& s);

    //@}

    /**
     * @name ionChannelHH
     *
     * @brief Accessor and modifier functions for the %ionChannelHH
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::IonChannelHH ionChannelHH_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ionChannelHH_type > ionChannelHH_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef ionChannelHH_sequence::iterator ionChannelHH_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ionChannelHH_sequence::const_iterator ionChannelHH_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ionChannelHH_type, char > ionChannelHH_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ionChannelHH_sequence&
    ionChannelHH () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ionChannelHH_sequence&
    ionChannelHH ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    ionChannelHH (const ionChannelHH_sequence& s);

    //@}

    /**
     * @name ionChannelVShift
     *
     * @brief Accessor and modifier functions for the %ionChannelVShift
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::IonChannelVShift ionChannelVShift_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ionChannelVShift_type > ionChannelVShift_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef ionChannelVShift_sequence::iterator ionChannelVShift_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ionChannelVShift_sequence::const_iterator ionChannelVShift_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ionChannelVShift_type, char > ionChannelVShift_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ionChannelVShift_sequence&
    ionChannelVShift () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ionChannelVShift_sequence&
    ionChannelVShift ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    ionChannelVShift (const ionChannelVShift_sequence& s);

    //@}

    /**
     * @name ionChannelKS
     *
     * @brief Accessor and modifier functions for the %ionChannelKS
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::IonChannelKS ionChannelKS_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ionChannelKS_type > ionChannelKS_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef ionChannelKS_sequence::iterator ionChannelKS_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ionChannelKS_sequence::const_iterator ionChannelKS_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ionChannelKS_type, char > ionChannelKS_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ionChannelKS_sequence&
    ionChannelKS () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ionChannelKS_sequence&
    ionChannelKS ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    ionChannelKS (const ionChannelKS_sequence& s);

    //@}

    /**
     * @name decayingPoolConcentrationModel
     *
     * @brief Accessor and modifier functions for the %decayingPoolConcentrationModel
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::DecayingPoolConcentrationModel decayingPoolConcentrationModel_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< decayingPoolConcentrationModel_type > decayingPoolConcentrationModel_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef decayingPoolConcentrationModel_sequence::iterator decayingPoolConcentrationModel_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef decayingPoolConcentrationModel_sequence::const_iterator decayingPoolConcentrationModel_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< decayingPoolConcentrationModel_type, char > decayingPoolConcentrationModel_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const decayingPoolConcentrationModel_sequence&
    decayingPoolConcentrationModel () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    decayingPoolConcentrationModel_sequence&
    decayingPoolConcentrationModel ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    decayingPoolConcentrationModel (const decayingPoolConcentrationModel_sequence& s);

    //@}

    /**
     * @name fixedFactorConcentrationModel
     *
     * @brief Accessor and modifier functions for the %fixedFactorConcentrationModel
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::FixedFactorConcentrationModel fixedFactorConcentrationModel_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< fixedFactorConcentrationModel_type > fixedFactorConcentrationModel_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef fixedFactorConcentrationModel_sequence::iterator fixedFactorConcentrationModel_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef fixedFactorConcentrationModel_sequence::const_iterator fixedFactorConcentrationModel_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< fixedFactorConcentrationModel_type, char > fixedFactorConcentrationModel_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const fixedFactorConcentrationModel_sequence&
    fixedFactorConcentrationModel () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    fixedFactorConcentrationModel_sequence&
    fixedFactorConcentrationModel ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    fixedFactorConcentrationModel (const fixedFactorConcentrationModel_sequence& s);

    //@}

    /**
     * @name alphaCurrentSynapse
     *
     * @brief Accessor and modifier functions for the %alphaCurrentSynapse
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::AlphaCurrentSynapse alphaCurrentSynapse_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< alphaCurrentSynapse_type > alphaCurrentSynapse_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef alphaCurrentSynapse_sequence::iterator alphaCurrentSynapse_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef alphaCurrentSynapse_sequence::const_iterator alphaCurrentSynapse_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< alphaCurrentSynapse_type, char > alphaCurrentSynapse_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const alphaCurrentSynapse_sequence&
    alphaCurrentSynapse () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    alphaCurrentSynapse_sequence&
    alphaCurrentSynapse ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    alphaCurrentSynapse (const alphaCurrentSynapse_sequence& s);

    //@}

    /**
     * @name alphaSynapse
     *
     * @brief Accessor and modifier functions for the %alphaSynapse
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::AlphaSynapse alphaSynapse_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< alphaSynapse_type > alphaSynapse_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef alphaSynapse_sequence::iterator alphaSynapse_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef alphaSynapse_sequence::const_iterator alphaSynapse_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< alphaSynapse_type, char > alphaSynapse_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const alphaSynapse_sequence&
    alphaSynapse () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    alphaSynapse_sequence&
    alphaSynapse ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    alphaSynapse (const alphaSynapse_sequence& s);

    //@}

    /**
     * @name expOneSynapse
     *
     * @brief Accessor and modifier functions for the %expOneSynapse
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ExpOneSynapse expOneSynapse_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< expOneSynapse_type > expOneSynapse_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef expOneSynapse_sequence::iterator expOneSynapse_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef expOneSynapse_sequence::const_iterator expOneSynapse_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< expOneSynapse_type, char > expOneSynapse_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const expOneSynapse_sequence&
    expOneSynapse () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    expOneSynapse_sequence&
    expOneSynapse ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    expOneSynapse (const expOneSynapse_sequence& s);

    //@}

    /**
     * @name expTwoSynapse
     *
     * @brief Accessor and modifier functions for the %expTwoSynapse
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ExpTwoSynapse expTwoSynapse_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< expTwoSynapse_type > expTwoSynapse_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef expTwoSynapse_sequence::iterator expTwoSynapse_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef expTwoSynapse_sequence::const_iterator expTwoSynapse_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< expTwoSynapse_type, char > expTwoSynapse_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const expTwoSynapse_sequence&
    expTwoSynapse () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    expTwoSynapse_sequence&
    expTwoSynapse ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    expTwoSynapse (const expTwoSynapse_sequence& s);

    //@}

    /**
     * @name expThreeSynapse
     *
     * @brief Accessor and modifier functions for the %expThreeSynapse
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ExpThreeSynapse expThreeSynapse_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< expThreeSynapse_type > expThreeSynapse_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef expThreeSynapse_sequence::iterator expThreeSynapse_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef expThreeSynapse_sequence::const_iterator expThreeSynapse_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< expThreeSynapse_type, char > expThreeSynapse_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const expThreeSynapse_sequence&
    expThreeSynapse () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    expThreeSynapse_sequence&
    expThreeSynapse ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    expThreeSynapse (const expThreeSynapse_sequence& s);

    //@}

    /**
     * @name blockingPlasticSynapse
     *
     * @brief Accessor and modifier functions for the %blockingPlasticSynapse
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::BlockingPlasticSynapse blockingPlasticSynapse_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< blockingPlasticSynapse_type > blockingPlasticSynapse_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef blockingPlasticSynapse_sequence::iterator blockingPlasticSynapse_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef blockingPlasticSynapse_sequence::const_iterator blockingPlasticSynapse_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< blockingPlasticSynapse_type, char > blockingPlasticSynapse_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const blockingPlasticSynapse_sequence&
    blockingPlasticSynapse () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    blockingPlasticSynapse_sequence&
    blockingPlasticSynapse ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    blockingPlasticSynapse (const blockingPlasticSynapse_sequence& s);

    //@}

    /**
     * @name doubleSynapse
     *
     * @brief Accessor and modifier functions for the %doubleSynapse
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::DoubleSynapse doubleSynapse_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< doubleSynapse_type > doubleSynapse_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef doubleSynapse_sequence::iterator doubleSynapse_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef doubleSynapse_sequence::const_iterator doubleSynapse_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< doubleSynapse_type, char > doubleSynapse_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const doubleSynapse_sequence&
    doubleSynapse () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    doubleSynapse_sequence&
    doubleSynapse ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    doubleSynapse (const doubleSynapse_sequence& s);

    //@}

    /**
     * @name gapJunction
     *
     * @brief Accessor and modifier functions for the %gapJunction
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::GapJunction gapJunction_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< gapJunction_type > gapJunction_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef gapJunction_sequence::iterator gapJunction_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef gapJunction_sequence::const_iterator gapJunction_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< gapJunction_type, char > gapJunction_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const gapJunction_sequence&
    gapJunction () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    gapJunction_sequence&
    gapJunction ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    gapJunction (const gapJunction_sequence& s);

    //@}

    /**
     * @name silentSynapse
     *
     * @brief Accessor and modifier functions for the %silentSynapse
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::SilentSynapse silentSynapse_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< silentSynapse_type > silentSynapse_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef silentSynapse_sequence::iterator silentSynapse_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef silentSynapse_sequence::const_iterator silentSynapse_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< silentSynapse_type, char > silentSynapse_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const silentSynapse_sequence&
    silentSynapse () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    silentSynapse_sequence&
    silentSynapse ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    silentSynapse (const silentSynapse_sequence& s);

    //@}

    /**
     * @name linearGradedSynapse
     *
     * @brief Accessor and modifier functions for the %linearGradedSynapse
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::LinearGradedSynapse linearGradedSynapse_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< linearGradedSynapse_type > linearGradedSynapse_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef linearGradedSynapse_sequence::iterator linearGradedSynapse_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef linearGradedSynapse_sequence::const_iterator linearGradedSynapse_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< linearGradedSynapse_type, char > linearGradedSynapse_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const linearGradedSynapse_sequence&
    linearGradedSynapse () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    linearGradedSynapse_sequence&
    linearGradedSynapse ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    linearGradedSynapse (const linearGradedSynapse_sequence& s);

    //@}

    /**
     * @name gradedSynapse
     *
     * @brief Accessor and modifier functions for the %gradedSynapse
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::GradedSynapse gradedSynapse_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< gradedSynapse_type > gradedSynapse_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef gradedSynapse_sequence::iterator gradedSynapse_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef gradedSynapse_sequence::const_iterator gradedSynapse_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< gradedSynapse_type, char > gradedSynapse_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const gradedSynapse_sequence&
    gradedSynapse () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    gradedSynapse_sequence&
    gradedSynapse ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    gradedSynapse (const gradedSynapse_sequence& s);

    //@}

    /**
     * @name biophysicalProperties
     *
     * @brief Accessor and modifier functions for the %biophysicalProperties
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::BiophysicalProperties biophysicalProperties_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< biophysicalProperties_type > biophysicalProperties_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef biophysicalProperties_sequence::iterator biophysicalProperties_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef biophysicalProperties_sequence::const_iterator biophysicalProperties_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< biophysicalProperties_type, char > biophysicalProperties_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const biophysicalProperties_sequence&
    biophysicalProperties () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    biophysicalProperties_sequence&
    biophysicalProperties ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    biophysicalProperties (const biophysicalProperties_sequence& s);

    //@}

    /**
     * @name cell
     *
     * @brief Accessor and modifier functions for the %cell
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Cell cell_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< cell_type > cell_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef cell_sequence::iterator cell_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef cell_sequence::const_iterator cell_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< cell_type, char > cell_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const cell_sequence&
    cell () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    cell_sequence&
    cell ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    cell (const cell_sequence& s);

    //@}

    /**
     * @name cell2CaPools
     *
     * @brief Accessor and modifier functions for the %cell2CaPools
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Cell2CaPools cell2CaPools_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< cell2CaPools_type > cell2CaPools_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef cell2CaPools_sequence::iterator cell2CaPools_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef cell2CaPools_sequence::const_iterator cell2CaPools_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< cell2CaPools_type, char > cell2CaPools_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const cell2CaPools_sequence&
    cell2CaPools () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    cell2CaPools_sequence&
    cell2CaPools ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    cell2CaPools (const cell2CaPools_sequence& s);

    //@}

    /**
     * @name baseCell
     *
     * @brief Accessor and modifier functions for the %baseCell
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::BaseCell baseCell_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< baseCell_type > baseCell_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef baseCell_sequence::iterator baseCell_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef baseCell_sequence::const_iterator baseCell_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< baseCell_type, char > baseCell_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const baseCell_sequence&
    baseCell () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    baseCell_sequence&
    baseCell ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    baseCell (const baseCell_sequence& s);

    //@}

    /**
     * @name iafTauCell
     *
     * @brief Accessor and modifier functions for the %iafTauCell
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::IafTauCell iafTauCell_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< iafTauCell_type > iafTauCell_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef iafTauCell_sequence::iterator iafTauCell_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef iafTauCell_sequence::const_iterator iafTauCell_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< iafTauCell_type, char > iafTauCell_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const iafTauCell_sequence&
    iafTauCell () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    iafTauCell_sequence&
    iafTauCell ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    iafTauCell (const iafTauCell_sequence& s);

    //@}

    /**
     * @name iafTauRefCell
     *
     * @brief Accessor and modifier functions for the %iafTauRefCell
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::IafTauRefCell iafTauRefCell_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< iafTauRefCell_type > iafTauRefCell_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef iafTauRefCell_sequence::iterator iafTauRefCell_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef iafTauRefCell_sequence::const_iterator iafTauRefCell_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< iafTauRefCell_type, char > iafTauRefCell_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const iafTauRefCell_sequence&
    iafTauRefCell () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    iafTauRefCell_sequence&
    iafTauRefCell ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    iafTauRefCell (const iafTauRefCell_sequence& s);

    //@}

    /**
     * @name iafCell
     *
     * @brief Accessor and modifier functions for the %iafCell
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::IafCell iafCell_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< iafCell_type > iafCell_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef iafCell_sequence::iterator iafCell_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef iafCell_sequence::const_iterator iafCell_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< iafCell_type, char > iafCell_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const iafCell_sequence&
    iafCell () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    iafCell_sequence&
    iafCell ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    iafCell (const iafCell_sequence& s);

    //@}

    /**
     * @name iafRefCell
     *
     * @brief Accessor and modifier functions for the %iafRefCell
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::IafRefCell iafRefCell_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< iafRefCell_type > iafRefCell_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef iafRefCell_sequence::iterator iafRefCell_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef iafRefCell_sequence::const_iterator iafRefCell_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< iafRefCell_type, char > iafRefCell_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const iafRefCell_sequence&
    iafRefCell () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    iafRefCell_sequence&
    iafRefCell ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    iafRefCell (const iafRefCell_sequence& s);

    //@}

    /**
     * @name izhikevichCell
     *
     * @brief Accessor and modifier functions for the %izhikevichCell
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::IzhikevichCell izhikevichCell_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< izhikevichCell_type > izhikevichCell_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef izhikevichCell_sequence::iterator izhikevichCell_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef izhikevichCell_sequence::const_iterator izhikevichCell_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< izhikevichCell_type, char > izhikevichCell_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const izhikevichCell_sequence&
    izhikevichCell () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    izhikevichCell_sequence&
    izhikevichCell ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    izhikevichCell (const izhikevichCell_sequence& s);

    //@}

    /**
     * @name izhikevich2007Cell
     *
     * @brief Accessor and modifier functions for the %izhikevich2007Cell
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Izhikevich2007Cell izhikevich2007Cell_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< izhikevich2007Cell_type > izhikevich2007Cell_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef izhikevich2007Cell_sequence::iterator izhikevich2007Cell_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef izhikevich2007Cell_sequence::const_iterator izhikevich2007Cell_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< izhikevich2007Cell_type, char > izhikevich2007Cell_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const izhikevich2007Cell_sequence&
    izhikevich2007Cell () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    izhikevich2007Cell_sequence&
    izhikevich2007Cell ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    izhikevich2007Cell (const izhikevich2007Cell_sequence& s);

    //@}

    /**
     * @name adExIaFCell
     *
     * @brief Accessor and modifier functions for the %adExIaFCell
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::AdExIaFCell adExIaFCell_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< adExIaFCell_type > adExIaFCell_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef adExIaFCell_sequence::iterator adExIaFCell_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef adExIaFCell_sequence::const_iterator adExIaFCell_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< adExIaFCell_type, char > adExIaFCell_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const adExIaFCell_sequence&
    adExIaFCell () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    adExIaFCell_sequence&
    adExIaFCell ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    adExIaFCell (const adExIaFCell_sequence& s);

    //@}

    /**
     * @name fitzHughNagumoCell
     *
     * @brief Accessor and modifier functions for the %fitzHughNagumoCell
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::FitzHughNagumoCell fitzHughNagumoCell_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< fitzHughNagumoCell_type > fitzHughNagumoCell_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef fitzHughNagumoCell_sequence::iterator fitzHughNagumoCell_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef fitzHughNagumoCell_sequence::const_iterator fitzHughNagumoCell_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< fitzHughNagumoCell_type, char > fitzHughNagumoCell_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const fitzHughNagumoCell_sequence&
    fitzHughNagumoCell () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    fitzHughNagumoCell_sequence&
    fitzHughNagumoCell ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    fitzHughNagumoCell (const fitzHughNagumoCell_sequence& s);

    //@}

    /**
     * @name fitzHughNagumo1969Cell
     *
     * @brief Accessor and modifier functions for the %fitzHughNagumo1969Cell
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::FitzHughNagumo1969Cell fitzHughNagumo1969Cell_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< fitzHughNagumo1969Cell_type > fitzHughNagumo1969Cell_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef fitzHughNagumo1969Cell_sequence::iterator fitzHughNagumo1969Cell_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef fitzHughNagumo1969Cell_sequence::const_iterator fitzHughNagumo1969Cell_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< fitzHughNagumo1969Cell_type, char > fitzHughNagumo1969Cell_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const fitzHughNagumo1969Cell_sequence&
    fitzHughNagumo1969Cell () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    fitzHughNagumo1969Cell_sequence&
    fitzHughNagumo1969Cell ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    fitzHughNagumo1969Cell (const fitzHughNagumo1969Cell_sequence& s);

    //@}

    /**
     * @name pinskyRinzelCA3Cell
     *
     * @brief Accessor and modifier functions for the %pinskyRinzelCA3Cell
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::PinskyRinzelCA3Cell pinskyRinzelCA3Cell_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< pinskyRinzelCA3Cell_type > pinskyRinzelCA3Cell_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef pinskyRinzelCA3Cell_sequence::iterator pinskyRinzelCA3Cell_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef pinskyRinzelCA3Cell_sequence::const_iterator pinskyRinzelCA3Cell_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< pinskyRinzelCA3Cell_type, char > pinskyRinzelCA3Cell_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const pinskyRinzelCA3Cell_sequence&
    pinskyRinzelCA3Cell () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    pinskyRinzelCA3Cell_sequence&
    pinskyRinzelCA3Cell ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    pinskyRinzelCA3Cell (const pinskyRinzelCA3Cell_sequence& s);

    //@}

    /**
     * @name pulseGenerator
     *
     * @brief Accessor and modifier functions for the %pulseGenerator
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::PulseGenerator pulseGenerator_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< pulseGenerator_type > pulseGenerator_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef pulseGenerator_sequence::iterator pulseGenerator_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef pulseGenerator_sequence::const_iterator pulseGenerator_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< pulseGenerator_type, char > pulseGenerator_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const pulseGenerator_sequence&
    pulseGenerator () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    pulseGenerator_sequence&
    pulseGenerator ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    pulseGenerator (const pulseGenerator_sequence& s);

    //@}

    /**
     * @name pulseGeneratorDL
     *
     * @brief Accessor and modifier functions for the %pulseGeneratorDL
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::PulseGeneratorDL pulseGeneratorDL_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< pulseGeneratorDL_type > pulseGeneratorDL_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef pulseGeneratorDL_sequence::iterator pulseGeneratorDL_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef pulseGeneratorDL_sequence::const_iterator pulseGeneratorDL_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< pulseGeneratorDL_type, char > pulseGeneratorDL_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const pulseGeneratorDL_sequence&
    pulseGeneratorDL () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    pulseGeneratorDL_sequence&
    pulseGeneratorDL ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    pulseGeneratorDL (const pulseGeneratorDL_sequence& s);

    //@}

    /**
     * @name sineGenerator
     *
     * @brief Accessor and modifier functions for the %sineGenerator
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::SineGenerator sineGenerator_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< sineGenerator_type > sineGenerator_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef sineGenerator_sequence::iterator sineGenerator_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef sineGenerator_sequence::const_iterator sineGenerator_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< sineGenerator_type, char > sineGenerator_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const sineGenerator_sequence&
    sineGenerator () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    sineGenerator_sequence&
    sineGenerator ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    sineGenerator (const sineGenerator_sequence& s);

    //@}

    /**
     * @name sineGeneratorDL
     *
     * @brief Accessor and modifier functions for the %sineGeneratorDL
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::SineGeneratorDL sineGeneratorDL_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< sineGeneratorDL_type > sineGeneratorDL_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef sineGeneratorDL_sequence::iterator sineGeneratorDL_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef sineGeneratorDL_sequence::const_iterator sineGeneratorDL_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< sineGeneratorDL_type, char > sineGeneratorDL_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const sineGeneratorDL_sequence&
    sineGeneratorDL () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    sineGeneratorDL_sequence&
    sineGeneratorDL ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    sineGeneratorDL (const sineGeneratorDL_sequence& s);

    //@}

    /**
     * @name rampGenerator
     *
     * @brief Accessor and modifier functions for the %rampGenerator
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::RampGenerator rampGenerator_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< rampGenerator_type > rampGenerator_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef rampGenerator_sequence::iterator rampGenerator_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef rampGenerator_sequence::const_iterator rampGenerator_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< rampGenerator_type, char > rampGenerator_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const rampGenerator_sequence&
    rampGenerator () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    rampGenerator_sequence&
    rampGenerator ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    rampGenerator (const rampGenerator_sequence& s);

    //@}

    /**
     * @name rampGeneratorDL
     *
     * @brief Accessor and modifier functions for the %rampGeneratorDL
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::RampGeneratorDL rampGeneratorDL_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< rampGeneratorDL_type > rampGeneratorDL_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef rampGeneratorDL_sequence::iterator rampGeneratorDL_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef rampGeneratorDL_sequence::const_iterator rampGeneratorDL_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< rampGeneratorDL_type, char > rampGeneratorDL_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const rampGeneratorDL_sequence&
    rampGeneratorDL () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    rampGeneratorDL_sequence&
    rampGeneratorDL ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    rampGeneratorDL (const rampGeneratorDL_sequence& s);

    //@}

    /**
     * @name compoundInput
     *
     * @brief Accessor and modifier functions for the %compoundInput
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::CompoundInput compoundInput_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< compoundInput_type > compoundInput_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef compoundInput_sequence::iterator compoundInput_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef compoundInput_sequence::const_iterator compoundInput_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< compoundInput_type, char > compoundInput_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const compoundInput_sequence&
    compoundInput () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    compoundInput_sequence&
    compoundInput ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    compoundInput (const compoundInput_sequence& s);

    //@}

    /**
     * @name compoundInputDL
     *
     * @brief Accessor and modifier functions for the %compoundInputDL
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::CompoundInputDL compoundInputDL_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< compoundInputDL_type > compoundInputDL_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef compoundInputDL_sequence::iterator compoundInputDL_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef compoundInputDL_sequence::const_iterator compoundInputDL_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< compoundInputDL_type, char > compoundInputDL_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const compoundInputDL_sequence&
    compoundInputDL () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    compoundInputDL_sequence&
    compoundInputDL ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    compoundInputDL (const compoundInputDL_sequence& s);

    //@}

    /**
     * @name voltageClamp
     *
     * @brief Accessor and modifier functions for the %voltageClamp
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::VoltageClamp voltageClamp_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< voltageClamp_type > voltageClamp_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef voltageClamp_sequence::iterator voltageClamp_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef voltageClamp_sequence::const_iterator voltageClamp_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< voltageClamp_type, char > voltageClamp_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const voltageClamp_sequence&
    voltageClamp () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    voltageClamp_sequence&
    voltageClamp ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    voltageClamp (const voltageClamp_sequence& s);

    //@}

    /**
     * @name voltageClampTriple
     *
     * @brief Accessor and modifier functions for the %voltageClampTriple
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::VoltageClampTriple voltageClampTriple_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< voltageClampTriple_type > voltageClampTriple_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef voltageClampTriple_sequence::iterator voltageClampTriple_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef voltageClampTriple_sequence::const_iterator voltageClampTriple_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< voltageClampTriple_type, char > voltageClampTriple_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const voltageClampTriple_sequence&
    voltageClampTriple () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    voltageClampTriple_sequence&
    voltageClampTriple ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    voltageClampTriple (const voltageClampTriple_sequence& s);

    //@}

    /**
     * @name spikeArray
     *
     * @brief Accessor and modifier functions for the %spikeArray
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::SpikeArray spikeArray_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< spikeArray_type > spikeArray_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef spikeArray_sequence::iterator spikeArray_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef spikeArray_sequence::const_iterator spikeArray_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< spikeArray_type, char > spikeArray_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const spikeArray_sequence&
    spikeArray () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    spikeArray_sequence&
    spikeArray ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    spikeArray (const spikeArray_sequence& s);

    //@}

    /**
     * @name timedSynapticInput
     *
     * @brief Accessor and modifier functions for the %timedSynapticInput
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::TimedSynapticInput timedSynapticInput_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< timedSynapticInput_type > timedSynapticInput_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef timedSynapticInput_sequence::iterator timedSynapticInput_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef timedSynapticInput_sequence::const_iterator timedSynapticInput_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< timedSynapticInput_type, char > timedSynapticInput_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const timedSynapticInput_sequence&
    timedSynapticInput () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    timedSynapticInput_sequence&
    timedSynapticInput ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    timedSynapticInput (const timedSynapticInput_sequence& s);

    //@}

    /**
     * @name spikeGenerator
     *
     * @brief Accessor and modifier functions for the %spikeGenerator
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::SpikeGenerator spikeGenerator_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< spikeGenerator_type > spikeGenerator_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef spikeGenerator_sequence::iterator spikeGenerator_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef spikeGenerator_sequence::const_iterator spikeGenerator_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< spikeGenerator_type, char > spikeGenerator_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const spikeGenerator_sequence&
    spikeGenerator () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    spikeGenerator_sequence&
    spikeGenerator ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    spikeGenerator (const spikeGenerator_sequence& s);

    //@}

    /**
     * @name spikeGeneratorRandom
     *
     * @brief Accessor and modifier functions for the %spikeGeneratorRandom
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::SpikeGeneratorRandom spikeGeneratorRandom_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< spikeGeneratorRandom_type > spikeGeneratorRandom_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef spikeGeneratorRandom_sequence::iterator spikeGeneratorRandom_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef spikeGeneratorRandom_sequence::const_iterator spikeGeneratorRandom_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< spikeGeneratorRandom_type, char > spikeGeneratorRandom_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const spikeGeneratorRandom_sequence&
    spikeGeneratorRandom () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    spikeGeneratorRandom_sequence&
    spikeGeneratorRandom ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    spikeGeneratorRandom (const spikeGeneratorRandom_sequence& s);

    //@}

    /**
     * @name spikeGeneratorPoisson
     *
     * @brief Accessor and modifier functions for the %spikeGeneratorPoisson
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::SpikeGeneratorPoisson spikeGeneratorPoisson_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< spikeGeneratorPoisson_type > spikeGeneratorPoisson_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef spikeGeneratorPoisson_sequence::iterator spikeGeneratorPoisson_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef spikeGeneratorPoisson_sequence::const_iterator spikeGeneratorPoisson_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< spikeGeneratorPoisson_type, char > spikeGeneratorPoisson_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const spikeGeneratorPoisson_sequence&
    spikeGeneratorPoisson () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    spikeGeneratorPoisson_sequence&
    spikeGeneratorPoisson ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    spikeGeneratorPoisson (const spikeGeneratorPoisson_sequence& s);

    //@}

    /**
     * @name spikeGeneratorRefPoisson
     *
     * @brief Accessor and modifier functions for the %spikeGeneratorRefPoisson
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::SpikeGeneratorRefPoisson spikeGeneratorRefPoisson_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< spikeGeneratorRefPoisson_type > spikeGeneratorRefPoisson_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef spikeGeneratorRefPoisson_sequence::iterator spikeGeneratorRefPoisson_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef spikeGeneratorRefPoisson_sequence::const_iterator spikeGeneratorRefPoisson_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< spikeGeneratorRefPoisson_type, char > spikeGeneratorRefPoisson_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const spikeGeneratorRefPoisson_sequence&
    spikeGeneratorRefPoisson () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    spikeGeneratorRefPoisson_sequence&
    spikeGeneratorRefPoisson ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    spikeGeneratorRefPoisson (const spikeGeneratorRefPoisson_sequence& s);

    //@}

    /**
     * @name poissonFiringSynapse
     *
     * @brief Accessor and modifier functions for the %poissonFiringSynapse
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::PoissonFiringSynapse poissonFiringSynapse_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< poissonFiringSynapse_type > poissonFiringSynapse_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef poissonFiringSynapse_sequence::iterator poissonFiringSynapse_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef poissonFiringSynapse_sequence::const_iterator poissonFiringSynapse_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< poissonFiringSynapse_type, char > poissonFiringSynapse_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const poissonFiringSynapse_sequence&
    poissonFiringSynapse () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    poissonFiringSynapse_sequence&
    poissonFiringSynapse ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    poissonFiringSynapse (const poissonFiringSynapse_sequence& s);

    //@}

    /**
     * @name transientPoissonFiringSynapse
     *
     * @brief Accessor and modifier functions for the %transientPoissonFiringSynapse
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::TransientPoissonFiringSynapse transientPoissonFiringSynapse_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< transientPoissonFiringSynapse_type > transientPoissonFiringSynapse_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef transientPoissonFiringSynapse_sequence::iterator transientPoissonFiringSynapse_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef transientPoissonFiringSynapse_sequence::const_iterator transientPoissonFiringSynapse_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< transientPoissonFiringSynapse_type, char > transientPoissonFiringSynapse_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const transientPoissonFiringSynapse_sequence&
    transientPoissonFiringSynapse () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    transientPoissonFiringSynapse_sequence&
    transientPoissonFiringSynapse ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    transientPoissonFiringSynapse (const transientPoissonFiringSynapse_sequence& s);

    //@}

    /**
     * @name IF_curr_alpha
     *
     * @brief Accessor and modifier functions for the %IF_curr_alpha
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::IF_curr_alpha IF_curr_alpha_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< IF_curr_alpha_type > IF_curr_alpha_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef IF_curr_alpha_sequence::iterator IF_curr_alpha_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef IF_curr_alpha_sequence::const_iterator IF_curr_alpha_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< IF_curr_alpha_type, char > IF_curr_alpha_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const IF_curr_alpha_sequence&
    IF_curr_alpha () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    IF_curr_alpha_sequence&
    IF_curr_alpha ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    IF_curr_alpha (const IF_curr_alpha_sequence& s);

    //@}

    /**
     * @name IF_curr_exp
     *
     * @brief Accessor and modifier functions for the %IF_curr_exp
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::IF_curr_exp IF_curr_exp_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< IF_curr_exp_type > IF_curr_exp_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef IF_curr_exp_sequence::iterator IF_curr_exp_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef IF_curr_exp_sequence::const_iterator IF_curr_exp_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< IF_curr_exp_type, char > IF_curr_exp_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const IF_curr_exp_sequence&
    IF_curr_exp () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    IF_curr_exp_sequence&
    IF_curr_exp ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    IF_curr_exp (const IF_curr_exp_sequence& s);

    //@}

    /**
     * @name IF_cond_alpha
     *
     * @brief Accessor and modifier functions for the %IF_cond_alpha
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::IF_cond_alpha IF_cond_alpha_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< IF_cond_alpha_type > IF_cond_alpha_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef IF_cond_alpha_sequence::iterator IF_cond_alpha_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef IF_cond_alpha_sequence::const_iterator IF_cond_alpha_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< IF_cond_alpha_type, char > IF_cond_alpha_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const IF_cond_alpha_sequence&
    IF_cond_alpha () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    IF_cond_alpha_sequence&
    IF_cond_alpha ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    IF_cond_alpha (const IF_cond_alpha_sequence& s);

    //@}

    /**
     * @name IF_cond_exp
     *
     * @brief Accessor and modifier functions for the %IF_cond_exp
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::IF_cond_exp IF_cond_exp_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< IF_cond_exp_type > IF_cond_exp_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef IF_cond_exp_sequence::iterator IF_cond_exp_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef IF_cond_exp_sequence::const_iterator IF_cond_exp_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< IF_cond_exp_type, char > IF_cond_exp_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const IF_cond_exp_sequence&
    IF_cond_exp () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    IF_cond_exp_sequence&
    IF_cond_exp ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    IF_cond_exp (const IF_cond_exp_sequence& s);

    //@}

    /**
     * @name EIF_cond_exp_isfa_ista
     *
     * @brief Accessor and modifier functions for the %EIF_cond_exp_isfa_ista
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::EIF_cond_exp_isfa_ista EIF_cond_exp_isfa_ista_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< EIF_cond_exp_isfa_ista_type > EIF_cond_exp_isfa_ista_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef EIF_cond_exp_isfa_ista_sequence::iterator EIF_cond_exp_isfa_ista_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef EIF_cond_exp_isfa_ista_sequence::const_iterator EIF_cond_exp_isfa_ista_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EIF_cond_exp_isfa_ista_type, char > EIF_cond_exp_isfa_ista_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const EIF_cond_exp_isfa_ista_sequence&
    EIF_cond_exp_isfa_ista () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    EIF_cond_exp_isfa_ista_sequence&
    EIF_cond_exp_isfa_ista ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    EIF_cond_exp_isfa_ista (const EIF_cond_exp_isfa_ista_sequence& s);

    //@}

    /**
     * @name EIF_cond_alpha_isfa_ista
     *
     * @brief Accessor and modifier functions for the %EIF_cond_alpha_isfa_ista
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::EIF_cond_alpha_isfa_ista EIF_cond_alpha_isfa_ista_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< EIF_cond_alpha_isfa_ista_type > EIF_cond_alpha_isfa_ista_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef EIF_cond_alpha_isfa_ista_sequence::iterator EIF_cond_alpha_isfa_ista_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef EIF_cond_alpha_isfa_ista_sequence::const_iterator EIF_cond_alpha_isfa_ista_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EIF_cond_alpha_isfa_ista_type, char > EIF_cond_alpha_isfa_ista_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const EIF_cond_alpha_isfa_ista_sequence&
    EIF_cond_alpha_isfa_ista () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    EIF_cond_alpha_isfa_ista_sequence&
    EIF_cond_alpha_isfa_ista ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    EIF_cond_alpha_isfa_ista (const EIF_cond_alpha_isfa_ista_sequence& s);

    //@}

    /**
     * @name HH_cond_exp
     *
     * @brief Accessor and modifier functions for the %HH_cond_exp
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::HH_cond_exp HH_cond_exp_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< HH_cond_exp_type > HH_cond_exp_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef HH_cond_exp_sequence::iterator HH_cond_exp_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef HH_cond_exp_sequence::const_iterator HH_cond_exp_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HH_cond_exp_type, char > HH_cond_exp_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const HH_cond_exp_sequence&
    HH_cond_exp () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    HH_cond_exp_sequence&
    HH_cond_exp ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    HH_cond_exp (const HH_cond_exp_sequence& s);

    //@}

    /**
     * @name expCondSynapse
     *
     * @brief Accessor and modifier functions for the %expCondSynapse
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ExpCondSynapse expCondSynapse_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< expCondSynapse_type > expCondSynapse_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef expCondSynapse_sequence::iterator expCondSynapse_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef expCondSynapse_sequence::const_iterator expCondSynapse_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< expCondSynapse_type, char > expCondSynapse_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const expCondSynapse_sequence&
    expCondSynapse () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    expCondSynapse_sequence&
    expCondSynapse ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    expCondSynapse (const expCondSynapse_sequence& s);

    //@}

    /**
     * @name alphaCondSynapse
     *
     * @brief Accessor and modifier functions for the %alphaCondSynapse
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::AlphaCondSynapse alphaCondSynapse_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< alphaCondSynapse_type > alphaCondSynapse_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef alphaCondSynapse_sequence::iterator alphaCondSynapse_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef alphaCondSynapse_sequence::const_iterator alphaCondSynapse_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< alphaCondSynapse_type, char > alphaCondSynapse_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const alphaCondSynapse_sequence&
    alphaCondSynapse () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    alphaCondSynapse_sequence&
    alphaCondSynapse ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    alphaCondSynapse (const alphaCondSynapse_sequence& s);

    //@}

    /**
     * @name expCurrSynapse
     *
     * @brief Accessor and modifier functions for the %expCurrSynapse
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ExpCurrSynapse expCurrSynapse_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< expCurrSynapse_type > expCurrSynapse_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef expCurrSynapse_sequence::iterator expCurrSynapse_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef expCurrSynapse_sequence::const_iterator expCurrSynapse_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< expCurrSynapse_type, char > expCurrSynapse_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const expCurrSynapse_sequence&
    expCurrSynapse () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    expCurrSynapse_sequence&
    expCurrSynapse ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    expCurrSynapse (const expCurrSynapse_sequence& s);

    //@}

    /**
     * @name alphaCurrSynapse
     *
     * @brief Accessor and modifier functions for the %alphaCurrSynapse
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::AlphaCurrSynapse alphaCurrSynapse_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< alphaCurrSynapse_type > alphaCurrSynapse_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef alphaCurrSynapse_sequence::iterator alphaCurrSynapse_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef alphaCurrSynapse_sequence::const_iterator alphaCurrSynapse_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< alphaCurrSynapse_type, char > alphaCurrSynapse_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const alphaCurrSynapse_sequence&
    alphaCurrSynapse () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    alphaCurrSynapse_sequence&
    alphaCurrSynapse ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    alphaCurrSynapse (const alphaCurrSynapse_sequence& s);

    //@}

    /**
     * @name SpikeSourcePoisson
     *
     * @brief Accessor and modifier functions for the %SpikeSourcePoisson
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::SpikeSourcePoisson SpikeSourcePoisson_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< SpikeSourcePoisson_type > SpikeSourcePoisson_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef SpikeSourcePoisson_sequence::iterator SpikeSourcePoisson_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef SpikeSourcePoisson_sequence::const_iterator SpikeSourcePoisson_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SpikeSourcePoisson_type, char > SpikeSourcePoisson_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const SpikeSourcePoisson_sequence&
    SpikeSourcePoisson () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    SpikeSourcePoisson_sequence&
    SpikeSourcePoisson ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    SpikeSourcePoisson (const SpikeSourcePoisson_sequence& s);

    //@}

    /**
     * @name network
     *
     * @brief Accessor and modifier functions for the %network
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Network network_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< network_type > network_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef network_sequence::iterator network_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef network_sequence::const_iterator network_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< network_type, char > network_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const network_sequence&
    network () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    network_sequence&
    network ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    network (const network_sequence& s);

    //@}

    /**
     * @name ComponentType
     *
     * @brief Accessor and modifier functions for the %ComponentType
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ComponentType ComponentType_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ComponentType_type > ComponentType_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef ComponentType_sequence::iterator ComponentType_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ComponentType_sequence::const_iterator ComponentType_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ComponentType_type, char > ComponentType_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ComponentType_sequence&
    ComponentType () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ComponentType_sequence&
    ComponentType ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    ComponentType (const ComponentType_sequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NeuroMLDocument_base (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NeuroMLDocument_base (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NeuroMLDocument_base (const NeuroMLDocument_base& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NeuroMLDocument_base*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NeuroMLDocument_base&
    operator= (const NeuroMLDocument_base& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NeuroMLDocument_base ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    include_sequence include_;
    extracellularProperties_sequence extracellularProperties_;
    intracellularProperties_sequence intracellularProperties_;
    morphology_sequence morphology_;
    ionChannel_sequence ionChannel_;
    ionChannelHH_sequence ionChannelHH_;
    ionChannelVShift_sequence ionChannelVShift_;
    ionChannelKS_sequence ionChannelKS_;
    decayingPoolConcentrationModel_sequence decayingPoolConcentrationModel_;
    fixedFactorConcentrationModel_sequence fixedFactorConcentrationModel_;
    alphaCurrentSynapse_sequence alphaCurrentSynapse_;
    alphaSynapse_sequence alphaSynapse_;
    expOneSynapse_sequence expOneSynapse_;
    expTwoSynapse_sequence expTwoSynapse_;
    expThreeSynapse_sequence expThreeSynapse_;
    blockingPlasticSynapse_sequence blockingPlasticSynapse_;
    doubleSynapse_sequence doubleSynapse_;
    gapJunction_sequence gapJunction_;
    silentSynapse_sequence silentSynapse_;
    linearGradedSynapse_sequence linearGradedSynapse_;
    gradedSynapse_sequence gradedSynapse_;
    biophysicalProperties_sequence biophysicalProperties_;
    cell_sequence cell_;
    cell2CaPools_sequence cell2CaPools_;
    baseCell_sequence baseCell_;
    iafTauCell_sequence iafTauCell_;
    iafTauRefCell_sequence iafTauRefCell_;
    iafCell_sequence iafCell_;
    iafRefCell_sequence iafRefCell_;
    izhikevichCell_sequence izhikevichCell_;
    izhikevich2007Cell_sequence izhikevich2007Cell_;
    adExIaFCell_sequence adExIaFCell_;
    fitzHughNagumoCell_sequence fitzHughNagumoCell_;
    fitzHughNagumo1969Cell_sequence fitzHughNagumo1969Cell_;
    pinskyRinzelCA3Cell_sequence pinskyRinzelCA3Cell_;
    pulseGenerator_sequence pulseGenerator_;
    pulseGeneratorDL_sequence pulseGeneratorDL_;
    sineGenerator_sequence sineGenerator_;
    sineGeneratorDL_sequence sineGeneratorDL_;
    rampGenerator_sequence rampGenerator_;
    rampGeneratorDL_sequence rampGeneratorDL_;
    compoundInput_sequence compoundInput_;
    compoundInputDL_sequence compoundInputDL_;
    voltageClamp_sequence voltageClamp_;
    voltageClampTriple_sequence voltageClampTriple_;
    spikeArray_sequence spikeArray_;
    timedSynapticInput_sequence timedSynapticInput_;
    spikeGenerator_sequence spikeGenerator_;
    spikeGeneratorRandom_sequence spikeGeneratorRandom_;
    spikeGeneratorPoisson_sequence spikeGeneratorPoisson_;
    spikeGeneratorRefPoisson_sequence spikeGeneratorRefPoisson_;
    poissonFiringSynapse_sequence poissonFiringSynapse_;
    transientPoissonFiringSynapse_sequence transientPoissonFiringSynapse_;
    IF_curr_alpha_sequence IF_curr_alpha_;
    IF_curr_exp_sequence IF_curr_exp_;
    IF_cond_alpha_sequence IF_cond_alpha_;
    IF_cond_exp_sequence IF_cond_exp_;
    EIF_cond_exp_isfa_ista_sequence EIF_cond_exp_isfa_ista_;
    EIF_cond_alpha_isfa_ista_sequence EIF_cond_alpha_isfa_ista_;
    HH_cond_exp_sequence HH_cond_exp_;
    expCondSynapse_sequence expCondSynapse_;
    alphaCondSynapse_sequence alphaCondSynapse_;
    expCurrSynapse_sequence expCurrSynapse_;
    alphaCurrSynapse_sequence alphaCurrSynapse_;
    SpikeSourcePoisson_sequence SpikeSourcePoisson_;
    network_sequence network_;
    ComponentType_sequence ComponentType_;

    //@endcond
  };

  bool
  operator== (const NeuroMLDocument_base&, const NeuroMLDocument_base&);

  bool
  operator!= (const NeuroMLDocument_base&, const NeuroMLDocument_base&);


  /**
   * @brief Class corresponding to the %IncludeType schema type.
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name href
     *
     * @brief Accessor and modifier functions for the %href
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::uri href_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< href_type, char > href_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const href_type&
    href () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    href_type&
    href ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    href (const href_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    href (::std::unique_ptr< href_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IncludeType (const href_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IncludeType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IncludeType (const IncludeType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IncludeType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IncludeType&
    operator= (const IncludeType& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IncludeType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< href_type > href_;

    //@endcond
  };

  bool
  operator== (const IncludeType&, const IncludeType&);

  bool
  operator!= (const IncludeType&, const IncludeType&);


  /**
   * @brief Class corresponding to the %IonChannelScalable schema type.
   *
   * @nosubgrouping
   */
  class IonChannelScalable: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name q10ConductanceScaling
     *
     * @brief Accessor and modifier functions for the %q10ConductanceScaling
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Q10ConductanceScaling q10ConductanceScaling_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< q10ConductanceScaling_type > q10ConductanceScaling_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef q10ConductanceScaling_sequence::iterator q10ConductanceScaling_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef q10ConductanceScaling_sequence::const_iterator q10ConductanceScaling_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< q10ConductanceScaling_type, char > q10ConductanceScaling_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const q10ConductanceScaling_sequence&
    q10ConductanceScaling () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    q10ConductanceScaling_sequence&
    q10ConductanceScaling ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    q10ConductanceScaling (const q10ConductanceScaling_sequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IonChannelScalable (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IonChannelScalable (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IonChannelScalable (const IonChannelScalable& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IonChannelScalable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IonChannelScalable&
    operator= (const IonChannelScalable& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IonChannelScalable ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    q10ConductanceScaling_sequence q10ConductanceScaling_;

    //@endcond
  };

  bool
  operator== (const IonChannelScalable&, const IonChannelScalable&);

  bool
  operator!= (const IonChannelScalable&, const IonChannelScalable&);


  /**
   * @brief Class corresponding to the %IonChannelKS schema type.
   *
   * A kinetic scheme based ion channel with multiple  **gateKS** s, each
   * of which consists of multiple  **KSState** s and  **KSTransition** s
   * giving the rates of transition between them
   * @param conductance 
   *
   * @nosubgrouping
   */
  class IonChannelKS: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name gateKS
     *
     * @brief Accessor and modifier functions for the %gateKS
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::GateKS gateKS_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< gateKS_type > gateKS_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef gateKS_sequence::iterator gateKS_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef gateKS_sequence::const_iterator gateKS_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< gateKS_type, char > gateKS_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const gateKS_sequence&
    gateKS () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    gateKS_sequence&
    gateKS ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    gateKS (const gateKS_sequence& s);

    //@}

    /**
     * @name species
     *
     * @brief Accessor and modifier functions for the %species
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId species_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< species_type > species_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< species_type, char > species_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const species_optional&
    species () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    species_optional&
    species ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    species (const species_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    species (const species_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    species (::std::unique_ptr< species_type > p);

    //@}

    /**
     * @name conductance
     *
     * @brief Accessor and modifier functions for the %conductance
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductance conductance_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< conductance_type > conductance_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< conductance_type, char > conductance_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const conductance_optional&
    conductance () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    conductance_optional&
    conductance ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    conductance (const conductance_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    conductance (const conductance_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    conductance (::std::unique_ptr< conductance_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IonChannelKS (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IonChannelKS (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IonChannelKS (const IonChannelKS& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IonChannelKS*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IonChannelKS&
    operator= (const IonChannelKS& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IonChannelKS ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    gateKS_sequence gateKS_;
    species_optional species_;
    conductance_optional conductance_;

    //@endcond
  };

  bool
  operator== (const IonChannelKS&, const IonChannelKS&);

  bool
  operator!= (const IonChannelKS&, const IonChannelKS&);


  /**
   * @brief Class corresponding to the %IonChannel schema type.
   *
   * Note  **ionChannel**  and  **ionChannelHH**  are currently
   * functionally identical. This is needed since many existing examples
   * use ionChannel, some use ionChannelHH. NeuroML v2beta4 should remove
   * one of these, probably ionChannelHH.
   * @param conductance 
   *
   * @nosubgrouping
   */
  class IonChannel: public ::neuroml2::IonChannelScalable
  {
    public:
    /**
     * @name gate
     *
     * @brief Accessor and modifier functions for the %gate
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::GateHHUndetermined gate_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< gate_type > gate_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef gate_sequence::iterator gate_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef gate_sequence::const_iterator gate_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< gate_type, char > gate_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const gate_sequence&
    gate () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    gate_sequence&
    gate ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    gate (const gate_sequence& s);

    //@}

    /**
     * @name gateHHrates
     *
     * @brief Accessor and modifier functions for the %gateHHrates
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::GateHHRates gateHHrates_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< gateHHrates_type > gateHHrates_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef gateHHrates_sequence::iterator gateHHrates_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef gateHHrates_sequence::const_iterator gateHHrates_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< gateHHrates_type, char > gateHHrates_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const gateHHrates_sequence&
    gateHHrates () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    gateHHrates_sequence&
    gateHHrates ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    gateHHrates (const gateHHrates_sequence& s);

    //@}

    /**
     * @name gateHHratesTau
     *
     * @brief Accessor and modifier functions for the %gateHHratesTau
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::GateHHRatesTau gateHHratesTau_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< gateHHratesTau_type > gateHHratesTau_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef gateHHratesTau_sequence::iterator gateHHratesTau_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef gateHHratesTau_sequence::const_iterator gateHHratesTau_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< gateHHratesTau_type, char > gateHHratesTau_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const gateHHratesTau_sequence&
    gateHHratesTau () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    gateHHratesTau_sequence&
    gateHHratesTau ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    gateHHratesTau (const gateHHratesTau_sequence& s);

    //@}

    /**
     * @name gateHHtauInf
     *
     * @brief Accessor and modifier functions for the %gateHHtauInf
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::GateHHTauInf gateHHtauInf_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< gateHHtauInf_type > gateHHtauInf_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef gateHHtauInf_sequence::iterator gateHHtauInf_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef gateHHtauInf_sequence::const_iterator gateHHtauInf_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< gateHHtauInf_type, char > gateHHtauInf_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const gateHHtauInf_sequence&
    gateHHtauInf () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    gateHHtauInf_sequence&
    gateHHtauInf ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    gateHHtauInf (const gateHHtauInf_sequence& s);

    //@}

    /**
     * @name gateHHratesInf
     *
     * @brief Accessor and modifier functions for the %gateHHratesInf
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::GateHHRatesInf gateHHratesInf_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< gateHHratesInf_type > gateHHratesInf_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef gateHHratesInf_sequence::iterator gateHHratesInf_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef gateHHratesInf_sequence::const_iterator gateHHratesInf_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< gateHHratesInf_type, char > gateHHratesInf_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const gateHHratesInf_sequence&
    gateHHratesInf () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    gateHHratesInf_sequence&
    gateHHratesInf ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    gateHHratesInf (const gateHHratesInf_sequence& s);

    //@}

    /**
     * @name gateHHratesTauInf
     *
     * @brief Accessor and modifier functions for the %gateHHratesTauInf
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::GateHHRatesTauInf gateHHratesTauInf_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< gateHHratesTauInf_type > gateHHratesTauInf_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef gateHHratesTauInf_sequence::iterator gateHHratesTauInf_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef gateHHratesTauInf_sequence::const_iterator gateHHratesTauInf_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< gateHHratesTauInf_type, char > gateHHratesTauInf_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const gateHHratesTauInf_sequence&
    gateHHratesTauInf () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    gateHHratesTauInf_sequence&
    gateHHratesTauInf ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    gateHHratesTauInf (const gateHHratesTauInf_sequence& s);

    //@}

    /**
     * @name gateHHInstantaneous
     *
     * @brief Accessor and modifier functions for the %gateHHInstantaneous
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::GateHHInstantaneous gateHHInstantaneous_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< gateHHInstantaneous_type > gateHHInstantaneous_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef gateHHInstantaneous_sequence::iterator gateHHInstantaneous_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef gateHHInstantaneous_sequence::const_iterator gateHHInstantaneous_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< gateHHInstantaneous_type, char > gateHHInstantaneous_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const gateHHInstantaneous_sequence&
    gateHHInstantaneous () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    gateHHInstantaneous_sequence&
    gateHHInstantaneous ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    gateHHInstantaneous (const gateHHInstantaneous_sequence& s);

    //@}

    /**
     * @name gateFractional
     *
     * @brief Accessor and modifier functions for the %gateFractional
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::GateFractional gateFractional_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< gateFractional_type > gateFractional_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef gateFractional_sequence::iterator gateFractional_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef gateFractional_sequence::const_iterator gateFractional_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< gateFractional_type, char > gateFractional_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const gateFractional_sequence&
    gateFractional () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    gateFractional_sequence&
    gateFractional ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    gateFractional (const gateFractional_sequence& s);

    //@}

    /**
     * @name species
     *
     * @brief Accessor and modifier functions for the %species
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId species_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< species_type > species_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< species_type, char > species_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const species_optional&
    species () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    species_optional&
    species ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    species (const species_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    species (const species_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    species (::std::unique_ptr< species_type > p);

    //@}

    /**
     * @name type
     *
     * @brief Accessor and modifier functions for the %type
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::channelTypes type_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< type_type > type_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const type_optional&
    type () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    type_optional&
    type ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    type (const type_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    type (const type_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    type (::std::unique_ptr< type_type > p);

    //@}

    /**
     * @name conductance
     *
     * @brief Accessor and modifier functions for the %conductance
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductance conductance_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< conductance_type > conductance_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< conductance_type, char > conductance_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const conductance_optional&
    conductance () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    conductance_optional&
    conductance ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    conductance (const conductance_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    conductance (const conductance_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    conductance (::std::unique_ptr< conductance_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IonChannel (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IonChannel (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IonChannel (const IonChannel& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IonChannel*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IonChannel&
    operator= (const IonChannel& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IonChannel ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    gate_sequence gate_;
    gateHHrates_sequence gateHHrates_;
    gateHHratesTau_sequence gateHHratesTau_;
    gateHHtauInf_sequence gateHHtauInf_;
    gateHHratesInf_sequence gateHHratesInf_;
    gateHHratesTauInf_sequence gateHHratesTauInf_;
    gateHHInstantaneous_sequence gateHHInstantaneous_;
    gateFractional_sequence gateFractional_;
    species_optional species_;
    type_optional type_;
    conductance_optional conductance_;

    //@endcond
  };

  bool
  operator== (const IonChannel&, const IonChannel&);

  bool
  operator!= (const IonChannel&, const IonChannel&);


  /**
   * @brief Class corresponding to the %IonChannelHH schema type.
   *
   * Note  **ionChannel**  and  **ionChannelHH**  are currently
   * functionally identical. This is needed since many existing examples
   * use ionChannel, some use ionChannelHH. NeuroML v2beta4 should remove
   * one of these, probably ionChannelHH.
   * @param conductance 
   *
   * @nosubgrouping
   */
  class IonChannelHH: public ::neuroml2::IonChannel
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IonChannelHH (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IonChannelHH (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IonChannelHH (const IonChannelHH& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IonChannelHH*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IonChannelHH ();
  };

  /**
   * @brief Class corresponding to the %IonChannelVShift schema type.
   *
   * Same as  **ionChannel** , but with a **vShift**  parameter to change
   * voltage activation of gates. The exact usage of **vShift**  in
   * expressions for rates is determined by the individual gates.
   * @param vShift 
   * @param conductance 
   *
   * @nosubgrouping
   */
  class IonChannelVShift: public ::neuroml2::IonChannel
  {
    public:
    /**
     * @name vShift
     *
     * @brief Accessor and modifier functions for the %vShift
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage vShift_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< vShift_type, char > vShift_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const vShift_type&
    vShift () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    vShift_type&
    vShift ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    vShift (const vShift_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    vShift (::std::unique_ptr< vShift_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IonChannelVShift (const id_type&,
                      const vShift_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IonChannelVShift (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IonChannelVShift (const IonChannelVShift& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IonChannelVShift*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IonChannelVShift&
    operator= (const IonChannelVShift& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IonChannelVShift ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< vShift_type > vShift_;

    //@endcond
  };

  bool
  operator== (const IonChannelVShift&, const IonChannelVShift&);

  bool
  operator!= (const IonChannelVShift&, const IonChannelVShift&);


  /**
   * @brief Enumeration class corresponding to the %channelTypes
   * schema type.
   */
  class channelTypes: public ::xml_schema::string
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum value
    {
      ionChannelPassive,
      ionChannelHH
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    channelTypes (value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    channelTypes (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    channelTypes (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    channelTypes (const ::xml_schema::string& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    channelTypes (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    channelTypes (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    channelTypes (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    channelTypes (const channelTypes& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual channelTypes*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    channelTypes&
    operator= (value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator value () const
    {
      return _xsd_channelTypes_convert ();
    }

    //@cond

    protected:
    value
    _xsd_channelTypes_convert () const;

    public:
    static const char* const _xsd_channelTypes_literals_[2];
    static const value _xsd_channelTypes_indexes_[2];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %Q10ConductanceScaling schema type.
   *
   * A value for the conductance scaling which varies as a standard
   * function of the difference between the current temperature,
   * **temperature,**  and the temperature at which the conductance was
   * originally determined, **experimentalTemp**
   * @param q10Factor 
   * @param experimentalTemp 
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name q10Factor
     *
     * @brief Accessor and modifier functions for the %q10Factor
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none q10Factor_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< q10Factor_type, char > q10Factor_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const q10Factor_type&
    q10Factor () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    q10Factor_type&
    q10Factor ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    q10Factor (const q10Factor_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    q10Factor (::std::unique_ptr< q10Factor_type > p);

    //@}

    /**
     * @name experimentalTemp
     *
     * @brief Accessor and modifier functions for the %experimentalTemp
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_temperature experimentalTemp_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< experimentalTemp_type, char > experimentalTemp_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const experimentalTemp_type&
    experimentalTemp () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    experimentalTemp_type&
    experimentalTemp ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    experimentalTemp (const experimentalTemp_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    experimentalTemp (::std::unique_ptr< experimentalTemp_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Q10ConductanceScaling (const q10Factor_type&,
                           const experimentalTemp_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Q10ConductanceScaling (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Q10ConductanceScaling (const Q10ConductanceScaling& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Q10ConductanceScaling*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Q10ConductanceScaling&
    operator= (const Q10ConductanceScaling& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Q10ConductanceScaling ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< q10Factor_type > q10Factor_;
    ::xsd::cxx::tree::one< experimentalTemp_type > experimentalTemp_;

    //@endcond
  };

  bool
  operator== (const Q10ConductanceScaling&, const Q10ConductanceScaling&);

  bool
  operator!= (const Q10ConductanceScaling&, const Q10ConductanceScaling&);


  /**
   * @brief Enumeration class corresponding to the %gateTypes
   * schema type.
   */
  class gateTypes: public ::xml_schema::string
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum value
    {
      gateHHrates,
      gateHHratesTau,
      gateHHtauInf,
      gateHHratesInf,
      gateHHratesTauInf,
      gateHHInstantaneous,
      gateKS,
      gateFractional
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    gateTypes (value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    gateTypes (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    gateTypes (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    gateTypes (const ::xml_schema::string& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    gateTypes (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    gateTypes (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    gateTypes (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    gateTypes (const gateTypes& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual gateTypes*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    gateTypes&
    operator= (value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator value () const
    {
      return _xsd_gateTypes_convert ();
    }

    //@cond

    protected:
    value
    _xsd_gateTypes_convert () const;

    public:
    static const char* const _xsd_gateTypes_literals_[8];
    static const value _xsd_gateTypes_indexes_[8];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ClosedState schema type.
   *
   * A  **KSState**  with **relativeConductance**  of 0
   * @param relativeConductance 
   *
   * @nosubgrouping
   */
  class ClosedState: public ::neuroml2::Base
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ClosedState (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ClosedState (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ClosedState (const ClosedState& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ClosedState*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ClosedState ();
  };

  /**
   * @brief Class corresponding to the %OpenState schema type.
   *
   * A  **KSState**  with **relativeConductance**  of 1
   * @param relativeConductance 
   *
   * @nosubgrouping
   */
  class OpenState: public ::neuroml2::Base
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    OpenState (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OpenState (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OpenState (const OpenState& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual OpenState*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~OpenState ();
  };

  /**
   * @brief Class corresponding to the %ForwardTransition schema type.
   *
   * A forward only  **KSTransition**  for a  **gateKS**  which specifies a
   * **rate**  ( type  **baseHHRate**  ) which follows one of the standard
   * Hodgkin Huxley forms ( e. g.  **HHExpRate** ,  **HHSigmoidRate** , 
   * **HHExpLinearRate**
   *
   * @nosubgrouping
   */
  class ForwardTransition: public ::neuroml2::Base
  {
    public:
    /**
     * @name from
     *
     * @brief Accessor and modifier functions for the %from
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId from_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< from_type, char > from_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const from_type&
    from () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    from_type&
    from ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    from (const from_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    from (::std::unique_ptr< from_type > p);

    //@}

    /**
     * @name to
     *
     * @brief Accessor and modifier functions for the %to
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId to_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< to_type, char > to_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const to_type&
    to () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    to_type&
    to ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    to (const to_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    to (::std::unique_ptr< to_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ForwardTransition (const id_type&,
                       const from_type&,
                       const to_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ForwardTransition (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ForwardTransition (const ForwardTransition& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ForwardTransition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ForwardTransition&
    operator= (const ForwardTransition& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ForwardTransition ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< from_type > from_;
    ::xsd::cxx::tree::one< to_type > to_;

    //@endcond
  };

  bool
  operator== (const ForwardTransition&, const ForwardTransition&);

  bool
  operator!= (const ForwardTransition&, const ForwardTransition&);


  /**
   * @brief Class corresponding to the %ReverseTransition schema type.
   *
   * A reverse only  **KSTransition**  for a  **gateKS**  which specifies a
   * **rate**  ( type  **baseHHRate**  ) which follows one of the standard
   * Hodgkin Huxley forms ( e. g.  **HHExpRate** ,  **HHSigmoidRate** , 
   * **HHExpLinearRate**
   *
   * @nosubgrouping
   */
  class ReverseTransition: public ::neuroml2::Base
  {
    public:
    /**
     * @name from
     *
     * @brief Accessor and modifier functions for the %from
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId from_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< from_type, char > from_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const from_type&
    from () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    from_type&
    from ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    from (const from_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    from (::std::unique_ptr< from_type > p);

    //@}

    /**
     * @name to
     *
     * @brief Accessor and modifier functions for the %to
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId to_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< to_type, char > to_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const to_type&
    to () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    to_type&
    to ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    to (const to_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    to (::std::unique_ptr< to_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ReverseTransition (const id_type&,
                       const from_type&,
                       const to_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ReverseTransition (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ReverseTransition (const ReverseTransition& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ReverseTransition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ReverseTransition&
    operator= (const ReverseTransition& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ReverseTransition ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< from_type > from_;
    ::xsd::cxx::tree::one< to_type > to_;

    //@endcond
  };

  bool
  operator== (const ReverseTransition&, const ReverseTransition&);

  bool
  operator!= (const ReverseTransition&, const ReverseTransition&);


  /**
   * @brief Class corresponding to the %TauInfTransition schema type.
   *
   * KS Transition specified in terms of time constant  **tau**  and steady
   * state  **inf**
   *
   * @nosubgrouping
   */
  class TauInfTransition: public ::neuroml2::Base
  {
    public:
    /**
     * @name steadyState
     *
     * @brief Accessor and modifier functions for the %steadyState
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::HHVariable steadyState_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< steadyState_type, char > steadyState_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const steadyState_type&
    steadyState () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    steadyState_type&
    steadyState ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    steadyState (const steadyState_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    steadyState (::std::unique_ptr< steadyState_type > p);

    //@}

    /**
     * @name timeCourse
     *
     * @brief Accessor and modifier functions for the %timeCourse
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::HHTime timeCourse_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< timeCourse_type, char > timeCourse_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const timeCourse_type&
    timeCourse () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    timeCourse_type&
    timeCourse ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    timeCourse (const timeCourse_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    timeCourse (::std::unique_ptr< timeCourse_type > p);

    //@}

    /**
     * @name from
     *
     * @brief Accessor and modifier functions for the %from
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId from_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< from_type, char > from_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const from_type&
    from () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    from_type&
    from ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    from (const from_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    from (::std::unique_ptr< from_type > p);

    //@}

    /**
     * @name to
     *
     * @brief Accessor and modifier functions for the %to
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId to_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< to_type, char > to_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const to_type&
    to () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    to_type&
    to ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    to (const to_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    to (::std::unique_ptr< to_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TauInfTransition (const id_type&,
                      const steadyState_type&,
                      const timeCourse_type&,
                      const from_type&,
                      const to_type&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    TauInfTransition (const id_type&,
                      ::std::unique_ptr< steadyState_type >,
                      ::std::unique_ptr< timeCourse_type >,
                      const from_type&,
                      const to_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TauInfTransition (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TauInfTransition (const TauInfTransition& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TauInfTransition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TauInfTransition&
    operator= (const TauInfTransition& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TauInfTransition ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< steadyState_type > steadyState_;
    ::xsd::cxx::tree::one< timeCourse_type > timeCourse_;
    ::xsd::cxx::tree::one< from_type > from_;
    ::xsd::cxx::tree::one< to_type > to_;

    //@endcond
  };

  bool
  operator== (const TauInfTransition&, const TauInfTransition&);

  bool
  operator!= (const TauInfTransition&, const TauInfTransition&);


  /**
   * @brief Class corresponding to the %GateKS schema type.
   *
   * A gate which consists of multiple  **KSState** s and  **KSTransition**
   * s giving the rates of transition between them
   * @param instances 
   *
   * @nosubgrouping
   */
  class GateKS: public ::neuroml2::Base
  {
    public:
    /**
     * @name notes
     *
     * @brief Accessor and modifier functions for the %notes
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Notes notes_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< notes_type > notes_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< notes_type, char > notes_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const notes_optional&
    notes () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    notes_optional&
    notes ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    notes (const notes_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    notes (const notes_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    notes (::std::unique_ptr< notes_type > p);

    //@}

    /**
     * @name q10Settings
     *
     * @brief Accessor and modifier functions for the %q10Settings
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Q10Settings q10Settings_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< q10Settings_type > q10Settings_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< q10Settings_type, char > q10Settings_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const q10Settings_optional&
    q10Settings () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    q10Settings_optional&
    q10Settings ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    q10Settings (const q10Settings_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    q10Settings (const q10Settings_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    q10Settings (::std::unique_ptr< q10Settings_type > p);

    //@}

    /**
     * @name closedState
     *
     * @brief Accessor and modifier functions for the %closedState
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ClosedState closedState_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< closedState_type > closedState_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef closedState_sequence::iterator closedState_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef closedState_sequence::const_iterator closedState_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< closedState_type, char > closedState_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const closedState_sequence&
    closedState () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    closedState_sequence&
    closedState ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    closedState (const closedState_sequence& s);

    //@}

    /**
     * @name openState
     *
     * @brief Accessor and modifier functions for the %openState
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::OpenState openState_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< openState_type > openState_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef openState_sequence::iterator openState_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef openState_sequence::const_iterator openState_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< openState_type, char > openState_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const openState_sequence&
    openState () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    openState_sequence&
    openState ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    openState (const openState_sequence& s);

    //@}

    /**
     * @name forwardTransition
     *
     * @brief Accessor and modifier functions for the %forwardTransition
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ForwardTransition forwardTransition_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< forwardTransition_type > forwardTransition_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef forwardTransition_sequence::iterator forwardTransition_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef forwardTransition_sequence::const_iterator forwardTransition_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< forwardTransition_type, char > forwardTransition_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const forwardTransition_sequence&
    forwardTransition () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    forwardTransition_sequence&
    forwardTransition ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    forwardTransition (const forwardTransition_sequence& s);

    //@}

    /**
     * @name reverseTransition
     *
     * @brief Accessor and modifier functions for the %reverseTransition
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ReverseTransition reverseTransition_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< reverseTransition_type > reverseTransition_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef reverseTransition_sequence::iterator reverseTransition_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef reverseTransition_sequence::const_iterator reverseTransition_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< reverseTransition_type, char > reverseTransition_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const reverseTransition_sequence&
    reverseTransition () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    reverseTransition_sequence&
    reverseTransition ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    reverseTransition (const reverseTransition_sequence& s);

    //@}

    /**
     * @name tauInfTransition
     *
     * @brief Accessor and modifier functions for the %tauInfTransition
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::TauInfTransition tauInfTransition_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< tauInfTransition_type > tauInfTransition_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef tauInfTransition_sequence::iterator tauInfTransition_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef tauInfTransition_sequence::const_iterator tauInfTransition_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< tauInfTransition_type, char > tauInfTransition_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const tauInfTransition_sequence&
    tauInfTransition () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    tauInfTransition_sequence&
    tauInfTransition ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    tauInfTransition (const tauInfTransition_sequence& s);

    //@}

    /**
     * @name instances
     *
     * @brief Accessor and modifier functions for the %instances
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::PositiveInteger instances_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< instances_type, char > instances_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const instances_type&
    instances () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    instances_type&
    instances ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    instances (const instances_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    instances (::std::unique_ptr< instances_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    GateKS (const id_type&,
            const instances_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GateKS (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GateKS (const GateKS& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual GateKS*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GateKS&
    operator= (const GateKS& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~GateKS ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    notes_optional notes_;
    q10Settings_optional q10Settings_;
    closedState_sequence closedState_;
    openState_sequence openState_;
    forwardTransition_sequence forwardTransition_;
    reverseTransition_sequence reverseTransition_;
    tauInfTransition_sequence tauInfTransition_;
    ::xsd::cxx::tree::one< instances_type > instances_;

    //@endcond
  };

  bool
  operator== (const GateKS&, const GateKS&);

  bool
  operator!= (const GateKS&, const GateKS&);


  /**
   * @brief Class corresponding to the %GateHHUndetermined schema type.
   *
   * Note all sub elements for gateHHrates, gateHHratesTau, gateFractional
   * etc. allowed here. Which are valid should be constrained by what type
   * is set
   *
   * @nosubgrouping
   */
  class GateHHUndetermined: public ::neuroml2::Base
  {
    public:
    /**
     * @name notes
     *
     * @brief Accessor and modifier functions for the %notes
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Notes notes_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< notes_type > notes_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< notes_type, char > notes_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const notes_optional&
    notes () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    notes_optional&
    notes ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    notes (const notes_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    notes (const notes_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    notes (::std::unique_ptr< notes_type > p);

    //@}

    /**
     * @name q10Settings
     *
     * @brief Accessor and modifier functions for the %q10Settings
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Q10Settings q10Settings_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< q10Settings_type > q10Settings_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< q10Settings_type, char > q10Settings_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const q10Settings_optional&
    q10Settings () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    q10Settings_optional&
    q10Settings ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    q10Settings (const q10Settings_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    q10Settings (const q10Settings_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    q10Settings (::std::unique_ptr< q10Settings_type > p);

    //@}

    /**
     * @name forwardRate
     *
     * @brief Accessor and modifier functions for the %forwardRate
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::HHRate forwardRate_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< forwardRate_type > forwardRate_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< forwardRate_type, char > forwardRate_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const forwardRate_optional&
    forwardRate () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    forwardRate_optional&
    forwardRate ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    forwardRate (const forwardRate_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    forwardRate (const forwardRate_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    forwardRate (::std::unique_ptr< forwardRate_type > p);

    //@}

    /**
     * @name reverseRate
     *
     * @brief Accessor and modifier functions for the %reverseRate
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::HHRate reverseRate_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< reverseRate_type > reverseRate_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< reverseRate_type, char > reverseRate_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const reverseRate_optional&
    reverseRate () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    reverseRate_optional&
    reverseRate ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    reverseRate (const reverseRate_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    reverseRate (const reverseRate_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    reverseRate (::std::unique_ptr< reverseRate_type > p);

    //@}

    /**
     * @name timeCourse
     *
     * @brief Accessor and modifier functions for the %timeCourse
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::HHTime timeCourse_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< timeCourse_type > timeCourse_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< timeCourse_type, char > timeCourse_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const timeCourse_optional&
    timeCourse () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    timeCourse_optional&
    timeCourse ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    timeCourse (const timeCourse_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    timeCourse (const timeCourse_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    timeCourse (::std::unique_ptr< timeCourse_type > p);

    //@}

    /**
     * @name steadyState
     *
     * @brief Accessor and modifier functions for the %steadyState
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::HHVariable steadyState_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< steadyState_type > steadyState_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< steadyState_type, char > steadyState_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const steadyState_optional&
    steadyState () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    steadyState_optional&
    steadyState ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    steadyState (const steadyState_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    steadyState (const steadyState_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    steadyState (::std::unique_ptr< steadyState_type > p);

    //@}

    /**
     * @name subGate
     *
     * @brief Accessor and modifier functions for the %subGate
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::GateFractionalSubgate subGate_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< subGate_type > subGate_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef subGate_sequence::iterator subGate_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef subGate_sequence::const_iterator subGate_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< subGate_type, char > subGate_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const subGate_sequence&
    subGate () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    subGate_sequence&
    subGate ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    subGate (const subGate_sequence& s);

    //@}

    /**
     * @name instances
     *
     * @brief Accessor and modifier functions for the %instances
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::PositiveInteger instances_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< instances_type, char > instances_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const instances_type&
    instances () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    instances_type&
    instances ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    instances (const instances_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    instances (::std::unique_ptr< instances_type > p);

    //@}

    /**
     * @name type
     *
     * @brief Accessor and modifier functions for the %type
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::gateTypes type_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const type_type&
    type () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    type_type&
    type ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    type (const type_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    type (::std::unique_ptr< type_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    GateHHUndetermined (const id_type&,
                        const instances_type&,
                        const type_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GateHHUndetermined (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GateHHUndetermined (const GateHHUndetermined& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual GateHHUndetermined*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GateHHUndetermined&
    operator= (const GateHHUndetermined& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~GateHHUndetermined ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    notes_optional notes_;
    q10Settings_optional q10Settings_;
    forwardRate_optional forwardRate_;
    reverseRate_optional reverseRate_;
    timeCourse_optional timeCourse_;
    steadyState_optional steadyState_;
    subGate_sequence subGate_;
    ::xsd::cxx::tree::one< instances_type > instances_;
    ::xsd::cxx::tree::one< type_type > type_;

    //@endcond
  };

  bool
  operator== (const GateHHUndetermined&, const GateHHUndetermined&);

  bool
  operator!= (const GateHHUndetermined&, const GateHHUndetermined&);


  /**
   * @brief Class corresponding to the %GateHHRates schema type.
   *
   * Gate which follows the general Hodgkin Huxley formalism
   * @param instances 
   *
   * @nosubgrouping
   */
  class GateHHRates: public ::neuroml2::Base
  {
    public:
    /**
     * @name notes
     *
     * @brief Accessor and modifier functions for the %notes
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Notes notes_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< notes_type > notes_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< notes_type, char > notes_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const notes_optional&
    notes () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    notes_optional&
    notes ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    notes (const notes_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    notes (const notes_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    notes (::std::unique_ptr< notes_type > p);

    //@}

    /**
     * @name q10Settings
     *
     * @brief Accessor and modifier functions for the %q10Settings
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Q10Settings q10Settings_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< q10Settings_type > q10Settings_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< q10Settings_type, char > q10Settings_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const q10Settings_optional&
    q10Settings () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    q10Settings_optional&
    q10Settings ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    q10Settings (const q10Settings_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    q10Settings (const q10Settings_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    q10Settings (::std::unique_ptr< q10Settings_type > p);

    //@}

    /**
     * @name forwardRate
     *
     * @brief Accessor and modifier functions for the %forwardRate
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::HHRate forwardRate_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< forwardRate_type, char > forwardRate_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const forwardRate_type&
    forwardRate () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    forwardRate_type&
    forwardRate ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    forwardRate (const forwardRate_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    forwardRate (::std::unique_ptr< forwardRate_type > p);

    //@}

    /**
     * @name reverseRate
     *
     * @brief Accessor and modifier functions for the %reverseRate
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::HHRate reverseRate_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< reverseRate_type, char > reverseRate_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const reverseRate_type&
    reverseRate () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    reverseRate_type&
    reverseRate ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    reverseRate (const reverseRate_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    reverseRate (::std::unique_ptr< reverseRate_type > p);

    //@}

    /**
     * @name instances
     *
     * @brief Accessor and modifier functions for the %instances
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::PositiveInteger instances_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< instances_type, char > instances_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const instances_type&
    instances () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    instances_type&
    instances ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    instances (const instances_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    instances (::std::unique_ptr< instances_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    GateHHRates (const id_type&,
                 const forwardRate_type&,
                 const reverseRate_type&,
                 const instances_type&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    GateHHRates (const id_type&,
                 ::std::unique_ptr< forwardRate_type >,
                 ::std::unique_ptr< reverseRate_type >,
                 const instances_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GateHHRates (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GateHHRates (const GateHHRates& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual GateHHRates*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GateHHRates&
    operator= (const GateHHRates& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~GateHHRates ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    notes_optional notes_;
    q10Settings_optional q10Settings_;
    ::xsd::cxx::tree::one< forwardRate_type > forwardRate_;
    ::xsd::cxx::tree::one< reverseRate_type > reverseRate_;
    ::xsd::cxx::tree::one< instances_type > instances_;

    //@endcond
  };

  bool
  operator== (const GateHHRates&, const GateHHRates&);

  bool
  operator!= (const GateHHRates&, const GateHHRates&);


  /**
   * @brief Class corresponding to the %GateHHTauInf schema type.
   *
   * Gate which follows the general Hodgkin Huxley formalism
   * @param instances 
   *
   * @nosubgrouping
   */
  class GateHHTauInf: public ::neuroml2::Base
  {
    public:
    /**
     * @name notes
     *
     * @brief Accessor and modifier functions for the %notes
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Notes notes_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< notes_type > notes_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< notes_type, char > notes_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const notes_optional&
    notes () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    notes_optional&
    notes ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    notes (const notes_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    notes (const notes_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    notes (::std::unique_ptr< notes_type > p);

    //@}

    /**
     * @name q10Settings
     *
     * @brief Accessor and modifier functions for the %q10Settings
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Q10Settings q10Settings_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< q10Settings_type > q10Settings_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< q10Settings_type, char > q10Settings_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const q10Settings_optional&
    q10Settings () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    q10Settings_optional&
    q10Settings ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    q10Settings (const q10Settings_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    q10Settings (const q10Settings_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    q10Settings (::std::unique_ptr< q10Settings_type > p);

    //@}

    /**
     * @name timeCourse
     *
     * @brief Accessor and modifier functions for the %timeCourse
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::HHTime timeCourse_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< timeCourse_type, char > timeCourse_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const timeCourse_type&
    timeCourse () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    timeCourse_type&
    timeCourse ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    timeCourse (const timeCourse_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    timeCourse (::std::unique_ptr< timeCourse_type > p);

    //@}

    /**
     * @name steadyState
     *
     * @brief Accessor and modifier functions for the %steadyState
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::HHVariable steadyState_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< steadyState_type, char > steadyState_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const steadyState_type&
    steadyState () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    steadyState_type&
    steadyState ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    steadyState (const steadyState_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    steadyState (::std::unique_ptr< steadyState_type > p);

    //@}

    /**
     * @name instances
     *
     * @brief Accessor and modifier functions for the %instances
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::PositiveInteger instances_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< instances_type, char > instances_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const instances_type&
    instances () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    instances_type&
    instances ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    instances (const instances_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    instances (::std::unique_ptr< instances_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    GateHHTauInf (const id_type&,
                  const timeCourse_type&,
                  const steadyState_type&,
                  const instances_type&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    GateHHTauInf (const id_type&,
                  ::std::unique_ptr< timeCourse_type >,
                  ::std::unique_ptr< steadyState_type >,
                  const instances_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GateHHTauInf (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GateHHTauInf (const GateHHTauInf& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual GateHHTauInf*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GateHHTauInf&
    operator= (const GateHHTauInf& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~GateHHTauInf ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    notes_optional notes_;
    q10Settings_optional q10Settings_;
    ::xsd::cxx::tree::one< timeCourse_type > timeCourse_;
    ::xsd::cxx::tree::one< steadyState_type > steadyState_;
    ::xsd::cxx::tree::one< instances_type > instances_;

    //@endcond
  };

  bool
  operator== (const GateHHTauInf&, const GateHHTauInf&);

  bool
  operator!= (const GateHHTauInf&, const GateHHTauInf&);


  /**
   * @brief Class corresponding to the %GateHHRatesTauInf schema type.
   *
   * Gate which follows the general Hodgkin Huxley formalism
   * @param instances 
   *
   * @nosubgrouping
   */
  class GateHHRatesTauInf: public ::neuroml2::Base
  {
    public:
    /**
     * @name notes
     *
     * @brief Accessor and modifier functions for the %notes
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Notes notes_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< notes_type > notes_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< notes_type, char > notes_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const notes_optional&
    notes () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    notes_optional&
    notes ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    notes (const notes_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    notes (const notes_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    notes (::std::unique_ptr< notes_type > p);

    //@}

    /**
     * @name q10Settings
     *
     * @brief Accessor and modifier functions for the %q10Settings
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Q10Settings q10Settings_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< q10Settings_type > q10Settings_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< q10Settings_type, char > q10Settings_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const q10Settings_optional&
    q10Settings () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    q10Settings_optional&
    q10Settings ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    q10Settings (const q10Settings_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    q10Settings (const q10Settings_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    q10Settings (::std::unique_ptr< q10Settings_type > p);

    //@}

    /**
     * @name forwardRate
     *
     * @brief Accessor and modifier functions for the %forwardRate
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::HHRate forwardRate_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< forwardRate_type, char > forwardRate_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const forwardRate_type&
    forwardRate () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    forwardRate_type&
    forwardRate ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    forwardRate (const forwardRate_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    forwardRate (::std::unique_ptr< forwardRate_type > p);

    //@}

    /**
     * @name reverseRate
     *
     * @brief Accessor and modifier functions for the %reverseRate
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::HHRate reverseRate_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< reverseRate_type, char > reverseRate_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const reverseRate_type&
    reverseRate () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    reverseRate_type&
    reverseRate ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    reverseRate (const reverseRate_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    reverseRate (::std::unique_ptr< reverseRate_type > p);

    //@}

    /**
     * @name timeCourse
     *
     * @brief Accessor and modifier functions for the %timeCourse
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::HHTime timeCourse_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< timeCourse_type, char > timeCourse_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const timeCourse_type&
    timeCourse () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    timeCourse_type&
    timeCourse ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    timeCourse (const timeCourse_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    timeCourse (::std::unique_ptr< timeCourse_type > p);

    //@}

    /**
     * @name steadyState
     *
     * @brief Accessor and modifier functions for the %steadyState
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::HHVariable steadyState_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< steadyState_type, char > steadyState_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const steadyState_type&
    steadyState () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    steadyState_type&
    steadyState ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    steadyState (const steadyState_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    steadyState (::std::unique_ptr< steadyState_type > p);

    //@}

    /**
     * @name instances
     *
     * @brief Accessor and modifier functions for the %instances
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::PositiveInteger instances_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< instances_type, char > instances_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const instances_type&
    instances () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    instances_type&
    instances ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    instances (const instances_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    instances (::std::unique_ptr< instances_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    GateHHRatesTauInf (const id_type&,
                       const forwardRate_type&,
                       const reverseRate_type&,
                       const timeCourse_type&,
                       const steadyState_type&,
                       const instances_type&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    GateHHRatesTauInf (const id_type&,
                       ::std::unique_ptr< forwardRate_type >,
                       ::std::unique_ptr< reverseRate_type >,
                       ::std::unique_ptr< timeCourse_type >,
                       ::std::unique_ptr< steadyState_type >,
                       const instances_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GateHHRatesTauInf (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GateHHRatesTauInf (const GateHHRatesTauInf& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual GateHHRatesTauInf*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GateHHRatesTauInf&
    operator= (const GateHHRatesTauInf& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~GateHHRatesTauInf ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    notes_optional notes_;
    q10Settings_optional q10Settings_;
    ::xsd::cxx::tree::one< forwardRate_type > forwardRate_;
    ::xsd::cxx::tree::one< reverseRate_type > reverseRate_;
    ::xsd::cxx::tree::one< timeCourse_type > timeCourse_;
    ::xsd::cxx::tree::one< steadyState_type > steadyState_;
    ::xsd::cxx::tree::one< instances_type > instances_;

    //@endcond
  };

  bool
  operator== (const GateHHRatesTauInf&, const GateHHRatesTauInf&);

  bool
  operator!= (const GateHHRatesTauInf&, const GateHHRatesTauInf&);


  /**
   * @brief Class corresponding to the %GateHHRatesTau schema type.
   *
   * Gate which follows the general Hodgkin Huxley formalism
   * @param instances 
   *
   * @nosubgrouping
   */
  class GateHHRatesTau: public ::neuroml2::Base
  {
    public:
    /**
     * @name notes
     *
     * @brief Accessor and modifier functions for the %notes
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Notes notes_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< notes_type > notes_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< notes_type, char > notes_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const notes_optional&
    notes () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    notes_optional&
    notes ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    notes (const notes_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    notes (const notes_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    notes (::std::unique_ptr< notes_type > p);

    //@}

    /**
     * @name q10Settings
     *
     * @brief Accessor and modifier functions for the %q10Settings
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Q10Settings q10Settings_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< q10Settings_type > q10Settings_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< q10Settings_type, char > q10Settings_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const q10Settings_optional&
    q10Settings () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    q10Settings_optional&
    q10Settings ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    q10Settings (const q10Settings_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    q10Settings (const q10Settings_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    q10Settings (::std::unique_ptr< q10Settings_type > p);

    //@}

    /**
     * @name forwardRate
     *
     * @brief Accessor and modifier functions for the %forwardRate
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::HHRate forwardRate_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< forwardRate_type, char > forwardRate_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const forwardRate_type&
    forwardRate () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    forwardRate_type&
    forwardRate ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    forwardRate (const forwardRate_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    forwardRate (::std::unique_ptr< forwardRate_type > p);

    //@}

    /**
     * @name reverseRate
     *
     * @brief Accessor and modifier functions for the %reverseRate
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::HHRate reverseRate_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< reverseRate_type, char > reverseRate_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const reverseRate_type&
    reverseRate () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    reverseRate_type&
    reverseRate ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    reverseRate (const reverseRate_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    reverseRate (::std::unique_ptr< reverseRate_type > p);

    //@}

    /**
     * @name timeCourse
     *
     * @brief Accessor and modifier functions for the %timeCourse
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::HHTime timeCourse_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< timeCourse_type, char > timeCourse_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const timeCourse_type&
    timeCourse () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    timeCourse_type&
    timeCourse ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    timeCourse (const timeCourse_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    timeCourse (::std::unique_ptr< timeCourse_type > p);

    //@}

    /**
     * @name instances
     *
     * @brief Accessor and modifier functions for the %instances
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::PositiveInteger instances_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< instances_type, char > instances_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const instances_type&
    instances () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    instances_type&
    instances ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    instances (const instances_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    instances (::std::unique_ptr< instances_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    GateHHRatesTau (const id_type&,
                    const forwardRate_type&,
                    const reverseRate_type&,
                    const timeCourse_type&,
                    const instances_type&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    GateHHRatesTau (const id_type&,
                    ::std::unique_ptr< forwardRate_type >,
                    ::std::unique_ptr< reverseRate_type >,
                    ::std::unique_ptr< timeCourse_type >,
                    const instances_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GateHHRatesTau (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GateHHRatesTau (const GateHHRatesTau& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual GateHHRatesTau*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GateHHRatesTau&
    operator= (const GateHHRatesTau& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~GateHHRatesTau ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    notes_optional notes_;
    q10Settings_optional q10Settings_;
    ::xsd::cxx::tree::one< forwardRate_type > forwardRate_;
    ::xsd::cxx::tree::one< reverseRate_type > reverseRate_;
    ::xsd::cxx::tree::one< timeCourse_type > timeCourse_;
    ::xsd::cxx::tree::one< instances_type > instances_;

    //@endcond
  };

  bool
  operator== (const GateHHRatesTau&, const GateHHRatesTau&);

  bool
  operator!= (const GateHHRatesTau&, const GateHHRatesTau&);


  /**
   * @brief Class corresponding to the %GateHHRatesInf schema type.
   *
   * Gate which follows the general Hodgkin Huxley formalism
   * @param instances 
   *
   * @nosubgrouping
   */
  class GateHHRatesInf: public ::neuroml2::Base
  {
    public:
    /**
     * @name notes
     *
     * @brief Accessor and modifier functions for the %notes
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Notes notes_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< notes_type > notes_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< notes_type, char > notes_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const notes_optional&
    notes () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    notes_optional&
    notes ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    notes (const notes_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    notes (const notes_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    notes (::std::unique_ptr< notes_type > p);

    //@}

    /**
     * @name q10Settings
     *
     * @brief Accessor and modifier functions for the %q10Settings
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Q10Settings q10Settings_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< q10Settings_type > q10Settings_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< q10Settings_type, char > q10Settings_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const q10Settings_optional&
    q10Settings () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    q10Settings_optional&
    q10Settings ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    q10Settings (const q10Settings_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    q10Settings (const q10Settings_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    q10Settings (::std::unique_ptr< q10Settings_type > p);

    //@}

    /**
     * @name forwardRate
     *
     * @brief Accessor and modifier functions for the %forwardRate
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::HHRate forwardRate_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< forwardRate_type, char > forwardRate_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const forwardRate_type&
    forwardRate () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    forwardRate_type&
    forwardRate ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    forwardRate (const forwardRate_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    forwardRate (::std::unique_ptr< forwardRate_type > p);

    //@}

    /**
     * @name reverseRate
     *
     * @brief Accessor and modifier functions for the %reverseRate
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::HHRate reverseRate_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< reverseRate_type, char > reverseRate_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const reverseRate_type&
    reverseRate () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    reverseRate_type&
    reverseRate ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    reverseRate (const reverseRate_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    reverseRate (::std::unique_ptr< reverseRate_type > p);

    //@}

    /**
     * @name steadyState
     *
     * @brief Accessor and modifier functions for the %steadyState
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::HHVariable steadyState_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< steadyState_type, char > steadyState_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const steadyState_type&
    steadyState () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    steadyState_type&
    steadyState ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    steadyState (const steadyState_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    steadyState (::std::unique_ptr< steadyState_type > p);

    //@}

    /**
     * @name instances
     *
     * @brief Accessor and modifier functions for the %instances
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::PositiveInteger instances_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< instances_type, char > instances_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const instances_type&
    instances () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    instances_type&
    instances ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    instances (const instances_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    instances (::std::unique_ptr< instances_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    GateHHRatesInf (const id_type&,
                    const forwardRate_type&,
                    const reverseRate_type&,
                    const steadyState_type&,
                    const instances_type&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    GateHHRatesInf (const id_type&,
                    ::std::unique_ptr< forwardRate_type >,
                    ::std::unique_ptr< reverseRate_type >,
                    ::std::unique_ptr< steadyState_type >,
                    const instances_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GateHHRatesInf (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GateHHRatesInf (const GateHHRatesInf& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual GateHHRatesInf*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GateHHRatesInf&
    operator= (const GateHHRatesInf& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~GateHHRatesInf ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    notes_optional notes_;
    q10Settings_optional q10Settings_;
    ::xsd::cxx::tree::one< forwardRate_type > forwardRate_;
    ::xsd::cxx::tree::one< reverseRate_type > reverseRate_;
    ::xsd::cxx::tree::one< steadyState_type > steadyState_;
    ::xsd::cxx::tree::one< instances_type > instances_;

    //@endcond
  };

  bool
  operator== (const GateHHRatesInf&, const GateHHRatesInf&);

  bool
  operator!= (const GateHHRatesInf&, const GateHHRatesInf&);


  /**
   * @brief Class corresponding to the %GateHHInstantaneous schema type.
   *
   * Gate which follows the general Hodgkin Huxley formalism but is
   * instantaneous, so tau = 0 and gate follows exactly inf value
   * @param instances 
   *
   * @nosubgrouping
   */
  class GateHHInstantaneous: public ::neuroml2::Base
  {
    public:
    /**
     * @name notes
     *
     * @brief Accessor and modifier functions for the %notes
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Notes notes_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< notes_type > notes_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< notes_type, char > notes_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const notes_optional&
    notes () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    notes_optional&
    notes ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    notes (const notes_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    notes (const notes_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    notes (::std::unique_ptr< notes_type > p);

    //@}

    /**
     * @name steadyState
     *
     * @brief Accessor and modifier functions for the %steadyState
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::HHVariable steadyState_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< steadyState_type, char > steadyState_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const steadyState_type&
    steadyState () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    steadyState_type&
    steadyState ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    steadyState (const steadyState_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    steadyState (::std::unique_ptr< steadyState_type > p);

    //@}

    /**
     * @name instances
     *
     * @brief Accessor and modifier functions for the %instances
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::PositiveInteger instances_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< instances_type, char > instances_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const instances_type&
    instances () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    instances_type&
    instances ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    instances (const instances_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    instances (::std::unique_ptr< instances_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    GateHHInstantaneous (const id_type&,
                         const steadyState_type&,
                         const instances_type&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    GateHHInstantaneous (const id_type&,
                         ::std::unique_ptr< steadyState_type >,
                         const instances_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GateHHInstantaneous (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GateHHInstantaneous (const GateHHInstantaneous& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual GateHHInstantaneous*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GateHHInstantaneous&
    operator= (const GateHHInstantaneous& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~GateHHInstantaneous ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    notes_optional notes_;
    ::xsd::cxx::tree::one< steadyState_type > steadyState_;
    ::xsd::cxx::tree::one< instances_type > instances_;

    //@endcond
  };

  bool
  operator== (const GateHHInstantaneous&, const GateHHInstantaneous&);

  bool
  operator!= (const GateHHInstantaneous&, const GateHHInstantaneous&);


  /**
   * @brief Class corresponding to the %GateFractional schema type.
   *
   * Gate composed of subgates contributing with fractional conductance
   * @param instances 
   *
   * @nosubgrouping
   */
  class GateFractional: public ::neuroml2::Base
  {
    public:
    /**
     * @name notes
     *
     * @brief Accessor and modifier functions for the %notes
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Notes notes_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< notes_type > notes_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< notes_type, char > notes_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const notes_optional&
    notes () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    notes_optional&
    notes ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    notes (const notes_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    notes (const notes_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    notes (::std::unique_ptr< notes_type > p);

    //@}

    /**
     * @name q10Settings
     *
     * @brief Accessor and modifier functions for the %q10Settings
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Q10Settings q10Settings_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< q10Settings_type > q10Settings_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< q10Settings_type, char > q10Settings_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const q10Settings_optional&
    q10Settings () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    q10Settings_optional&
    q10Settings ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    q10Settings (const q10Settings_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    q10Settings (const q10Settings_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    q10Settings (::std::unique_ptr< q10Settings_type > p);

    //@}

    /**
     * @name subGate
     *
     * @brief Accessor and modifier functions for the %subGate
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::GateFractionalSubgate subGate_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< subGate_type > subGate_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef subGate_sequence::iterator subGate_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef subGate_sequence::const_iterator subGate_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< subGate_type, char > subGate_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const subGate_sequence&
    subGate () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    subGate_sequence&
    subGate ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    subGate (const subGate_sequence& s);

    //@}

    /**
     * @name instances
     *
     * @brief Accessor and modifier functions for the %instances
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::PositiveInteger instances_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< instances_type, char > instances_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const instances_type&
    instances () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    instances_type&
    instances ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    instances (const instances_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    instances (::std::unique_ptr< instances_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    GateFractional (const id_type&,
                    const instances_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GateFractional (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GateFractional (const GateFractional& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual GateFractional*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GateFractional&
    operator= (const GateFractional& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~GateFractional ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    notes_optional notes_;
    q10Settings_optional q10Settings_;
    subGate_sequence subGate_;
    ::xsd::cxx::tree::one< instances_type > instances_;

    //@endcond
  };

  bool
  operator== (const GateFractional&, const GateFractional&);

  bool
  operator!= (const GateFractional&, const GateFractional&);


  /**
   * @brief Class corresponding to the %GateFractionalSubgate schema type.
   *
   * @nosubgrouping
   */
  class GateFractionalSubgate: public ::neuroml2::Base
  {
    public:
    /**
     * @name notes
     *
     * @brief Accessor and modifier functions for the %notes
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Notes notes_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< notes_type > notes_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< notes_type, char > notes_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const notes_optional&
    notes () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    notes_optional&
    notes ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    notes (const notes_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    notes (const notes_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    notes (::std::unique_ptr< notes_type > p);

    //@}

    /**
     * @name q10Settings
     *
     * @brief Accessor and modifier functions for the %q10Settings
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Q10Settings q10Settings_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< q10Settings_type > q10Settings_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< q10Settings_type, char > q10Settings_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const q10Settings_optional&
    q10Settings () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    q10Settings_optional&
    q10Settings ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    q10Settings (const q10Settings_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    q10Settings (const q10Settings_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    q10Settings (::std::unique_ptr< q10Settings_type > p);

    //@}

    /**
     * @name steadyState
     *
     * @brief Accessor and modifier functions for the %steadyState
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::HHVariable steadyState_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< steadyState_type, char > steadyState_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const steadyState_type&
    steadyState () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    steadyState_type&
    steadyState ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    steadyState (const steadyState_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    steadyState (::std::unique_ptr< steadyState_type > p);

    //@}

    /**
     * @name timeCourse
     *
     * @brief Accessor and modifier functions for the %timeCourse
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::HHTime timeCourse_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< timeCourse_type, char > timeCourse_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const timeCourse_type&
    timeCourse () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    timeCourse_type&
    timeCourse ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    timeCourse (const timeCourse_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    timeCourse (::std::unique_ptr< timeCourse_type > p);

    //@}

    /**
     * @name fractionalConductance
     *
     * @brief Accessor and modifier functions for the %fractionalConductance
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none fractionalConductance_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< fractionalConductance_type, char > fractionalConductance_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const fractionalConductance_type&
    fractionalConductance () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    fractionalConductance_type&
    fractionalConductance ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    fractionalConductance (const fractionalConductance_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    fractionalConductance (::std::unique_ptr< fractionalConductance_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    GateFractionalSubgate (const id_type&,
                           const steadyState_type&,
                           const timeCourse_type&,
                           const fractionalConductance_type&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    GateFractionalSubgate (const id_type&,
                           ::std::unique_ptr< steadyState_type >,
                           ::std::unique_ptr< timeCourse_type >,
                           const fractionalConductance_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GateFractionalSubgate (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GateFractionalSubgate (const GateFractionalSubgate& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual GateFractionalSubgate*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GateFractionalSubgate&
    operator= (const GateFractionalSubgate& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~GateFractionalSubgate ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    notes_optional notes_;
    q10Settings_optional q10Settings_;
    ::xsd::cxx::tree::one< steadyState_type > steadyState_;
    ::xsd::cxx::tree::one< timeCourse_type > timeCourse_;
    ::xsd::cxx::tree::one< fractionalConductance_type > fractionalConductance_;

    //@endcond
  };

  bool
  operator== (const GateFractionalSubgate&, const GateFractionalSubgate&);

  bool
  operator!= (const GateFractionalSubgate&, const GateFractionalSubgate&);


  /**
   * @brief Class corresponding to the %Q10Settings schema type.
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name type
     *
     * @brief Accessor and modifier functions for the %type
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId type_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const type_type&
    type () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    type_type&
    type ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    type (const type_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    type (::std::unique_ptr< type_type > p);

    //@}

    /**
     * @name fixedQ10
     *
     * @brief Accessor and modifier functions for the %fixedQ10
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none fixedQ10_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< fixedQ10_type > fixedQ10_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< fixedQ10_type, char > fixedQ10_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const fixedQ10_optional&
    fixedQ10 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    fixedQ10_optional&
    fixedQ10 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    fixedQ10 (const fixedQ10_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    fixedQ10 (const fixedQ10_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    fixedQ10 (::std::unique_ptr< fixedQ10_type > p);

    //@}

    /**
     * @name q10Factor
     *
     * @brief Accessor and modifier functions for the %q10Factor
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none q10Factor_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< q10Factor_type > q10Factor_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< q10Factor_type, char > q10Factor_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const q10Factor_optional&
    q10Factor () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    q10Factor_optional&
    q10Factor ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    q10Factor (const q10Factor_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    q10Factor (const q10Factor_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    q10Factor (::std::unique_ptr< q10Factor_type > p);

    //@}

    /**
     * @name experimentalTemp
     *
     * @brief Accessor and modifier functions for the %experimentalTemp
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_temperature experimentalTemp_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< experimentalTemp_type > experimentalTemp_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< experimentalTemp_type, char > experimentalTemp_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const experimentalTemp_optional&
    experimentalTemp () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    experimentalTemp_optional&
    experimentalTemp ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    experimentalTemp (const experimentalTemp_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    experimentalTemp (const experimentalTemp_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    experimentalTemp (::std::unique_ptr< experimentalTemp_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Q10Settings (const type_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Q10Settings (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Q10Settings (const Q10Settings& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Q10Settings*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Q10Settings&
    operator= (const Q10Settings& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Q10Settings ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< type_type > type_;
    fixedQ10_optional fixedQ10_;
    q10Factor_optional q10Factor_;
    experimentalTemp_optional experimentalTemp_;

    //@endcond
  };

  bool
  operator== (const Q10Settings&, const Q10Settings&);

  bool
  operator!= (const Q10Settings&, const Q10Settings&);


  /**
   * @brief Class corresponding to the %HHRate schema type.
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name type
     *
     * @brief Accessor and modifier functions for the %type
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId type_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const type_type&
    type () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    type_type&
    type ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    type (const type_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    type (::std::unique_ptr< type_type > p);

    //@}

    /**
     * @name rate
     *
     * @brief Accessor and modifier functions for the %rate
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_pertime rate_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< rate_type > rate_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< rate_type, char > rate_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const rate_optional&
    rate () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    rate_optional&
    rate ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    rate (const rate_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    rate (const rate_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    rate (::std::unique_ptr< rate_type > p);

    //@}

    /**
     * @name midpoint
     *
     * @brief Accessor and modifier functions for the %midpoint
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage midpoint_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< midpoint_type > midpoint_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< midpoint_type, char > midpoint_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const midpoint_optional&
    midpoint () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    midpoint_optional&
    midpoint ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    midpoint (const midpoint_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    midpoint (const midpoint_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    midpoint (::std::unique_ptr< midpoint_type > p);

    //@}

    /**
     * @name scale
     *
     * @brief Accessor and modifier functions for the %scale
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage scale_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< scale_type > scale_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< scale_type, char > scale_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const scale_optional&
    scale () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    scale_optional&
    scale ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    scale (const scale_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    scale (const scale_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    scale (::std::unique_ptr< scale_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HHRate (const type_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HHRate (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HHRate (const HHRate& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HHRate*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HHRate&
    operator= (const HHRate& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HHRate ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< type_type > type_;
    rate_optional rate_;
    midpoint_optional midpoint_;
    scale_optional scale_;

    //@endcond
  };

  bool
  operator== (const HHRate&, const HHRate&);

  bool
  operator!= (const HHRate&, const HHRate&);


  /**
   * @brief Class corresponding to the %HHVariable schema type.
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name type
     *
     * @brief Accessor and modifier functions for the %type
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId type_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const type_type&
    type () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    type_type&
    type ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    type (const type_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    type (::std::unique_ptr< type_type > p);

    //@}

    /**
     * @name rate
     *
     * @brief Accessor and modifier functions for the %rate
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ rate_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< rate_type > rate_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< rate_type, char > rate_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const rate_optional&
    rate () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    rate_optional&
    rate ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    rate (const rate_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    rate (const rate_optional& x);

    //@}

    /**
     * @name midpoint
     *
     * @brief Accessor and modifier functions for the %midpoint
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage midpoint_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< midpoint_type > midpoint_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< midpoint_type, char > midpoint_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const midpoint_optional&
    midpoint () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    midpoint_optional&
    midpoint ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    midpoint (const midpoint_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    midpoint (const midpoint_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    midpoint (::std::unique_ptr< midpoint_type > p);

    //@}

    /**
     * @name scale
     *
     * @brief Accessor and modifier functions for the %scale
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage scale_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< scale_type > scale_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< scale_type, char > scale_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const scale_optional&
    scale () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    scale_optional&
    scale ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    scale (const scale_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    scale (const scale_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    scale (::std::unique_ptr< scale_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HHVariable (const type_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HHVariable (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HHVariable (const HHVariable& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HHVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HHVariable&
    operator= (const HHVariable& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HHVariable ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< type_type > type_;
    rate_optional rate_;
    midpoint_optional midpoint_;
    scale_optional scale_;

    //@endcond
  };

  bool
  operator== (const HHVariable&, const HHVariable&);

  bool
  operator!= (const HHVariable&, const HHVariable&);


  /**
   * @brief Class corresponding to the %HHTime schema type.
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name type
     *
     * @brief Accessor and modifier functions for the %type
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId type_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const type_type&
    type () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    type_type&
    type ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    type (const type_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    type (::std::unique_ptr< type_type > p);

    //@}

    /**
     * @name rate
     *
     * @brief Accessor and modifier functions for the %rate
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time rate_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< rate_type > rate_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< rate_type, char > rate_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const rate_optional&
    rate () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    rate_optional&
    rate ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    rate (const rate_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    rate (const rate_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    rate (::std::unique_ptr< rate_type > p);

    //@}

    /**
     * @name midpoint
     *
     * @brief Accessor and modifier functions for the %midpoint
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage midpoint_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< midpoint_type > midpoint_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< midpoint_type, char > midpoint_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const midpoint_optional&
    midpoint () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    midpoint_optional&
    midpoint ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    midpoint (const midpoint_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    midpoint (const midpoint_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    midpoint (::std::unique_ptr< midpoint_type > p);

    //@}

    /**
     * @name scale
     *
     * @brief Accessor and modifier functions for the %scale
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage scale_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< scale_type > scale_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< scale_type, char > scale_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const scale_optional&
    scale () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    scale_optional&
    scale ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    scale (const scale_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    scale (const scale_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    scale (::std::unique_ptr< scale_type > p);

    //@}

    /**
     * @name tau
     *
     * @brief Accessor and modifier functions for the %tau
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time tau_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< tau_type > tau_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< tau_type, char > tau_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const tau_optional&
    tau () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    tau_optional&
    tau ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    tau (const tau_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    tau (const tau_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    tau (::std::unique_ptr< tau_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HHTime (const type_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HHTime (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HHTime (const HHTime& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HHTime*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HHTime&
    operator= (const HHTime& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HHTime ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< type_type > type_;
    rate_optional rate_;
    midpoint_optional midpoint_;
    scale_optional scale_;
    tau_optional tau_;

    //@endcond
  };

  bool
  operator== (const HHTime&, const HHTime&);

  bool
  operator!= (const HHTime&, const HHTime&);


  /**
   * @brief Class corresponding to the %DecayingPoolConcentrationModel schema type.
   *
   * Model of an intracellular buffering mechanism for **ion**  ( currently
   * hard Coded to be calcium, due to requirement for **iCa**  ) which has
   * a baseline level **restingConc**  and tends to this value with time
   * course **decayConstant.**  The ion is assumed to occupy a shell inside
   * the membrane of thickness **shellThickness.**
   * @param restingConc 
   * @param decayConstant 
   * @param shellThickness 
   *
   * @nosubgrouping
   */
  class DecayingPoolConcentrationModel: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name ion
     *
     * @brief Accessor and modifier functions for the %ion
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId ion_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ion_type, char > ion_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ion_type&
    ion () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ion_type&
    ion ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    ion (const ion_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    ion (::std::unique_ptr< ion_type > p);

    //@}

    /**
     * @name restingConc
     *
     * @brief Accessor and modifier functions for the %restingConc
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_concentration restingConc_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< restingConc_type, char > restingConc_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const restingConc_type&
    restingConc () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    restingConc_type&
    restingConc ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    restingConc (const restingConc_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    restingConc (::std::unique_ptr< restingConc_type > p);

    //@}

    /**
     * @name decayConstant
     *
     * @brief Accessor and modifier functions for the %decayConstant
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time decayConstant_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< decayConstant_type, char > decayConstant_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const decayConstant_type&
    decayConstant () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    decayConstant_type&
    decayConstant ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    decayConstant (const decayConstant_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    decayConstant (::std::unique_ptr< decayConstant_type > p);

    //@}

    /**
     * @name shellThickness
     *
     * @brief Accessor and modifier functions for the %shellThickness
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_length shellThickness_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< shellThickness_type, char > shellThickness_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const shellThickness_type&
    shellThickness () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    shellThickness_type&
    shellThickness ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    shellThickness (const shellThickness_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    shellThickness (::std::unique_ptr< shellThickness_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DecayingPoolConcentrationModel (const id_type&,
                                    const ion_type&,
                                    const restingConc_type&,
                                    const decayConstant_type&,
                                    const shellThickness_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DecayingPoolConcentrationModel (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DecayingPoolConcentrationModel (const DecayingPoolConcentrationModel& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DecayingPoolConcentrationModel*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DecayingPoolConcentrationModel&
    operator= (const DecayingPoolConcentrationModel& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DecayingPoolConcentrationModel ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< ion_type > ion_;
    ::xsd::cxx::tree::one< restingConc_type > restingConc_;
    ::xsd::cxx::tree::one< decayConstant_type > decayConstant_;
    ::xsd::cxx::tree::one< shellThickness_type > shellThickness_;

    //@endcond
  };

  bool
  operator== (const DecayingPoolConcentrationModel&, const DecayingPoolConcentrationModel&);

  bool
  operator!= (const DecayingPoolConcentrationModel&, const DecayingPoolConcentrationModel&);


  /**
   * @brief Class corresponding to the %FixedFactorConcentrationModel schema type.
   *
   * Model of buffering of concentration of an ion ( currently hard coded
   * to be calcium, due to requirement for **iCa**  ) which has a baseline
   * level **restingConc**  and tends to this value with time course
   * **decayConstant.**  A fixed factor **rho**  is used to scale the
   * incoming current *independently of the size of the compartment* to
   * produce a concentration change.
   * @param restingConc 
   * @param decayConstant 
   * @param rho 
   *
   * @nosubgrouping
   */
  class FixedFactorConcentrationModel: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name ion
     *
     * @brief Accessor and modifier functions for the %ion
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId ion_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ion_type, char > ion_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ion_type&
    ion () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ion_type&
    ion ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    ion (const ion_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    ion (::std::unique_ptr< ion_type > p);

    //@}

    /**
     * @name restingConc
     *
     * @brief Accessor and modifier functions for the %restingConc
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_concentration restingConc_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< restingConc_type, char > restingConc_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const restingConc_type&
    restingConc () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    restingConc_type&
    restingConc ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    restingConc (const restingConc_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    restingConc (::std::unique_ptr< restingConc_type > p);

    //@}

    /**
     * @name decayConstant
     *
     * @brief Accessor and modifier functions for the %decayConstant
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time decayConstant_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< decayConstant_type, char > decayConstant_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const decayConstant_type&
    decayConstant () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    decayConstant_type&
    decayConstant ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    decayConstant (const decayConstant_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    decayConstant (::std::unique_ptr< decayConstant_type > p);

    //@}

    /**
     * @name rho
     *
     * @brief Accessor and modifier functions for the %rho
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_rhoFactor rho_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< rho_type, char > rho_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const rho_type&
    rho () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    rho_type&
    rho ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    rho (const rho_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    rho (::std::unique_ptr< rho_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    FixedFactorConcentrationModel (const id_type&,
                                   const ion_type&,
                                   const restingConc_type&,
                                   const decayConstant_type&,
                                   const rho_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    FixedFactorConcentrationModel (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    FixedFactorConcentrationModel (const FixedFactorConcentrationModel& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual FixedFactorConcentrationModel*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    FixedFactorConcentrationModel&
    operator= (const FixedFactorConcentrationModel& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~FixedFactorConcentrationModel ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< ion_type > ion_;
    ::xsd::cxx::tree::one< restingConc_type > restingConc_;
    ::xsd::cxx::tree::one< decayConstant_type > decayConstant_;
    ::xsd::cxx::tree::one< rho_type > rho_;

    //@endcond
  };

  bool
  operator== (const FixedFactorConcentrationModel&, const FixedFactorConcentrationModel&);

  bool
  operator!= (const FixedFactorConcentrationModel&, const FixedFactorConcentrationModel&);


  /**
   * @brief Class corresponding to the %BaseSynapse schema type.
   *
   * Base type for all synapses, i. e. ComponentTypes which produce a
   * current ( dimension current ) and change Dynamics in response to an
   * incoming event. cno_0000009
   *
   * @nosubgrouping
   */
  class BaseSynapse: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BaseSynapse (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BaseSynapse (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BaseSynapse (const BaseSynapse& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BaseSynapse*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BaseSynapse ();
  };

  /**
   * @brief Class corresponding to the %BaseVoltageDepSynapse schema type.
   *
   * Base type for synapses with a dependence on membrane potential
   *
   * @nosubgrouping
   */
  class BaseVoltageDepSynapse: public ::neuroml2::BaseSynapse
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BaseVoltageDepSynapse (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BaseVoltageDepSynapse (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BaseVoltageDepSynapse (const BaseVoltageDepSynapse& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BaseVoltageDepSynapse*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BaseVoltageDepSynapse ();
  };

  /**
   * @brief Class corresponding to the %BaseCurrentBasedSynapse schema type.
   *
   * Synapse model which produces a synaptic current.
   *
   * @nosubgrouping
   */
  class BaseCurrentBasedSynapse: public ::neuroml2::BaseSynapse
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BaseCurrentBasedSynapse (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BaseCurrentBasedSynapse (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BaseCurrentBasedSynapse (const BaseCurrentBasedSynapse& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BaseCurrentBasedSynapse*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BaseCurrentBasedSynapse ();
  };

  /**
   * @brief Class corresponding to the %BaseConductanceBasedSynapse schema type.
   *
   * Synapse model which exposes a conductance **g**  in addition to
   * producing a current. Not necessarily ohmic!! cno_0000027
   * @param gbase Baseline conductance, generally the maximum conductance
   * following a single spike
   * @param erev Reversal potential of the synapse
   *
   * @nosubgrouping
   */
  class BaseConductanceBasedSynapse: public ::neuroml2::BaseVoltageDepSynapse
  {
    public:
    /**
     * @name gbase
     *
     * @brief Accessor and modifier functions for the %gbase
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductance gbase_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< gbase_type, char > gbase_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const gbase_type&
    gbase () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    gbase_type&
    gbase ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    gbase (const gbase_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    gbase (::std::unique_ptr< gbase_type > p);

    //@}

    /**
     * @name erev
     *
     * @brief Accessor and modifier functions for the %erev
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage erev_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< erev_type, char > erev_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const erev_type&
    erev () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    erev_type&
    erev ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    erev (const erev_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    erev (::std::unique_ptr< erev_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BaseConductanceBasedSynapse (const id_type&,
                                 const gbase_type&,
                                 const erev_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BaseConductanceBasedSynapse (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BaseConductanceBasedSynapse (const BaseConductanceBasedSynapse& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BaseConductanceBasedSynapse*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BaseConductanceBasedSynapse&
    operator= (const BaseConductanceBasedSynapse& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BaseConductanceBasedSynapse ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< gbase_type > gbase_;
    ::xsd::cxx::tree::one< erev_type > erev_;

    //@endcond
  };

  bool
  operator== (const BaseConductanceBasedSynapse&, const BaseConductanceBasedSynapse&);

  bool
  operator!= (const BaseConductanceBasedSynapse&, const BaseConductanceBasedSynapse&);


  /**
   * @brief Class corresponding to the %BaseConductanceBasedSynapseTwo schema type.
   *
   * Synapse model suited for a sum of two expTwoSynapses which exposes a
   * conductance **g**  in addition to producing a current. Not necessarily
   * ohmic!! cno_0000027
   * @param gbase1 Baseline conductance 1
   * @param gbase2 Baseline conductance 2
   * @param erev Reversal potential of the synapse
   *
   * @nosubgrouping
   */
  class BaseConductanceBasedSynapseTwo: public ::neuroml2::BaseVoltageDepSynapse
  {
    public:
    /**
     * @name gbase1
     *
     * @brief Accessor and modifier functions for the %gbase1
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductance gbase1_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< gbase1_type, char > gbase1_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const gbase1_type&
    gbase1 () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    gbase1_type&
    gbase1 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    gbase1 (const gbase1_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    gbase1 (::std::unique_ptr< gbase1_type > p);

    //@}

    /**
     * @name gbase2
     *
     * @brief Accessor and modifier functions for the %gbase2
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductance gbase2_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< gbase2_type, char > gbase2_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const gbase2_type&
    gbase2 () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    gbase2_type&
    gbase2 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    gbase2 (const gbase2_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    gbase2 (::std::unique_ptr< gbase2_type > p);

    //@}

    /**
     * @name erev
     *
     * @brief Accessor and modifier functions for the %erev
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage erev_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< erev_type, char > erev_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const erev_type&
    erev () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    erev_type&
    erev ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    erev (const erev_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    erev (::std::unique_ptr< erev_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BaseConductanceBasedSynapseTwo (const id_type&,
                                    const gbase1_type&,
                                    const gbase2_type&,
                                    const erev_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BaseConductanceBasedSynapseTwo (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BaseConductanceBasedSynapseTwo (const BaseConductanceBasedSynapseTwo& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BaseConductanceBasedSynapseTwo*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BaseConductanceBasedSynapseTwo&
    operator= (const BaseConductanceBasedSynapseTwo& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BaseConductanceBasedSynapseTwo ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< gbase1_type > gbase1_;
    ::xsd::cxx::tree::one< gbase2_type > gbase2_;
    ::xsd::cxx::tree::one< erev_type > erev_;

    //@endcond
  };

  bool
  operator== (const BaseConductanceBasedSynapseTwo&, const BaseConductanceBasedSynapseTwo&);

  bool
  operator!= (const BaseConductanceBasedSynapseTwo&, const BaseConductanceBasedSynapseTwo&);


  /**
   * @brief Class corresponding to the %GapJunction schema type.
   *
   * Gap junction/single electrical connection
   * @param conductance 
   *
   * @nosubgrouping
   */
  class GapJunction: public ::neuroml2::BaseSynapse
  {
    public:
    /**
     * @name conductance
     *
     * @brief Accessor and modifier functions for the %conductance
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductance conductance_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< conductance_type, char > conductance_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const conductance_type&
    conductance () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    conductance_type&
    conductance ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    conductance (const conductance_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    conductance (::std::unique_ptr< conductance_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    GapJunction (const id_type&,
                 const conductance_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GapJunction (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GapJunction (const GapJunction& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual GapJunction*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GapJunction&
    operator= (const GapJunction& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~GapJunction ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< conductance_type > conductance_;

    //@endcond
  };

  bool
  operator== (const GapJunction&, const GapJunction&);

  bool
  operator!= (const GapJunction&, const GapJunction&);


  /**
   * @brief Class corresponding to the %SilentSynapse schema type.
   *
   * Dummy synapse which emits no current. Used as presynaptic endpoint for
   * analog synaptic connection.
   *
   * @nosubgrouping
   */
  class SilentSynapse: public ::neuroml2::BaseSynapse
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SilentSynapse (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SilentSynapse (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SilentSynapse (const SilentSynapse& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SilentSynapse*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SilentSynapse ();
  };

  /**
   * @brief Class corresponding to the %LinearGradedSynapse schema type.
   *
   * Behaves just like a one way gap junction.
   * @param conductance 
   *
   * @nosubgrouping
   */
  class LinearGradedSynapse: public ::neuroml2::BaseSynapse
  {
    public:
    /**
     * @name conductance
     *
     * @brief Accessor and modifier functions for the %conductance
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductance conductance_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< conductance_type, char > conductance_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const conductance_type&
    conductance () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    conductance_type&
    conductance ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    conductance (const conductance_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    conductance (::std::unique_ptr< conductance_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LinearGradedSynapse (const id_type&,
                         const conductance_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LinearGradedSynapse (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LinearGradedSynapse (const LinearGradedSynapse& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LinearGradedSynapse*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LinearGradedSynapse&
    operator= (const LinearGradedSynapse& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LinearGradedSynapse ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< conductance_type > conductance_;

    //@endcond
  };

  bool
  operator== (const LinearGradedSynapse&, const LinearGradedSynapse&);

  bool
  operator!= (const LinearGradedSynapse&, const LinearGradedSynapse&);


  /**
   * @brief Class corresponding to the %GradedSynapse schema type.
   *
   * Graded/analog synapse. Based on synapse in Methods of http://www.
   * nature.com/neuro/journal/v7/n12/abs/nn1352.html
   * @param conductance 
   * @param delta Slope of the activation curve
   * @param k Rate constant for transmitter-receptor dissociation rate
   * @param Vth The half-activation voltage of the synapse
   * @param erev The reversal potential of the synapse
   *
   * @nosubgrouping
   */
  class GradedSynapse: public ::neuroml2::BaseSynapse
  {
    public:
    /**
     * @name conductance
     *
     * @brief Accessor and modifier functions for the %conductance
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductance conductance_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< conductance_type, char > conductance_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const conductance_type&
    conductance () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    conductance_type&
    conductance ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    conductance (const conductance_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    conductance (::std::unique_ptr< conductance_type > p);

    //@}

    /**
     * @name delta
     *
     * @brief Accessor and modifier functions for the %delta
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage delta_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< delta_type, char > delta_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const delta_type&
    delta () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    delta_type&
    delta ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    delta (const delta_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    delta (::std::unique_ptr< delta_type > p);

    //@}

    /**
     * @name Vth
     *
     * @brief Accessor and modifier functions for the %Vth
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage Vth_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Vth_type, char > Vth_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const Vth_type&
    Vth () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    Vth_type&
    Vth ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    Vth (const Vth_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    Vth (::std::unique_ptr< Vth_type > p);

    //@}

    /**
     * @name k
     *
     * @brief Accessor and modifier functions for the %k
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_pertime k_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< k_type, char > k_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const k_type&
    k () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    k_type&
    k ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    k (const k_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    k (::std::unique_ptr< k_type > p);

    //@}

    /**
     * @name erev
     *
     * @brief Accessor and modifier functions for the %erev
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage erev_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< erev_type, char > erev_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const erev_type&
    erev () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    erev_type&
    erev ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    erev (const erev_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    erev (::std::unique_ptr< erev_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    GradedSynapse (const id_type&,
                   const conductance_type&,
                   const delta_type&,
                   const Vth_type&,
                   const k_type&,
                   const erev_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GradedSynapse (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GradedSynapse (const GradedSynapse& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual GradedSynapse*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GradedSynapse&
    operator= (const GradedSynapse& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~GradedSynapse ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< conductance_type > conductance_;
    ::xsd::cxx::tree::one< delta_type > delta_;
    ::xsd::cxx::tree::one< Vth_type > Vth_;
    ::xsd::cxx::tree::one< k_type > k_;
    ::xsd::cxx::tree::one< erev_type > erev_;

    //@endcond
  };

  bool
  operator== (const GradedSynapse&, const GradedSynapse&);

  bool
  operator!= (const GradedSynapse&, const GradedSynapse&);


  /**
   * @brief Class corresponding to the %AlphaCurrentSynapse schema type.
   *
   * Alpha current synapse: rise time and decay time are both **tau.**
   * @param tau Time course for rise and decay
   * @param ibase Baseline current increase after receiving a spike
   *
   * @nosubgrouping
   */
  class AlphaCurrentSynapse: public ::neuroml2::BaseCurrentBasedSynapse
  {
    public:
    /**
     * @name tau
     *
     * @brief Accessor and modifier functions for the %tau
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time tau_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< tau_type, char > tau_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const tau_type&
    tau () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    tau_type&
    tau ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    tau (const tau_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    tau (::std::unique_ptr< tau_type > p);

    //@}

    /**
     * @name ibase
     *
     * @brief Accessor and modifier functions for the %ibase
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_current ibase_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ibase_type, char > ibase_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ibase_type&
    ibase () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ibase_type&
    ibase ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    ibase (const ibase_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    ibase (::std::unique_ptr< ibase_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AlphaCurrentSynapse (const id_type&,
                         const tau_type&,
                         const ibase_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlphaCurrentSynapse (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlphaCurrentSynapse (const AlphaCurrentSynapse& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AlphaCurrentSynapse*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlphaCurrentSynapse&
    operator= (const AlphaCurrentSynapse& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AlphaCurrentSynapse ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< tau_type > tau_;
    ::xsd::cxx::tree::one< ibase_type > ibase_;

    //@endcond
  };

  bool
  operator== (const AlphaCurrentSynapse&, const AlphaCurrentSynapse&);

  bool
  operator!= (const AlphaCurrentSynapse&, const AlphaCurrentSynapse&);


  /**
   * @brief Class corresponding to the %AlphaSynapse schema type.
   *
   * Ohmic synapse model where rise time and decay time are both **tau.** 
   * Max conductance reached during this time ( assuming zero conductance
   * before ) is **gbase**  * **weight.**
   * @param tau Time course of rise/decay
   * @param gbase Baseline conductance, generally the maximum conductance
   * following a single spike
   * @param erev Reversal potential of the synapse
   *
   * @nosubgrouping
   */
  class AlphaSynapse: public ::neuroml2::BaseConductanceBasedSynapse
  {
    public:
    /**
     * @name tau
     *
     * @brief Accessor and modifier functions for the %tau
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time tau_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< tau_type, char > tau_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const tau_type&
    tau () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    tau_type&
    tau ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    tau (const tau_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    tau (::std::unique_ptr< tau_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AlphaSynapse (const id_type&,
                  const gbase_type&,
                  const erev_type&,
                  const tau_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlphaSynapse (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlphaSynapse (const AlphaSynapse& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AlphaSynapse*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlphaSynapse&
    operator= (const AlphaSynapse& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AlphaSynapse ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< tau_type > tau_;

    //@endcond
  };

  bool
  operator== (const AlphaSynapse&, const AlphaSynapse&);

  bool
  operator!= (const AlphaSynapse&, const AlphaSynapse&);


  /**
   * @brief Class corresponding to the %ExpOneSynapse schema type.
   *
   * Ohmic synapse model whose conductance rises instantaneously by (
   * **gbase**  * **weight**  ) on receiving an event, and which decays
   * exponentially to zero with time course **tauDecay**
   * @param tauDecay Time course of decay
   * @param gbase Baseline conductance, generally the maximum conductance
   * following a single spike
   * @param erev Reversal potential of the synapse
   *
   * @nosubgrouping
   */
  class ExpOneSynapse: public ::neuroml2::BaseConductanceBasedSynapse
  {
    public:
    /**
     * @name tauDecay
     *
     * @brief Accessor and modifier functions for the %tauDecay
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time tauDecay_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< tauDecay_type, char > tauDecay_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const tauDecay_type&
    tauDecay () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    tauDecay_type&
    tauDecay ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    tauDecay (const tauDecay_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    tauDecay (::std::unique_ptr< tauDecay_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ExpOneSynapse (const id_type&,
                   const gbase_type&,
                   const erev_type&,
                   const tauDecay_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ExpOneSynapse (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ExpOneSynapse (const ExpOneSynapse& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ExpOneSynapse*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ExpOneSynapse&
    operator= (const ExpOneSynapse& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ExpOneSynapse ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< tauDecay_type > tauDecay_;

    //@endcond
  };

  bool
  operator== (const ExpOneSynapse&, const ExpOneSynapse&);

  bool
  operator!= (const ExpOneSynapse&, const ExpOneSynapse&);


  /**
   * @brief Class corresponding to the %ExpTwoSynapse schema type.
   *
   * Ohmic synapse model whose conductance waveform on receiving an event
   * has a rise time of **tauRise**  and a decay time of **tauDecay.**  Max
   * conductance reached during this time ( assuming zero conductance
   * before ) is **gbase**  * **weight.**
   * @param tauRise 
   * @param tauDecay 
   * @param gbase Baseline conductance, generally the maximum conductance
   * following a single spike
   * @param erev Reversal potential of the synapse
   *
   * @nosubgrouping
   */
  class ExpTwoSynapse: public ::neuroml2::BaseConductanceBasedSynapse
  {
    public:
    /**
     * @name tauDecay
     *
     * @brief Accessor and modifier functions for the %tauDecay
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time tauDecay_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< tauDecay_type, char > tauDecay_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const tauDecay_type&
    tauDecay () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    tauDecay_type&
    tauDecay ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    tauDecay (const tauDecay_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    tauDecay (::std::unique_ptr< tauDecay_type > p);

    //@}

    /**
     * @name tauRise
     *
     * @brief Accessor and modifier functions for the %tauRise
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time tauRise_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< tauRise_type, char > tauRise_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const tauRise_type&
    tauRise () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    tauRise_type&
    tauRise ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    tauRise (const tauRise_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    tauRise (::std::unique_ptr< tauRise_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ExpTwoSynapse (const id_type&,
                   const gbase_type&,
                   const erev_type&,
                   const tauDecay_type&,
                   const tauRise_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ExpTwoSynapse (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ExpTwoSynapse (const ExpTwoSynapse& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ExpTwoSynapse*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ExpTwoSynapse&
    operator= (const ExpTwoSynapse& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ExpTwoSynapse ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< tauDecay_type > tauDecay_;
    ::xsd::cxx::tree::one< tauRise_type > tauRise_;

    //@endcond
  };

  bool
  operator== (const ExpTwoSynapse&, const ExpTwoSynapse&);

  bool
  operator!= (const ExpTwoSynapse&, const ExpTwoSynapse&);


  /**
   * @brief Class corresponding to the %ExpThreeSynapse schema type.
   *
   * Ohmic synapse similar to expTwoSynapse but consisting of two
   * components that can differ in decay times and max conductances but
   * share the same rise time.
   * @param tauRise 
   * @param tauDecay1 
   * @param tauDecay2 
   * @param gbase1 Baseline conductance 1
   * @param gbase2 Baseline conductance 2
   * @param erev Reversal potential of the synapse
   *
   * @nosubgrouping
   */
  class ExpThreeSynapse: public ::neuroml2::BaseConductanceBasedSynapseTwo
  {
    public:
    /**
     * @name tauDecay1
     *
     * @brief Accessor and modifier functions for the %tauDecay1
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time tauDecay1_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< tauDecay1_type, char > tauDecay1_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const tauDecay1_type&
    tauDecay1 () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    tauDecay1_type&
    tauDecay1 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    tauDecay1 (const tauDecay1_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    tauDecay1 (::std::unique_ptr< tauDecay1_type > p);

    //@}

    /**
     * @name tauDecay2
     *
     * @brief Accessor and modifier functions for the %tauDecay2
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time tauDecay2_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< tauDecay2_type, char > tauDecay2_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const tauDecay2_type&
    tauDecay2 () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    tauDecay2_type&
    tauDecay2 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    tauDecay2 (const tauDecay2_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    tauDecay2 (::std::unique_ptr< tauDecay2_type > p);

    //@}

    /**
     * @name tauRise
     *
     * @brief Accessor and modifier functions for the %tauRise
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time tauRise_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< tauRise_type, char > tauRise_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const tauRise_type&
    tauRise () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    tauRise_type&
    tauRise ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    tauRise (const tauRise_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    tauRise (::std::unique_ptr< tauRise_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ExpThreeSynapse (const id_type&,
                     const gbase1_type&,
                     const gbase2_type&,
                     const erev_type&,
                     const tauDecay1_type&,
                     const tauDecay2_type&,
                     const tauRise_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ExpThreeSynapse (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ExpThreeSynapse (const ExpThreeSynapse& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ExpThreeSynapse*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ExpThreeSynapse&
    operator= (const ExpThreeSynapse& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ExpThreeSynapse ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< tauDecay1_type > tauDecay1_;
    ::xsd::cxx::tree::one< tauDecay2_type > tauDecay2_;
    ::xsd::cxx::tree::one< tauRise_type > tauRise_;

    //@endcond
  };

  bool
  operator== (const ExpThreeSynapse&, const ExpThreeSynapse&);

  bool
  operator!= (const ExpThreeSynapse&, const ExpThreeSynapse&);


  /**
   * @brief Class corresponding to the %DoubleSynapse schema type.
   *
   * Synapse consisting of two independent synaptic mechanisms ( e. g.
   * AMPA-R and NMDA-R ), which can be easily colocated in connections
   *
   * @nosubgrouping
   */
  class DoubleSynapse: public ::neuroml2::BaseVoltageDepSynapse
  {
    public:
    /**
     * @name synapse1
     *
     * @brief Accessor and modifier functions for the %synapse1
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId synapse1_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< synapse1_type, char > synapse1_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const synapse1_type&
    synapse1 () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    synapse1_type&
    synapse1 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    synapse1 (const synapse1_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    synapse1 (::std::unique_ptr< synapse1_type > p);

    //@}

    /**
     * @name synapse2
     *
     * @brief Accessor and modifier functions for the %synapse2
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId synapse2_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< synapse2_type, char > synapse2_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const synapse2_type&
    synapse2 () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    synapse2_type&
    synapse2 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    synapse2 (const synapse2_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    synapse2 (::std::unique_ptr< synapse2_type > p);

    //@}

    /**
     * @name synapse1Path
     *
     * @brief Accessor and modifier functions for the %synapse1Path
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string synapse1Path_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< synapse1Path_type, char > synapse1Path_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const synapse1Path_type&
    synapse1Path () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    synapse1Path_type&
    synapse1Path ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    synapse1Path (const synapse1Path_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    synapse1Path (::std::unique_ptr< synapse1Path_type > p);

    //@}

    /**
     * @name synapse2Path
     *
     * @brief Accessor and modifier functions for the %synapse2Path
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string synapse2Path_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< synapse2Path_type, char > synapse2Path_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const synapse2Path_type&
    synapse2Path () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    synapse2Path_type&
    synapse2Path ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    synapse2Path (const synapse2Path_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    synapse2Path (::std::unique_ptr< synapse2Path_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DoubleSynapse (const id_type&,
                   const synapse1_type&,
                   const synapse2_type&,
                   const synapse1Path_type&,
                   const synapse2Path_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DoubleSynapse (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DoubleSynapse (const DoubleSynapse& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DoubleSynapse*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DoubleSynapse&
    operator= (const DoubleSynapse& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DoubleSynapse ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< synapse1_type > synapse1_;
    ::xsd::cxx::tree::one< synapse2_type > synapse2_;
    ::xsd::cxx::tree::one< synapse1Path_type > synapse1Path_;
    ::xsd::cxx::tree::one< synapse2Path_type > synapse2Path_;

    //@endcond
  };

  bool
  operator== (const DoubleSynapse&, const DoubleSynapse&);

  bool
  operator!= (const DoubleSynapse&, const DoubleSynapse&);


  /**
   * @brief Class corresponding to the %BlockingPlasticSynapse schema type.
   *
   * Biexponential synapse that allows for optional block and plasticity
   * mechanisms, which can be expressed as child elements.
   * @param tauRise 
   * @param tauDecay 
   * @param gbase Baseline conductance, generally the maximum conductance
   * following a single spike
   * @param erev Reversal potential of the synapse
   *
   * @nosubgrouping
   */
  class BlockingPlasticSynapse: public ::neuroml2::ExpTwoSynapse
  {
    public:
    /**
     * @name plasticityMechanism
     *
     * @brief Accessor and modifier functions for the %plasticityMechanism
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::PlasticityMechanism plasticityMechanism_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< plasticityMechanism_type > plasticityMechanism_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< plasticityMechanism_type, char > plasticityMechanism_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const plasticityMechanism_optional&
    plasticityMechanism () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    plasticityMechanism_optional&
    plasticityMechanism ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    plasticityMechanism (const plasticityMechanism_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    plasticityMechanism (const plasticityMechanism_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    plasticityMechanism (::std::unique_ptr< plasticityMechanism_type > p);

    //@}

    /**
     * @name blockMechanism
     *
     * @brief Accessor and modifier functions for the %blockMechanism
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::BlockMechanism blockMechanism_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< blockMechanism_type > blockMechanism_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< blockMechanism_type, char > blockMechanism_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const blockMechanism_optional&
    blockMechanism () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    blockMechanism_optional&
    blockMechanism ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    blockMechanism (const blockMechanism_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    blockMechanism (const blockMechanism_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    blockMechanism (::std::unique_ptr< blockMechanism_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BlockingPlasticSynapse (const id_type&,
                            const gbase_type&,
                            const erev_type&,
                            const tauDecay_type&,
                            const tauRise_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BlockingPlasticSynapse (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BlockingPlasticSynapse (const BlockingPlasticSynapse& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BlockingPlasticSynapse*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BlockingPlasticSynapse&
    operator= (const BlockingPlasticSynapse& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BlockingPlasticSynapse ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    plasticityMechanism_optional plasticityMechanism_;
    blockMechanism_optional blockMechanism_;

    //@endcond
  };

  bool
  operator== (const BlockingPlasticSynapse&, const BlockingPlasticSynapse&);

  bool
  operator!= (const BlockingPlasticSynapse&, const BlockingPlasticSynapse&);


  /**
   * @brief Enumeration class corresponding to the %BlockTypes
   * schema type.
   */
  class BlockTypes: public ::xml_schema::string
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum value
    {
      voltageConcDepBlockMechanism
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    BlockTypes (value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    BlockTypes (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    BlockTypes (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    BlockTypes (const ::xml_schema::string& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BlockTypes (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BlockTypes (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BlockTypes (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BlockTypes (const BlockTypes& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BlockTypes*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    BlockTypes&
    operator= (value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator value () const
    {
      return _xsd_BlockTypes_convert ();
    }

    //@cond

    protected:
    value
    _xsd_BlockTypes_convert () const;

    public:
    static const char* const _xsd_BlockTypes_literals_[1];
    static const value _xsd_BlockTypes_indexes_[1];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %BlockMechanism schema type.
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name type
     *
     * @brief Accessor and modifier functions for the %type
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::BlockTypes type_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const type_type&
    type () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    type_type&
    type ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    type (const type_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    type (::std::unique_ptr< type_type > p);

    //@}

    /**
     * @name species
     *
     * @brief Accessor and modifier functions for the %species
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId species_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< species_type, char > species_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const species_type&
    species () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    species_type&
    species ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    species (const species_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    species (::std::unique_ptr< species_type > p);

    //@}

    /**
     * @name blockConcentration
     *
     * @brief Accessor and modifier functions for the %blockConcentration
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_concentration blockConcentration_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< blockConcentration_type, char > blockConcentration_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const blockConcentration_type&
    blockConcentration () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    blockConcentration_type&
    blockConcentration ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    blockConcentration (const blockConcentration_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    blockConcentration (::std::unique_ptr< blockConcentration_type > p);

    //@}

    /**
     * @name scalingConc
     *
     * @brief Accessor and modifier functions for the %scalingConc
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_concentration scalingConc_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< scalingConc_type, char > scalingConc_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const scalingConc_type&
    scalingConc () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    scalingConc_type&
    scalingConc ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    scalingConc (const scalingConc_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    scalingConc (::std::unique_ptr< scalingConc_type > p);

    //@}

    /**
     * @name scalingVolt
     *
     * @brief Accessor and modifier functions for the %scalingVolt
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage scalingVolt_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< scalingVolt_type, char > scalingVolt_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const scalingVolt_type&
    scalingVolt () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    scalingVolt_type&
    scalingVolt ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    scalingVolt (const scalingVolt_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    scalingVolt (::std::unique_ptr< scalingVolt_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BlockMechanism (const type_type&,
                    const species_type&,
                    const blockConcentration_type&,
                    const scalingConc_type&,
                    const scalingVolt_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BlockMechanism (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BlockMechanism (const BlockMechanism& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BlockMechanism*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BlockMechanism&
    operator= (const BlockMechanism& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BlockMechanism ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< type_type > type_;
    ::xsd::cxx::tree::one< species_type > species_;
    ::xsd::cxx::tree::one< blockConcentration_type > blockConcentration_;
    ::xsd::cxx::tree::one< scalingConc_type > scalingConc_;
    ::xsd::cxx::tree::one< scalingVolt_type > scalingVolt_;

    //@endcond
  };

  bool
  operator== (const BlockMechanism&, const BlockMechanism&);

  bool
  operator!= (const BlockMechanism&, const BlockMechanism&);


  /**
   * @brief Enumeration class corresponding to the %PlasticityTypes
   * schema type.
   */
  class PlasticityTypes: public ::xml_schema::string
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum value
    {
      tsodyksMarkramDepMechanism,
      tsodyksMarkramDepFacMechanism
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    PlasticityTypes (value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    PlasticityTypes (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    PlasticityTypes (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    PlasticityTypes (const ::xml_schema::string& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PlasticityTypes (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PlasticityTypes (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PlasticityTypes (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PlasticityTypes (const PlasticityTypes& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PlasticityTypes*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    PlasticityTypes&
    operator= (value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator value () const
    {
      return _xsd_PlasticityTypes_convert ();
    }

    //@cond

    protected:
    value
    _xsd_PlasticityTypes_convert () const;

    public:
    static const char* const _xsd_PlasticityTypes_literals_[2];
    static const value _xsd_PlasticityTypes_indexes_[2];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %PlasticityMechanism schema type.
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name type
     *
     * @brief Accessor and modifier functions for the %type
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::PlasticityTypes type_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const type_type&
    type () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    type_type&
    type ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    type (const type_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    type (::std::unique_ptr< type_type > p);

    //@}

    /**
     * @name initReleaseProb
     *
     * @brief Accessor and modifier functions for the %initReleaseProb
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::ZeroToOne initReleaseProb_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< initReleaseProb_type, char > initReleaseProb_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const initReleaseProb_type&
    initReleaseProb () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    initReleaseProb_type&
    initReleaseProb ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    initReleaseProb (const initReleaseProb_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    initReleaseProb (::std::unique_ptr< initReleaseProb_type > p);

    //@}

    /**
     * @name tauRec
     *
     * @brief Accessor and modifier functions for the %tauRec
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time tauRec_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< tauRec_type, char > tauRec_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const tauRec_type&
    tauRec () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    tauRec_type&
    tauRec ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    tauRec (const tauRec_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    tauRec (::std::unique_ptr< tauRec_type > p);

    //@}

    /**
     * @name tauFac
     *
     * @brief Accessor and modifier functions for the %tauFac
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time tauFac_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< tauFac_type > tauFac_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< tauFac_type, char > tauFac_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const tauFac_optional&
    tauFac () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    tauFac_optional&
    tauFac ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    tauFac (const tauFac_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    tauFac (const tauFac_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    tauFac (::std::unique_ptr< tauFac_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PlasticityMechanism (const type_type&,
                         const initReleaseProb_type&,
                         const tauRec_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PlasticityMechanism (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PlasticityMechanism (const PlasticityMechanism& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PlasticityMechanism*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PlasticityMechanism&
    operator= (const PlasticityMechanism& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PlasticityMechanism ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< type_type > type_;
    ::xsd::cxx::tree::one< initReleaseProb_type > initReleaseProb_;
    ::xsd::cxx::tree::one< tauRec_type > tauRec_;
    tauFac_optional tauFac_;

    //@endcond
  };

  bool
  operator== (const PlasticityMechanism&, const PlasticityMechanism&);

  bool
  operator!= (const PlasticityMechanism&, const PlasticityMechanism&);


  /**
   * @brief Class corresponding to the %BaseCell schema type.
   *
   * Base type of any cell ( e. g. point neuron like 
   * **izhikevich2007Cell** , or a morphologically detailed  **Cell**  with
   * **segment** s ) which can be used in a  **population**
   *
   * @nosubgrouping
   */
  class BaseCell: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BaseCell (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BaseCell (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BaseCell (const BaseCell& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BaseCell*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BaseCell ();
  };

  /**
   * @brief Class corresponding to the %IafTauCell schema type.
   *
   * Integrate and fire cell which returns to its leak reversal potential
   * of **leakReversal**  with a time constant **tau**
   * @param leakReversal 
   * @param tau 
   * @param thresh The membrane potential at which to emit a spiking event
   * and reset voltage
   * @param reset The value the membrane potential is reset to on spiking
   *
   * @nosubgrouping
   */
  class IafTauCell: public ::neuroml2::BaseCell
  {
    public:
    /**
     * @name leakReversal
     *
     * @brief Accessor and modifier functions for the %leakReversal
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage leakReversal_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< leakReversal_type, char > leakReversal_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const leakReversal_type&
    leakReversal () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    leakReversal_type&
    leakReversal ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    leakReversal (const leakReversal_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    leakReversal (::std::unique_ptr< leakReversal_type > p);

    //@}

    /**
     * @name thresh
     *
     * @brief Accessor and modifier functions for the %thresh
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage thresh_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< thresh_type, char > thresh_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const thresh_type&
    thresh () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    thresh_type&
    thresh ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    thresh (const thresh_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    thresh (::std::unique_ptr< thresh_type > p);

    //@}

    /**
     * @name reset
     *
     * @brief Accessor and modifier functions for the %reset
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage reset_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< reset_type, char > reset_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const reset_type&
    reset () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    reset_type&
    reset ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    reset (const reset_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    reset (::std::unique_ptr< reset_type > p);

    //@}

    /**
     * @name tau
     *
     * @brief Accessor and modifier functions for the %tau
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time tau_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< tau_type, char > tau_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const tau_type&
    tau () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    tau_type&
    tau ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    tau (const tau_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    tau (::std::unique_ptr< tau_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IafTauCell (const id_type&,
                const leakReversal_type&,
                const thresh_type&,
                const reset_type&,
                const tau_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IafTauCell (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IafTauCell (const IafTauCell& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IafTauCell*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IafTauCell&
    operator= (const IafTauCell& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IafTauCell ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< leakReversal_type > leakReversal_;
    ::xsd::cxx::tree::one< thresh_type > thresh_;
    ::xsd::cxx::tree::one< reset_type > reset_;
    ::xsd::cxx::tree::one< tau_type > tau_;

    //@endcond
  };

  bool
  operator== (const IafTauCell&, const IafTauCell&);

  bool
  operator!= (const IafTauCell&, const IafTauCell&);


  /**
   * @brief Class corresponding to the %IafTauRefCell schema type.
   *
   * Integrate and fire cell which returns to its leak reversal potential
   * of **leakReversal**  with a time course **tau.**  It has a refractory
   * period of **refract**  after spiking
   * @param refract 
   * @param leakReversal 
   * @param tau 
   * @param thresh The membrane potential at which to emit a spiking event
   * and reset voltage
   * @param reset The value the membrane potential is reset to on spiking
   *
   * @nosubgrouping
   */
  class IafTauRefCell: public ::neuroml2::IafTauCell
  {
    public:
    /**
     * @name refract
     *
     * @brief Accessor and modifier functions for the %refract
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time refract_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< refract_type, char > refract_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const refract_type&
    refract () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    refract_type&
    refract ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    refract (const refract_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    refract (::std::unique_ptr< refract_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IafTauRefCell (const id_type&,
                   const leakReversal_type&,
                   const thresh_type&,
                   const reset_type&,
                   const tau_type&,
                   const refract_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IafTauRefCell (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IafTauRefCell (const IafTauRefCell& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IafTauRefCell*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IafTauRefCell&
    operator= (const IafTauRefCell& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IafTauRefCell ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< refract_type > refract_;

    //@endcond
  };

  bool
  operator== (const IafTauRefCell&, const IafTauRefCell&);

  bool
  operator!= (const IafTauRefCell&, const IafTauRefCell&);


  /**
   * @brief Class corresponding to the %IafCell schema type.
   *
   * Integrate and fire cell with capacitance **C,**  **leakConductance** 
   * and **leakReversal**
   * @param leakConductance 
   * @param leakReversal 
   * @param thresh 
   * @param reset 
   * @param C Total capacitance of the cell membrane
   *
   * @nosubgrouping
   */
  class IafCell: public ::neuroml2::BaseCell
  {
    public:
    /**
     * @name leakReversal
     *
     * @brief Accessor and modifier functions for the %leakReversal
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage leakReversal_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< leakReversal_type, char > leakReversal_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const leakReversal_type&
    leakReversal () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    leakReversal_type&
    leakReversal ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    leakReversal (const leakReversal_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    leakReversal (::std::unique_ptr< leakReversal_type > p);

    //@}

    /**
     * @name thresh
     *
     * @brief Accessor and modifier functions for the %thresh
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage thresh_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< thresh_type, char > thresh_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const thresh_type&
    thresh () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    thresh_type&
    thresh ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    thresh (const thresh_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    thresh (::std::unique_ptr< thresh_type > p);

    //@}

    /**
     * @name reset
     *
     * @brief Accessor and modifier functions for the %reset
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage reset_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< reset_type, char > reset_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const reset_type&
    reset () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    reset_type&
    reset ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    reset (const reset_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    reset (::std::unique_ptr< reset_type > p);

    //@}

    /**
     * @name C
     *
     * @brief Accessor and modifier functions for the %C
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_capacitance C_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< C_type, char > C_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const C_type&
    C () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    C_type&
    C ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    C (const C_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    C (::std::unique_ptr< C_type > p);

    //@}

    /**
     * @name leakConductance
     *
     * @brief Accessor and modifier functions for the %leakConductance
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductance leakConductance_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< leakConductance_type, char > leakConductance_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const leakConductance_type&
    leakConductance () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    leakConductance_type&
    leakConductance ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    leakConductance (const leakConductance_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    leakConductance (::std::unique_ptr< leakConductance_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IafCell (const id_type&,
             const leakReversal_type&,
             const thresh_type&,
             const reset_type&,
             const C_type&,
             const leakConductance_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IafCell (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IafCell (const IafCell& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IafCell*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IafCell&
    operator= (const IafCell& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IafCell ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< leakReversal_type > leakReversal_;
    ::xsd::cxx::tree::one< thresh_type > thresh_;
    ::xsd::cxx::tree::one< reset_type > reset_;
    ::xsd::cxx::tree::one< C_type > C_;
    ::xsd::cxx::tree::one< leakConductance_type > leakConductance_;

    //@endcond
  };

  bool
  operator== (const IafCell&, const IafCell&);

  bool
  operator!= (const IafCell&, const IafCell&);


  /**
   * @brief Class corresponding to the %IafRefCell schema type.
   *
   * Integrate and fire cell with capacitance **C,**  **leakConductance,** 
   * **leakReversal**  and refractory period **refract**
   * @param refract 
   * @param leakConductance 
   * @param leakReversal 
   * @param thresh 
   * @param reset 
   * @param C Total capacitance of the cell membrane
   *
   * @nosubgrouping
   */
  class IafRefCell: public ::neuroml2::IafCell
  {
    public:
    /**
     * @name refract
     *
     * @brief Accessor and modifier functions for the %refract
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time refract_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< refract_type, char > refract_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const refract_type&
    refract () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    refract_type&
    refract ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    refract (const refract_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    refract (::std::unique_ptr< refract_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IafRefCell (const id_type&,
                const leakReversal_type&,
                const thresh_type&,
                const reset_type&,
                const C_type&,
                const leakConductance_type&,
                const refract_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IafRefCell (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IafRefCell (const IafRefCell& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IafRefCell*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IafRefCell&
    operator= (const IafRefCell& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IafRefCell ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< refract_type > refract_;

    //@endcond
  };

  bool
  operator== (const IafRefCell&, const IafRefCell&);

  bool
  operator!= (const IafRefCell&, const IafRefCell&);


  /**
   * @brief Class corresponding to the %IzhikevichCell schema type.
   *
   * Cell based on the 2003 model of Izhikevich, see
   * http://izhikevich.org/publications/spikes.htm
   * @param v0 Initial membrane potential
   * @param a Time scale of the recovery variable U
   * @param b Sensitivity of U to the subthreshold fluctuations of the
   * membrane potential V
   * @param c After-spike reset value of V
   * @param d After-spike increase to U
   * @param thresh Spike threshold
   *
   * @nosubgrouping
   */
  class IzhikevichCell: public ::neuroml2::BaseCell
  {
    public:
    /**
     * @name v0
     *
     * @brief Accessor and modifier functions for the %v0
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage v0_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< v0_type, char > v0_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const v0_type&
    v0 () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    v0_type&
    v0 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    v0 (const v0_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    v0 (::std::unique_ptr< v0_type > p);

    //@}

    /**
     * @name thresh
     *
     * @brief Accessor and modifier functions for the %thresh
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage thresh_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< thresh_type, char > thresh_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const thresh_type&
    thresh () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    thresh_type&
    thresh ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    thresh (const thresh_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    thresh (::std::unique_ptr< thresh_type > p);

    //@}

    /**
     * @name a
     *
     * @brief Accessor and modifier functions for the %a
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none a_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< a_type, char > a_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const a_type&
    a () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    a_type&
    a ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    a (const a_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    a (::std::unique_ptr< a_type > p);

    //@}

    /**
     * @name b
     *
     * @brief Accessor and modifier functions for the %b
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none b_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< b_type, char > b_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const b_type&
    b () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    b_type&
    b ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    b (const b_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    b (::std::unique_ptr< b_type > p);

    //@}

    /**
     * @name c
     *
     * @brief Accessor and modifier functions for the %c
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none c_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< c_type, char > c_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const c_type&
    c () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    c_type&
    c ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    c (const c_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    c (::std::unique_ptr< c_type > p);

    //@}

    /**
     * @name d
     *
     * @brief Accessor and modifier functions for the %d
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none d_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< d_type, char > d_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const d_type&
    d () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    d_type&
    d ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    d (const d_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    d (::std::unique_ptr< d_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IzhikevichCell (const id_type&,
                    const v0_type&,
                    const thresh_type&,
                    const a_type&,
                    const b_type&,
                    const c_type&,
                    const d_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IzhikevichCell (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IzhikevichCell (const IzhikevichCell& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IzhikevichCell*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IzhikevichCell&
    operator= (const IzhikevichCell& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IzhikevichCell ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< v0_type > v0_;
    ::xsd::cxx::tree::one< thresh_type > thresh_;
    ::xsd::cxx::tree::one< a_type > a_;
    ::xsd::cxx::tree::one< b_type > b_;
    ::xsd::cxx::tree::one< c_type > c_;
    ::xsd::cxx::tree::one< d_type > d_;

    //@endcond
  };

  bool
  operator== (const IzhikevichCell&, const IzhikevichCell&);

  bool
  operator!= (const IzhikevichCell&, const IzhikevichCell&);


  /**
   * @brief Class corresponding to the %BaseCellMembPotCap schema type.
   *
   * Any cell with a membrane potential **v**  with voltage units and a
   * membrane capacitance **C.**  Also defines exposed value **iSyn**  for
   * current due to external synapses and **iMemb**  for total
   * transmembrane current ( usually channel currents plus **iSyn**  )
   * @param C Total capacitance of the cell membrane
   *
   * @nosubgrouping
   */
  class BaseCellMembPotCap: public ::neuroml2::BaseCell
  {
    public:
    /**
     * @name C
     *
     * @brief Accessor and modifier functions for the %C
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_capacitance C_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< C_type, char > C_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const C_type&
    C () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    C_type&
    C ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    C (const C_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    C (::std::unique_ptr< C_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BaseCellMembPotCap (const id_type&,
                        const C_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BaseCellMembPotCap (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BaseCellMembPotCap (const BaseCellMembPotCap& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BaseCellMembPotCap*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BaseCellMembPotCap&
    operator= (const BaseCellMembPotCap& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BaseCellMembPotCap ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< C_type > C_;

    //@endcond
  };

  bool
  operator== (const BaseCellMembPotCap&, const BaseCellMembPotCap&);

  bool
  operator!= (const BaseCellMembPotCap&, const BaseCellMembPotCap&);


  /**
   * @brief Class corresponding to the %Izhikevich2007Cell schema type.
   *
   * Cell based on the modified Izhikevich model in Izhikevich 2007,
   * Dynamical systems in neuroscience, MIT Press
   * @param v0 
   * @param k 
   * @param vr 
   * @param vt 
   * @param vpeak 
   * @param a 
   * @param b 
   * @param c 
   * @param d 
   * @param C Total capacitance of the cell membrane
   *
   * @nosubgrouping
   */
  class Izhikevich2007Cell: public ::neuroml2::BaseCellMembPotCap
  {
    public:
    /**
     * @name v0
     *
     * @brief Accessor and modifier functions for the %v0
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage v0_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< v0_type, char > v0_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const v0_type&
    v0 () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    v0_type&
    v0 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    v0 (const v0_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    v0 (::std::unique_ptr< v0_type > p);

    //@}

    /**
     * @name k
     *
     * @brief Accessor and modifier functions for the %k
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductancePerVoltage k_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< k_type, char > k_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const k_type&
    k () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    k_type&
    k ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    k (const k_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    k (::std::unique_ptr< k_type > p);

    //@}

    /**
     * @name vr
     *
     * @brief Accessor and modifier functions for the %vr
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage vr_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< vr_type, char > vr_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const vr_type&
    vr () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    vr_type&
    vr ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    vr (const vr_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    vr (::std::unique_ptr< vr_type > p);

    //@}

    /**
     * @name vt
     *
     * @brief Accessor and modifier functions for the %vt
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage vt_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< vt_type, char > vt_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const vt_type&
    vt () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    vt_type&
    vt ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    vt (const vt_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    vt (::std::unique_ptr< vt_type > p);

    //@}

    /**
     * @name vpeak
     *
     * @brief Accessor and modifier functions for the %vpeak
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage vpeak_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< vpeak_type, char > vpeak_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const vpeak_type&
    vpeak () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    vpeak_type&
    vpeak ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    vpeak (const vpeak_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    vpeak (::std::unique_ptr< vpeak_type > p);

    //@}

    /**
     * @name a
     *
     * @brief Accessor and modifier functions for the %a
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_pertime a_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< a_type, char > a_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const a_type&
    a () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    a_type&
    a ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    a (const a_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    a (::std::unique_ptr< a_type > p);

    //@}

    /**
     * @name b
     *
     * @brief Accessor and modifier functions for the %b
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductance b_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< b_type, char > b_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const b_type&
    b () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    b_type&
    b ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    b (const b_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    b (::std::unique_ptr< b_type > p);

    //@}

    /**
     * @name c
     *
     * @brief Accessor and modifier functions for the %c
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage c_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< c_type, char > c_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const c_type&
    c () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    c_type&
    c ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    c (const c_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    c (::std::unique_ptr< c_type > p);

    //@}

    /**
     * @name d
     *
     * @brief Accessor and modifier functions for the %d
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_current d_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< d_type, char > d_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const d_type&
    d () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    d_type&
    d ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    d (const d_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    d (::std::unique_ptr< d_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Izhikevich2007Cell (const id_type&,
                        const C_type&,
                        const v0_type&,
                        const k_type&,
                        const vr_type&,
                        const vt_type&,
                        const vpeak_type&,
                        const a_type&,
                        const b_type&,
                        const c_type&,
                        const d_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Izhikevich2007Cell (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Izhikevich2007Cell (const Izhikevich2007Cell& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Izhikevich2007Cell*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Izhikevich2007Cell&
    operator= (const Izhikevich2007Cell& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Izhikevich2007Cell ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< v0_type > v0_;
    ::xsd::cxx::tree::one< k_type > k_;
    ::xsd::cxx::tree::one< vr_type > vr_;
    ::xsd::cxx::tree::one< vt_type > vt_;
    ::xsd::cxx::tree::one< vpeak_type > vpeak_;
    ::xsd::cxx::tree::one< a_type > a_;
    ::xsd::cxx::tree::one< b_type > b_;
    ::xsd::cxx::tree::one< c_type > c_;
    ::xsd::cxx::tree::one< d_type > d_;

    //@endcond
  };

  bool
  operator== (const Izhikevich2007Cell&, const Izhikevich2007Cell&);

  bool
  operator!= (const Izhikevich2007Cell&, const Izhikevich2007Cell&);


  /**
   * @brief Class corresponding to the %AdExIaFCell schema type.
   *
   * Model based on Brette R and Gerstner W ( 2005 ) Adaptive Exponential
   * Integrate-and-Fire Model as an Effective Description of Neuronal
   * Activity. J Neurophysiol 94:3637-3642
   * @param gL 
   * @param EL 
   * @param VT 
   * @param thresh 
   * @param reset 
   * @param delT 
   * @param tauw 
   * @param refract 
   * @param a 
   * @param b 
   * @param C Total capacitance of the cell membrane
   *
   * @nosubgrouping
   */
  class AdExIaFCell: public ::neuroml2::BaseCellMembPotCap
  {
    public:
    /**
     * @name gL
     *
     * @brief Accessor and modifier functions for the %gL
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductance gL_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< gL_type, char > gL_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const gL_type&
    gL () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    gL_type&
    gL ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    gL (const gL_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    gL (::std::unique_ptr< gL_type > p);

    //@}

    /**
     * @name EL
     *
     * @brief Accessor and modifier functions for the %EL
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage EL_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< EL_type, char > EL_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const EL_type&
    EL () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    EL_type&
    EL ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    EL (const EL_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    EL (::std::unique_ptr< EL_type > p);

    //@}

    /**
     * @name reset
     *
     * @brief Accessor and modifier functions for the %reset
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage reset_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< reset_type, char > reset_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const reset_type&
    reset () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    reset_type&
    reset ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    reset (const reset_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    reset (::std::unique_ptr< reset_type > p);

    //@}

    /**
     * @name VT
     *
     * @brief Accessor and modifier functions for the %VT
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage VT_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< VT_type, char > VT_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const VT_type&
    VT () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    VT_type&
    VT ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    VT (const VT_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    VT (::std::unique_ptr< VT_type > p);

    //@}

    /**
     * @name thresh
     *
     * @brief Accessor and modifier functions for the %thresh
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage thresh_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< thresh_type, char > thresh_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const thresh_type&
    thresh () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    thresh_type&
    thresh ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    thresh (const thresh_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    thresh (::std::unique_ptr< thresh_type > p);

    //@}

    /**
     * @name delT
     *
     * @brief Accessor and modifier functions for the %delT
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage delT_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< delT_type, char > delT_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const delT_type&
    delT () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    delT_type&
    delT ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    delT (const delT_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    delT (::std::unique_ptr< delT_type > p);

    //@}

    /**
     * @name tauw
     *
     * @brief Accessor and modifier functions for the %tauw
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time tauw_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< tauw_type, char > tauw_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const tauw_type&
    tauw () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    tauw_type&
    tauw ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    tauw (const tauw_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    tauw (::std::unique_ptr< tauw_type > p);

    //@}

    /**
     * @name refract
     *
     * @brief Accessor and modifier functions for the %refract
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time refract_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< refract_type, char > refract_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const refract_type&
    refract () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    refract_type&
    refract ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    refract (const refract_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    refract (::std::unique_ptr< refract_type > p);

    //@}

    /**
     * @name a
     *
     * @brief Accessor and modifier functions for the %a
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductance a_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< a_type, char > a_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const a_type&
    a () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    a_type&
    a ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    a (const a_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    a (::std::unique_ptr< a_type > p);

    //@}

    /**
     * @name b
     *
     * @brief Accessor and modifier functions for the %b
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_current b_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< b_type, char > b_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const b_type&
    b () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    b_type&
    b ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    b (const b_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    b (::std::unique_ptr< b_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AdExIaFCell (const id_type&,
                 const C_type&,
                 const gL_type&,
                 const EL_type&,
                 const reset_type&,
                 const VT_type&,
                 const thresh_type&,
                 const delT_type&,
                 const tauw_type&,
                 const refract_type&,
                 const a_type&,
                 const b_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AdExIaFCell (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AdExIaFCell (const AdExIaFCell& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AdExIaFCell*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AdExIaFCell&
    operator= (const AdExIaFCell& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AdExIaFCell ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< gL_type > gL_;
    ::xsd::cxx::tree::one< EL_type > EL_;
    ::xsd::cxx::tree::one< reset_type > reset_;
    ::xsd::cxx::tree::one< VT_type > VT_;
    ::xsd::cxx::tree::one< thresh_type > thresh_;
    ::xsd::cxx::tree::one< delT_type > delT_;
    ::xsd::cxx::tree::one< tauw_type > tauw_;
    ::xsd::cxx::tree::one< refract_type > refract_;
    ::xsd::cxx::tree::one< a_type > a_;
    ::xsd::cxx::tree::one< b_type > b_;

    //@endcond
  };

  bool
  operator== (const AdExIaFCell&, const AdExIaFCell&);

  bool
  operator!= (const AdExIaFCell&, const AdExIaFCell&);


  /**
   * @brief Class corresponding to the %FitzHughNagumoCell schema type.
   *
   * Simple dimensionless model of spiking cell from FitzHugh and Nagumo.
   * Superseded by **fitzHughNagumo1969Cell**  ( See
   * https://github.com/NeuroML/NeuroML2/issues/42 )
   * @param I 
   *
   * @nosubgrouping
   */
  class FitzHughNagumoCell: public ::neuroml2::BaseCell
  {
    public:
    /**
     * @name I
     *
     * @brief Accessor and modifier functions for the %I
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none I_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< I_type, char > I_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const I_type&
    I () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    I_type&
    I ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    I (const I_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    I (::std::unique_ptr< I_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    FitzHughNagumoCell (const id_type&,
                        const I_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    FitzHughNagumoCell (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    FitzHughNagumoCell (const FitzHughNagumoCell& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual FitzHughNagumoCell*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    FitzHughNagumoCell&
    operator= (const FitzHughNagumoCell& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~FitzHughNagumoCell ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< I_type > I_;

    //@endcond
  };

  bool
  operator== (const FitzHughNagumoCell&, const FitzHughNagumoCell&);

  bool
  operator!= (const FitzHughNagumoCell&, const FitzHughNagumoCell&);


  /**
   * @brief Class corresponding to the %FitzHughNagumo1969Cell schema type.
   *
   * The Fitzhugh Nagumo model is a two-dimensional simplification of the
   * Hodgkin-Huxley model of spike generation in squid giant axons. This
   * system was suggested by FitzHugh ( FitzHugh R. [1961]: Impulses and
   * physiological states in theoretical models of nerve membrane.
   * Biophysical J. 1:445-466 ), who called it " Bonhoeffer-van der Pol
   * model ", and the equivalent circuit by Nagumo et al. ( Nagumo J. ,
   * Arimoto S. , and Yoshizawa S. [1962] An active pulse transmission line
   * simulating nerve axon. Proc IRE. 50:2061-2070. 1962 ). This version
   * corresponds to the one described in FitzHugh R. [1969]: Mathematical
   * models of excitation and propagation in nerve. Chapter 1 ( pp. 1-85 in
   * H. P. Schwan, ed. Biological Engineering, McGraw-Hill Book Co. , N. Y.
   * )
   * @param a 
   * @param b 
   * @param I plays the role of an external injected current
   * @param phi 
   * @param V0 
   * @param W0 
   *
   * @nosubgrouping
   */
  class FitzHughNagumo1969Cell: public ::neuroml2::BaseCell
  {
    public:
    /**
     * @name a
     *
     * @brief Accessor and modifier functions for the %a
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none a_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< a_type, char > a_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const a_type&
    a () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    a_type&
    a ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    a (const a_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    a (::std::unique_ptr< a_type > p);

    //@}

    /**
     * @name b
     *
     * @brief Accessor and modifier functions for the %b
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none b_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< b_type, char > b_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const b_type&
    b () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    b_type&
    b ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    b (const b_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    b (::std::unique_ptr< b_type > p);

    //@}

    /**
     * @name I
     *
     * @brief Accessor and modifier functions for the %I
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none I_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< I_type, char > I_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const I_type&
    I () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    I_type&
    I ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    I (const I_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    I (::std::unique_ptr< I_type > p);

    //@}

    /**
     * @name phi
     *
     * @brief Accessor and modifier functions for the %phi
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none phi_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< phi_type, char > phi_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const phi_type&
    phi () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    phi_type&
    phi ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    phi (const phi_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    phi (::std::unique_ptr< phi_type > p);

    //@}

    /**
     * @name V0
     *
     * @brief Accessor and modifier functions for the %V0
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none V0_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< V0_type, char > V0_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const V0_type&
    V0 () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    V0_type&
    V0 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    V0 (const V0_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    V0 (::std::unique_ptr< V0_type > p);

    //@}

    /**
     * @name W0
     *
     * @brief Accessor and modifier functions for the %W0
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none W0_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< W0_type, char > W0_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const W0_type&
    W0 () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    W0_type&
    W0 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    W0 (const W0_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    W0 (::std::unique_ptr< W0_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    FitzHughNagumo1969Cell (const id_type&,
                            const a_type&,
                            const b_type&,
                            const I_type&,
                            const phi_type&,
                            const V0_type&,
                            const W0_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    FitzHughNagumo1969Cell (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    FitzHughNagumo1969Cell (const FitzHughNagumo1969Cell& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual FitzHughNagumo1969Cell*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    FitzHughNagumo1969Cell&
    operator= (const FitzHughNagumo1969Cell& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~FitzHughNagumo1969Cell ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< a_type > a_;
    ::xsd::cxx::tree::one< b_type > b_;
    ::xsd::cxx::tree::one< I_type > I_;
    ::xsd::cxx::tree::one< phi_type > phi_;
    ::xsd::cxx::tree::one< V0_type > V0_;
    ::xsd::cxx::tree::one< W0_type > W0_;

    //@endcond
  };

  bool
  operator== (const FitzHughNagumo1969Cell&, const FitzHughNagumo1969Cell&);

  bool
  operator!= (const FitzHughNagumo1969Cell&, const FitzHughNagumo1969Cell&);


  /**
   * @brief Class corresponding to the %PinskyRinzelCA3Cell schema type.
   *
   * Reduced CA3 cell model from Pinsky and Rinzel 1994. See
   * https://github.com/OpenSourceBrain/PinskyRinzelModel
   * @param iSoma 
   * @param iDend 
   * @param gLs 
   * @param gLd 
   * @param gNa 
   * @param gKdr 
   * @param gCa 
   * @param gKahp 
   * @param gKC 
   * @param gc 
   * @param eNa 
   * @param eCa 
   * @param eK 
   * @param eL 
   * @param pp 
   * @param cm 
   * @param alphac 
   * @param betac 
   * @param gNmda 
   * @param gAmpa 
   * @param qd0 
   *
   * @nosubgrouping
   */
  class PinskyRinzelCA3Cell: public ::neuroml2::BaseCell
  {
    public:
    /**
     * @name iSoma
     *
     * @brief Accessor and modifier functions for the %iSoma
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_currentDensity iSoma_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< iSoma_type, char > iSoma_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const iSoma_type&
    iSoma () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    iSoma_type&
    iSoma ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    iSoma (const iSoma_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    iSoma (::std::unique_ptr< iSoma_type > p);

    //@}

    /**
     * @name iDend
     *
     * @brief Accessor and modifier functions for the %iDend
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_currentDensity iDend_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< iDend_type, char > iDend_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const iDend_type&
    iDend () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    iDend_type&
    iDend ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    iDend (const iDend_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    iDend (::std::unique_ptr< iDend_type > p);

    //@}

    /**
     * @name gc
     *
     * @brief Accessor and modifier functions for the %gc
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductanceDensity gc_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< gc_type, char > gc_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const gc_type&
    gc () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    gc_type&
    gc ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    gc (const gc_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    gc (::std::unique_ptr< gc_type > p);

    //@}

    /**
     * @name gLs
     *
     * @brief Accessor and modifier functions for the %gLs
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductanceDensity gLs_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< gLs_type, char > gLs_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const gLs_type&
    gLs () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    gLs_type&
    gLs ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    gLs (const gLs_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    gLs (::std::unique_ptr< gLs_type > p);

    //@}

    /**
     * @name gLd
     *
     * @brief Accessor and modifier functions for the %gLd
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductanceDensity gLd_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< gLd_type, char > gLd_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const gLd_type&
    gLd () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    gLd_type&
    gLd ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    gLd (const gLd_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    gLd (::std::unique_ptr< gLd_type > p);

    //@}

    /**
     * @name gNa
     *
     * @brief Accessor and modifier functions for the %gNa
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductanceDensity gNa_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< gNa_type, char > gNa_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const gNa_type&
    gNa () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    gNa_type&
    gNa ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    gNa (const gNa_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    gNa (::std::unique_ptr< gNa_type > p);

    //@}

    /**
     * @name gKdr
     *
     * @brief Accessor and modifier functions for the %gKdr
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductanceDensity gKdr_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< gKdr_type, char > gKdr_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const gKdr_type&
    gKdr () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    gKdr_type&
    gKdr ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    gKdr (const gKdr_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    gKdr (::std::unique_ptr< gKdr_type > p);

    //@}

    /**
     * @name gCa
     *
     * @brief Accessor and modifier functions for the %gCa
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductanceDensity gCa_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< gCa_type, char > gCa_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const gCa_type&
    gCa () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    gCa_type&
    gCa ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    gCa (const gCa_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    gCa (::std::unique_ptr< gCa_type > p);

    //@}

    /**
     * @name gKahp
     *
     * @brief Accessor and modifier functions for the %gKahp
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductanceDensity gKahp_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< gKahp_type, char > gKahp_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const gKahp_type&
    gKahp () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    gKahp_type&
    gKahp ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    gKahp (const gKahp_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    gKahp (::std::unique_ptr< gKahp_type > p);

    //@}

    /**
     * @name gKC
     *
     * @brief Accessor and modifier functions for the %gKC
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductanceDensity gKC_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< gKC_type, char > gKC_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const gKC_type&
    gKC () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    gKC_type&
    gKC ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    gKC (const gKC_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    gKC (::std::unique_ptr< gKC_type > p);

    //@}

    /**
     * @name gNmda
     *
     * @brief Accessor and modifier functions for the %gNmda
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductanceDensity gNmda_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< gNmda_type, char > gNmda_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const gNmda_type&
    gNmda () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    gNmda_type&
    gNmda ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    gNmda (const gNmda_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    gNmda (::std::unique_ptr< gNmda_type > p);

    //@}

    /**
     * @name gAmpa
     *
     * @brief Accessor and modifier functions for the %gAmpa
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductanceDensity gAmpa_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< gAmpa_type, char > gAmpa_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const gAmpa_type&
    gAmpa () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    gAmpa_type&
    gAmpa ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    gAmpa (const gAmpa_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    gAmpa (::std::unique_ptr< gAmpa_type > p);

    //@}

    /**
     * @name eNa
     *
     * @brief Accessor and modifier functions for the %eNa
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage eNa_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< eNa_type, char > eNa_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const eNa_type&
    eNa () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    eNa_type&
    eNa ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    eNa (const eNa_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    eNa (::std::unique_ptr< eNa_type > p);

    //@}

    /**
     * @name eCa
     *
     * @brief Accessor and modifier functions for the %eCa
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage eCa_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< eCa_type, char > eCa_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const eCa_type&
    eCa () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    eCa_type&
    eCa ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    eCa (const eCa_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    eCa (::std::unique_ptr< eCa_type > p);

    //@}

    /**
     * @name eK
     *
     * @brief Accessor and modifier functions for the %eK
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage eK_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< eK_type, char > eK_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const eK_type&
    eK () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    eK_type&
    eK ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    eK (const eK_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    eK (::std::unique_ptr< eK_type > p);

    //@}

    /**
     * @name eL
     *
     * @brief Accessor and modifier functions for the %eL
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage eL_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< eL_type, char > eL_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const eL_type&
    eL () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    eL_type&
    eL ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    eL (const eL_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    eL (::std::unique_ptr< eL_type > p);

    //@}

    /**
     * @name qd0
     *
     * @brief Accessor and modifier functions for the %qd0
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none qd0_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< qd0_type, char > qd0_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const qd0_type&
    qd0 () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    qd0_type&
    qd0 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    qd0 (const qd0_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    qd0 (::std::unique_ptr< qd0_type > p);

    //@}

    /**
     * @name pp
     *
     * @brief Accessor and modifier functions for the %pp
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none pp_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< pp_type, char > pp_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const pp_type&
    pp () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    pp_type&
    pp ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    pp (const pp_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    pp (::std::unique_ptr< pp_type > p);

    //@}

    /**
     * @name alphac
     *
     * @brief Accessor and modifier functions for the %alphac
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none alphac_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< alphac_type, char > alphac_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const alphac_type&
    alphac () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    alphac_type&
    alphac ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    alphac (const alphac_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    alphac (::std::unique_ptr< alphac_type > p);

    //@}

    /**
     * @name betac
     *
     * @brief Accessor and modifier functions for the %betac
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none betac_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< betac_type, char > betac_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const betac_type&
    betac () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    betac_type&
    betac ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    betac (const betac_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    betac (::std::unique_ptr< betac_type > p);

    //@}

    /**
     * @name cm
     *
     * @brief Accessor and modifier functions for the %cm
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_specificCapacitance cm_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< cm_type, char > cm_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const cm_type&
    cm () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    cm_type&
    cm ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    cm (const cm_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    cm (::std::unique_ptr< cm_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PinskyRinzelCA3Cell (const id_type&,
                         const iSoma_type&,
                         const iDend_type&,
                         const gc_type&,
                         const gLs_type&,
                         const gLd_type&,
                         const gNa_type&,
                         const gKdr_type&,
                         const gCa_type&,
                         const gKahp_type&,
                         const gKC_type&,
                         const gNmda_type&,
                         const gAmpa_type&,
                         const eNa_type&,
                         const eCa_type&,
                         const eK_type&,
                         const eL_type&,
                         const qd0_type&,
                         const pp_type&,
                         const alphac_type&,
                         const betac_type&,
                         const cm_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PinskyRinzelCA3Cell (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PinskyRinzelCA3Cell (const PinskyRinzelCA3Cell& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PinskyRinzelCA3Cell*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PinskyRinzelCA3Cell&
    operator= (const PinskyRinzelCA3Cell& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PinskyRinzelCA3Cell ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< iSoma_type > iSoma_;
    ::xsd::cxx::tree::one< iDend_type > iDend_;
    ::xsd::cxx::tree::one< gc_type > gc_;
    ::xsd::cxx::tree::one< gLs_type > gLs_;
    ::xsd::cxx::tree::one< gLd_type > gLd_;
    ::xsd::cxx::tree::one< gNa_type > gNa_;
    ::xsd::cxx::tree::one< gKdr_type > gKdr_;
    ::xsd::cxx::tree::one< gCa_type > gCa_;
    ::xsd::cxx::tree::one< gKahp_type > gKahp_;
    ::xsd::cxx::tree::one< gKC_type > gKC_;
    ::xsd::cxx::tree::one< gNmda_type > gNmda_;
    ::xsd::cxx::tree::one< gAmpa_type > gAmpa_;
    ::xsd::cxx::tree::one< eNa_type > eNa_;
    ::xsd::cxx::tree::one< eCa_type > eCa_;
    ::xsd::cxx::tree::one< eK_type > eK_;
    ::xsd::cxx::tree::one< eL_type > eL_;
    ::xsd::cxx::tree::one< qd0_type > qd0_;
    ::xsd::cxx::tree::one< pp_type > pp_;
    ::xsd::cxx::tree::one< alphac_type > alphac_;
    ::xsd::cxx::tree::one< betac_type > betac_;
    ::xsd::cxx::tree::one< cm_type > cm_;

    //@endcond
  };

  bool
  operator== (const PinskyRinzelCA3Cell&, const PinskyRinzelCA3Cell&);

  bool
  operator!= (const PinskyRinzelCA3Cell&, const PinskyRinzelCA3Cell&);


  /**
   * @brief Class corresponding to the %Cell schema type.
   *
   * Cell with  **segment** s specified in a  **morphology**  element along
   * with details on its  **biophysicalProperties** . NOTE: this can only
   * be correctly simulated using jLEMS when there is a single segment in
   * the cell, and **v**  of this cell represents the membrane potential in
   * that isopotential segment.
   *
   * @nosubgrouping
   */
  class Cell: public ::neuroml2::BaseCell
  {
    public:
    /**
     * @name morphology
     *
     * @brief Accessor and modifier functions for the %morphology
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Morphology morphology_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< morphology_type > morphology_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< morphology_type, char > morphology_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const morphology_optional&
    morphology () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    morphology_optional&
    morphology ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    morphology (const morphology_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    morphology (const morphology_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    morphology (::std::unique_ptr< morphology_type > p);

    //@}

    /**
     * @name biophysicalProperties
     *
     * @brief Accessor and modifier functions for the %biophysicalProperties
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::BiophysicalProperties biophysicalProperties_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< biophysicalProperties_type > biophysicalProperties_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< biophysicalProperties_type, char > biophysicalProperties_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const biophysicalProperties_optional&
    biophysicalProperties () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    biophysicalProperties_optional&
    biophysicalProperties ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    biophysicalProperties (const biophysicalProperties_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    biophysicalProperties (const biophysicalProperties_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    biophysicalProperties (::std::unique_ptr< biophysicalProperties_type > p);

    //@}

    /**
     * @name morphology
     *
     * @brief Accessor and modifier functions for the %morphology
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId morphology1_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< morphology1_type > morphology1_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< morphology1_type, char > morphology1_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const morphology1_optional&
    morphology1 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    morphology1_optional&
    morphology1 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    morphology1 (const morphology1_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    morphology1 (const morphology1_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    morphology1 (::std::unique_ptr< morphology1_type > p);

    //@}

    /**
     * @name biophysicalProperties
     *
     * @brief Accessor and modifier functions for the %biophysicalProperties
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId biophysicalProperties1_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< biophysicalProperties1_type > biophysicalProperties1_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< biophysicalProperties1_type, char > biophysicalProperties1_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const biophysicalProperties1_optional&
    biophysicalProperties1 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    biophysicalProperties1_optional&
    biophysicalProperties1 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    biophysicalProperties1 (const biophysicalProperties1_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    biophysicalProperties1 (const biophysicalProperties1_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    biophysicalProperties1 (::std::unique_ptr< biophysicalProperties1_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Cell (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Cell (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Cell (const Cell& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Cell*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Cell&
    operator= (const Cell& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Cell ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    morphology_optional morphology_;
    biophysicalProperties_optional biophysicalProperties_;
    morphology1_optional morphology1_;
    biophysicalProperties1_optional biophysicalProperties1_;

    //@endcond
  };

  bool
  operator== (const Cell&, const Cell&);

  bool
  operator!= (const Cell&, const Cell&);


  /**
   * @brief Class corresponding to the %Cell2CaPools schema type.
   *
   * Variant of cell with two independent Ca2+ pools. Cell with 
   * **segment** s specified in a  **morphology**  element along with
   * details on its  **biophysicalProperties** . NOTE: this can only be
   * correctly simulated using jLEMS when there is a single segment in the
   * cell, and **v**  of this cell represents the membrane potential in
   * that isopotential segment.
   *
   * @nosubgrouping
   */
  class Cell2CaPools: public ::neuroml2::Cell
  {
    public:
    /**
     * @name biophysicalProperties2CaPools
     *
     * @brief Accessor and modifier functions for the %biophysicalProperties2CaPools
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::BiophysicalProperties2CaPools biophysicalProperties2CaPools_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< biophysicalProperties2CaPools_type > biophysicalProperties2CaPools_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< biophysicalProperties2CaPools_type, char > biophysicalProperties2CaPools_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const biophysicalProperties2CaPools_optional&
    biophysicalProperties2CaPools () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    biophysicalProperties2CaPools_optional&
    biophysicalProperties2CaPools ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    biophysicalProperties2CaPools (const biophysicalProperties2CaPools_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    biophysicalProperties2CaPools (const biophysicalProperties2CaPools_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    biophysicalProperties2CaPools (::std::unique_ptr< biophysicalProperties2CaPools_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Cell2CaPools (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Cell2CaPools (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Cell2CaPools (const Cell2CaPools& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Cell2CaPools*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Cell2CaPools&
    operator= (const Cell2CaPools& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Cell2CaPools ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    biophysicalProperties2CaPools_optional biophysicalProperties2CaPools_;

    //@endcond
  };

  bool
  operator== (const Cell2CaPools&, const Cell2CaPools&);

  bool
  operator!= (const Cell2CaPools&, const Cell2CaPools&);


  /**
   * @brief Class corresponding to the %Morphology schema type.
   *
   * The collection of  **segment** s which specify the 3D structure of the
   * cell, along with a number of  **segmentGroup** s
   *
   * @nosubgrouping
   */
  class Morphology_base: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name segment
     *
     * @brief Accessor and modifier functions for the %segment
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Segment segment_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< segment_type > segment_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef segment_sequence::iterator segment_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef segment_sequence::const_iterator segment_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< segment_type, char > segment_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const segment_sequence&
    segment () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    segment_sequence&
    segment ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    segment (const segment_sequence& s);

    //@}

    /**
     * @name segmentGroup
     *
     * @brief Accessor and modifier functions for the %segmentGroup
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::SegmentGroup segmentGroup_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< segmentGroup_type > segmentGroup_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef segmentGroup_sequence::iterator segmentGroup_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef segmentGroup_sequence::const_iterator segmentGroup_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< segmentGroup_type, char > segmentGroup_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const segmentGroup_sequence&
    segmentGroup () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    segmentGroup_sequence&
    segmentGroup ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    segmentGroup (const segmentGroup_sequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Morphology_base (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Morphology_base (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Morphology_base (const Morphology_base& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Morphology_base*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Morphology_base&
    operator= (const Morphology_base& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Morphology_base ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    segment_sequence segment_;
    segmentGroup_sequence segmentGroup_;

    //@endcond
  };

  bool
  operator== (const Morphology_base&, const Morphology_base&);

  bool
  operator!= (const Morphology_base&, const Morphology_base&);


  /**
   * @brief Class corresponding to the %BaseNonNegativeIntegerId schema type.
   *
   * Anything which can have a unique (within its parent) id, which must be
   * an integer zero or greater.
   *
   * @nosubgrouping
   */
  class BaseNonNegativeIntegerId: public ::neuroml2::BaseWithoutId
  {
    public:
    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NonNegativeInteger id_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const id_type&
    id () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    id_type&
    id ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    id (const id_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    id (::std::unique_ptr< id_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BaseNonNegativeIntegerId (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BaseNonNegativeIntegerId (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BaseNonNegativeIntegerId (const BaseNonNegativeIntegerId& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BaseNonNegativeIntegerId*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BaseNonNegativeIntegerId&
    operator= (const BaseNonNegativeIntegerId& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BaseNonNegativeIntegerId ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< id_type > id_;

    //@endcond
  };

  bool
  operator== (const BaseNonNegativeIntegerId&, const BaseNonNegativeIntegerId&);

  bool
  operator!= (const BaseNonNegativeIntegerId&, const BaseNonNegativeIntegerId&);


  /**
   * @brief Class corresponding to the %Segment schema type.
   *
   * A segment defines the smallest unit within a possibly branching
   * structure (  **morphology**  ), such as a dendrite or axon. Its **id**
   * should be a nonnegative integer ( usually soma/root = 0 ). Its end
   * points are given by the  **proximal**  and  **distal**  points. The 
   * **proximal**  point can be omitted, usually because it is the same as
   * a point on the  **parent**  segment, see  **proximal**  for details. 
   * **parent**  specifies the parent segment. The first segment of a 
   * **cell**  ( with no  **parent**  ) usually represents the soma. The
   * shape is normally a cylinder ( radii of the  **proximal**  and 
   * **distal**  equal, but positions different ) or a conical frustum (
   * radii and positions different ). If the x, y, x positions of the 
   * **proximal**  and  **distal**  are equal, the segment can be
   * interpreted as a sphere, and in this case the radii of these points
   * must be equal. NOTE: LEMS does not yet support multicompartmental
   * modelling, so the Dynamics here is only appropriate for single
   * compartment modelling.
   *
   * @nosubgrouping
   */
  class Segment_base: public ::neuroml2::BaseNonNegativeIntegerId
  {
    public:
    /**
     * @name parent
     *
     * @brief Accessor and modifier functions for the %parent
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::SegmentParent parent_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< parent_type > parent_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< parent_type, char > parent_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const parent_optional&
    parent () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    parent_optional&
    parent ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    parent (const parent_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    parent (const parent_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    parent (::std::unique_ptr< parent_type > p);

    //@}

    /**
     * @name proximal
     *
     * @brief Accessor and modifier functions for the %proximal
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Point3DWithDiam proximal_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< proximal_type > proximal_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< proximal_type, char > proximal_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const proximal_optional&
    proximal () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    proximal_optional&
    proximal ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    proximal (const proximal_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    proximal (const proximal_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    proximal (::std::unique_ptr< proximal_type > p);

    //@}

    /**
     * @name distal
     *
     * @brief Accessor and modifier functions for the %distal
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Point3DWithDiam distal_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< distal_type, char > distal_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const distal_type&
    distal () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    distal_type&
    distal ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    distal (const distal_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    distal (::std::unique_ptr< distal_type > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string name_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< name_type > name_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const name_optional&
    name () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    name_optional&
    name ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    name (const name_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    name (const name_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    name (::std::unique_ptr< name_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Segment_base (const id_type&,
                  const distal_type&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    Segment_base (const id_type&,
                  ::std::unique_ptr< distal_type >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Segment_base (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Segment_base (const Segment_base& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Segment_base*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Segment_base&
    operator= (const Segment_base& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Segment_base ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    parent_optional parent_;
    proximal_optional proximal_;
    ::xsd::cxx::tree::one< distal_type > distal_;
    name_optional name_;

    //@endcond
  };

  bool
  operator== (const Segment_base&, const Segment_base&);

  bool
  operator!= (const Segment_base&, const Segment_base&);


  /**
   * @brief Class corresponding to the %SegmentParent schema type.
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name segment
     *
     * @brief Accessor and modifier functions for the %segment
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NonNegativeInteger segment_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< segment_type, char > segment_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const segment_type&
    segment () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    segment_type&
    segment ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    segment (const segment_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    segment (::std::unique_ptr< segment_type > p);

    //@}

    /**
     * @name fractionAlong
     *
     * @brief Accessor and modifier functions for the %fractionAlong
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::ZeroToOne fractionAlong_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< fractionAlong_type, char > fractionAlong_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const fractionAlong_type&
    fractionAlong () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    fractionAlong_type&
    fractionAlong ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    fractionAlong (const fractionAlong_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    fractionAlong (::std::unique_ptr< fractionAlong_type > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static fractionAlong_type
    fractionAlong_default_value ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SegmentParent (const segment_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SegmentParent (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SegmentParent (const SegmentParent& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SegmentParent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SegmentParent&
    operator= (const SegmentParent& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SegmentParent ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< segment_type > segment_;
    ::xsd::cxx::tree::one< fractionAlong_type > fractionAlong_;

    //@endcond
  };

  bool
  operator== (const SegmentParent&, const SegmentParent&);

  bool
  operator!= (const SegmentParent&, const SegmentParent&);


  /**
   * @brief Class corresponding to the %Point3DWithDiam schema type.
   *
   * Base type for ComponentTypes which specify an ( **x,**  **y,**  **z** 
   * ) coordinate along with a **diameter.**  Note: no dimension used in
   * the attributes for these coordinates! These are assumed to have
   * dimension micrometer ( 10^-6 m ). This is due to micrometers being the
   * default option for the majority of neuronal morphology formats, and
   * dimensions are omitted here to facilitate reading and writing of
   * morphologies in NeuroML.
   * @param x: x coordinate of the point. Note no dimension used, see
   * description of  **point3DWithDiam**  for details.
   * @param y: y coordinate of the ppoint. Note no dimension used, see
   * description of  **point3DWithDiam**  for details.
   * @param z: z coordinate of the ppoint. Note no dimension used, see
   * description of  **point3DWithDiam**  for details.
   * @param diameter: Diameter of the ppoint. Note no dimension used, see
   * description of  **point3DWithDiam**  for details.
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name x
     *
     * @brief Accessor and modifier functions for the %x
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::double_ x_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::double_ > x_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const x_type&
    x () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    x_type&
    x ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    x (const x_type& x);

    //@}

    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::double_ y_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::double_ > y_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const y_type&
    y () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    y_type&
    y ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    y (const y_type& x);

    //@}

    /**
     * @name z
     *
     * @brief Accessor and modifier functions for the %z
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::double_ z_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< z_type, char, ::xsd::cxx::tree::schema_type::double_ > z_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const z_type&
    z () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    z_type&
    z ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    z (const z_type& x);

    //@}

    /**
     * @name diameter
     *
     * @brief Accessor and modifier functions for the %diameter
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::DoubleGreaterThanZero diameter_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< diameter_type, char > diameter_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const diameter_type&
    diameter () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    diameter_type&
    diameter ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    diameter (const diameter_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    diameter (::std::unique_ptr< diameter_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Point3DWithDiam (const x_type&,
                     const y_type&,
                     const z_type&,
                     const diameter_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Point3DWithDiam (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Point3DWithDiam (const Point3DWithDiam& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Point3DWithDiam*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Point3DWithDiam&
    operator= (const Point3DWithDiam& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Point3DWithDiam ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< x_type > x_;
    ::xsd::cxx::tree::one< y_type > y_;
    ::xsd::cxx::tree::one< z_type > z_;
    ::xsd::cxx::tree::one< diameter_type > diameter_;

    //@endcond
  };

  bool
  operator== (const Point3DWithDiam&, const Point3DWithDiam&);

  bool
  operator!= (const Point3DWithDiam&, const Point3DWithDiam&);


  /**
   * @brief Class corresponding to the %SegmentGroup schema type.
   *
   * A method to describe a group of  **segment** s in a  **morphology** ,
   * e. g. soma_group, dendrite_group, axon_group. While a name is useful
   * to describe the group, the **neuroLexId**  attribute can be used to
   * explicitly specify the meaning of the group, e. g. sao1044911821 for
   * 'Neuronal Cell Body', sao1211023249 for 'Dendrite'. The  **segment** s
   * in this group can be specified as: a list of individual  **member** 
   * segments; a  **path** , all of the segments along which should be
   * included; a  **subTree**  of the  **cell**  to include; other
   * segmentGroups to  **include**  ( so all segments from those get
   * included here ). An  **inhomogeneousParameter**  can be defined on the
   * region of the cell specified by this group ( see 
   * **variableParameter**  for usage ).
   *
   * @nosubgrouping
   */
  class SegmentGroup: public ::neuroml2::Base
  {
    public:
    /**
     * @name notes
     *
     * @brief Accessor and modifier functions for the %notes
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Notes notes_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< notes_type > notes_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< notes_type, char > notes_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const notes_optional&
    notes () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    notes_optional&
    notes ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    notes (const notes_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    notes (const notes_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    notes (::std::unique_ptr< notes_type > p);

    //@}

    /**
     * @name property
     *
     * @brief Accessor and modifier functions for the %property
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Property property_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< property_type > property_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef property_sequence::iterator property_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef property_sequence::const_iterator property_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< property_type, char > property_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const property_sequence&
    property () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    property_sequence&
    property ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    property (const property_sequence& s);

    //@}

    /**
     * @name annotation
     *
     * @brief Accessor and modifier functions for the %annotation
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Annotation annotation_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< annotation_type > annotation_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< annotation_type, char > annotation_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const annotation_optional&
    annotation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    annotation_optional&
    annotation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    annotation (const annotation_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    annotation (const annotation_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    annotation (::std::unique_ptr< annotation_type > p);

    //@}

    /**
     * @name member
     *
     * @brief Accessor and modifier functions for the %member
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Member member_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< member_type > member_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef member_sequence::iterator member_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef member_sequence::const_iterator member_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< member_type, char > member_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const member_sequence&
    member () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    member_sequence&
    member ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    member (const member_sequence& s);

    //@}

    /**
     * @name include
     *
     * @brief Accessor and modifier functions for the %include
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Include include_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef include_sequence::iterator include_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef include_sequence::const_iterator include_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const include_sequence&
    include () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    include_sequence&
    include ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    include (const include_sequence& s);

    //@}

    /**
     * @name path
     *
     * @brief Accessor and modifier functions for the %path
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Path path_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< path_type > path_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef path_sequence::iterator path_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef path_sequence::const_iterator path_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< path_type, char > path_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const path_sequence&
    path () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    path_sequence&
    path ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    path (const path_sequence& s);

    //@}

    /**
     * @name subTree
     *
     * @brief Accessor and modifier functions for the %subTree
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::SubTree subTree_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< subTree_type > subTree_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef subTree_sequence::iterator subTree_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef subTree_sequence::const_iterator subTree_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< subTree_type, char > subTree_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const subTree_sequence&
    subTree () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    subTree_sequence&
    subTree ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    subTree (const subTree_sequence& s);

    //@}

    /**
     * @name inhomogeneousParameter
     *
     * @brief Accessor and modifier functions for the %inhomogeneousParameter
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::InhomogeneousParameter inhomogeneousParameter_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< inhomogeneousParameter_type > inhomogeneousParameter_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef inhomogeneousParameter_sequence::iterator inhomogeneousParameter_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef inhomogeneousParameter_sequence::const_iterator inhomogeneousParameter_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< inhomogeneousParameter_type, char > inhomogeneousParameter_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const inhomogeneousParameter_sequence&
    inhomogeneousParameter () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    inhomogeneousParameter_sequence&
    inhomogeneousParameter ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    inhomogeneousParameter (const inhomogeneousParameter_sequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SegmentGroup (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SegmentGroup (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SegmentGroup (const SegmentGroup& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SegmentGroup*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SegmentGroup&
    operator= (const SegmentGroup& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SegmentGroup ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    notes_optional notes_;
    property_sequence property_;
    annotation_optional annotation_;
    member_sequence member_;
    include_sequence include_;
    path_sequence path_;
    subTree_sequence subTree_;
    inhomogeneousParameter_sequence inhomogeneousParameter_;

    //@endcond
  };

  bool
  operator== (const SegmentGroup&, const SegmentGroup&);

  bool
  operator!= (const SegmentGroup&, const SegmentGroup&);


  /**
   * @brief Class corresponding to the %InhomogeneousParameter schema type.
   *
   * An inhomogeneous parameter specified across the  **segmentGroup**  (
   * see  **variableParameter**  for usage ).
   *
   * @nosubgrouping
   */
  class InhomogeneousParameter: public ::neuroml2::Base
  {
    public:
    /**
     * @name proximal
     *
     * @brief Accessor and modifier functions for the %proximal
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ProximalDetails proximal_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< proximal_type > proximal_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< proximal_type, char > proximal_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const proximal_optional&
    proximal () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    proximal_optional&
    proximal ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    proximal (const proximal_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    proximal (const proximal_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    proximal (::std::unique_ptr< proximal_type > p);

    //@}

    /**
     * @name distal
     *
     * @brief Accessor and modifier functions for the %distal
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::DistalDetails distal_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< distal_type > distal_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< distal_type, char > distal_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const distal_optional&
    distal () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    distal_optional&
    distal ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    distal (const distal_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    distal (const distal_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    distal (::std::unique_ptr< distal_type > p);

    //@}

    /**
     * @name variable
     *
     * @brief Accessor and modifier functions for the %variable
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string variable_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< variable_type, char > variable_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const variable_type&
    variable () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    variable_type&
    variable ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    variable (const variable_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    variable (::std::unique_ptr< variable_type > p);

    //@}

    /**
     * @name metric
     *
     * @brief Accessor and modifier functions for the %metric
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Metric metric_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< metric_type, char > metric_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const metric_type&
    metric () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    metric_type&
    metric ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    metric (const metric_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    metric (::std::unique_ptr< metric_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InhomogeneousParameter (const id_type&,
                            const variable_type&,
                            const metric_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InhomogeneousParameter (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InhomogeneousParameter (const InhomogeneousParameter& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InhomogeneousParameter*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InhomogeneousParameter&
    operator= (const InhomogeneousParameter& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InhomogeneousParameter ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    proximal_optional proximal_;
    distal_optional distal_;
    ::xsd::cxx::tree::one< variable_type > variable_;
    ::xsd::cxx::tree::one< metric_type > metric_;

    //@endcond
  };

  bool
  operator== (const InhomogeneousParameter&, const InhomogeneousParameter&);

  bool
  operator!= (const InhomogeneousParameter&, const InhomogeneousParameter&);


  /**
   * @brief Enumeration class corresponding to the %Metric
   * schema type.
   *
   * Allowed metrics for InhomogeneousParam
   */
  class Metric: public ::xml_schema::string
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum value
    {
      Path_Length_from_root
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Metric (value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Metric (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Metric (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Metric (const ::xml_schema::string& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Metric (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Metric (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Metric (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Metric (const Metric& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Metric*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Metric&
    operator= (value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator value () const
    {
      return _xsd_Metric_convert ();
    }

    //@cond

    protected:
    value
    _xsd_Metric_convert () const;

    public:
    static const char* const _xsd_Metric_literals_[1];
    static const value _xsd_Metric_indexes_[1];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ProximalDetails schema type.
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name translationStart
     *
     * @brief Accessor and modifier functions for the %translationStart
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::double_ translationStart_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< translationStart_type, char, ::xsd::cxx::tree::schema_type::double_ > translationStart_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const translationStart_type&
    translationStart () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    translationStart_type&
    translationStart ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    translationStart (const translationStart_type& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ProximalDetails (const translationStart_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ProximalDetails (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ProximalDetails (const ProximalDetails& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ProximalDetails*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ProximalDetails&
    operator= (const ProximalDetails& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ProximalDetails ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< translationStart_type > translationStart_;

    //@endcond
  };

  bool
  operator== (const ProximalDetails&, const ProximalDetails&);

  bool
  operator!= (const ProximalDetails&, const ProximalDetails&);


  /**
   * @brief Class corresponding to the %DistalDetails schema type.
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name normalizationEnd
     *
     * @brief Accessor and modifier functions for the %normalizationEnd
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::double_ normalizationEnd_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< normalizationEnd_type, char, ::xsd::cxx::tree::schema_type::double_ > normalizationEnd_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const normalizationEnd_type&
    normalizationEnd () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    normalizationEnd_type&
    normalizationEnd ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    normalizationEnd (const normalizationEnd_type& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DistalDetails (const normalizationEnd_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DistalDetails (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DistalDetails (const DistalDetails& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DistalDetails*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DistalDetails&
    operator= (const DistalDetails& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DistalDetails ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< normalizationEnd_type > normalizationEnd_;

    //@endcond
  };

  bool
  operator== (const DistalDetails&, const DistalDetails&);

  bool
  operator!= (const DistalDetails&, const DistalDetails&);


  /**
   * @brief Class corresponding to the %Member schema type.
   *
   * A single identified **segment**  which is part of the 
  **segmentGroup** *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name segment
     *
     * @brief Accessor and modifier functions for the %segment
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NonNegativeInteger segment_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< segment_type, char > segment_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const segment_type&
    segment () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    segment_type&
    segment ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    segment (const segment_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    segment (::std::unique_ptr< segment_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Member (const segment_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Member (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Member (const Member& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Member*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Member&
    operator= (const Member& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Member ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< segment_type > segment_;

    //@endcond
  };

  bool
  operator== (const Member&, const Member&);

  bool
  operator!= (const Member&, const Member&);


  /**
   * @brief Class corresponding to the %Include schema type.
   *
   * Include all members of another  **segmentGroup**  in this group
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name segmentGroup
     *
     * @brief Accessor and modifier functions for the %segmentGroup
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId segmentGroup_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< segmentGroup_type, char > segmentGroup_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const segmentGroup_type&
    segmentGroup () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    segmentGroup_type&
    segmentGroup ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    segmentGroup (const segmentGroup_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    segmentGroup (::std::unique_ptr< segmentGroup_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Include (const segmentGroup_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Include (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Include (const Include& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Include*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Include&
    operator= (const Include& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Include ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< segmentGroup_type > segmentGroup_;

    //@endcond
  };

  bool
  operator== (const Include&, const Include&);

  bool
  operator!= (const Include&, const Include&);


  /**
   * @brief Class corresponding to the %Path schema type.
   *
   * Include all the  **segment** s between those specified by  **from** 
   * and  **to** , inclusive
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name from
     *
     * @brief Accessor and modifier functions for the %from
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::SegmentEndPoint from_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< from_type > from_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< from_type, char > from_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const from_optional&
    from () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    from_optional&
    from ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    from (const from_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    from (const from_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    from (::std::unique_ptr< from_type > p);

    //@}

    /**
     * @name to
     *
     * @brief Accessor and modifier functions for the %to
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::SegmentEndPoint to_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< to_type > to_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< to_type, char > to_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const to_optional&
    to () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    to_optional&
    to ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    to (const to_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    to (const to_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    to (::std::unique_ptr< to_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Path ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Path (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Path (const Path& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Path*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Path&
    operator= (const Path& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Path ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    from_optional from_;
    to_optional to_;

    //@endcond
  };

  bool
  operator== (const Path&, const Path&);

  bool
  operator!= (const Path&, const Path&);


  /**
   * @brief Class corresponding to the %SubTree schema type.
   *
   * Include all the  **segment** s distal to that specified by  **from** 
   * in the  **segmentGroup**
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name from
     *
     * @brief Accessor and modifier functions for the %from
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::SegmentEndPoint from_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< from_type > from_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< from_type, char > from_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const from_optional&
    from () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    from_optional&
    from ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    from (const from_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    from (const from_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    from (::std::unique_ptr< from_type > p);

    //@}

    /**
     * @name to
     *
     * @brief Accessor and modifier functions for the %to
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::SegmentEndPoint to_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< to_type > to_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< to_type, char > to_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const to_optional&
    to () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    to_optional&
    to ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    to (const to_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    to (const to_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    to (::std::unique_ptr< to_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SubTree ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SubTree (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SubTree (const SubTree& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SubTree*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SubTree&
    operator= (const SubTree& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SubTree ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    from_optional from_;
    to_optional to_;

    //@endcond
  };

  bool
  operator== (const SubTree&, const SubTree&);

  bool
  operator!= (const SubTree&, const SubTree&);


  /**
   * @brief Class corresponding to the %SegmentEndPoint schema type.
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name segment
     *
     * @brief Accessor and modifier functions for the %segment
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NonNegativeInteger segment_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< segment_type, char > segment_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const segment_type&
    segment () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    segment_type&
    segment ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    segment (const segment_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    segment (::std::unique_ptr< segment_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SegmentEndPoint (const segment_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SegmentEndPoint (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SegmentEndPoint (const SegmentEndPoint& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SegmentEndPoint*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SegmentEndPoint&
    operator= (const SegmentEndPoint& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SegmentEndPoint ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< segment_type > segment_;

    //@endcond
  };

  bool
  operator== (const SegmentEndPoint&, const SegmentEndPoint&);

  bool
  operator!= (const SegmentEndPoint&, const SegmentEndPoint&);


  /**
   * @brief Class corresponding to the %BiophysicalProperties schema type.
   *
   * The biophysical properties of the  **cell** , including the 
   * **membraneProperties**  and the  **intracellularProperties**
   *
   * @nosubgrouping
   */
  class BiophysicalProperties: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name membraneProperties
     *
     * @brief Accessor and modifier functions for the %membraneProperties
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::MembraneProperties membraneProperties_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< membraneProperties_type, char > membraneProperties_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const membraneProperties_type&
    membraneProperties () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    membraneProperties_type&
    membraneProperties ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    membraneProperties (const membraneProperties_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    membraneProperties (::std::unique_ptr< membraneProperties_type > p);

    //@}

    /**
     * @name intracellularProperties
     *
     * @brief Accessor and modifier functions for the %intracellularProperties
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::IntracellularProperties intracellularProperties_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< intracellularProperties_type > intracellularProperties_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< intracellularProperties_type, char > intracellularProperties_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const intracellularProperties_optional&
    intracellularProperties () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    intracellularProperties_optional&
    intracellularProperties ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    intracellularProperties (const intracellularProperties_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    intracellularProperties (const intracellularProperties_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    intracellularProperties (::std::unique_ptr< intracellularProperties_type > p);

    //@}

    /**
     * @name extracellularProperties
     *
     * @brief Accessor and modifier functions for the %extracellularProperties
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ExtracellularProperties extracellularProperties_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< extracellularProperties_type > extracellularProperties_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< extracellularProperties_type, char > extracellularProperties_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const extracellularProperties_optional&
    extracellularProperties () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    extracellularProperties_optional&
    extracellularProperties ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    extracellularProperties (const extracellularProperties_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    extracellularProperties (const extracellularProperties_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    extracellularProperties (::std::unique_ptr< extracellularProperties_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BiophysicalProperties (const id_type&,
                           const membraneProperties_type&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    BiophysicalProperties (const id_type&,
                           ::std::unique_ptr< membraneProperties_type >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BiophysicalProperties (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BiophysicalProperties (const BiophysicalProperties& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BiophysicalProperties*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BiophysicalProperties&
    operator= (const BiophysicalProperties& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BiophysicalProperties ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< membraneProperties_type > membraneProperties_;
    intracellularProperties_optional intracellularProperties_;
    extracellularProperties_optional extracellularProperties_;

    //@endcond
  };

  bool
  operator== (const BiophysicalProperties&, const BiophysicalProperties&);

  bool
  operator!= (const BiophysicalProperties&, const BiophysicalProperties&);


  /**
   * @brief Class corresponding to the %BiophysicalProperties2CaPools schema type.
   *
   * The biophysical properties of the  **cell** , including the 
   * **membraneProperties2CaPools**  and the 
   * **intracellularProperties2CaPools**  for a cell with two Ca pools
   *
   * @nosubgrouping
   */
  class BiophysicalProperties2CaPools: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name membraneProperties2CaPools
     *
     * @brief Accessor and modifier functions for the %membraneProperties2CaPools
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::MembraneProperties2CaPools membraneProperties2CaPools_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< membraneProperties2CaPools_type, char > membraneProperties2CaPools_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const membraneProperties2CaPools_type&
    membraneProperties2CaPools () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    membraneProperties2CaPools_type&
    membraneProperties2CaPools ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    membraneProperties2CaPools (const membraneProperties2CaPools_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    membraneProperties2CaPools (::std::unique_ptr< membraneProperties2CaPools_type > p);

    //@}

    /**
     * @name intracellularProperties2CaPools
     *
     * @brief Accessor and modifier functions for the %intracellularProperties2CaPools
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::IntracellularProperties2CaPools intracellularProperties2CaPools_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< intracellularProperties2CaPools_type > intracellularProperties2CaPools_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< intracellularProperties2CaPools_type, char > intracellularProperties2CaPools_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const intracellularProperties2CaPools_optional&
    intracellularProperties2CaPools () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    intracellularProperties2CaPools_optional&
    intracellularProperties2CaPools ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    intracellularProperties2CaPools (const intracellularProperties2CaPools_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    intracellularProperties2CaPools (const intracellularProperties2CaPools_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    intracellularProperties2CaPools (::std::unique_ptr< intracellularProperties2CaPools_type > p);

    //@}

    /**
     * @name extracellularProperties
     *
     * @brief Accessor and modifier functions for the %extracellularProperties
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ExtracellularProperties extracellularProperties_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< extracellularProperties_type > extracellularProperties_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< extracellularProperties_type, char > extracellularProperties_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const extracellularProperties_optional&
    extracellularProperties () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    extracellularProperties_optional&
    extracellularProperties ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    extracellularProperties (const extracellularProperties_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    extracellularProperties (const extracellularProperties_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    extracellularProperties (::std::unique_ptr< extracellularProperties_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BiophysicalProperties2CaPools (const id_type&,
                                   const membraneProperties2CaPools_type&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    BiophysicalProperties2CaPools (const id_type&,
                                   ::std::unique_ptr< membraneProperties2CaPools_type >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BiophysicalProperties2CaPools (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BiophysicalProperties2CaPools (const BiophysicalProperties2CaPools& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BiophysicalProperties2CaPools*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BiophysicalProperties2CaPools&
    operator= (const BiophysicalProperties2CaPools& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BiophysicalProperties2CaPools ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< membraneProperties2CaPools_type > membraneProperties2CaPools_;
    intracellularProperties2CaPools_optional intracellularProperties2CaPools_;
    extracellularProperties_optional extracellularProperties_;

    //@endcond
  };

  bool
  operator== (const BiophysicalProperties2CaPools&, const BiophysicalProperties2CaPools&);

  bool
  operator!= (const BiophysicalProperties2CaPools&, const BiophysicalProperties2CaPools&);


  /**
   * @brief Class corresponding to the %MembraneProperties schema type.
   *
   * Properties specific to the membrane, such as the **populations**  of
   * channels, **channelDensities,**  **specificCapacitance,**  etc.
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name channelPopulation
     *
     * @brief Accessor and modifier functions for the %channelPopulation
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ChannelPopulation channelPopulation_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< channelPopulation_type > channelPopulation_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef channelPopulation_sequence::iterator channelPopulation_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef channelPopulation_sequence::const_iterator channelPopulation_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< channelPopulation_type, char > channelPopulation_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const channelPopulation_sequence&
    channelPopulation () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    channelPopulation_sequence&
    channelPopulation ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    channelPopulation (const channelPopulation_sequence& s);

    //@}

    /**
     * @name channelDensity
     *
     * @brief Accessor and modifier functions for the %channelDensity
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ChannelDensity channelDensity_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< channelDensity_type > channelDensity_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef channelDensity_sequence::iterator channelDensity_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef channelDensity_sequence::const_iterator channelDensity_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< channelDensity_type, char > channelDensity_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const channelDensity_sequence&
    channelDensity () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    channelDensity_sequence&
    channelDensity ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    channelDensity (const channelDensity_sequence& s);

    //@}

    /**
     * @name channelDensityVShift
     *
     * @brief Accessor and modifier functions for the %channelDensityVShift
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ChannelDensityVShift channelDensityVShift_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< channelDensityVShift_type > channelDensityVShift_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef channelDensityVShift_sequence::iterator channelDensityVShift_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef channelDensityVShift_sequence::const_iterator channelDensityVShift_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< channelDensityVShift_type, char > channelDensityVShift_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const channelDensityVShift_sequence&
    channelDensityVShift () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    channelDensityVShift_sequence&
    channelDensityVShift ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    channelDensityVShift (const channelDensityVShift_sequence& s);

    //@}

    /**
     * @name channelDensityNernst
     *
     * @brief Accessor and modifier functions for the %channelDensityNernst
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ChannelDensityNernst channelDensityNernst_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< channelDensityNernst_type > channelDensityNernst_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef channelDensityNernst_sequence::iterator channelDensityNernst_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef channelDensityNernst_sequence::const_iterator channelDensityNernst_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< channelDensityNernst_type, char > channelDensityNernst_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const channelDensityNernst_sequence&
    channelDensityNernst () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    channelDensityNernst_sequence&
    channelDensityNernst ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    channelDensityNernst (const channelDensityNernst_sequence& s);

    //@}

    /**
     * @name channelDensityGHK
     *
     * @brief Accessor and modifier functions for the %channelDensityGHK
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ChannelDensityGHK channelDensityGHK_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< channelDensityGHK_type > channelDensityGHK_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef channelDensityGHK_sequence::iterator channelDensityGHK_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef channelDensityGHK_sequence::const_iterator channelDensityGHK_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< channelDensityGHK_type, char > channelDensityGHK_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const channelDensityGHK_sequence&
    channelDensityGHK () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    channelDensityGHK_sequence&
    channelDensityGHK ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    channelDensityGHK (const channelDensityGHK_sequence& s);

    //@}

    /**
     * @name channelDensityGHK2
     *
     * @brief Accessor and modifier functions for the %channelDensityGHK2
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ChannelDensityGHK2 channelDensityGHK2_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< channelDensityGHK2_type > channelDensityGHK2_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef channelDensityGHK2_sequence::iterator channelDensityGHK2_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef channelDensityGHK2_sequence::const_iterator channelDensityGHK2_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< channelDensityGHK2_type, char > channelDensityGHK2_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const channelDensityGHK2_sequence&
    channelDensityGHK2 () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    channelDensityGHK2_sequence&
    channelDensityGHK2 ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    channelDensityGHK2 (const channelDensityGHK2_sequence& s);

    //@}

    /**
     * @name channelDensityNonUniform
     *
     * @brief Accessor and modifier functions for the %channelDensityNonUniform
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ChannelDensityNonUniform channelDensityNonUniform_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< channelDensityNonUniform_type > channelDensityNonUniform_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef channelDensityNonUniform_sequence::iterator channelDensityNonUniform_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef channelDensityNonUniform_sequence::const_iterator channelDensityNonUniform_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< channelDensityNonUniform_type, char > channelDensityNonUniform_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const channelDensityNonUniform_sequence&
    channelDensityNonUniform () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    channelDensityNonUniform_sequence&
    channelDensityNonUniform ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    channelDensityNonUniform (const channelDensityNonUniform_sequence& s);

    //@}

    /**
     * @name channelDensityNonUniformNernst
     *
     * @brief Accessor and modifier functions for the %channelDensityNonUniformNernst
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ChannelDensityNonUniformNernst channelDensityNonUniformNernst_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< channelDensityNonUniformNernst_type > channelDensityNonUniformNernst_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef channelDensityNonUniformNernst_sequence::iterator channelDensityNonUniformNernst_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef channelDensityNonUniformNernst_sequence::const_iterator channelDensityNonUniformNernst_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< channelDensityNonUniformNernst_type, char > channelDensityNonUniformNernst_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const channelDensityNonUniformNernst_sequence&
    channelDensityNonUniformNernst () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    channelDensityNonUniformNernst_sequence&
    channelDensityNonUniformNernst ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    channelDensityNonUniformNernst (const channelDensityNonUniformNernst_sequence& s);

    //@}

    /**
     * @name channelDensityNonUniformGHK
     *
     * @brief Accessor and modifier functions for the %channelDensityNonUniformGHK
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ChannelDensityNonUniformGHK channelDensityNonUniformGHK_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< channelDensityNonUniformGHK_type > channelDensityNonUniformGHK_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef channelDensityNonUniformGHK_sequence::iterator channelDensityNonUniformGHK_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef channelDensityNonUniformGHK_sequence::const_iterator channelDensityNonUniformGHK_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< channelDensityNonUniformGHK_type, char > channelDensityNonUniformGHK_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const channelDensityNonUniformGHK_sequence&
    channelDensityNonUniformGHK () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    channelDensityNonUniformGHK_sequence&
    channelDensityNonUniformGHK ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    channelDensityNonUniformGHK (const channelDensityNonUniformGHK_sequence& s);

    //@}

    /**
     * @name spikeThresh
     *
     * @brief Accessor and modifier functions for the %spikeThresh
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::SpikeThresh spikeThresh_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< spikeThresh_type > spikeThresh_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef spikeThresh_sequence::iterator spikeThresh_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef spikeThresh_sequence::const_iterator spikeThresh_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< spikeThresh_type, char > spikeThresh_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const spikeThresh_sequence&
    spikeThresh () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    spikeThresh_sequence&
    spikeThresh ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    spikeThresh (const spikeThresh_sequence& s);

    //@}

    /**
     * @name specificCapacitance
     *
     * @brief Accessor and modifier functions for the %specificCapacitance
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::SpecificCapacitance specificCapacitance_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< specificCapacitance_type > specificCapacitance_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef specificCapacitance_sequence::iterator specificCapacitance_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef specificCapacitance_sequence::const_iterator specificCapacitance_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< specificCapacitance_type, char > specificCapacitance_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const specificCapacitance_sequence&
    specificCapacitance () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    specificCapacitance_sequence&
    specificCapacitance ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    specificCapacitance (const specificCapacitance_sequence& s);

    //@}

    /**
     * @name initMembPotential
     *
     * @brief Accessor and modifier functions for the %initMembPotential
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::InitMembPotential initMembPotential_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< initMembPotential_type > initMembPotential_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef initMembPotential_sequence::iterator initMembPotential_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef initMembPotential_sequence::const_iterator initMembPotential_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< initMembPotential_type, char > initMembPotential_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const initMembPotential_sequence&
    initMembPotential () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    initMembPotential_sequence&
    initMembPotential ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    initMembPotential (const initMembPotential_sequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MembraneProperties ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MembraneProperties (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MembraneProperties (const MembraneProperties& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MembraneProperties*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MembraneProperties&
    operator= (const MembraneProperties& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MembraneProperties ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    channelPopulation_sequence channelPopulation_;
    channelDensity_sequence channelDensity_;
    channelDensityVShift_sequence channelDensityVShift_;
    channelDensityNernst_sequence channelDensityNernst_;
    channelDensityGHK_sequence channelDensityGHK_;
    channelDensityGHK2_sequence channelDensityGHK2_;
    channelDensityNonUniform_sequence channelDensityNonUniform_;
    channelDensityNonUniformNernst_sequence channelDensityNonUniformNernst_;
    channelDensityNonUniformGHK_sequence channelDensityNonUniformGHK_;
    spikeThresh_sequence spikeThresh_;
    specificCapacitance_sequence specificCapacitance_;
    initMembPotential_sequence initMembPotential_;

    //@endcond
  };

  bool
  operator== (const MembraneProperties&, const MembraneProperties&);

  bool
  operator!= (const MembraneProperties&, const MembraneProperties&);


  /**
   * @brief Class corresponding to the %MembraneProperties2CaPools schema type.
   *
   * Variant of membraneProperties with 2 independent Ca pools
   *
   * @nosubgrouping
   */
  class MembraneProperties2CaPools: public ::neuroml2::MembraneProperties
  {
    public:
    /**
     * @name channelDensityNernstCa2
     *
     * @brief Accessor and modifier functions for the %channelDensityNernstCa2
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ChannelDensityNernstCa2 channelDensityNernstCa2_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< channelDensityNernstCa2_type > channelDensityNernstCa2_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef channelDensityNernstCa2_sequence::iterator channelDensityNernstCa2_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef channelDensityNernstCa2_sequence::const_iterator channelDensityNernstCa2_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< channelDensityNernstCa2_type, char > channelDensityNernstCa2_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const channelDensityNernstCa2_sequence&
    channelDensityNernstCa2 () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    channelDensityNernstCa2_sequence&
    channelDensityNernstCa2 ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    channelDensityNernstCa2 (const channelDensityNernstCa2_sequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MembraneProperties2CaPools ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MembraneProperties2CaPools (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MembraneProperties2CaPools (const MembraneProperties2CaPools& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MembraneProperties2CaPools*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MembraneProperties2CaPools&
    operator= (const MembraneProperties2CaPools& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MembraneProperties2CaPools ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    channelDensityNernstCa2_sequence channelDensityNernstCa2_;

    //@endcond
  };

  bool
  operator== (const MembraneProperties2CaPools&, const MembraneProperties2CaPools&);

  bool
  operator!= (const MembraneProperties2CaPools&, const MembraneProperties2CaPools&);


  /**
   * @brief Class corresponding to the %SpikeThresh schema type.
   *
   * Membrane potential at which to emit a spiking event. Note, usually the
   * spiking event will not be emitted again until the membrane potential
   * has fallen below this value and rises again to cross it in a positive
   * direction
   * @param value 
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage value_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const value_type&
    value () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    value_type&
    value ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    value (const value_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    value (::std::unique_ptr< value_type > p);

    //@}

    /**
     * @name segmentGroup
     *
     * @brief Accessor and modifier functions for the %segmentGroup
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId segmentGroup_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< segmentGroup_type, char > segmentGroup_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const segmentGroup_type&
    segmentGroup () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    segmentGroup_type&
    segmentGroup ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    segmentGroup (const segmentGroup_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    segmentGroup (::std::unique_ptr< segmentGroup_type > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const segmentGroup_type&
    segmentGroup_default_value ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SpikeThresh (const value_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SpikeThresh (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SpikeThresh (const SpikeThresh& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SpikeThresh*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SpikeThresh&
    operator= (const SpikeThresh& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SpikeThresh ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< value_type > value_;
    ::xsd::cxx::tree::one< segmentGroup_type > segmentGroup_;
    static const segmentGroup_type segmentGroup_default_value_;

    //@endcond
  };

  bool
  operator== (const SpikeThresh&, const SpikeThresh&);

  bool
  operator!= (const SpikeThresh&, const SpikeThresh&);


  /**
   * @brief Class corresponding to the %SpecificCapacitance schema type.
   *
   * Capacitance per unit area
   * @param value 
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_specificCapacitance value_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const value_type&
    value () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    value_type&
    value ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    value (const value_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    value (::std::unique_ptr< value_type > p);

    //@}

    /**
     * @name segmentGroup
     *
     * @brief Accessor and modifier functions for the %segmentGroup
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId segmentGroup_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< segmentGroup_type, char > segmentGroup_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const segmentGroup_type&
    segmentGroup () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    segmentGroup_type&
    segmentGroup ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    segmentGroup (const segmentGroup_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    segmentGroup (::std::unique_ptr< segmentGroup_type > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const segmentGroup_type&
    segmentGroup_default_value ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SpecificCapacitance (const value_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SpecificCapacitance (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SpecificCapacitance (const SpecificCapacitance& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SpecificCapacitance*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SpecificCapacitance&
    operator= (const SpecificCapacitance& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SpecificCapacitance ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< value_type > value_;
    ::xsd::cxx::tree::one< segmentGroup_type > segmentGroup_;
    static const segmentGroup_type segmentGroup_default_value_;

    //@endcond
  };

  bool
  operator== (const SpecificCapacitance&, const SpecificCapacitance&);

  bool
  operator!= (const SpecificCapacitance&, const SpecificCapacitance&);


  /**
   * @brief Class corresponding to the %InitMembPotential schema type.
   *
   * Explicitly set initial membrane potential for the cell
   * @param value 
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage value_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const value_type&
    value () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    value_type&
    value ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    value (const value_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    value (::std::unique_ptr< value_type > p);

    //@}

    /**
     * @name segmentGroup
     *
     * @brief Accessor and modifier functions for the %segmentGroup
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId segmentGroup_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< segmentGroup_type, char > segmentGroup_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const segmentGroup_type&
    segmentGroup () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    segmentGroup_type&
    segmentGroup ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    segmentGroup (const segmentGroup_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    segmentGroup (::std::unique_ptr< segmentGroup_type > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const segmentGroup_type&
    segmentGroup_default_value ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InitMembPotential (const value_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InitMembPotential (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InitMembPotential (const InitMembPotential& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InitMembPotential*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InitMembPotential&
    operator= (const InitMembPotential& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InitMembPotential ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< value_type > value_;
    ::xsd::cxx::tree::one< segmentGroup_type > segmentGroup_;
    static const segmentGroup_type segmentGroup_default_value_;

    //@endcond
  };

  bool
  operator== (const InitMembPotential&, const InitMembPotential&);

  bool
  operator!= (const InitMembPotential&, const InitMembPotential&);


  /**
   * @brief Class corresponding to the %Resistivity schema type.
   *
   * The resistivity, or specific axial resistance, of the cytoplasm
   * @param value 
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_resistivity value_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const value_type&
    value () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    value_type&
    value ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    value (const value_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    value (::std::unique_ptr< value_type > p);

    //@}

    /**
     * @name segmentGroup
     *
     * @brief Accessor and modifier functions for the %segmentGroup
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId segmentGroup_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< segmentGroup_type, char > segmentGroup_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const segmentGroup_type&
    segmentGroup () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    segmentGroup_type&
    segmentGroup ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    segmentGroup (const segmentGroup_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    segmentGroup (::std::unique_ptr< segmentGroup_type > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const segmentGroup_type&
    segmentGroup_default_value ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Resistivity (const value_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Resistivity (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Resistivity (const Resistivity& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Resistivity*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Resistivity&
    operator= (const Resistivity& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Resistivity ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< value_type > value_;
    ::xsd::cxx::tree::one< segmentGroup_type > segmentGroup_;
    static const segmentGroup_type segmentGroup_default_value_;

    //@endcond
  };

  bool
  operator== (const Resistivity&, const Resistivity&);

  bool
  operator!= (const Resistivity&, const Resistivity&);


  /**
   * @brief Class corresponding to the %ChannelPopulation schema type.
   *
   * Population of a **number**  of ohmic ion channels. These each produce
   * a conductance **channelg**  across a reversal potential **erev,** 
   * giving a total current **i.**  Note that active membrane currents are
   * more frequently specified as a density over an area of the  **cell** 
   * using  **channelDensity**
   * @param number The number of channels present. This will be multiplied
   * by the time varying conductance of the individual ion channel ( which
   * extends  **baseIonChannel**  ) to produce the total conductance
   * @param erev The reversal potential of the current produced
   *
   * @nosubgrouping
   */
  class ChannelPopulation: public ::neuroml2::Base
  {
    public:
    /**
     * @name variableParameter
     *
     * @brief Accessor and modifier functions for the %variableParameter
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::VariableParameter variableParameter_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< variableParameter_type > variableParameter_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef variableParameter_sequence::iterator variableParameter_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef variableParameter_sequence::const_iterator variableParameter_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< variableParameter_type, char > variableParameter_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const variableParameter_sequence&
    variableParameter () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    variableParameter_sequence&
    variableParameter ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    variableParameter (const variableParameter_sequence& s);

    //@}

    /**
     * @name ionChannel
     *
     * @brief Accessor and modifier functions for the %ionChannel
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId ionChannel_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ionChannel_type, char > ionChannel_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ionChannel_type&
    ionChannel () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ionChannel_type&
    ionChannel ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    ionChannel (const ionChannel_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    ionChannel (::std::unique_ptr< ionChannel_type > p);

    //@}

    /**
     * @name number
     *
     * @brief Accessor and modifier functions for the %number
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NonNegativeInteger number_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< number_type, char > number_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const number_type&
    number () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    number_type&
    number ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    number (const number_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    number (::std::unique_ptr< number_type > p);

    //@}

    /**
     * @name erev
     *
     * @brief Accessor and modifier functions for the %erev
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage erev_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< erev_type, char > erev_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const erev_type&
    erev () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    erev_type&
    erev ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    erev (const erev_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    erev (::std::unique_ptr< erev_type > p);

    //@}

    /**
     * @name segmentGroup
     *
     * @brief Accessor and modifier functions for the %segmentGroup
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId segmentGroup_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< segmentGroup_type, char > segmentGroup_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const segmentGroup_type&
    segmentGroup () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    segmentGroup_type&
    segmentGroup ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    segmentGroup (const segmentGroup_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    segmentGroup (::std::unique_ptr< segmentGroup_type > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const segmentGroup_type&
    segmentGroup_default_value ();

    //@}

    /**
     * @name segment
     *
     * @brief Accessor and modifier functions for the %segment
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NonNegativeInteger segment_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< segment_type > segment_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< segment_type, char > segment_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const segment_optional&
    segment () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    segment_optional&
    segment ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    segment (const segment_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    segment (const segment_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    segment (::std::unique_ptr< segment_type > p);

    //@}

    /**
     * @name ion
     *
     * @brief Accessor and modifier functions for the %ion
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId ion_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ion_type, char > ion_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ion_type&
    ion () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ion_type&
    ion ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    ion (const ion_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    ion (::std::unique_ptr< ion_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ChannelPopulation (const id_type&,
                       const ionChannel_type&,
                       const number_type&,
                       const erev_type&,
                       const ion_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ChannelPopulation (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChannelPopulation (const ChannelPopulation& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ChannelPopulation*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChannelPopulation&
    operator= (const ChannelPopulation& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ChannelPopulation ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    variableParameter_sequence variableParameter_;
    ::xsd::cxx::tree::one< ionChannel_type > ionChannel_;
    ::xsd::cxx::tree::one< number_type > number_;
    ::xsd::cxx::tree::one< erev_type > erev_;
    ::xsd::cxx::tree::one< segmentGroup_type > segmentGroup_;
    static const segmentGroup_type segmentGroup_default_value_;
    segment_optional segment_;
    ::xsd::cxx::tree::one< ion_type > ion_;

    //@endcond
  };

  bool
  operator== (const ChannelPopulation&, const ChannelPopulation&);

  bool
  operator!= (const ChannelPopulation&, const ChannelPopulation&);


  /**
   * @brief Class corresponding to the %ChannelDensityNonUniform schema type.
   *
   * Specifies a time varying ohmic conductance density, which is
   * distributed on a region of the **cell.**  The conductance density of
   * the channel is not uniform, but is set using the 
   * **variableParameter** . Note, there is no dynamical description of
   * this in LEMS yet, as this type only makes sense for multicompartmental
   * cells. A ComponentType for this needs to be present to enable export
   * of NeuroML 2 multicompartmental cells via LEMS/jNeuroML to NEURON
   * @param erev The reversal potential of the current produced
   *
   * @nosubgrouping
   */
  class ChannelDensityNonUniform: public ::neuroml2::Base
  {
    public:
    /**
     * @name variableParameter
     *
     * @brief Accessor and modifier functions for the %variableParameter
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::VariableParameter variableParameter_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< variableParameter_type > variableParameter_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef variableParameter_sequence::iterator variableParameter_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef variableParameter_sequence::const_iterator variableParameter_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< variableParameter_type, char > variableParameter_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const variableParameter_sequence&
    variableParameter () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    variableParameter_sequence&
    variableParameter ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    variableParameter (const variableParameter_sequence& s);

    //@}

    /**
     * @name ionChannel
     *
     * @brief Accessor and modifier functions for the %ionChannel
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId ionChannel_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ionChannel_type, char > ionChannel_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ionChannel_type&
    ionChannel () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ionChannel_type&
    ionChannel ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    ionChannel (const ionChannel_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    ionChannel (::std::unique_ptr< ionChannel_type > p);

    //@}

    /**
     * @name erev
     *
     * @brief Accessor and modifier functions for the %erev
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage erev_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< erev_type, char > erev_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const erev_type&
    erev () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    erev_type&
    erev ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    erev (const erev_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    erev (::std::unique_ptr< erev_type > p);

    //@}

    /**
     * @name ion
     *
     * @brief Accessor and modifier functions for the %ion
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId ion_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ion_type, char > ion_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ion_type&
    ion () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ion_type&
    ion ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    ion (const ion_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    ion (::std::unique_ptr< ion_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ChannelDensityNonUniform (const id_type&,
                              const ionChannel_type&,
                              const erev_type&,
                              const ion_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ChannelDensityNonUniform (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChannelDensityNonUniform (const ChannelDensityNonUniform& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ChannelDensityNonUniform*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChannelDensityNonUniform&
    operator= (const ChannelDensityNonUniform& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ChannelDensityNonUniform ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    variableParameter_sequence variableParameter_;
    ::xsd::cxx::tree::one< ionChannel_type > ionChannel_;
    ::xsd::cxx::tree::one< erev_type > erev_;
    ::xsd::cxx::tree::one< ion_type > ion_;

    //@endcond
  };

  bool
  operator== (const ChannelDensityNonUniform&, const ChannelDensityNonUniform&);

  bool
  operator!= (const ChannelDensityNonUniform&, const ChannelDensityNonUniform&);


  /**
   * @brief Class corresponding to the %ChannelDensityNonUniformNernst schema type.
   *
   * Specifies a time varying conductance density, which is distributed on
   * a region of the **cell,**  and whose reversal potential is calculated
   * from the Nernst equation. Hard coded for Ca only!. The conductance
   * density of the channel is not uniform, but is set using the 
   * **variableParameter** . Note, there is no dynamical description of
   * this in LEMS yet, as this type only makes sense for multicompartmental
   * cells. A ComponentType for this needs to be present to enable export
   * of NeuroML 2 multicompartmental cells via LEMS/jNeuroML to NEURON
   *
   * @nosubgrouping
   */
  class ChannelDensityNonUniformNernst: public ::neuroml2::Base
  {
    public:
    /**
     * @name variableParameter
     *
     * @brief Accessor and modifier functions for the %variableParameter
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::VariableParameter variableParameter_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< variableParameter_type > variableParameter_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef variableParameter_sequence::iterator variableParameter_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef variableParameter_sequence::const_iterator variableParameter_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< variableParameter_type, char > variableParameter_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const variableParameter_sequence&
    variableParameter () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    variableParameter_sequence&
    variableParameter ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    variableParameter (const variableParameter_sequence& s);

    //@}

    /**
     * @name ionChannel
     *
     * @brief Accessor and modifier functions for the %ionChannel
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId ionChannel_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ionChannel_type, char > ionChannel_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ionChannel_type&
    ionChannel () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ionChannel_type&
    ionChannel ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    ionChannel (const ionChannel_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    ionChannel (::std::unique_ptr< ionChannel_type > p);

    //@}

    /**
     * @name ion
     *
     * @brief Accessor and modifier functions for the %ion
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId ion_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ion_type, char > ion_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ion_type&
    ion () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ion_type&
    ion ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    ion (const ion_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    ion (::std::unique_ptr< ion_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ChannelDensityNonUniformNernst (const id_type&,
                                    const ionChannel_type&,
                                    const ion_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ChannelDensityNonUniformNernst (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChannelDensityNonUniformNernst (const ChannelDensityNonUniformNernst& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ChannelDensityNonUniformNernst*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChannelDensityNonUniformNernst&
    operator= (const ChannelDensityNonUniformNernst& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ChannelDensityNonUniformNernst ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    variableParameter_sequence variableParameter_;
    ::xsd::cxx::tree::one< ionChannel_type > ionChannel_;
    ::xsd::cxx::tree::one< ion_type > ion_;

    //@endcond
  };

  bool
  operator== (const ChannelDensityNonUniformNernst&, const ChannelDensityNonUniformNernst&);

  bool
  operator!= (const ChannelDensityNonUniformNernst&, const ChannelDensityNonUniformNernst&);


  /**
   * @brief Class corresponding to the %ChannelDensityNonUniformGHK schema type.
   *
   * Specifies a time varying conductance density, which is distributed on
   * a region of the **cell,**  and whose current is calculated from the
   * Goldman-Hodgkin-Katz equation. Hard coded for Ca only!. The
   * conductance density of the channel is not uniform, but is set using
   * the  **variableParameter** . Note, there is no dynamical description
   * of this in LEMS yet, as this type only makes sense for
   * multicompartmental cells. A ComponentType for this needs to be present
   * to enable export of NeuroML 2 multicompartmental cells via
   * LEMS/jNeuroML to NEURON
   *
   * @nosubgrouping
   */
  class ChannelDensityNonUniformGHK: public ::neuroml2::Base
  {
    public:
    /**
     * @name variableParameter
     *
     * @brief Accessor and modifier functions for the %variableParameter
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::VariableParameter variableParameter_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< variableParameter_type > variableParameter_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef variableParameter_sequence::iterator variableParameter_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef variableParameter_sequence::const_iterator variableParameter_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< variableParameter_type, char > variableParameter_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const variableParameter_sequence&
    variableParameter () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    variableParameter_sequence&
    variableParameter ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    variableParameter (const variableParameter_sequence& s);

    //@}

    /**
     * @name ionChannel
     *
     * @brief Accessor and modifier functions for the %ionChannel
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId ionChannel_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ionChannel_type, char > ionChannel_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ionChannel_type&
    ionChannel () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ionChannel_type&
    ionChannel ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    ionChannel (const ionChannel_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    ionChannel (::std::unique_ptr< ionChannel_type > p);

    //@}

    /**
     * @name ion
     *
     * @brief Accessor and modifier functions for the %ion
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId ion_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ion_type, char > ion_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ion_type&
    ion () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ion_type&
    ion ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    ion (const ion_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    ion (::std::unique_ptr< ion_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ChannelDensityNonUniformGHK (const id_type&,
                                 const ionChannel_type&,
                                 const ion_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ChannelDensityNonUniformGHK (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChannelDensityNonUniformGHK (const ChannelDensityNonUniformGHK& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ChannelDensityNonUniformGHK*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChannelDensityNonUniformGHK&
    operator= (const ChannelDensityNonUniformGHK& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ChannelDensityNonUniformGHK ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    variableParameter_sequence variableParameter_;
    ::xsd::cxx::tree::one< ionChannel_type > ionChannel_;
    ::xsd::cxx::tree::one< ion_type > ion_;

    //@endcond
  };

  bool
  operator== (const ChannelDensityNonUniformGHK&, const ChannelDensityNonUniformGHK&);

  bool
  operator!= (const ChannelDensityNonUniformGHK&, const ChannelDensityNonUniformGHK&);


  /**
   * @brief Class corresponding to the %ChannelDensity schema type.
   *
   * Specifies a time varying ohmic conductance density, **gDensity,** 
   * which is distributed on an area of the **cell**  ( specified in 
   * **membraneProperties**  ) with fixed reversal potential **erev** 
   * producing a current density **iDensity**
   * @param erev The reversal potential of the current produced
   * @param condDensity 
   *
   * @nosubgrouping
   */
  class ChannelDensity: public ::neuroml2::Base
  {
    public:
    /**
     * @name variableParameter
     *
     * @brief Accessor and modifier functions for the %variableParameter
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::VariableParameter variableParameter_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< variableParameter_type > variableParameter_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef variableParameter_sequence::iterator variableParameter_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef variableParameter_sequence::const_iterator variableParameter_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< variableParameter_type, char > variableParameter_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const variableParameter_sequence&
    variableParameter () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    variableParameter_sequence&
    variableParameter ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    variableParameter (const variableParameter_sequence& s);

    //@}

    /**
     * @name ionChannel
     *
     * @brief Accessor and modifier functions for the %ionChannel
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId ionChannel_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ionChannel_type, char > ionChannel_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ionChannel_type&
    ionChannel () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ionChannel_type&
    ionChannel ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    ionChannel (const ionChannel_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    ionChannel (::std::unique_ptr< ionChannel_type > p);

    //@}

    /**
     * @name condDensity
     *
     * @brief Accessor and modifier functions for the %condDensity
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductanceDensity condDensity_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< condDensity_type > condDensity_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< condDensity_type, char > condDensity_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const condDensity_optional&
    condDensity () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    condDensity_optional&
    condDensity ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    condDensity (const condDensity_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    condDensity (const condDensity_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    condDensity (::std::unique_ptr< condDensity_type > p);

    //@}

    /**
     * @name erev
     *
     * @brief Accessor and modifier functions for the %erev
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage erev_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< erev_type, char > erev_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const erev_type&
    erev () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    erev_type&
    erev ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    erev (const erev_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    erev (::std::unique_ptr< erev_type > p);

    //@}

    /**
     * @name segmentGroup
     *
     * @brief Accessor and modifier functions for the %segmentGroup
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId segmentGroup_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< segmentGroup_type, char > segmentGroup_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const segmentGroup_type&
    segmentGroup () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    segmentGroup_type&
    segmentGroup ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    segmentGroup (const segmentGroup_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    segmentGroup (::std::unique_ptr< segmentGroup_type > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const segmentGroup_type&
    segmentGroup_default_value ();

    //@}

    /**
     * @name segment
     *
     * @brief Accessor and modifier functions for the %segment
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NonNegativeInteger segment_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< segment_type > segment_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< segment_type, char > segment_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const segment_optional&
    segment () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    segment_optional&
    segment ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    segment (const segment_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    segment (const segment_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    segment (::std::unique_ptr< segment_type > p);

    //@}

    /**
     * @name ion
     *
     * @brief Accessor and modifier functions for the %ion
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId ion_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ion_type, char > ion_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ion_type&
    ion () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ion_type&
    ion ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    ion (const ion_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    ion (::std::unique_ptr< ion_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ChannelDensity (const id_type&,
                    const ionChannel_type&,
                    const erev_type&,
                    const ion_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ChannelDensity (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChannelDensity (const ChannelDensity& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ChannelDensity*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChannelDensity&
    operator= (const ChannelDensity& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ChannelDensity ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    variableParameter_sequence variableParameter_;
    ::xsd::cxx::tree::one< ionChannel_type > ionChannel_;
    condDensity_optional condDensity_;
    ::xsd::cxx::tree::one< erev_type > erev_;
    ::xsd::cxx::tree::one< segmentGroup_type > segmentGroup_;
    static const segmentGroup_type segmentGroup_default_value_;
    segment_optional segment_;
    ::xsd::cxx::tree::one< ion_type > ion_;

    //@endcond
  };

  bool
  operator== (const ChannelDensity&, const ChannelDensity&);

  bool
  operator!= (const ChannelDensity&, const ChannelDensity&);


  /**
   * @brief Class corresponding to the %ChannelDensityVShift schema type.
   *
   * Same as  **channelDensity** , but with a **vShift**  parameter to
   * change voltage activation of gates. The exact usage of **vShift**  in
   * expressions for rates is determined by the individual gates.
   * @param vShift 
   * @param erev The reversal potential of the current produced
   * @param condDensity 
   *
   * @nosubgrouping
   */
  class ChannelDensityVShift: public ::neuroml2::ChannelDensity
  {
    public:
    /**
     * @name vShift
     *
     * @brief Accessor and modifier functions for the %vShift
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage vShift_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< vShift_type, char > vShift_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const vShift_type&
    vShift () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    vShift_type&
    vShift ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    vShift (const vShift_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    vShift (::std::unique_ptr< vShift_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ChannelDensityVShift (const id_type&,
                          const ionChannel_type&,
                          const erev_type&,
                          const ion_type&,
                          const vShift_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ChannelDensityVShift (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChannelDensityVShift (const ChannelDensityVShift& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ChannelDensityVShift*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChannelDensityVShift&
    operator= (const ChannelDensityVShift& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ChannelDensityVShift ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< vShift_type > vShift_;

    //@endcond
  };

  bool
  operator== (const ChannelDensityVShift&, const ChannelDensityVShift&);

  bool
  operator!= (const ChannelDensityVShift&, const ChannelDensityVShift&);


  /**
   * @brief Class corresponding to the %ChannelDensityNernst schema type.
   *
   * Specifies a time varying conductance density, **gDensity,**  which is
   * distributed on an area of the **cell,**  producing a current density
   * **iDensity**  and whose reversal potential is calculated from the
   * Nernst equation. Hard coded for Ca only! See
   * https://github.com/OpenSourceBrain/ghk-nernst.
   * @param condDensity 
   *
   * @nosubgrouping
   */
  class ChannelDensityNernst: public ::neuroml2::Base
  {
    public:
    /**
     * @name variableParameter
     *
     * @brief Accessor and modifier functions for the %variableParameter
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::VariableParameter variableParameter_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< variableParameter_type > variableParameter_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef variableParameter_sequence::iterator variableParameter_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef variableParameter_sequence::const_iterator variableParameter_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< variableParameter_type, char > variableParameter_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const variableParameter_sequence&
    variableParameter () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    variableParameter_sequence&
    variableParameter ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    variableParameter (const variableParameter_sequence& s);

    //@}

    /**
     * @name ionChannel
     *
     * @brief Accessor and modifier functions for the %ionChannel
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId ionChannel_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ionChannel_type, char > ionChannel_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ionChannel_type&
    ionChannel () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ionChannel_type&
    ionChannel ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    ionChannel (const ionChannel_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    ionChannel (::std::unique_ptr< ionChannel_type > p);

    //@}

    /**
     * @name condDensity
     *
     * @brief Accessor and modifier functions for the %condDensity
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductanceDensity condDensity_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< condDensity_type > condDensity_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< condDensity_type, char > condDensity_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const condDensity_optional&
    condDensity () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    condDensity_optional&
    condDensity ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    condDensity (const condDensity_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    condDensity (const condDensity_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    condDensity (::std::unique_ptr< condDensity_type > p);

    //@}

    /**
     * @name segmentGroup
     *
     * @brief Accessor and modifier functions for the %segmentGroup
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId segmentGroup_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< segmentGroup_type, char > segmentGroup_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const segmentGroup_type&
    segmentGroup () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    segmentGroup_type&
    segmentGroup ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    segmentGroup (const segmentGroup_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    segmentGroup (::std::unique_ptr< segmentGroup_type > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const segmentGroup_type&
    segmentGroup_default_value ();

    //@}

    /**
     * @name segment
     *
     * @brief Accessor and modifier functions for the %segment
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId segment_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< segment_type > segment_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< segment_type, char > segment_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const segment_optional&
    segment () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    segment_optional&
    segment ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    segment (const segment_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    segment (const segment_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    segment (::std::unique_ptr< segment_type > p);

    //@}

    /**
     * @name ion
     *
     * @brief Accessor and modifier functions for the %ion
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId ion_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ion_type, char > ion_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ion_type&
    ion () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ion_type&
    ion ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    ion (const ion_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    ion (::std::unique_ptr< ion_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ChannelDensityNernst (const id_type&,
                          const ionChannel_type&,
                          const ion_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ChannelDensityNernst (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChannelDensityNernst (const ChannelDensityNernst& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ChannelDensityNernst*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChannelDensityNernst&
    operator= (const ChannelDensityNernst& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ChannelDensityNernst ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    variableParameter_sequence variableParameter_;
    ::xsd::cxx::tree::one< ionChannel_type > ionChannel_;
    condDensity_optional condDensity_;
    ::xsd::cxx::tree::one< segmentGroup_type > segmentGroup_;
    static const segmentGroup_type segmentGroup_default_value_;
    segment_optional segment_;
    ::xsd::cxx::tree::one< ion_type > ion_;

    //@endcond
  };

  bool
  operator== (const ChannelDensityNernst&, const ChannelDensityNernst&);

  bool
  operator!= (const ChannelDensityNernst&, const ChannelDensityNernst&);


  /**
   * @brief Class corresponding to the %ChannelDensityNernstCa2 schema type.
   *
   * This component is similar to the original component type 
   * **channelDensityNernst**  but it is changed in order to have a
   * reversal potential that depends on a second independent Ca++ pool (
   * ca2 ). See https://github.com/OpenSourceBrain/ghk-nernst.
   * @param condDensity 
   *
   * @nosubgrouping
   */
  class ChannelDensityNernstCa2: public ::neuroml2::ChannelDensityNernst
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ChannelDensityNernstCa2 (const id_type&,
                             const ionChannel_type&,
                             const ion_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ChannelDensityNernstCa2 (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChannelDensityNernstCa2 (const ChannelDensityNernstCa2& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ChannelDensityNernstCa2*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ChannelDensityNernstCa2 ();
  };

  /**
   * @brief Class corresponding to the %ChannelDensityGHK schema type.
   *
   * Specifies a time varying conductance density, **gDensity,**  which is
   * distributed on an area of the cell, producing a current density
   * **iDensity**  and whose reversal potential is calculated from the
   * Goldman Hodgkin Katz equation. Hard coded for Ca only! See
   * https://github.com/OpenSourceBrain/ghk-nernst.
   * @param permeability 
   *
   * @nosubgrouping
   */
  class ChannelDensityGHK: public ::neuroml2::Base
  {
    public:
    /**
     * @name ionChannel
     *
     * @brief Accessor and modifier functions for the %ionChannel
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId ionChannel_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ionChannel_type, char > ionChannel_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ionChannel_type&
    ionChannel () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ionChannel_type&
    ionChannel ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    ionChannel (const ionChannel_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    ionChannel (::std::unique_ptr< ionChannel_type > p);

    //@}

    /**
     * @name permeability
     *
     * @brief Accessor and modifier functions for the %permeability
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_permeability permeability_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< permeability_type, char > permeability_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const permeability_type&
    permeability () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    permeability_type&
    permeability ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    permeability (const permeability_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    permeability (::std::unique_ptr< permeability_type > p);

    //@}

    /**
     * @name segmentGroup
     *
     * @brief Accessor and modifier functions for the %segmentGroup
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId segmentGroup_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< segmentGroup_type, char > segmentGroup_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const segmentGroup_type&
    segmentGroup () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    segmentGroup_type&
    segmentGroup ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    segmentGroup (const segmentGroup_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    segmentGroup (::std::unique_ptr< segmentGroup_type > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const segmentGroup_type&
    segmentGroup_default_value ();

    //@}

    /**
     * @name segment
     *
     * @brief Accessor and modifier functions for the %segment
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId segment_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< segment_type > segment_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< segment_type, char > segment_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const segment_optional&
    segment () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    segment_optional&
    segment ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    segment (const segment_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    segment (const segment_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    segment (::std::unique_ptr< segment_type > p);

    //@}

    /**
     * @name ion
     *
     * @brief Accessor and modifier functions for the %ion
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId ion_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ion_type, char > ion_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ion_type&
    ion () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ion_type&
    ion ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    ion (const ion_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    ion (::std::unique_ptr< ion_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ChannelDensityGHK (const id_type&,
                       const ionChannel_type&,
                       const permeability_type&,
                       const ion_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ChannelDensityGHK (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChannelDensityGHK (const ChannelDensityGHK& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ChannelDensityGHK*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChannelDensityGHK&
    operator= (const ChannelDensityGHK& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ChannelDensityGHK ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< ionChannel_type > ionChannel_;
    ::xsd::cxx::tree::one< permeability_type > permeability_;
    ::xsd::cxx::tree::one< segmentGroup_type > segmentGroup_;
    static const segmentGroup_type segmentGroup_default_value_;
    segment_optional segment_;
    ::xsd::cxx::tree::one< ion_type > ion_;

    //@endcond
  };

  bool
  operator== (const ChannelDensityGHK&, const ChannelDensityGHK&);

  bool
  operator!= (const ChannelDensityGHK&, const ChannelDensityGHK&);


  /**
   * @brief Class corresponding to the %ChannelDensityGHK2 schema type.
   *
   * Time varying conductance density, **gDensity,**  which is distributed
   * on an area of the cell, producing a current density **iDensity.** 
   * Modified version of Jaffe et al. 1994 ( used also in Lawrence et al.
   * 2006 ). See https://github.com/OpenSourceBrain/ghk-nernst.
   * @param condDensity 
   *
   * @nosubgrouping
   */
  class ChannelDensityGHK2: public ::neuroml2::Base
  {
    public:
    /**
     * @name ionChannel
     *
     * @brief Accessor and modifier functions for the %ionChannel
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId ionChannel_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ionChannel_type, char > ionChannel_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ionChannel_type&
    ionChannel () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ionChannel_type&
    ionChannel ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    ionChannel (const ionChannel_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    ionChannel (::std::unique_ptr< ionChannel_type > p);

    //@}

    /**
     * @name condDensity
     *
     * @brief Accessor and modifier functions for the %condDensity
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_conductanceDensity condDensity_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< condDensity_type > condDensity_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< condDensity_type, char > condDensity_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const condDensity_optional&
    condDensity () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    condDensity_optional&
    condDensity ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    condDensity (const condDensity_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    condDensity (const condDensity_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    condDensity (::std::unique_ptr< condDensity_type > p);

    //@}

    /**
     * @name segmentGroup
     *
     * @brief Accessor and modifier functions for the %segmentGroup
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId segmentGroup_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< segmentGroup_type, char > segmentGroup_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const segmentGroup_type&
    segmentGroup () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    segmentGroup_type&
    segmentGroup ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    segmentGroup (const segmentGroup_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    segmentGroup (::std::unique_ptr< segmentGroup_type > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const segmentGroup_type&
    segmentGroup_default_value ();

    //@}

    /**
     * @name segment
     *
     * @brief Accessor and modifier functions for the %segment
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId segment_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< segment_type > segment_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< segment_type, char > segment_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const segment_optional&
    segment () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    segment_optional&
    segment ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    segment (const segment_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    segment (const segment_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    segment (::std::unique_ptr< segment_type > p);

    //@}

    /**
     * @name ion
     *
     * @brief Accessor and modifier functions for the %ion
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId ion_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ion_type, char > ion_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ion_type&
    ion () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ion_type&
    ion ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    ion (const ion_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    ion (::std::unique_ptr< ion_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ChannelDensityGHK2 (const id_type&,
                        const ionChannel_type&,
                        const ion_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ChannelDensityGHK2 (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChannelDensityGHK2 (const ChannelDensityGHK2& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ChannelDensityGHK2*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChannelDensityGHK2&
    operator= (const ChannelDensityGHK2& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ChannelDensityGHK2 ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< ionChannel_type > ionChannel_;
    condDensity_optional condDensity_;
    ::xsd::cxx::tree::one< segmentGroup_type > segmentGroup_;
    static const segmentGroup_type segmentGroup_default_value_;
    segment_optional segment_;
    ::xsd::cxx::tree::one< ion_type > ion_;

    //@endcond
  };

  bool
  operator== (const ChannelDensityGHK2&, const ChannelDensityGHK2&);

  bool
  operator!= (const ChannelDensityGHK2&, const ChannelDensityGHK2&);


  /**
   * @brief Class corresponding to the %VariableParameter schema type.
   *
   * Specifies a **parameter**  ( e. g. condDensity ) which can vary its
   * value across a **segmentGroup.**  The value is calculated from
   * **value**  attribute of the  **inhomogeneousValue**  subelement. This
   * element is normally a child of  **channelDensityNonUniform** , 
   * **channelDensityNonUniformNernst**  or 
   * **channelDensityNonUniformGHK**  and is used to calculate the value of
   * the conductance, etc. which will vary on different parts of the cell.
   * The **segmentGroup**  specified here needs to define an 
   * **inhomogeneousParameter**  ( referenced from
   * **inhomogeneousParameter**  in the  **inhomogeneousValue**  ), which
   * calculates a **variable**  ( e. g. p ) varying across the cell ( e. g.
   * based on the path length from soma ), which is then used in the
   * **value**  attribute of the  **inhomogeneousValue**  ( so for example
   * condDensity = f( p ) )
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name inhomogeneousValue
     *
     * @brief Accessor and modifier functions for the %inhomogeneousValue
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::InhomogeneousValue inhomogeneousValue_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< inhomogeneousValue_type > inhomogeneousValue_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< inhomogeneousValue_type, char > inhomogeneousValue_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const inhomogeneousValue_optional&
    inhomogeneousValue () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    inhomogeneousValue_optional&
    inhomogeneousValue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    inhomogeneousValue (const inhomogeneousValue_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    inhomogeneousValue (const inhomogeneousValue_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    inhomogeneousValue (::std::unique_ptr< inhomogeneousValue_type > p);

    //@}

    /**
     * @name parameter
     *
     * @brief Accessor and modifier functions for the %parameter
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string parameter_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< parameter_type, char > parameter_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const parameter_type&
    parameter () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    parameter_type&
    parameter ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    parameter (const parameter_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    parameter (::std::unique_ptr< parameter_type > p);

    //@}

    /**
     * @name segmentGroup
     *
     * @brief Accessor and modifier functions for the %segmentGroup
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string segmentGroup_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< segmentGroup_type, char > segmentGroup_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const segmentGroup_type&
    segmentGroup () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    segmentGroup_type&
    segmentGroup ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    segmentGroup (const segmentGroup_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    segmentGroup (::std::unique_ptr< segmentGroup_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    VariableParameter (const parameter_type&,
                       const segmentGroup_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    VariableParameter (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VariableParameter (const VariableParameter& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual VariableParameter*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VariableParameter&
    operator= (const VariableParameter& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~VariableParameter ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    inhomogeneousValue_optional inhomogeneousValue_;
    ::xsd::cxx::tree::one< parameter_type > parameter_;
    ::xsd::cxx::tree::one< segmentGroup_type > segmentGroup_;

    //@endcond
  };

  bool
  operator== (const VariableParameter&, const VariableParameter&);

  bool
  operator!= (const VariableParameter&, const VariableParameter&);


  /**
   * @brief Class corresponding to the %InhomogeneousValue schema type.
   *
   * Specifies the **value**  of an **inhomogeneousParameter.**  For usage
   * see  **variableParameter**
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name inhomogeneousParameter
     *
     * @brief Accessor and modifier functions for the %inhomogeneousParameter
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string inhomogeneousParameter_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< inhomogeneousParameter_type, char > inhomogeneousParameter_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const inhomogeneousParameter_type&
    inhomogeneousParameter () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    inhomogeneousParameter_type&
    inhomogeneousParameter ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    inhomogeneousParameter (const inhomogeneousParameter_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    inhomogeneousParameter (::std::unique_ptr< inhomogeneousParameter_type > p);

    //@}

    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string value_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const value_type&
    value () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    value_type&
    value ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    value (const value_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    value (::std::unique_ptr< value_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InhomogeneousValue (const inhomogeneousParameter_type&,
                        const value_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InhomogeneousValue (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InhomogeneousValue (const InhomogeneousValue& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InhomogeneousValue*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InhomogeneousValue&
    operator= (const InhomogeneousValue& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InhomogeneousValue ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< inhomogeneousParameter_type > inhomogeneousParameter_;
    ::xsd::cxx::tree::one< value_type > value_;

    //@endcond
  };

  bool
  operator== (const InhomogeneousValue&, const InhomogeneousValue&);

  bool
  operator!= (const InhomogeneousValue&, const InhomogeneousValue&);


  /**
   * @brief Class corresponding to the %Species schema type.
   *
   * Description of a chemical species identified by **ion,**  which has
   * internal, **concentration,**  and external, **extConcentration** 
   * values for its concentration
   * @param initialConcentration 
   * @param initialExtConcentration 
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId id_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const id_type&
    id () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    id_type&
    id ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    id (const id_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    id (::std::unique_ptr< id_type > p);

    //@}

    /**
     * @name concentrationModel
     *
     * @brief Accessor and modifier functions for the %concentrationModel
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId concentrationModel_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< concentrationModel_type, char > concentrationModel_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const concentrationModel_type&
    concentrationModel () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    concentrationModel_type&
    concentrationModel ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    concentrationModel (const concentrationModel_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    concentrationModel (::std::unique_ptr< concentrationModel_type > p);

    //@}

    /**
     * @name ion
     *
     * @brief Accessor and modifier functions for the %ion
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId ion_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ion_type > ion_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ion_type, char > ion_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ion_optional&
    ion () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ion_optional&
    ion ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    ion (const ion_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    ion (const ion_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    ion (::std::unique_ptr< ion_type > p);

    //@}

    /**
     * @name initialConcentration
     *
     * @brief Accessor and modifier functions for the %initialConcentration
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_concentration initialConcentration_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< initialConcentration_type, char > initialConcentration_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const initialConcentration_type&
    initialConcentration () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    initialConcentration_type&
    initialConcentration ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    initialConcentration (const initialConcentration_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    initialConcentration (::std::unique_ptr< initialConcentration_type > p);

    //@}

    /**
     * @name initialExtConcentration
     *
     * @brief Accessor and modifier functions for the %initialExtConcentration
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_concentration initialExtConcentration_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< initialExtConcentration_type, char > initialExtConcentration_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const initialExtConcentration_type&
    initialExtConcentration () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    initialExtConcentration_type&
    initialExtConcentration ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    initialExtConcentration (const initialExtConcentration_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    initialExtConcentration (::std::unique_ptr< initialExtConcentration_type > p);

    //@}

    /**
     * @name segmentGroup
     *
     * @brief Accessor and modifier functions for the %segmentGroup
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId segmentGroup_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< segmentGroup_type, char > segmentGroup_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const segmentGroup_type&
    segmentGroup () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    segmentGroup_type&
    segmentGroup ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    segmentGroup (const segmentGroup_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    segmentGroup (::std::unique_ptr< segmentGroup_type > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const segmentGroup_type&
    segmentGroup_default_value ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Species (const id_type&,
             const concentrationModel_type&,
             const initialConcentration_type&,
             const initialExtConcentration_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Species (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Species (const Species& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Species*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Species&
    operator= (const Species& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Species ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< id_type > id_;
    ::xsd::cxx::tree::one< concentrationModel_type > concentrationModel_;
    ion_optional ion_;
    ::xsd::cxx::tree::one< initialConcentration_type > initialConcentration_;
    ::xsd::cxx::tree::one< initialExtConcentration_type > initialExtConcentration_;
    ::xsd::cxx::tree::one< segmentGroup_type > segmentGroup_;
    static const segmentGroup_type segmentGroup_default_value_;

    //@endcond
  };

  bool
  operator== (const Species&, const Species&);

  bool
  operator!= (const Species&, const Species&);


  /**
   * @brief Class corresponding to the %ConcentrationModel_D schema type.
   *
   * @nosubgrouping
   */
  class ConcentrationModel_D: public ::neuroml2::DecayingPoolConcentrationModel
  {
    public:
    /**
     * @name type
     *
     * @brief Accessor and modifier functions for the %type
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::simple_type type_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const type_type&
    type () const;

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const type_type&
    type_default_value ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ConcentrationModel_D (const id_type&,
                          const ion_type&,
                          const restingConc_type&,
                          const decayConstant_type&,
                          const shellThickness_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ConcentrationModel_D (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ConcentrationModel_D (const ConcentrationModel_D& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ConcentrationModel_D*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ConcentrationModel_D&
    operator= (const ConcentrationModel_D& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ConcentrationModel_D ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< type_type > type_;
    static const type_type type_default_value_;

    //@endcond
  };

  bool
  operator== (const ConcentrationModel_D&, const ConcentrationModel_D&);

  bool
  operator!= (const ConcentrationModel_D&, const ConcentrationModel_D&);


  /**
   * @brief Class corresponding to the %IntracellularProperties schema type.
   *
   * Biophysical properties related to the intracellular space within the 
   * **cell** , such as the  **resistivity**  and the list of ionic 
   * **species**  present. **caConc**  and **caConcExt**  are explicitly
   * exposed here to facilitate accessing these values from other
   * Components, even though **caConcExt**  is clearly not an intracellular
   * property
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name species
     *
     * @brief Accessor and modifier functions for the %species
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Species species_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< species_type > species_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef species_sequence::iterator species_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef species_sequence::const_iterator species_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< species_type, char > species_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const species_sequence&
    species () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    species_sequence&
    species ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    species (const species_sequence& s);

    //@}

    /**
     * @name resistivity
     *
     * @brief Accessor and modifier functions for the %resistivity
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Resistivity resistivity_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< resistivity_type > resistivity_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef resistivity_sequence::iterator resistivity_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef resistivity_sequence::const_iterator resistivity_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< resistivity_type, char > resistivity_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const resistivity_sequence&
    resistivity () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    resistivity_sequence&
    resistivity ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    resistivity (const resistivity_sequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IntracellularProperties ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IntracellularProperties (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IntracellularProperties (const IntracellularProperties& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IntracellularProperties*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IntracellularProperties&
    operator= (const IntracellularProperties& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IntracellularProperties ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    species_sequence species_;
    resistivity_sequence resistivity_;

    //@endcond
  };

  bool
  operator== (const IntracellularProperties&, const IntracellularProperties&);

  bool
  operator!= (const IntracellularProperties&, const IntracellularProperties&);


  /**
   * @brief Class corresponding to the %IntracellularProperties2CaPools schema type.
   *
   * Variant of intracellularProperties with 2 independent Ca pools
   *
   * @nosubgrouping
   */
  class IntracellularProperties2CaPools: public ::neuroml2::IntracellularProperties
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IntracellularProperties2CaPools ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IntracellularProperties2CaPools (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IntracellularProperties2CaPools (const IntracellularProperties2CaPools& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IntracellularProperties2CaPools*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IntracellularProperties2CaPools ();
  };

  /**
   * @brief Class corresponding to the %ExtracellularProperties schema type.
   *
   * @nosubgrouping
   */
  class ExtracellularProperties: public ::neuroml2::Base
  {
    public:
    /**
     * @name species
     *
     * @brief Accessor and modifier functions for the %species
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Species species_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< species_type > species_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef species_sequence::iterator species_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef species_sequence::const_iterator species_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< species_type, char > species_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const species_sequence&
    species () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    species_sequence&
    species ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    species (const species_sequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ExtracellularProperties (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ExtracellularProperties (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ExtracellularProperties (const ExtracellularProperties& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ExtracellularProperties*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ExtracellularProperties&
    operator= (const ExtracellularProperties& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ExtracellularProperties ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    species_sequence species_;

    //@endcond
  };

  bool
  operator== (const ExtracellularProperties&, const ExtracellularProperties&);

  bool
  operator!= (const ExtracellularProperties&, const ExtracellularProperties&);


  /**
   * @brief Class corresponding to the %ExtracellularPropertiesLocal schema type.
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name species
     *
     * @brief Accessor and modifier functions for the %species
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Species species_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< species_type > species_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef species_sequence::iterator species_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef species_sequence::const_iterator species_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< species_type, char > species_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const species_sequence&
    species () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    species_sequence&
    species ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    species (const species_sequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ExtracellularPropertiesLocal ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ExtracellularPropertiesLocal (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ExtracellularPropertiesLocal (const ExtracellularPropertiesLocal& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ExtracellularPropertiesLocal*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ExtracellularPropertiesLocal&
    operator= (const ExtracellularPropertiesLocal& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ExtracellularPropertiesLocal ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    species_sequence species_;

    //@endcond
  };

  bool
  operator== (const ExtracellularPropertiesLocal&, const ExtracellularPropertiesLocal&);

  bool
  operator!= (const ExtracellularPropertiesLocal&, const ExtracellularPropertiesLocal&);


  /**
   * @brief Class corresponding to the %ReactionScheme schema type.
   *
   * @nosubgrouping
   */
  class ReactionScheme: public ::neuroml2::Base
  {
    public:
    /**
     * @name source
     *
     * @brief Accessor and modifier functions for the %source
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string source_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< source_type, char > source_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const source_type&
    source () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    source_type&
    source ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    source (const source_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    source (::std::unique_ptr< source_type > p);

    //@}

    /**
     * @name type
     *
     * @brief Accessor and modifier functions for the %type
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string type_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const type_type&
    type () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    type_type&
    type ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    type (const type_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    type (::std::unique_ptr< type_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ReactionScheme (const id_type&,
                    const source_type&,
                    const type_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ReactionScheme (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ReactionScheme (const ReactionScheme& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ReactionScheme*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ReactionScheme&
    operator= (const ReactionScheme& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ReactionScheme ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< source_type > source_;
    ::xsd::cxx::tree::one< type_type > type_;

    //@endcond
  };

  bool
  operator== (const ReactionScheme&, const ReactionScheme&);

  bool
  operator!= (const ReactionScheme&, const ReactionScheme&);


  /**
   * @brief Class corresponding to the %PulseGenerator schema type.
   *
   * Generates a constant current pulse of a certain **amplitude**  for a
   * specified **duration**  after a **delay.**  Scaled by **weight,**  if
   * set
   * @param delay Delay before change in current. Current is zero prior to
   * this.
   * @param duration Duration for holding current at amplitude. Current is
   * zero after delay + duration.
   * @param amplitude Amplitude of current pulse
   *
   * @nosubgrouping
   */
  class PulseGenerator: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name delay
     *
     * @brief Accessor and modifier functions for the %delay
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time delay_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< delay_type, char > delay_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const delay_type&
    delay () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    delay_type&
    delay ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    delay (const delay_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    delay (::std::unique_ptr< delay_type > p);

    //@}

    /**
     * @name duration
     *
     * @brief Accessor and modifier functions for the %duration
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time duration_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< duration_type, char > duration_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const duration_type&
    duration () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    duration_type&
    duration ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    duration (const duration_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    duration (::std::unique_ptr< duration_type > p);

    //@}

    /**
     * @name amplitude
     *
     * @brief Accessor and modifier functions for the %amplitude
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_current amplitude_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< amplitude_type, char > amplitude_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const amplitude_type&
    amplitude () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    amplitude_type&
    amplitude ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    amplitude (const amplitude_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    amplitude (::std::unique_ptr< amplitude_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PulseGenerator (const id_type&,
                    const delay_type&,
                    const duration_type&,
                    const amplitude_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PulseGenerator (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PulseGenerator (const PulseGenerator& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PulseGenerator*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PulseGenerator&
    operator= (const PulseGenerator& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PulseGenerator ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< delay_type > delay_;
    ::xsd::cxx::tree::one< duration_type > duration_;
    ::xsd::cxx::tree::one< amplitude_type > amplitude_;

    //@endcond
  };

  bool
  operator== (const PulseGenerator&, const PulseGenerator&);

  bool
  operator!= (const PulseGenerator&, const PulseGenerator&);


  /**
   * @brief Class corresponding to the %PulseGeneratorDL schema type.
   *
   * Dimensionless equivalent of  **pulseGenerator** . Generates a constant
   * current pulse of a certain **amplitude**  for a specified **duration**
   * after a **delay.**  Scaled by **weight,**  if set
   * @param delay Delay before change in current. Current is zero prior to
   * this.
   * @param duration Duration for holding current at amplitude. Current is
   * zero after delay + duration.
   * @param amplitude Amplitude of current pulse
   *
   * @nosubgrouping
   */
  class PulseGeneratorDL: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name delay
     *
     * @brief Accessor and modifier functions for the %delay
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time delay_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< delay_type, char > delay_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const delay_type&
    delay () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    delay_type&
    delay ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    delay (const delay_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    delay (::std::unique_ptr< delay_type > p);

    //@}

    /**
     * @name duration
     *
     * @brief Accessor and modifier functions for the %duration
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time duration_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< duration_type, char > duration_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const duration_type&
    duration () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    duration_type&
    duration ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    duration (const duration_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    duration (::std::unique_ptr< duration_type > p);

    //@}

    /**
     * @name amplitude
     *
     * @brief Accessor and modifier functions for the %amplitude
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none amplitude_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< amplitude_type, char > amplitude_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const amplitude_type&
    amplitude () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    amplitude_type&
    amplitude ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    amplitude (const amplitude_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    amplitude (::std::unique_ptr< amplitude_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PulseGeneratorDL (const id_type&,
                      const delay_type&,
                      const duration_type&,
                      const amplitude_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PulseGeneratorDL (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PulseGeneratorDL (const PulseGeneratorDL& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PulseGeneratorDL*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PulseGeneratorDL&
    operator= (const PulseGeneratorDL& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PulseGeneratorDL ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< delay_type > delay_;
    ::xsd::cxx::tree::one< duration_type > duration_;
    ::xsd::cxx::tree::one< amplitude_type > amplitude_;

    //@endcond
  };

  bool
  operator== (const PulseGeneratorDL&, const PulseGeneratorDL&);

  bool
  operator!= (const PulseGeneratorDL&, const PulseGeneratorDL&);


  /**
   * @brief Class corresponding to the %SineGenerator schema type.
   *
   * Generates a sinusoidally varying current after a time **delay,**  for
   * a fixed **duration.**  The **period**  and maximum **amplitude**  of
   * the current can be set as well as the **phase**  at which to start.
   * Scaled by **weight,**  if set
   * @param phase Phase ( between 0 and 2*pi ) at which to start the
   * varying current ( i. e. at time given by delay )
   * @param delay Delay before change in current. Current is zero prior to
   * this.
   * @param duration Duration for holding current at amplitude. Current is
   * zero after delay + duration.
   * @param amplitude Maximum amplitude of current
   * @param period Time period of oscillation
   *
   * @nosubgrouping
   */
  class SineGenerator: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name delay
     *
     * @brief Accessor and modifier functions for the %delay
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time delay_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< delay_type, char > delay_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const delay_type&
    delay () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    delay_type&
    delay ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    delay (const delay_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    delay (::std::unique_ptr< delay_type > p);

    //@}

    /**
     * @name phase
     *
     * @brief Accessor and modifier functions for the %phase
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none phase_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< phase_type, char > phase_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const phase_type&
    phase () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    phase_type&
    phase ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    phase (const phase_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    phase (::std::unique_ptr< phase_type > p);

    //@}

    /**
     * @name duration
     *
     * @brief Accessor and modifier functions for the %duration
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time duration_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< duration_type, char > duration_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const duration_type&
    duration () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    duration_type&
    duration ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    duration (const duration_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    duration (::std::unique_ptr< duration_type > p);

    //@}

    /**
     * @name amplitude
     *
     * @brief Accessor and modifier functions for the %amplitude
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_current amplitude_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< amplitude_type, char > amplitude_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const amplitude_type&
    amplitude () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    amplitude_type&
    amplitude ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    amplitude (const amplitude_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    amplitude (::std::unique_ptr< amplitude_type > p);

    //@}

    /**
     * @name period
     *
     * @brief Accessor and modifier functions for the %period
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time period_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< period_type, char > period_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const period_type&
    period () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    period_type&
    period ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    period (const period_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    period (::std::unique_ptr< period_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SineGenerator (const id_type&,
                   const delay_type&,
                   const phase_type&,
                   const duration_type&,
                   const amplitude_type&,
                   const period_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SineGenerator (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SineGenerator (const SineGenerator& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SineGenerator*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SineGenerator&
    operator= (const SineGenerator& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SineGenerator ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< delay_type > delay_;
    ::xsd::cxx::tree::one< phase_type > phase_;
    ::xsd::cxx::tree::one< duration_type > duration_;
    ::xsd::cxx::tree::one< amplitude_type > amplitude_;
    ::xsd::cxx::tree::one< period_type > period_;

    //@endcond
  };

  bool
  operator== (const SineGenerator&, const SineGenerator&);

  bool
  operator!= (const SineGenerator&, const SineGenerator&);


  /**
   * @brief Class corresponding to the %SineGeneratorDL schema type.
   *
   * Dimensionless equivalent of  **sineGenerator** . Generates a
   * sinusoidally varying current after a time **delay,**  for a fixed
   * **duration.**  The **period**  and maximum **amplitude**  of the
   * current can be set as well as the **phase**  at which to start. Scaled
   * by **weight,**  if set
   * @param phase Phase ( between 0 and 2*pi ) at which to start the
   * varying current ( i. e. at time given by delay )
   * @param delay Delay before change in current. Current is zero prior to
   * this.
   * @param duration Duration for holding current at amplitude. Current is
   * zero after delay + duration.
   * @param amplitude Maximum amplitude of current
   * @param period Time period of oscillation
   *
   * @nosubgrouping
   */
  class SineGeneratorDL: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name delay
     *
     * @brief Accessor and modifier functions for the %delay
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time delay_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< delay_type, char > delay_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const delay_type&
    delay () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    delay_type&
    delay ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    delay (const delay_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    delay (::std::unique_ptr< delay_type > p);

    //@}

    /**
     * @name phase
     *
     * @brief Accessor and modifier functions for the %phase
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none phase_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< phase_type, char > phase_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const phase_type&
    phase () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    phase_type&
    phase ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    phase (const phase_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    phase (::std::unique_ptr< phase_type > p);

    //@}

    /**
     * @name duration
     *
     * @brief Accessor and modifier functions for the %duration
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time duration_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< duration_type, char > duration_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const duration_type&
    duration () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    duration_type&
    duration ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    duration (const duration_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    duration (::std::unique_ptr< duration_type > p);

    //@}

    /**
     * @name amplitude
     *
     * @brief Accessor and modifier functions for the %amplitude
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none amplitude_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< amplitude_type, char > amplitude_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const amplitude_type&
    amplitude () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    amplitude_type&
    amplitude ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    amplitude (const amplitude_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    amplitude (::std::unique_ptr< amplitude_type > p);

    //@}

    /**
     * @name period
     *
     * @brief Accessor and modifier functions for the %period
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time period_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< period_type, char > period_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const period_type&
    period () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    period_type&
    period ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    period (const period_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    period (::std::unique_ptr< period_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SineGeneratorDL (const id_type&,
                     const delay_type&,
                     const phase_type&,
                     const duration_type&,
                     const amplitude_type&,
                     const period_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SineGeneratorDL (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SineGeneratorDL (const SineGeneratorDL& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SineGeneratorDL*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SineGeneratorDL&
    operator= (const SineGeneratorDL& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SineGeneratorDL ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< delay_type > delay_;
    ::xsd::cxx::tree::one< phase_type > phase_;
    ::xsd::cxx::tree::one< duration_type > duration_;
    ::xsd::cxx::tree::one< amplitude_type > amplitude_;
    ::xsd::cxx::tree::one< period_type > period_;

    //@endcond
  };

  bool
  operator== (const SineGeneratorDL&, const SineGeneratorDL&);

  bool
  operator!= (const SineGeneratorDL&, const SineGeneratorDL&);


  /**
   * @brief Class corresponding to the %RampGenerator schema type.
   *
   * Generates a ramping current after a time **delay,**  for a fixed
   * **duration.**  During this time the current steadily changes from
   * **startAmplitude**  to **finishAmplitude.**  Scaled by **weight,**  if
   * set
   * @param delay Delay before change in current. Current is
   * baselineAmplitude prior to this.
   * @param duration Duration for holding current at amplitude. Current is
   * baselineAmplitude after delay + duration.
   * @param startAmplitude Amplitude of linearly varying current at time
   * delay
   * @param finishAmplitude Amplitude of linearly varying current at time
   * delay + duration
   * @param baselineAmplitude Amplitude of current before time delay, and
   * after time delay + duration
   *
   * @nosubgrouping
   */
  class RampGenerator: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name delay
     *
     * @brief Accessor and modifier functions for the %delay
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time delay_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< delay_type, char > delay_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const delay_type&
    delay () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    delay_type&
    delay ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    delay (const delay_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    delay (::std::unique_ptr< delay_type > p);

    //@}

    /**
     * @name duration
     *
     * @brief Accessor and modifier functions for the %duration
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time duration_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< duration_type, char > duration_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const duration_type&
    duration () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    duration_type&
    duration ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    duration (const duration_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    duration (::std::unique_ptr< duration_type > p);

    //@}

    /**
     * @name startAmplitude
     *
     * @brief Accessor and modifier functions for the %startAmplitude
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_current startAmplitude_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< startAmplitude_type, char > startAmplitude_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const startAmplitude_type&
    startAmplitude () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    startAmplitude_type&
    startAmplitude ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    startAmplitude (const startAmplitude_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    startAmplitude (::std::unique_ptr< startAmplitude_type > p);

    //@}

    /**
     * @name finishAmplitude
     *
     * @brief Accessor and modifier functions for the %finishAmplitude
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_current finishAmplitude_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< finishAmplitude_type, char > finishAmplitude_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const finishAmplitude_type&
    finishAmplitude () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    finishAmplitude_type&
    finishAmplitude ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    finishAmplitude (const finishAmplitude_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    finishAmplitude (::std::unique_ptr< finishAmplitude_type > p);

    //@}

    /**
     * @name baselineAmplitude
     *
     * @brief Accessor and modifier functions for the %baselineAmplitude
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_current baselineAmplitude_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< baselineAmplitude_type, char > baselineAmplitude_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const baselineAmplitude_type&
    baselineAmplitude () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    baselineAmplitude_type&
    baselineAmplitude ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    baselineAmplitude (const baselineAmplitude_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    baselineAmplitude (::std::unique_ptr< baselineAmplitude_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    RampGenerator (const id_type&,
                   const delay_type&,
                   const duration_type&,
                   const startAmplitude_type&,
                   const finishAmplitude_type&,
                   const baselineAmplitude_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RampGenerator (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RampGenerator (const RampGenerator& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RampGenerator*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RampGenerator&
    operator= (const RampGenerator& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~RampGenerator ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< delay_type > delay_;
    ::xsd::cxx::tree::one< duration_type > duration_;
    ::xsd::cxx::tree::one< startAmplitude_type > startAmplitude_;
    ::xsd::cxx::tree::one< finishAmplitude_type > finishAmplitude_;
    ::xsd::cxx::tree::one< baselineAmplitude_type > baselineAmplitude_;

    //@endcond
  };

  bool
  operator== (const RampGenerator&, const RampGenerator&);

  bool
  operator!= (const RampGenerator&, const RampGenerator&);


  /**
   * @brief Class corresponding to the %RampGeneratorDL schema type.
   *
   * Dimensionless equivalent of  **rampGenerator** . Generates a ramping
   * current after a time **delay,**  for a fixed **duration.**  During
   * this time the dimensionless current steadily changes from
   * **startAmplitude**  to **finishAmplitude.**  Scaled by **weight,**  if
   * set
   * @param delay Delay before change in current. Current is
   * baselineAmplitude prior to this.
   * @param duration Duration for holding current at amplitude. Current is
   * baselineAmplitude after delay + duration.
   * @param startAmplitude Amplitude of linearly varying current at time
   * delay
   * @param finishAmplitude Amplitude of linearly varying current at time
   * delay + duration
   * @param baselineAmplitude Amplitude of current before time delay, and
   * after time delay + duration
   *
   * @nosubgrouping
   */
  class RampGeneratorDL: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name delay
     *
     * @brief Accessor and modifier functions for the %delay
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time delay_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< delay_type, char > delay_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const delay_type&
    delay () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    delay_type&
    delay ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    delay (const delay_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    delay (::std::unique_ptr< delay_type > p);

    //@}

    /**
     * @name duration
     *
     * @brief Accessor and modifier functions for the %duration
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time duration_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< duration_type, char > duration_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const duration_type&
    duration () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    duration_type&
    duration ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    duration (const duration_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    duration (::std::unique_ptr< duration_type > p);

    //@}

    /**
     * @name startAmplitude
     *
     * @brief Accessor and modifier functions for the %startAmplitude
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none startAmplitude_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< startAmplitude_type, char > startAmplitude_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const startAmplitude_type&
    startAmplitude () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    startAmplitude_type&
    startAmplitude ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    startAmplitude (const startAmplitude_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    startAmplitude (::std::unique_ptr< startAmplitude_type > p);

    //@}

    /**
     * @name finishAmplitude
     *
     * @brief Accessor and modifier functions for the %finishAmplitude
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none finishAmplitude_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< finishAmplitude_type, char > finishAmplitude_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const finishAmplitude_type&
    finishAmplitude () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    finishAmplitude_type&
    finishAmplitude ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    finishAmplitude (const finishAmplitude_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    finishAmplitude (::std::unique_ptr< finishAmplitude_type > p);

    //@}

    /**
     * @name baselineAmplitude
     *
     * @brief Accessor and modifier functions for the %baselineAmplitude
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_none baselineAmplitude_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< baselineAmplitude_type, char > baselineAmplitude_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const baselineAmplitude_type&
    baselineAmplitude () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    baselineAmplitude_type&
    baselineAmplitude ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    baselineAmplitude (const baselineAmplitude_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    baselineAmplitude (::std::unique_ptr< baselineAmplitude_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    RampGeneratorDL (const id_type&,
                     const delay_type&,
                     const duration_type&,
                     const startAmplitude_type&,
                     const finishAmplitude_type&,
                     const baselineAmplitude_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RampGeneratorDL (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RampGeneratorDL (const RampGeneratorDL& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RampGeneratorDL*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RampGeneratorDL&
    operator= (const RampGeneratorDL& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~RampGeneratorDL ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< delay_type > delay_;
    ::xsd::cxx::tree::one< duration_type > duration_;
    ::xsd::cxx::tree::one< startAmplitude_type > startAmplitude_;
    ::xsd::cxx::tree::one< finishAmplitude_type > finishAmplitude_;
    ::xsd::cxx::tree::one< baselineAmplitude_type > baselineAmplitude_;

    //@endcond
  };

  bool
  operator== (const RampGeneratorDL&, const RampGeneratorDL&);

  bool
  operator!= (const RampGeneratorDL&, const RampGeneratorDL&);


  /**
   * @brief Class corresponding to the %CompoundInput schema type.
   *
   * Generates a current which is the sum of all its child 
   * **basePointCurrent**  element, e. g. can be a combination of 
   * **pulseGenerator** ,  **sineGenerator**  elements producing a single
   * **i.**  Scaled by **weight,**  if set
   *
   * @nosubgrouping
   */
  class CompoundInput: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name pulseGenerator
     *
     * @brief Accessor and modifier functions for the %pulseGenerator
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::PulseGenerator pulseGenerator_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< pulseGenerator_type > pulseGenerator_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef pulseGenerator_sequence::iterator pulseGenerator_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef pulseGenerator_sequence::const_iterator pulseGenerator_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< pulseGenerator_type, char > pulseGenerator_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const pulseGenerator_sequence&
    pulseGenerator () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    pulseGenerator_sequence&
    pulseGenerator ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    pulseGenerator (const pulseGenerator_sequence& s);

    //@}

    /**
     * @name sineGenerator
     *
     * @brief Accessor and modifier functions for the %sineGenerator
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::SineGenerator sineGenerator_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< sineGenerator_type > sineGenerator_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef sineGenerator_sequence::iterator sineGenerator_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef sineGenerator_sequence::const_iterator sineGenerator_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< sineGenerator_type, char > sineGenerator_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const sineGenerator_sequence&
    sineGenerator () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    sineGenerator_sequence&
    sineGenerator ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    sineGenerator (const sineGenerator_sequence& s);

    //@}

    /**
     * @name rampGenerator
     *
     * @brief Accessor and modifier functions for the %rampGenerator
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::RampGenerator rampGenerator_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< rampGenerator_type > rampGenerator_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef rampGenerator_sequence::iterator rampGenerator_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef rampGenerator_sequence::const_iterator rampGenerator_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< rampGenerator_type, char > rampGenerator_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const rampGenerator_sequence&
    rampGenerator () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    rampGenerator_sequence&
    rampGenerator ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    rampGenerator (const rampGenerator_sequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    CompoundInput (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CompoundInput (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CompoundInput (const CompoundInput& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual CompoundInput*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CompoundInput&
    operator= (const CompoundInput& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~CompoundInput ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    pulseGenerator_sequence pulseGenerator_;
    sineGenerator_sequence sineGenerator_;
    rampGenerator_sequence rampGenerator_;

    //@endcond
  };

  bool
  operator== (const CompoundInput&, const CompoundInput&);

  bool
  operator!= (const CompoundInput&, const CompoundInput&);


  /**
   * @brief Class corresponding to the %CompoundInputDL schema type.
   *
   * Generates a current which is the sum of all its child 
   * **basePointCurrentDL**  elements, e. g. can be a combination of 
   * **pulseGeneratorDL** ,  **sineGeneratorDL**  elements producing a
   * single **i.**  Scaled by **weight,**  if set
   *
   * @nosubgrouping
   */
  class CompoundInputDL: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name pulseGeneratorDL
     *
     * @brief Accessor and modifier functions for the %pulseGeneratorDL
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::PulseGeneratorDL pulseGeneratorDL_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< pulseGeneratorDL_type > pulseGeneratorDL_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef pulseGeneratorDL_sequence::iterator pulseGeneratorDL_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef pulseGeneratorDL_sequence::const_iterator pulseGeneratorDL_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< pulseGeneratorDL_type, char > pulseGeneratorDL_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const pulseGeneratorDL_sequence&
    pulseGeneratorDL () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    pulseGeneratorDL_sequence&
    pulseGeneratorDL ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    pulseGeneratorDL (const pulseGeneratorDL_sequence& s);

    //@}

    /**
     * @name sineGeneratorDL
     *
     * @brief Accessor and modifier functions for the %sineGeneratorDL
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::SineGeneratorDL sineGeneratorDL_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< sineGeneratorDL_type > sineGeneratorDL_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef sineGeneratorDL_sequence::iterator sineGeneratorDL_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef sineGeneratorDL_sequence::const_iterator sineGeneratorDL_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< sineGeneratorDL_type, char > sineGeneratorDL_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const sineGeneratorDL_sequence&
    sineGeneratorDL () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    sineGeneratorDL_sequence&
    sineGeneratorDL ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    sineGeneratorDL (const sineGeneratorDL_sequence& s);

    //@}

    /**
     * @name rampGeneratorDL
     *
     * @brief Accessor and modifier functions for the %rampGeneratorDL
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::RampGeneratorDL rampGeneratorDL_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< rampGeneratorDL_type > rampGeneratorDL_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef rampGeneratorDL_sequence::iterator rampGeneratorDL_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef rampGeneratorDL_sequence::const_iterator rampGeneratorDL_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< rampGeneratorDL_type, char > rampGeneratorDL_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const rampGeneratorDL_sequence&
    rampGeneratorDL () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    rampGeneratorDL_sequence&
    rampGeneratorDL ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    rampGeneratorDL (const rampGeneratorDL_sequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    CompoundInputDL (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CompoundInputDL (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CompoundInputDL (const CompoundInputDL& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual CompoundInputDL*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CompoundInputDL&
    operator= (const CompoundInputDL& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~CompoundInputDL ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    pulseGeneratorDL_sequence pulseGeneratorDL_;
    sineGeneratorDL_sequence sineGeneratorDL_;
    rampGeneratorDL_sequence rampGeneratorDL_;

    //@endcond
  };

  bool
  operator== (const CompoundInputDL&, const CompoundInputDL&);

  bool
  operator!= (const CompoundInputDL&, const CompoundInputDL&);


  /**
   * @brief Class corresponding to the %VoltageClamp schema type.
   *
   * Voltage clamp. Applies a variable current **i**  to try to keep parent
   * at **targetVoltage.**  Not yet fully tested!!! Consider using
   * voltageClampTriple!!
   * @param delay Delay before change in current. Current is zero prior to
   * this.
   * @param duration Duration for attempting to keep parent at
   * targetVoltage. Current is zero after delay + duration.
   * @param targetVoltage Current will be applied to try to get parent to
   * this target voltage
   * @param simpleSeriesResistance Current will be calculated by the
   * difference in voltage between the target and parent, divided by this
   * value
   *
   * @nosubgrouping
   */
  class VoltageClamp: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name delay
     *
     * @brief Accessor and modifier functions for the %delay
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time delay_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< delay_type, char > delay_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const delay_type&
    delay () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    delay_type&
    delay ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    delay (const delay_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    delay (::std::unique_ptr< delay_type > p);

    //@}

    /**
     * @name duration
     *
     * @brief Accessor and modifier functions for the %duration
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time duration_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< duration_type, char > duration_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const duration_type&
    duration () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    duration_type&
    duration ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    duration (const duration_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    duration (::std::unique_ptr< duration_type > p);

    //@}

    /**
     * @name targetVoltage
     *
     * @brief Accessor and modifier functions for the %targetVoltage
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage targetVoltage_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< targetVoltage_type, char > targetVoltage_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const targetVoltage_type&
    targetVoltage () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    targetVoltage_type&
    targetVoltage ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    targetVoltage (const targetVoltage_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    targetVoltage (::std::unique_ptr< targetVoltage_type > p);

    //@}

    /**
     * @name simpleSeriesResistance
     *
     * @brief Accessor and modifier functions for the %simpleSeriesResistance
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_resistance simpleSeriesResistance_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< simpleSeriesResistance_type, char > simpleSeriesResistance_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const simpleSeriesResistance_type&
    simpleSeriesResistance () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    simpleSeriesResistance_type&
    simpleSeriesResistance ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    simpleSeriesResistance (const simpleSeriesResistance_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    simpleSeriesResistance (::std::unique_ptr< simpleSeriesResistance_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    VoltageClamp (const id_type&,
                  const delay_type&,
                  const duration_type&,
                  const targetVoltage_type&,
                  const simpleSeriesResistance_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    VoltageClamp (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VoltageClamp (const VoltageClamp& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual VoltageClamp*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VoltageClamp&
    operator= (const VoltageClamp& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~VoltageClamp ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< delay_type > delay_;
    ::xsd::cxx::tree::one< duration_type > duration_;
    ::xsd::cxx::tree::one< targetVoltage_type > targetVoltage_;
    ::xsd::cxx::tree::one< simpleSeriesResistance_type > simpleSeriesResistance_;

    //@endcond
  };

  bool
  operator== (const VoltageClamp&, const VoltageClamp&);

  bool
  operator!= (const VoltageClamp&, const VoltageClamp&);


  /**
   * @brief Class corresponding to the %VoltageClampTriple schema type.
   *
   * Voltage clamp with 3 clamp levels. Applies a variable current **i**  (
   * through **simpleSeriesResistance**  ) to try to keep parent cell at
   * **conditioningVoltage**  until time **delay,**  **testingVoltage** 
   * until **delay**  + **duration,**  and **returnVoltage**  afterwards.
   * Only enabled if **active**  = 1.
   * @param active Whether the voltage clamp is active ( 1 ) or inactive (
   * 0 ).
   * @param delay Delay before switching from conditioningVoltage to
   * testingVoltage.
   * @param duration Duration to hold at testingVoltage.
   * @param conditioningVoltage Target voltage before time delay
   * @param testingVoltage Target voltage between times delay and delay +
   * duration
   * @param returnVoltage Target voltage after time duration
   * @param simpleSeriesResistance Current will be calculated by the
   * difference in voltage between the target and parent, divided by this
   * value
   *
   * @nosubgrouping
   */
  class VoltageClampTriple: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name active
     *
     * @brief Accessor and modifier functions for the %active
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::ZeroOrOne active_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< active_type, char > active_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const active_type&
    active () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    active_type&
    active ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    active (const active_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    active (::std::unique_ptr< active_type > p);

    //@}

    /**
     * @name delay
     *
     * @brief Accessor and modifier functions for the %delay
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time delay_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< delay_type, char > delay_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const delay_type&
    delay () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    delay_type&
    delay ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    delay (const delay_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    delay (::std::unique_ptr< delay_type > p);

    //@}

    /**
     * @name duration
     *
     * @brief Accessor and modifier functions for the %duration
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time duration_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< duration_type, char > duration_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const duration_type&
    duration () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    duration_type&
    duration ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    duration (const duration_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    duration (::std::unique_ptr< duration_type > p);

    //@}

    /**
     * @name conditioningVoltage
     *
     * @brief Accessor and modifier functions for the %conditioningVoltage
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage conditioningVoltage_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< conditioningVoltage_type, char > conditioningVoltage_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const conditioningVoltage_type&
    conditioningVoltage () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    conditioningVoltage_type&
    conditioningVoltage ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    conditioningVoltage (const conditioningVoltage_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    conditioningVoltage (::std::unique_ptr< conditioningVoltage_type > p);

    //@}

    /**
     * @name testingVoltage
     *
     * @brief Accessor and modifier functions for the %testingVoltage
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage testingVoltage_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< testingVoltage_type, char > testingVoltage_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const testingVoltage_type&
    testingVoltage () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    testingVoltage_type&
    testingVoltage ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    testingVoltage (const testingVoltage_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    testingVoltage (::std::unique_ptr< testingVoltage_type > p);

    //@}

    /**
     * @name returnVoltage
     *
     * @brief Accessor and modifier functions for the %returnVoltage
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_voltage returnVoltage_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< returnVoltage_type, char > returnVoltage_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const returnVoltage_type&
    returnVoltage () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    returnVoltage_type&
    returnVoltage ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    returnVoltage (const returnVoltage_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    returnVoltage (::std::unique_ptr< returnVoltage_type > p);

    //@}

    /**
     * @name simpleSeriesResistance
     *
     * @brief Accessor and modifier functions for the %simpleSeriesResistance
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_resistance simpleSeriesResistance_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< simpleSeriesResistance_type, char > simpleSeriesResistance_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const simpleSeriesResistance_type&
    simpleSeriesResistance () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    simpleSeriesResistance_type&
    simpleSeriesResistance ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    simpleSeriesResistance (const simpleSeriesResistance_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    simpleSeriesResistance (::std::unique_ptr< simpleSeriesResistance_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    VoltageClampTriple (const id_type&,
                        const active_type&,
                        const delay_type&,
                        const duration_type&,
                        const conditioningVoltage_type&,
                        const testingVoltage_type&,
                        const returnVoltage_type&,
                        const simpleSeriesResistance_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    VoltageClampTriple (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VoltageClampTriple (const VoltageClampTriple& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual VoltageClampTriple*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VoltageClampTriple&
    operator= (const VoltageClampTriple& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~VoltageClampTriple ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< active_type > active_;
    ::xsd::cxx::tree::one< delay_type > delay_;
    ::xsd::cxx::tree::one< duration_type > duration_;
    ::xsd::cxx::tree::one< conditioningVoltage_type > conditioningVoltage_;
    ::xsd::cxx::tree::one< testingVoltage_type > testingVoltage_;
    ::xsd::cxx::tree::one< returnVoltage_type > returnVoltage_;
    ::xsd::cxx::tree::one< simpleSeriesResistance_type > simpleSeriesResistance_;

    //@endcond
  };

  bool
  operator== (const VoltageClampTriple&, const VoltageClampTriple&);

  bool
  operator!= (const VoltageClampTriple&, const VoltageClampTriple&);


  /**
   * @brief Class corresponding to the %Spike schema type.
   *
   * Emits a single spike at the specified **time**
   * @param time Time at which to emit one spike event
   *
   * @nosubgrouping
   */
  class Spike: public ::neuroml2::BaseNonNegativeIntegerId
  {
    public:
    /**
     * @name time
     *
     * @brief Accessor and modifier functions for the %time
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time time_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< time_type, char > time_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const time_type&
    time () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    time_type&
    time ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    time (const time_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    time (::std::unique_ptr< time_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Spike (const id_type&,
           const time_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Spike (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Spike (const Spike& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Spike*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Spike&
    operator= (const Spike& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Spike ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< time_type > time_;

    //@endcond
  };

  bool
  operator== (const Spike&, const Spike&);

  bool
  operator!= (const Spike&, const Spike&);


  /**
   * @brief Class corresponding to the %SpikeArray schema type.
   *
   * Set of spike ComponentTypes, each emitting one spike at a certain
   * time. Can be used to feed a predetermined spike train into a cell
   *
   * @nosubgrouping
   */
  class SpikeArray: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name spike
     *
     * @brief Accessor and modifier functions for the %spike
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Spike spike_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< spike_type > spike_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef spike_sequence::iterator spike_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef spike_sequence::const_iterator spike_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< spike_type, char > spike_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const spike_sequence&
    spike () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    spike_sequence&
    spike ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    spike (const spike_sequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SpikeArray (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SpikeArray (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SpikeArray (const SpikeArray& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SpikeArray*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SpikeArray&
    operator= (const SpikeArray& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SpikeArray ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    spike_sequence spike_;

    //@endcond
  };

  bool
  operator== (const SpikeArray&, const SpikeArray&);

  bool
  operator!= (const SpikeArray&, const SpikeArray&);


  /**
   * @brief Class corresponding to the %TimedSynapticInput schema type.
   *
   * Spike array connected to a single **synapse,**  producing a current
   * triggered by each  **spike**  in the array.
   *
   * @nosubgrouping
   */
  class TimedSynapticInput: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name spike
     *
     * @brief Accessor and modifier functions for the %spike
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Spike spike_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< spike_type > spike_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef spike_sequence::iterator spike_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef spike_sequence::const_iterator spike_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< spike_type, char > spike_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const spike_sequence&
    spike () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    spike_sequence&
    spike ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    spike (const spike_sequence& s);

    //@}

    /**
     * @name synapse
     *
     * @brief Accessor and modifier functions for the %synapse
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId synapse_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< synapse_type, char > synapse_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const synapse_type&
    synapse () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    synapse_type&
    synapse ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    synapse (const synapse_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    synapse (::std::unique_ptr< synapse_type > p);

    //@}

    /**
     * @name spikeTarget
     *
     * @brief Accessor and modifier functions for the %spikeTarget
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string spikeTarget_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< spikeTarget_type, char > spikeTarget_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const spikeTarget_type&
    spikeTarget () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    spikeTarget_type&
    spikeTarget ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    spikeTarget (const spikeTarget_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    spikeTarget (::std::unique_ptr< spikeTarget_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TimedSynapticInput (const id_type&,
                        const synapse_type&,
                        const spikeTarget_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimedSynapticInput (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimedSynapticInput (const TimedSynapticInput& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TimedSynapticInput*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimedSynapticInput&
    operator= (const TimedSynapticInput& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TimedSynapticInput ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    spike_sequence spike_;
    ::xsd::cxx::tree::one< synapse_type > synapse_;
    ::xsd::cxx::tree::one< spikeTarget_type > spikeTarget_;

    //@endcond
  };

  bool
  operator== (const TimedSynapticInput&, const TimedSynapticInput&);

  bool
  operator!= (const TimedSynapticInput&, const TimedSynapticInput&);


  /**
   * @brief Class corresponding to the %SpikeGenerator schema type.
   *
   * Simple generator of spikes at a regular interval set by **period**
   * @param period Time between spikes. The first spike will be emitted
   * after this time.
   *
   * @nosubgrouping
   */
  class SpikeGenerator: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name period
     *
     * @brief Accessor and modifier functions for the %period
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time period_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< period_type, char > period_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const period_type&
    period () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    period_type&
    period ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    period (const period_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    period (::std::unique_ptr< period_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SpikeGenerator (const id_type&,
                    const period_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SpikeGenerator (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SpikeGenerator (const SpikeGenerator& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SpikeGenerator*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SpikeGenerator&
    operator= (const SpikeGenerator& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SpikeGenerator ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< period_type > period_;

    //@endcond
  };

  bool
  operator== (const SpikeGenerator&, const SpikeGenerator&);

  bool
  operator!= (const SpikeGenerator&, const SpikeGenerator&);


  /**
   * @brief Class corresponding to the %SpikeGeneratorRandom schema type.
   *
   * Generator of spikes with a random interspike interval of at least
   * **minISI**  and at most **maxISI**
   * @param maxISI Maximum interspike interval
   * @param minISI Minimum interspike interval
   *
   * @nosubgrouping
   */
  class SpikeGeneratorRandom: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name maxISI
     *
     * @brief Accessor and modifier functions for the %maxISI
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time maxISI_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< maxISI_type, char > maxISI_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const maxISI_type&
    maxISI () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    maxISI_type&
    maxISI ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    maxISI (const maxISI_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    maxISI (::std::unique_ptr< maxISI_type > p);

    //@}

    /**
     * @name minISI
     *
     * @brief Accessor and modifier functions for the %minISI
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time minISI_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< minISI_type, char > minISI_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const minISI_type&
    minISI () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    minISI_type&
    minISI ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    minISI (const minISI_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    minISI (::std::unique_ptr< minISI_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SpikeGeneratorRandom (const id_type&,
                          const maxISI_type&,
                          const minISI_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SpikeGeneratorRandom (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SpikeGeneratorRandom (const SpikeGeneratorRandom& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SpikeGeneratorRandom*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SpikeGeneratorRandom&
    operator= (const SpikeGeneratorRandom& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SpikeGeneratorRandom ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< maxISI_type > maxISI_;
    ::xsd::cxx::tree::one< minISI_type > minISI_;

    //@endcond
  };

  bool
  operator== (const SpikeGeneratorRandom&, const SpikeGeneratorRandom&);

  bool
  operator!= (const SpikeGeneratorRandom&, const SpikeGeneratorRandom&);


  /**
   * @brief Class corresponding to the %SpikeGeneratorPoisson schema type.
   *
   * Generator of spikes whose ISI is distributed according to an
   * exponential PDF with scale: 1 / **averageRate**
   * @param averageRate The average rate at which spikes are emitted
   *
   * @nosubgrouping
   */
  class SpikeGeneratorPoisson: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name averageRate
     *
     * @brief Accessor and modifier functions for the %averageRate
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_pertime averageRate_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< averageRate_type, char > averageRate_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const averageRate_type&
    averageRate () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    averageRate_type&
    averageRate ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    averageRate (const averageRate_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    averageRate (::std::unique_ptr< averageRate_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SpikeGeneratorPoisson (const id_type&,
                           const averageRate_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SpikeGeneratorPoisson (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SpikeGeneratorPoisson (const SpikeGeneratorPoisson& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SpikeGeneratorPoisson*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SpikeGeneratorPoisson&
    operator= (const SpikeGeneratorPoisson& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SpikeGeneratorPoisson ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< averageRate_type > averageRate_;

    //@endcond
  };

  bool
  operator== (const SpikeGeneratorPoisson&, const SpikeGeneratorPoisson&);

  bool
  operator!= (const SpikeGeneratorPoisson&, const SpikeGeneratorPoisson&);


  /**
   * @brief Class corresponding to the %SpikeGeneratorRefPoisson schema type.
   *
   * Generator of spikes whose ISI distribution is the maximum entropy
   * distribution over [ **minimumISI,**  +infinity ) with mean: 1 /
   * **averageRate**
   * @param minimumISI The minimum interspike interval
   * @param averageRate The average rate at which spikes are emitted
   *
   * @nosubgrouping
   */
  class SpikeGeneratorRefPoisson: public ::neuroml2::SpikeGeneratorPoisson
  {
    public:
    /**
     * @name minimumISI
     *
     * @brief Accessor and modifier functions for the %minimumISI
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time minimumISI_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< minimumISI_type, char > minimumISI_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const minimumISI_type&
    minimumISI () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    minimumISI_type&
    minimumISI ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    minimumISI (const minimumISI_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    minimumISI (::std::unique_ptr< minimumISI_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SpikeGeneratorRefPoisson (const id_type&,
                              const averageRate_type&,
                              const minimumISI_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SpikeGeneratorRefPoisson (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SpikeGeneratorRefPoisson (const SpikeGeneratorRefPoisson& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SpikeGeneratorRefPoisson*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SpikeGeneratorRefPoisson&
    operator= (const SpikeGeneratorRefPoisson& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SpikeGeneratorRefPoisson ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< minimumISI_type > minimumISI_;

    //@endcond
  };

  bool
  operator== (const SpikeGeneratorRefPoisson&, const SpikeGeneratorRefPoisson&);

  bool
  operator!= (const SpikeGeneratorRefPoisson&, const SpikeGeneratorRefPoisson&);


  /**
   * @brief Class corresponding to the %PoissonFiringSynapse schema type.
   *
   * Poisson spike generator firing at **averageRate,**  which is connected
   * to single **synapse**  that is triggered every time a spike is
   * generated, producing an input current. See also 
   * **transientPoissonFiringSynapse** .
   * @param averageRate The average rate at which spikes are emitted
   *
   * @nosubgrouping
   */
  class PoissonFiringSynapse: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name averageRate
     *
     * @brief Accessor and modifier functions for the %averageRate
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_pertime averageRate_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< averageRate_type, char > averageRate_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const averageRate_type&
    averageRate () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    averageRate_type&
    averageRate ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    averageRate (const averageRate_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    averageRate (::std::unique_ptr< averageRate_type > p);

    //@}

    /**
     * @name synapse
     *
     * @brief Accessor and modifier functions for the %synapse
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string synapse_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< synapse_type, char > synapse_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const synapse_type&
    synapse () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    synapse_type&
    synapse ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    synapse (const synapse_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    synapse (::std::unique_ptr< synapse_type > p);

    //@}

    /**
     * @name spikeTarget
     *
     * @brief Accessor and modifier functions for the %spikeTarget
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string spikeTarget_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< spikeTarget_type, char > spikeTarget_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const spikeTarget_type&
    spikeTarget () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    spikeTarget_type&
    spikeTarget ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    spikeTarget (const spikeTarget_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    spikeTarget (::std::unique_ptr< spikeTarget_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PoissonFiringSynapse (const id_type&,
                          const averageRate_type&,
                          const synapse_type&,
                          const spikeTarget_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PoissonFiringSynapse (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PoissonFiringSynapse (const PoissonFiringSynapse& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PoissonFiringSynapse*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PoissonFiringSynapse&
    operator= (const PoissonFiringSynapse& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PoissonFiringSynapse ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< averageRate_type > averageRate_;
    ::xsd::cxx::tree::one< synapse_type > synapse_;
    ::xsd::cxx::tree::one< spikeTarget_type > spikeTarget_;

    //@endcond
  };

  bool
  operator== (const PoissonFiringSynapse&, const PoissonFiringSynapse&);

  bool
  operator!= (const PoissonFiringSynapse&, const PoissonFiringSynapse&);


  /**
   * @brief Class corresponding to the %TransientPoissonFiringSynapse schema type.
   *
   * Poisson spike generator firing at **averageRate**  after a **delay** 
   * and for a **duration,**  connected to single **synapse**  that is
   * triggered every time a spike is generated, providing an input current.
   * Similar to ComponentType  **poissonFiringSynapse** .
   * @param averageRate 
   * @param delay 
   * @param duration 
   *
   * @nosubgrouping
   */
  class TransientPoissonFiringSynapse: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name averageRate
     *
     * @brief Accessor and modifier functions for the %averageRate
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_pertime averageRate_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< averageRate_type, char > averageRate_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const averageRate_type&
    averageRate () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    averageRate_type&
    averageRate ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    averageRate (const averageRate_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    averageRate (::std::unique_ptr< averageRate_type > p);

    //@}

    /**
     * @name delay
     *
     * @brief Accessor and modifier functions for the %delay
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time delay_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< delay_type, char > delay_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const delay_type&
    delay () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    delay_type&
    delay ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    delay (const delay_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    delay (::std::unique_ptr< delay_type > p);

    //@}

    /**
     * @name duration
     *
     * @brief Accessor and modifier functions for the %duration
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time duration_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< duration_type, char > duration_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const duration_type&
    duration () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    duration_type&
    duration ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    duration (const duration_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    duration (::std::unique_ptr< duration_type > p);

    //@}

    /**
     * @name synapse
     *
     * @brief Accessor and modifier functions for the %synapse
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string synapse_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< synapse_type, char > synapse_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const synapse_type&
    synapse () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    synapse_type&
    synapse ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    synapse (const synapse_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    synapse (::std::unique_ptr< synapse_type > p);

    //@}

    /**
     * @name spikeTarget
     *
     * @brief Accessor and modifier functions for the %spikeTarget
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string spikeTarget_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< spikeTarget_type, char > spikeTarget_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const spikeTarget_type&
    spikeTarget () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    spikeTarget_type&
    spikeTarget ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    spikeTarget (const spikeTarget_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    spikeTarget (::std::unique_ptr< spikeTarget_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TransientPoissonFiringSynapse (const id_type&,
                                   const averageRate_type&,
                                   const delay_type&,
                                   const duration_type&,
                                   const synapse_type&,
                                   const spikeTarget_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TransientPoissonFiringSynapse (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TransientPoissonFiringSynapse (const TransientPoissonFiringSynapse& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TransientPoissonFiringSynapse*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TransientPoissonFiringSynapse&
    operator= (const TransientPoissonFiringSynapse& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TransientPoissonFiringSynapse ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< averageRate_type > averageRate_;
    ::xsd::cxx::tree::one< delay_type > delay_;
    ::xsd::cxx::tree::one< duration_type > duration_;
    ::xsd::cxx::tree::one< synapse_type > synapse_;
    ::xsd::cxx::tree::one< spikeTarget_type > spikeTarget_;

    //@endcond
  };

  bool
  operator== (const TransientPoissonFiringSynapse&, const TransientPoissonFiringSynapse&);

  bool
  operator!= (const TransientPoissonFiringSynapse&, const TransientPoissonFiringSynapse&);


  /**
   * @brief Class corresponding to the %Network schema type.
   *
   * Network containing:  **population** s ( potentially of type 
   * **populationList** , and so specifying a list of cell  **location** s
   * );  **projection** s ( with lists of  **connection** s ) and/or 
   * **explicitConnection** s; and  **inputList** s ( with lists of 
   * **input** s ) and/or  **explicitInput** s. Note: often in NeuroML this
   * will be of type  **networkWithTemperature**  if there are temperature
   * dependent elements ( e. g. ion channels ).
   *
   * @nosubgrouping
   */
  class Network: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name space
     *
     * @brief Accessor and modifier functions for the %space
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Space space_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< space_type > space_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef space_sequence::iterator space_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef space_sequence::const_iterator space_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< space_type, char > space_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const space_sequence&
    space () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    space_sequence&
    space ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    space (const space_sequence& s);

    //@}

    /**
     * @name region
     *
     * @brief Accessor and modifier functions for the %region
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Region region_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< region_type > region_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef region_sequence::iterator region_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef region_sequence::const_iterator region_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< region_type, char > region_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const region_sequence&
    region () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    region_sequence&
    region ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    region (const region_sequence& s);

    //@}

    /**
     * @name extracellularProperties
     *
     * @brief Accessor and modifier functions for the %extracellularProperties
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ExtracellularPropertiesLocal extracellularProperties_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< extracellularProperties_type > extracellularProperties_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef extracellularProperties_sequence::iterator extracellularProperties_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef extracellularProperties_sequence::const_iterator extracellularProperties_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< extracellularProperties_type, char > extracellularProperties_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const extracellularProperties_sequence&
    extracellularProperties () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    extracellularProperties_sequence&
    extracellularProperties ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    extracellularProperties (const extracellularProperties_sequence& s);

    //@}

    /**
     * @name population
     *
     * @brief Accessor and modifier functions for the %population
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Population population_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< population_type > population_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef population_sequence::iterator population_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef population_sequence::const_iterator population_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< population_type, char > population_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const population_sequence&
    population () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    population_sequence&
    population ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    population (const population_sequence& s);

    //@}

    /**
     * @name cellSet
     *
     * @brief Accessor and modifier functions for the %cellSet
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::CellSet cellSet_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< cellSet_type > cellSet_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef cellSet_sequence::iterator cellSet_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef cellSet_sequence::const_iterator cellSet_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< cellSet_type, char > cellSet_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const cellSet_sequence&
    cellSet () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    cellSet_sequence&
    cellSet ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    cellSet (const cellSet_sequence& s);

    //@}

    /**
     * @name synapticConnection
     *
     * @brief Accessor and modifier functions for the %synapticConnection
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::SynapticConnection synapticConnection_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< synapticConnection_type > synapticConnection_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef synapticConnection_sequence::iterator synapticConnection_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef synapticConnection_sequence::const_iterator synapticConnection_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< synapticConnection_type, char > synapticConnection_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const synapticConnection_sequence&
    synapticConnection () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    synapticConnection_sequence&
    synapticConnection ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    synapticConnection (const synapticConnection_sequence& s);

    //@}

    /**
     * @name projection
     *
     * @brief Accessor and modifier functions for the %projection
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Projection projection_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< projection_type > projection_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef projection_sequence::iterator projection_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef projection_sequence::const_iterator projection_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< projection_type, char > projection_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const projection_sequence&
    projection () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    projection_sequence&
    projection ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    projection (const projection_sequence& s);

    //@}

    /**
     * @name electricalProjection
     *
     * @brief Accessor and modifier functions for the %electricalProjection
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ElectricalProjection electricalProjection_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< electricalProjection_type > electricalProjection_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef electricalProjection_sequence::iterator electricalProjection_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef electricalProjection_sequence::const_iterator electricalProjection_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< electricalProjection_type, char > electricalProjection_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const electricalProjection_sequence&
    electricalProjection () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    electricalProjection_sequence&
    electricalProjection ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    electricalProjection (const electricalProjection_sequence& s);

    //@}

    /**
     * @name continuousProjection
     *
     * @brief Accessor and modifier functions for the %continuousProjection
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ContinuousProjection continuousProjection_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< continuousProjection_type > continuousProjection_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef continuousProjection_sequence::iterator continuousProjection_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef continuousProjection_sequence::const_iterator continuousProjection_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< continuousProjection_type, char > continuousProjection_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const continuousProjection_sequence&
    continuousProjection () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    continuousProjection_sequence&
    continuousProjection ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    continuousProjection (const continuousProjection_sequence& s);

    //@}

    /**
     * @name explicitInput
     *
     * @brief Accessor and modifier functions for the %explicitInput
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ExplicitInput explicitInput_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< explicitInput_type > explicitInput_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef explicitInput_sequence::iterator explicitInput_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef explicitInput_sequence::const_iterator explicitInput_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< explicitInput_type, char > explicitInput_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const explicitInput_sequence&
    explicitInput () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    explicitInput_sequence&
    explicitInput ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    explicitInput (const explicitInput_sequence& s);

    //@}

    /**
     * @name inputList
     *
     * @brief Accessor and modifier functions for the %inputList
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::InputList inputList_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< inputList_type > inputList_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef inputList_sequence::iterator inputList_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef inputList_sequence::const_iterator inputList_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< inputList_type, char > inputList_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const inputList_sequence&
    inputList () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    inputList_sequence&
    inputList ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    inputList (const inputList_sequence& s);

    //@}

    /**
     * @name type
     *
     * @brief Accessor and modifier functions for the %type
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::networkTypes type_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< type_type > type_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const type_optional&
    type () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    type_optional&
    type ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    type (const type_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    type (const type_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    type (::std::unique_ptr< type_type > p);

    //@}

    /**
     * @name temperature
     *
     * @brief Accessor and modifier functions for the %temperature
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_temperature temperature_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< temperature_type > temperature_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< temperature_type, char > temperature_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const temperature_optional&
    temperature () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    temperature_optional&
    temperature ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    temperature (const temperature_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    temperature (const temperature_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    temperature (::std::unique_ptr< temperature_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Network (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Network (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Network (const Network& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Network*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Network&
    operator= (const Network& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Network ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    space_sequence space_;
    region_sequence region_;
    extracellularProperties_sequence extracellularProperties_;
    population_sequence population_;
    cellSet_sequence cellSet_;
    synapticConnection_sequence synapticConnection_;
    projection_sequence projection_;
    electricalProjection_sequence electricalProjection_;
    continuousProjection_sequence continuousProjection_;
    explicitInput_sequence explicitInput_;
    inputList_sequence inputList_;
    type_optional type_;
    temperature_optional temperature_;

    //@endcond
  };

  bool
  operator== (const Network&, const Network&);

  bool
  operator!= (const Network&, const Network&);


  /**
   * @brief Enumeration class corresponding to the %networkTypes
   * schema type.
   */
  class networkTypes: public ::xml_schema::string
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum value
    {
      network,
      networkWithTemperature
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    networkTypes (value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    networkTypes (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    networkTypes (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    networkTypes (const ::xml_schema::string& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    networkTypes (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    networkTypes (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    networkTypes (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    networkTypes (const networkTypes& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual networkTypes*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    networkTypes&
    operator= (value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator value () const
    {
      return _xsd_networkTypes_convert ();
    }

    //@cond

    protected:
    value
    _xsd_networkTypes_convert () const;

    public:
    static const char* const _xsd_networkTypes_literals_[2];
    static const value _xsd_networkTypes_indexes_[2];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %Space schema type.
   *
   * @nosubgrouping
   */
  class Space: public ::neuroml2::Base
  {
    public:
    /**
     * @name structure
     *
     * @brief Accessor and modifier functions for the %structure
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::SpaceStructure structure_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< structure_type > structure_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< structure_type, char > structure_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const structure_optional&
    structure () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    structure_optional&
    structure ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    structure (const structure_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    structure (const structure_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    structure (::std::unique_ptr< structure_type > p);

    //@}

    /**
     * @name basedOn
     *
     * @brief Accessor and modifier functions for the %basedOn
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::allowedSpaces basedOn_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< basedOn_type > basedOn_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< basedOn_type, char > basedOn_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const basedOn_optional&
    basedOn () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    basedOn_optional&
    basedOn ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    basedOn (const basedOn_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    basedOn (const basedOn_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    basedOn (::std::unique_ptr< basedOn_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Space (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Space (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Space (const Space& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Space*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Space&
    operator= (const Space& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Space ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    structure_optional structure_;
    basedOn_optional basedOn_;

    //@endcond
  };

  bool
  operator== (const Space&, const Space&);

  bool
  operator!= (const Space&, const Space&);


  /**
   * @brief Class corresponding to the %SpaceStructure schema type.
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name xSpacing
     *
     * @brief Accessor and modifier functions for the %xSpacing
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ xSpacing_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< xSpacing_type > xSpacing_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< xSpacing_type, char > xSpacing_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const xSpacing_optional&
    xSpacing () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    xSpacing_optional&
    xSpacing ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    xSpacing (const xSpacing_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    xSpacing (const xSpacing_optional& x);

    //@}

    /**
     * @name ySpacing
     *
     * @brief Accessor and modifier functions for the %ySpacing
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ ySpacing_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ySpacing_type > ySpacing_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ySpacing_type, char > ySpacing_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ySpacing_optional&
    ySpacing () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ySpacing_optional&
    ySpacing ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    ySpacing (const ySpacing_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    ySpacing (const ySpacing_optional& x);

    //@}

    /**
     * @name zSpacing
     *
     * @brief Accessor and modifier functions for the %zSpacing
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ zSpacing_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< zSpacing_type > zSpacing_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< zSpacing_type, char > zSpacing_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const zSpacing_optional&
    zSpacing () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    zSpacing_optional&
    zSpacing ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    zSpacing (const zSpacing_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    zSpacing (const zSpacing_optional& x);

    //@}

    /**
     * @name xStart
     *
     * @brief Accessor and modifier functions for the %xStart
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ xStart_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< xStart_type, char > xStart_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const xStart_type&
    xStart () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    xStart_type&
    xStart ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    xStart (const xStart_type& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static xStart_type
    xStart_default_value ();

    //@}

    /**
     * @name yStart
     *
     * @brief Accessor and modifier functions for the %yStart
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ yStart_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< yStart_type, char > yStart_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const yStart_type&
    yStart () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    yStart_type&
    yStart ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    yStart (const yStart_type& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static yStart_type
    yStart_default_value ();

    //@}

    /**
     * @name zStart
     *
     * @brief Accessor and modifier functions for the %zStart
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ zStart_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< zStart_type, char > zStart_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const zStart_type&
    zStart () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    zStart_type&
    zStart ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    zStart (const zStart_type& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static zStart_type
    zStart_default_value ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SpaceStructure ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SpaceStructure (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SpaceStructure (const SpaceStructure& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SpaceStructure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SpaceStructure&
    operator= (const SpaceStructure& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SpaceStructure ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    xSpacing_optional xSpacing_;
    ySpacing_optional ySpacing_;
    zSpacing_optional zSpacing_;
    ::xsd::cxx::tree::one< xStart_type > xStart_;
    ::xsd::cxx::tree::one< yStart_type > yStart_;
    ::xsd::cxx::tree::one< zStart_type > zStart_;

    //@endcond
  };

  bool
  operator== (const SpaceStructure&, const SpaceStructure&);

  bool
  operator!= (const SpaceStructure&, const SpaceStructure&);


  /**
   * @brief Enumeration class corresponding to the %allowedSpaces
   * schema type.
   */
  class allowedSpaces: public ::xml_schema::string
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum value
    {
      Euclidean_1D,
      Euclidean_2D,
      Euclidean_3D,
      Grid_1D,
      Grid_2D,
      Grid_3D
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    allowedSpaces (value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    allowedSpaces (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    allowedSpaces (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    allowedSpaces (const ::xml_schema::string& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    allowedSpaces (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    allowedSpaces (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    allowedSpaces (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    allowedSpaces (const allowedSpaces& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual allowedSpaces*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    allowedSpaces&
    operator= (value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator value () const
    {
      return _xsd_allowedSpaces_convert ();
    }

    //@cond

    protected:
    value
    _xsd_allowedSpaces_convert () const;

    public:
    static const char* const _xsd_allowedSpaces_literals_[6];
    static const value _xsd_allowedSpaces_indexes_[6];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %Region schema type.
   *
   * Initial attempt to specify 3D region for placing cells. Work in
   * progress. . .
   *
   * @nosubgrouping
   */
  class Region: public ::neuroml2::Base
  {
    public:
    /**
     * @name space
     *
     * @brief Accessor and modifier functions for the %space
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId space_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< space_type > space_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< space_type, char > space_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const space_optional&
    space () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    space_optional&
    space ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    space (const space_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    space (const space_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    space (::std::unique_ptr< space_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Region (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Region (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Region (const Region& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Region*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Region&
    operator= (const Region& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Region ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    space_optional space_;

    //@endcond
  };

  bool
  operator== (const Region&, const Region&);

  bool
  operator!= (const Region&, const Region&);


  /**
   * @brief Class corresponding to the %Population schema type.
   *
   * A population of components, with just one parameter for the **size,** 
   * i. e. number of components to create. Note: quite often this is used
   * with type= **populationList**  which means the size is determined by
   * the number of  **instance** s ( with  **location** s ) in the list.
   * The **size**  attribute is still set, and there will be a validation
   * error if this does not match the number in the list.
   * @param size Number of instances of this Component to create when the
   * population is instantiated
   *
   * @nosubgrouping
   */
  class Population: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name layout
     *
     * @brief Accessor and modifier functions for the %layout
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Layout layout_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< layout_type > layout_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< layout_type, char > layout_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const layout_optional&
    layout () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    layout_optional&
    layout ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    layout (const layout_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    layout (const layout_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    layout (::std::unique_ptr< layout_type > p);

    //@}

    /**
     * @name instance
     *
     * @brief Accessor and modifier functions for the %instance
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Instance instance_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< instance_type > instance_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef instance_sequence::iterator instance_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef instance_sequence::const_iterator instance_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< instance_type, char > instance_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const instance_sequence&
    instance () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    instance_sequence&
    instance ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    instance (const instance_sequence& s);

    //@}

    /**
     * @name component
     *
     * @brief Accessor and modifier functions for the %component
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId component_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< component_type, char > component_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const component_type&
    component () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    component_type&
    component ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    component (const component_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    component (::std::unique_ptr< component_type > p);

    //@}

    /**
     * @name size
     *
     * @brief Accessor and modifier functions for the %size
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NonNegativeInteger size_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< size_type > size_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< size_type, char > size_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const size_optional&
    size () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    size_optional&
    size ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    size (const size_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    size (const size_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    size (::std::unique_ptr< size_type > p);

    //@}

    /**
     * @name type
     *
     * @brief Accessor and modifier functions for the %type
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::populationTypes type_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< type_type > type_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const type_optional&
    type () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    type_optional&
    type ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    type (const type_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    type (const type_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    type (::std::unique_ptr< type_type > p);

    //@}

    /**
     * @name extracellularProperties
     *
     * @brief Accessor and modifier functions for the %extracellularProperties
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId extracellularProperties_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< extracellularProperties_type > extracellularProperties_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< extracellularProperties_type, char > extracellularProperties_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const extracellularProperties_optional&
    extracellularProperties () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    extracellularProperties_optional&
    extracellularProperties ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    extracellularProperties (const extracellularProperties_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    extracellularProperties (const extracellularProperties_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    extracellularProperties (::std::unique_ptr< extracellularProperties_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Population (const id_type&,
                const component_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Population (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Population (const Population& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Population*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Population&
    operator= (const Population& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Population ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    layout_optional layout_;
    instance_sequence instance_;
    ::xsd::cxx::tree::one< component_type > component_;
    size_optional size_;
    type_optional type_;
    extracellularProperties_optional extracellularProperties_;

    //@endcond
  };

  bool
  operator== (const Population&, const Population&);

  bool
  operator!= (const Population&, const Population&);


  /**
   * @brief Enumeration class corresponding to the %populationTypes
   * schema type.
   */
  class populationTypes: public ::xml_schema::string
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum value
    {
      population,
      populationList
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    populationTypes (value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    populationTypes (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    populationTypes (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    populationTypes (const ::xml_schema::string& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    populationTypes (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    populationTypes (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    populationTypes (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    populationTypes (const populationTypes& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual populationTypes*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    populationTypes&
    operator= (value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator value () const
    {
      return _xsd_populationTypes_convert ();
    }

    //@cond

    protected:
    value
    _xsd_populationTypes_convert () const;

    public:
    static const char* const _xsd_populationTypes_literals_[2];
    static const value _xsd_populationTypes_indexes_[2];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %Layout schema type.
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name random
     *
     * @brief Accessor and modifier functions for the %random
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::RandomLayout random_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< random_type > random_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< random_type, char > random_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const random_optional&
    random () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    random_optional&
    random ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    random (const random_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    random (const random_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    random (::std::unique_ptr< random_type > p);

    //@}

    /**
     * @name grid
     *
     * @brief Accessor and modifier functions for the %grid
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::GridLayout grid_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< grid_type > grid_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< grid_type, char > grid_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const grid_optional&
    grid () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    grid_optional&
    grid ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    grid (const grid_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    grid (const grid_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    grid (::std::unique_ptr< grid_type > p);

    //@}

    /**
     * @name unstructured
     *
     * @brief Accessor and modifier functions for the %unstructured
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::UnstructuredLayout unstructured_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< unstructured_type > unstructured_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< unstructured_type, char > unstructured_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const unstructured_optional&
    unstructured () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    unstructured_optional&
    unstructured ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    unstructured (const unstructured_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    unstructured (const unstructured_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    unstructured (::std::unique_ptr< unstructured_type > p);

    //@}

    /**
     * @name space
     *
     * @brief Accessor and modifier functions for the %space
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId space_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< space_type > space_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< space_type, char > space_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const space_optional&
    space () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    space_optional&
    space ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    space (const space_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    space (const space_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    space (::std::unique_ptr< space_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Layout ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Layout (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Layout (const Layout& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Layout*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Layout&
    operator= (const Layout& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Layout ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    random_optional random_;
    grid_optional grid_;
    unstructured_optional unstructured_;
    space_optional space_;

    //@endcond
  };

  bool
  operator== (const Layout&, const Layout&);

  bool
  operator!= (const Layout&, const Layout&);


  /**
   * @brief Class corresponding to the %UnstructuredLayout schema type.
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name number
     *
     * @brief Accessor and modifier functions for the %number
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::non_negative_integer number_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< number_type > number_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< number_type, char > number_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const number_optional&
    number () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    number_optional&
    number ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    number (const number_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    number (const number_optional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    UnstructuredLayout ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    UnstructuredLayout (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    UnstructuredLayout (const UnstructuredLayout& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual UnstructuredLayout*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    UnstructuredLayout&
    operator= (const UnstructuredLayout& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~UnstructuredLayout ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    number_optional number_;

    //@endcond
  };

  bool
  operator== (const UnstructuredLayout&, const UnstructuredLayout&);

  bool
  operator!= (const UnstructuredLayout&, const UnstructuredLayout&);


  /**
   * @brief Class corresponding to the %RandomLayout schema type.
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name number
     *
     * @brief Accessor and modifier functions for the %number
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::non_negative_integer number_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< number_type > number_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< number_type, char > number_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const number_optional&
    number () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    number_optional&
    number ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    number (const number_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    number (const number_optional& x);

    //@}

    /**
     * @name region
     *
     * @brief Accessor and modifier functions for the %region
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId region_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< region_type > region_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< region_type, char > region_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const region_optional&
    region () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    region_optional&
    region ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    region (const region_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    region (const region_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    region (::std::unique_ptr< region_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    RandomLayout ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RandomLayout (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RandomLayout (const RandomLayout& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RandomLayout*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RandomLayout&
    operator= (const RandomLayout& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~RandomLayout ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    number_optional number_;
    region_optional region_;

    //@endcond
  };

  bool
  operator== (const RandomLayout&, const RandomLayout&);

  bool
  operator!= (const RandomLayout&, const RandomLayout&);


  /**
   * @brief Class corresponding to the %GridLayout schema type.
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name xSize
     *
     * @brief Accessor and modifier functions for the %xSize
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::non_negative_integer xSize_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< xSize_type > xSize_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< xSize_type, char > xSize_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const xSize_optional&
    xSize () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    xSize_optional&
    xSize ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    xSize (const xSize_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    xSize (const xSize_optional& x);

    //@}

    /**
     * @name ySize
     *
     * @brief Accessor and modifier functions for the %ySize
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::non_negative_integer ySize_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ySize_type > ySize_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ySize_type, char > ySize_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ySize_optional&
    ySize () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ySize_optional&
    ySize ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    ySize (const ySize_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    ySize (const ySize_optional& x);

    //@}

    /**
     * @name zSize
     *
     * @brief Accessor and modifier functions for the %zSize
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::non_negative_integer zSize_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< zSize_type > zSize_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< zSize_type, char > zSize_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const zSize_optional&
    zSize () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    zSize_optional&
    zSize ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    zSize (const zSize_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    zSize (const zSize_optional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    GridLayout ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GridLayout (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GridLayout (const GridLayout& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual GridLayout*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GridLayout&
    operator= (const GridLayout& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~GridLayout ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    xSize_optional xSize_;
    ySize_optional ySize_;
    zSize_optional zSize_;

    //@endcond
  };

  bool
  operator== (const GridLayout&, const GridLayout&);

  bool
  operator!= (const GridLayout&, const GridLayout&);


  /**
   * @brief Class corresponding to the %Instance schema type.
   *
   * Specifies a single instance of a component in a  **population**  (
   * placed at  **location**  ).
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name location
     *
     * @brief Accessor and modifier functions for the %location
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Location location_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< location_type, char > location_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const location_type&
    location () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    location_type&
    location ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    location (const location_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    location (::std::unique_ptr< location_type > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::non_negative_integer id_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< id_type > id_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const id_optional&
    id () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    id_optional&
    id ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    id (const id_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    id (const id_optional& x);

    //@}

    /**
     * @name i
     *
     * @brief Accessor and modifier functions for the %i
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::non_negative_integer i_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< i_type > i_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< i_type, char > i_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const i_optional&
    i () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    i_optional&
    i ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    i (const i_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    i (const i_optional& x);

    //@}

    /**
     * @name j
     *
     * @brief Accessor and modifier functions for the %j
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::non_negative_integer j_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< j_type > j_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< j_type, char > j_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const j_optional&
    j () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    j_optional&
    j ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    j (const j_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    j (const j_optional& x);

    //@}

    /**
     * @name k
     *
     * @brief Accessor and modifier functions for the %k
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::non_negative_integer k_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< k_type > k_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< k_type, char > k_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const k_optional&
    k () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    k_optional&
    k ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    k (const k_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    k (const k_optional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Instance (const location_type&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    Instance (::std::unique_ptr< location_type >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Instance (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Instance (const Instance& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Instance*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Instance&
    operator= (const Instance& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Instance ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< location_type > location_;
    id_optional id_;
    i_optional i_;
    j_optional j_;
    k_optional k_;

    //@endcond
  };

  bool
  operator== (const Instance&, const Instance&);

  bool
  operator!= (const Instance&, const Instance&);


  /**
   * @brief Class corresponding to the %Location schema type.
   *
   * Specifies the ( x, y, z ) location of a single  **instance**  of a
   * component in a  **population**
   * @param x 
   * @param y 
   * @param z 
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name x
     *
     * @brief Accessor and modifier functions for the %x
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ x_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< x_type, char > x_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const x_type&
    x () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    x_type&
    x ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    x (const x_type& x);

    //@}

    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ y_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< y_type, char > y_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const y_type&
    y () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    y_type&
    y ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    y (const y_type& x);

    //@}

    /**
     * @name z
     *
     * @brief Accessor and modifier functions for the %z
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ z_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< z_type, char > z_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const z_type&
    z () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    z_type&
    z ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    z (const z_type& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Location (const x_type&,
              const y_type&,
              const z_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Location (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Location (const Location& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Location*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Location&
    operator= (const Location& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Location ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< x_type > x_;
    ::xsd::cxx::tree::one< y_type > y_;
    ::xsd::cxx::tree::one< z_type > z_;

    //@endcond
  };

  bool
  operator== (const Location&, const Location&);

  bool
  operator!= (const Location&, const Location&);


  /**
   * @brief Class corresponding to the %CellSet schema type.
   *
   * @nosubgrouping
   */
  class CellSet: public ::neuroml2::Base
  {
    public:
    /**
     * @name select
     *
     * @brief Accessor and modifier functions for the %select
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string select_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< select_type, char > select_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const select_type&
    select () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    select_type&
    select ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    select (const select_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    select (::std::unique_ptr< select_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    CellSet (const id_type&,
             const select_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CellSet (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CellSet (const CellSet& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual CellSet*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CellSet&
    operator= (const CellSet& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~CellSet ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< select_type > select_;

    //@endcond
  };

  bool
  operator== (const CellSet&, const CellSet&);

  bool
  operator!= (const CellSet&, const CellSet&);


  /**
   * @brief Class corresponding to the %SynapticConnection schema type.
   *
   * Explicit event connection between named components, which gets
   * processed via a new instance of a **synapse**  component which is
   * created on the target component
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name from
     *
     * @brief Accessor and modifier functions for the %from
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string from_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< from_type, char > from_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const from_type&
    from () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    from_type&
    from ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    from (const from_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    from (::std::unique_ptr< from_type > p);

    //@}

    /**
     * @name to
     *
     * @brief Accessor and modifier functions for the %to
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string to_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< to_type, char > to_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const to_type&
    to () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    to_type&
    to ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    to (const to_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    to (::std::unique_ptr< to_type > p);

    //@}

    /**
     * @name synapse
     *
     * @brief Accessor and modifier functions for the %synapse
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string synapse_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< synapse_type, char > synapse_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const synapse_type&
    synapse () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    synapse_type&
    synapse ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    synapse (const synapse_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    synapse (::std::unique_ptr< synapse_type > p);

    //@}

    /**
     * @name destination
     *
     * @brief Accessor and modifier functions for the %destination
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId destination_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< destination_type > destination_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< destination_type, char > destination_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const destination_optional&
    destination () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    destination_optional&
    destination ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    destination (const destination_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    destination (const destination_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    destination (::std::unique_ptr< destination_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SynapticConnection (const from_type&,
                        const to_type&,
                        const synapse_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SynapticConnection (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SynapticConnection (const SynapticConnection& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SynapticConnection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SynapticConnection&
    operator= (const SynapticConnection& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SynapticConnection ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< from_type > from_;
    ::xsd::cxx::tree::one< to_type > to_;
    ::xsd::cxx::tree::one< synapse_type > synapse_;
    destination_optional destination_;

    //@endcond
  };

  bool
  operator== (const SynapticConnection&, const SynapticConnection&);

  bool
  operator!= (const SynapticConnection&, const SynapticConnection&);


  /**
   * @brief Class corresponding to the %BaseProjection schema type.
   *
   * Base for projection (set of synaptic connections) between two
   * populations
   *
   * @nosubgrouping
   */
  class BaseProjection: public ::neuroml2::Base
  {
    public:
    /**
     * @name presynapticPopulation
     *
     * @brief Accessor and modifier functions for the %presynapticPopulation
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId presynapticPopulation_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< presynapticPopulation_type, char > presynapticPopulation_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const presynapticPopulation_type&
    presynapticPopulation () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    presynapticPopulation_type&
    presynapticPopulation ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    presynapticPopulation (const presynapticPopulation_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    presynapticPopulation (::std::unique_ptr< presynapticPopulation_type > p);

    //@}

    /**
     * @name postsynapticPopulation
     *
     * @brief Accessor and modifier functions for the %postsynapticPopulation
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId postsynapticPopulation_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< postsynapticPopulation_type, char > postsynapticPopulation_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const postsynapticPopulation_type&
    postsynapticPopulation () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    postsynapticPopulation_type&
    postsynapticPopulation ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    postsynapticPopulation (const postsynapticPopulation_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    postsynapticPopulation (::std::unique_ptr< postsynapticPopulation_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BaseProjection (const id_type&,
                    const presynapticPopulation_type&,
                    const postsynapticPopulation_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BaseProjection (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BaseProjection (const BaseProjection& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BaseProjection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BaseProjection&
    operator= (const BaseProjection& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BaseProjection ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< presynapticPopulation_type > presynapticPopulation_;
    ::xsd::cxx::tree::one< postsynapticPopulation_type > postsynapticPopulation_;

    //@endcond
  };

  bool
  operator== (const BaseProjection&, const BaseProjection&);

  bool
  operator!= (const BaseProjection&, const BaseProjection&);


  /**
   * @brief Class corresponding to the %Projection schema type.
   *
   * Projection from one population, **presynapticPopulation**  to another,
   * **postsynapticPopulation,**  through **synapse.**  Contains lists of 
   * **connection**  or  **connectionWD**  elements.
   *
   * @nosubgrouping
   */
  class Projection: public ::neuroml2::BaseProjection
  {
    public:
    /**
     * @name connection
     *
     * @brief Accessor and modifier functions for the %connection
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Connection connection_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< connection_type > connection_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef connection_sequence::iterator connection_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef connection_sequence::const_iterator connection_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< connection_type, char > connection_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const connection_sequence&
    connection () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    connection_sequence&
    connection ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    connection (const connection_sequence& s);

    //@}

    /**
     * @name connectionWD
     *
     * @brief Accessor and modifier functions for the %connectionWD
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ConnectionWD connectionWD_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< connectionWD_type > connectionWD_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef connectionWD_sequence::iterator connectionWD_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef connectionWD_sequence::const_iterator connectionWD_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< connectionWD_type, char > connectionWD_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const connectionWD_sequence&
    connectionWD () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    connectionWD_sequence&
    connectionWD ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    connectionWD (const connectionWD_sequence& s);

    //@}

    /**
     * @name synapse
     *
     * @brief Accessor and modifier functions for the %synapse
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId synapse_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< synapse_type, char > synapse_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const synapse_type&
    synapse () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    synapse_type&
    synapse ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    synapse (const synapse_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    synapse (::std::unique_ptr< synapse_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Projection (const id_type&,
                const presynapticPopulation_type&,
                const postsynapticPopulation_type&,
                const synapse_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Projection (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Projection (const Projection& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Projection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Projection&
    operator= (const Projection& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Projection ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    connection_sequence connection_;
    connectionWD_sequence connectionWD_;
    ::xsd::cxx::tree::one< synapse_type > synapse_;

    //@endcond
  };

  bool
  operator== (const Projection&, const Projection&);

  bool
  operator!= (const Projection&, const Projection&);


  /**
   * @brief Class corresponding to the %BaseConnection schema type.
   *
   * Base of all synaptic connections (chemical/electrical/analog, etc.)
   * inside projections
   *
   * @nosubgrouping
   */
  class BaseConnection: public ::neuroml2::BaseNonNegativeIntegerId
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BaseConnection (const id_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BaseConnection (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BaseConnection (const BaseConnection& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BaseConnection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BaseConnection ();
  };

  /**
   * @brief Class corresponding to the %BaseConnectionOldFormat schema type.
   *
   * Base of all synaptic connections with preCellId, postSegmentId, etc.
   * Note: this is not the best name for these attributes, since Id is
   * superfluous, hence BaseConnectionNewFormat
   *
   * @nosubgrouping
   */
  class BaseConnectionOldFormat: public ::neuroml2::BaseConnection
  {
    public:
    /**
     * @name preCellId
     *
     * @brief Accessor and modifier functions for the %preCellId
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string preCellId_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< preCellId_type, char > preCellId_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const preCellId_type&
    preCellId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    preCellId_type&
    preCellId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    preCellId (const preCellId_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    preCellId (::std::unique_ptr< preCellId_type > p);

    //@}

    /**
     * @name preSegmentId
     *
     * @brief Accessor and modifier functions for the %preSegmentId
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NonNegativeInteger preSegmentId_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< preSegmentId_type, char > preSegmentId_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const preSegmentId_type&
    preSegmentId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    preSegmentId_type&
    preSegmentId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    preSegmentId (const preSegmentId_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    preSegmentId (::std::unique_ptr< preSegmentId_type > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static preSegmentId_type
    preSegmentId_default_value ();

    //@}

    /**
     * @name preFractionAlong
     *
     * @brief Accessor and modifier functions for the %preFractionAlong
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::ZeroToOne preFractionAlong_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< preFractionAlong_type, char > preFractionAlong_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const preFractionAlong_type&
    preFractionAlong () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    preFractionAlong_type&
    preFractionAlong ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    preFractionAlong (const preFractionAlong_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    preFractionAlong (::std::unique_ptr< preFractionAlong_type > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static preFractionAlong_type
    preFractionAlong_default_value ();

    //@}

    /**
     * @name postCellId
     *
     * @brief Accessor and modifier functions for the %postCellId
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string postCellId_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< postCellId_type, char > postCellId_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const postCellId_type&
    postCellId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    postCellId_type&
    postCellId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    postCellId (const postCellId_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    postCellId (::std::unique_ptr< postCellId_type > p);

    //@}

    /**
     * @name postSegmentId
     *
     * @brief Accessor and modifier functions for the %postSegmentId
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NonNegativeInteger postSegmentId_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< postSegmentId_type, char > postSegmentId_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const postSegmentId_type&
    postSegmentId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    postSegmentId_type&
    postSegmentId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    postSegmentId (const postSegmentId_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    postSegmentId (::std::unique_ptr< postSegmentId_type > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static postSegmentId_type
    postSegmentId_default_value ();

    //@}

    /**
     * @name postFractionAlong
     *
     * @brief Accessor and modifier functions for the %postFractionAlong
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::ZeroToOne postFractionAlong_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< postFractionAlong_type, char > postFractionAlong_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const postFractionAlong_type&
    postFractionAlong () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    postFractionAlong_type&
    postFractionAlong ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    postFractionAlong (const postFractionAlong_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    postFractionAlong (::std::unique_ptr< postFractionAlong_type > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static postFractionAlong_type
    postFractionAlong_default_value ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BaseConnectionOldFormat (const id_type&,
                             const preCellId_type&,
                             const postCellId_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BaseConnectionOldFormat (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BaseConnectionOldFormat (const BaseConnectionOldFormat& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BaseConnectionOldFormat*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BaseConnectionOldFormat&
    operator= (const BaseConnectionOldFormat& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BaseConnectionOldFormat ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< preCellId_type > preCellId_;
    ::xsd::cxx::tree::one< preSegmentId_type > preSegmentId_;
    ::xsd::cxx::tree::one< preFractionAlong_type > preFractionAlong_;
    ::xsd::cxx::tree::one< postCellId_type > postCellId_;
    ::xsd::cxx::tree::one< postSegmentId_type > postSegmentId_;
    ::xsd::cxx::tree::one< postFractionAlong_type > postFractionAlong_;

    //@endcond
  };

  bool
  operator== (const BaseConnectionOldFormat&, const BaseConnectionOldFormat&);

  bool
  operator!= (const BaseConnectionOldFormat&, const BaseConnectionOldFormat&);


  /**
   * @brief Class corresponding to the %BaseConnectionNewFormat schema type.
   *
   * Base of all synaptic connections with preCell, postSegment, etc.
   * See BaseConnectionOldFormat
   *
   * @nosubgrouping
   */
  class BaseConnectionNewFormat: public ::neuroml2::BaseConnection
  {
    public:
    /**
     * @name preCell
     *
     * @brief Accessor and modifier functions for the %preCell
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string preCell_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< preCell_type, char > preCell_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const preCell_type&
    preCell () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    preCell_type&
    preCell ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    preCell (const preCell_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    preCell (::std::unique_ptr< preCell_type > p);

    //@}

    /**
     * @name preSegment
     *
     * @brief Accessor and modifier functions for the %preSegment
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NonNegativeInteger preSegment_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< preSegment_type, char > preSegment_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const preSegment_type&
    preSegment () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    preSegment_type&
    preSegment ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    preSegment (const preSegment_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    preSegment (::std::unique_ptr< preSegment_type > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static preSegment_type
    preSegment_default_value ();

    //@}

    /**
     * @name preFractionAlong
     *
     * @brief Accessor and modifier functions for the %preFractionAlong
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::ZeroToOne preFractionAlong_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< preFractionAlong_type, char > preFractionAlong_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const preFractionAlong_type&
    preFractionAlong () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    preFractionAlong_type&
    preFractionAlong ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    preFractionAlong (const preFractionAlong_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    preFractionAlong (::std::unique_ptr< preFractionAlong_type > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static preFractionAlong_type
    preFractionAlong_default_value ();

    //@}

    /**
     * @name postCell
     *
     * @brief Accessor and modifier functions for the %postCell
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string postCell_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< postCell_type, char > postCell_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const postCell_type&
    postCell () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    postCell_type&
    postCell ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    postCell (const postCell_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    postCell (::std::unique_ptr< postCell_type > p);

    //@}

    /**
     * @name postSegment
     *
     * @brief Accessor and modifier functions for the %postSegment
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NonNegativeInteger postSegment_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< postSegment_type, char > postSegment_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const postSegment_type&
    postSegment () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    postSegment_type&
    postSegment ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    postSegment (const postSegment_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    postSegment (::std::unique_ptr< postSegment_type > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static postSegment_type
    postSegment_default_value ();

    //@}

    /**
     * @name postFractionAlong
     *
     * @brief Accessor and modifier functions for the %postFractionAlong
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::ZeroToOne postFractionAlong_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< postFractionAlong_type, char > postFractionAlong_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const postFractionAlong_type&
    postFractionAlong () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    postFractionAlong_type&
    postFractionAlong ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    postFractionAlong (const postFractionAlong_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    postFractionAlong (::std::unique_ptr< postFractionAlong_type > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static postFractionAlong_type
    postFractionAlong_default_value ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BaseConnectionNewFormat (const id_type&,
                             const preCell_type&,
                             const postCell_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BaseConnectionNewFormat (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BaseConnectionNewFormat (const BaseConnectionNewFormat& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BaseConnectionNewFormat*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BaseConnectionNewFormat&
    operator= (const BaseConnectionNewFormat& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BaseConnectionNewFormat ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< preCell_type > preCell_;
    ::xsd::cxx::tree::one< preSegment_type > preSegment_;
    ::xsd::cxx::tree::one< preFractionAlong_type > preFractionAlong_;
    ::xsd::cxx::tree::one< postCell_type > postCell_;
    ::xsd::cxx::tree::one< postSegment_type > postSegment_;
    ::xsd::cxx::tree::one< postFractionAlong_type > postFractionAlong_;

    //@endcond
  };

  bool
  operator== (const BaseConnectionNewFormat&, const BaseConnectionNewFormat&);

  bool
  operator!= (const BaseConnectionNewFormat&, const BaseConnectionNewFormat&);


  /**
   * @brief Class corresponding to the %Connection schema type.
   *
   * Event connection directly between named components, which gets
   * processed via a new instance of a **synapse**  component which is
   * created on the target component. Normally contained inside a 
   * **projection**  element.
   *
   * @nosubgrouping
   */
  class Connection_base: public ::neuroml2::BaseConnectionOldFormat
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Connection_base (const id_type&,
                     const preCellId_type&,
                     const postCellId_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Connection_base (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Connection_base (const Connection_base& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Connection_base*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Connection_base ();
  };

  /**
   * @brief Class corresponding to the %ConnectionWD schema type.
   *
   * Event connection between named components, which gets processed via a
   * new instance of a synapse component which is created on the target
   * component, includes setting of **weight**  and **delay**  for the
   * synaptic connection
   * @param weight 
   * @param delay 
   *
   * @nosubgrouping
   */
  class ConnectionWD: public ::neuroml2::BaseConnectionOldFormat
  {
    public:
    /**
     * @name weight
     *
     * @brief Accessor and modifier functions for the %weight
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ weight_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< weight_type, char > weight_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const weight_type&
    weight () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    weight_type&
    weight ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    weight (const weight_type& x);

    //@}

    /**
     * @name delay
     *
     * @brief Accessor and modifier functions for the %delay
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time delay_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< delay_type, char > delay_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const delay_type&
    delay () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    delay_type&
    delay ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    delay (const delay_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    delay (::std::unique_ptr< delay_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ConnectionWD (const id_type&,
                  const preCellId_type&,
                  const postCellId_type&,
                  const weight_type&,
                  const delay_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ConnectionWD (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ConnectionWD (const ConnectionWD& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ConnectionWD*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ConnectionWD&
    operator= (const ConnectionWD& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ConnectionWD ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< weight_type > weight_;
    ::xsd::cxx::tree::one< delay_type > delay_;

    //@endcond
  };

  bool
  operator== (const ConnectionWD&, const ConnectionWD&);

  bool
  operator!= (const ConnectionWD&, const ConnectionWD&);


  /**
   * @brief Class corresponding to the %ElectricalProjection schema type.
   *
   * A projection between **presynapticPopulation**  to another
   * **postsynapticPopulation**  through gap junctions.
   *
   * @nosubgrouping
   */
  class ElectricalProjection: public ::neuroml2::BaseProjection
  {
    public:
    /**
     * @name electricalConnection
     *
     * @brief Accessor and modifier functions for the %electricalConnection
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ElectricalConnection electricalConnection_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< electricalConnection_type > electricalConnection_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef electricalConnection_sequence::iterator electricalConnection_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef electricalConnection_sequence::const_iterator electricalConnection_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< electricalConnection_type, char > electricalConnection_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const electricalConnection_sequence&
    electricalConnection () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    electricalConnection_sequence&
    electricalConnection ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    electricalConnection (const electricalConnection_sequence& s);

    //@}

    /**
     * @name electricalConnectionInstance
     *
     * @brief Accessor and modifier functions for the %electricalConnectionInstance
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ElectricalConnectionInstance electricalConnectionInstance_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< electricalConnectionInstance_type > electricalConnectionInstance_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef electricalConnectionInstance_sequence::iterator electricalConnectionInstance_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef electricalConnectionInstance_sequence::const_iterator electricalConnectionInstance_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< electricalConnectionInstance_type, char > electricalConnectionInstance_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const electricalConnectionInstance_sequence&
    electricalConnectionInstance () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    electricalConnectionInstance_sequence&
    electricalConnectionInstance ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    electricalConnectionInstance (const electricalConnectionInstance_sequence& s);

    //@}

    /**
     * @name electricalConnectionInstanceW
     *
     * @brief Accessor and modifier functions for the %electricalConnectionInstanceW
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ElectricalConnectionInstanceW electricalConnectionInstanceW_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< electricalConnectionInstanceW_type > electricalConnectionInstanceW_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef electricalConnectionInstanceW_sequence::iterator electricalConnectionInstanceW_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef electricalConnectionInstanceW_sequence::const_iterator electricalConnectionInstanceW_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< electricalConnectionInstanceW_type, char > electricalConnectionInstanceW_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const electricalConnectionInstanceW_sequence&
    electricalConnectionInstanceW () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    electricalConnectionInstanceW_sequence&
    electricalConnectionInstanceW ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    electricalConnectionInstanceW (const electricalConnectionInstanceW_sequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ElectricalProjection (const id_type&,
                          const presynapticPopulation_type&,
                          const postsynapticPopulation_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ElectricalProjection (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ElectricalProjection (const ElectricalProjection& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ElectricalProjection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ElectricalProjection&
    operator= (const ElectricalProjection& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ElectricalProjection ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    electricalConnection_sequence electricalConnection_;
    electricalConnectionInstance_sequence electricalConnectionInstance_;
    electricalConnectionInstanceW_sequence electricalConnectionInstanceW_;

    //@endcond
  };

  bool
  operator== (const ElectricalProjection&, const ElectricalProjection&);

  bool
  operator!= (const ElectricalProjection&, const ElectricalProjection&);


  /**
   * @brief Class corresponding to the %ElectricalConnection schema type.
   *
   * To enable connections between populations through gap junctions.
   *
   * @nosubgrouping
   */
  class ElectricalConnection: public ::neuroml2::BaseConnectionNewFormat
  {
    public:
    /**
     * @name synapse
     *
     * @brief Accessor and modifier functions for the %synapse
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId synapse_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< synapse_type, char > synapse_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const synapse_type&
    synapse () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    synapse_type&
    synapse ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    synapse (const synapse_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    synapse (::std::unique_ptr< synapse_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ElectricalConnection (const id_type&,
                          const preCell_type&,
                          const postCell_type&,
                          const synapse_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ElectricalConnection (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ElectricalConnection (const ElectricalConnection& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ElectricalConnection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ElectricalConnection&
    operator= (const ElectricalConnection& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ElectricalConnection ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< synapse_type > synapse_;

    //@endcond
  };

  bool
  operator== (const ElectricalConnection&, const ElectricalConnection&);

  bool
  operator!= (const ElectricalConnection&, const ElectricalConnection&);


  /**
   * @brief Class corresponding to the %ElectricalConnectionInstance schema type.
   *
   * To enable connections between populations through gap junctions.
   * Populations need to be of type  **populationList**  and contain 
   * **instance**  and  **location**  elements.
   *
   * @nosubgrouping
   */
  class ElectricalConnectionInstance: public ::neuroml2::ElectricalConnection
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ElectricalConnectionInstance (const id_type&,
                                  const preCell_type&,
                                  const postCell_type&,
                                  const synapse_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ElectricalConnectionInstance (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ElectricalConnectionInstance (const ElectricalConnectionInstance& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ElectricalConnectionInstance*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ElectricalConnectionInstance ();
  };

  /**
   * @brief Class corresponding to the %ElectricalConnectionInstanceW schema type.
   *
   * To enable connections between populations through gap junctions.
   * Populations need to be of type  **populationList**  and contain 
   * **instance**  and  **location**  elements. Includes setting of
   * **weight**  for the connection
   * @param weight 
   *
   * @nosubgrouping
   */
  class ElectricalConnectionInstanceW: public ::neuroml2::ElectricalConnectionInstance
  {
    public:
    /**
     * @name weight
     *
     * @brief Accessor and modifier functions for the %weight
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ weight_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< weight_type, char > weight_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const weight_type&
    weight () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    weight_type&
    weight ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    weight (const weight_type& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ElectricalConnectionInstanceW (const id_type&,
                                   const preCell_type&,
                                   const postCell_type&,
                                   const synapse_type&,
                                   const weight_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ElectricalConnectionInstanceW (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ElectricalConnectionInstanceW (const ElectricalConnectionInstanceW& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ElectricalConnectionInstanceW*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ElectricalConnectionInstanceW&
    operator= (const ElectricalConnectionInstanceW& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ElectricalConnectionInstanceW ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< weight_type > weight_;

    //@endcond
  };

  bool
  operator== (const ElectricalConnectionInstanceW&, const ElectricalConnectionInstanceW&);

  bool
  operator!= (const ElectricalConnectionInstanceW&, const ElectricalConnectionInstanceW&);


  /**
   * @brief Class corresponding to the %ContinuousProjection schema type.
   *
   * A projection between **presynapticPopulation**  and
   * **postsynapticPopulation**  through components **preComponent**  at
   * the start and **postComponent**  at the end of a 
   * **continuousConnection**  or  **continuousConnectionInstance** . Can
   * be used for analog synapses.
   *
   * @nosubgrouping
   */
  class ContinuousProjection: public ::neuroml2::BaseProjection
  {
    public:
    /**
     * @name continuousConnection
     *
     * @brief Accessor and modifier functions for the %continuousConnection
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ContinuousConnection continuousConnection_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< continuousConnection_type > continuousConnection_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef continuousConnection_sequence::iterator continuousConnection_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef continuousConnection_sequence::const_iterator continuousConnection_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< continuousConnection_type, char > continuousConnection_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const continuousConnection_sequence&
    continuousConnection () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    continuousConnection_sequence&
    continuousConnection ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    continuousConnection (const continuousConnection_sequence& s);

    //@}

    /**
     * @name continuousConnectionInstance
     *
     * @brief Accessor and modifier functions for the %continuousConnectionInstance
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ContinuousConnectionInstance continuousConnectionInstance_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< continuousConnectionInstance_type > continuousConnectionInstance_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef continuousConnectionInstance_sequence::iterator continuousConnectionInstance_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef continuousConnectionInstance_sequence::const_iterator continuousConnectionInstance_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< continuousConnectionInstance_type, char > continuousConnectionInstance_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const continuousConnectionInstance_sequence&
    continuousConnectionInstance () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    continuousConnectionInstance_sequence&
    continuousConnectionInstance ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    continuousConnectionInstance (const continuousConnectionInstance_sequence& s);

    //@}

    /**
     * @name continuousConnectionInstanceW
     *
     * @brief Accessor and modifier functions for the %continuousConnectionInstanceW
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::ContinuousConnectionInstanceW continuousConnectionInstanceW_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< continuousConnectionInstanceW_type > continuousConnectionInstanceW_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef continuousConnectionInstanceW_sequence::iterator continuousConnectionInstanceW_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef continuousConnectionInstanceW_sequence::const_iterator continuousConnectionInstanceW_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< continuousConnectionInstanceW_type, char > continuousConnectionInstanceW_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const continuousConnectionInstanceW_sequence&
    continuousConnectionInstanceW () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    continuousConnectionInstanceW_sequence&
    continuousConnectionInstanceW ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    continuousConnectionInstanceW (const continuousConnectionInstanceW_sequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ContinuousProjection (const id_type&,
                          const presynapticPopulation_type&,
                          const postsynapticPopulation_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ContinuousProjection (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ContinuousProjection (const ContinuousProjection& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ContinuousProjection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ContinuousProjection&
    operator= (const ContinuousProjection& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ContinuousProjection ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    continuousConnection_sequence continuousConnection_;
    continuousConnectionInstance_sequence continuousConnectionInstance_;
    continuousConnectionInstanceW_sequence continuousConnectionInstanceW_;

    //@endcond
  };

  bool
  operator== (const ContinuousProjection&, const ContinuousProjection&);

  bool
  operator!= (const ContinuousProjection&, const ContinuousProjection&);


  /**
   * @brief Class corresponding to the %ContinuousConnection schema type.
   *
   * An instance of a connection in a  **continuousProjection**  between
   * **presynapticPopulation**  to another **postsynapticPopulation** 
   * through a **preComponent**  at the start and **postComponent**  at the
   * end. Can be used for analog synapses.
   *
   * @nosubgrouping
   */
  class ContinuousConnection: public ::neuroml2::BaseConnectionNewFormat
  {
    public:
    /**
     * @name preComponent
     *
     * @brief Accessor and modifier functions for the %preComponent
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId preComponent_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< preComponent_type, char > preComponent_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const preComponent_type&
    preComponent () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    preComponent_type&
    preComponent ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    preComponent (const preComponent_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    preComponent (::std::unique_ptr< preComponent_type > p);

    //@}

    /**
     * @name postComponent
     *
     * @brief Accessor and modifier functions for the %postComponent
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId postComponent_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< postComponent_type, char > postComponent_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const postComponent_type&
    postComponent () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    postComponent_type&
    postComponent ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    postComponent (const postComponent_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    postComponent (::std::unique_ptr< postComponent_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ContinuousConnection (const id_type&,
                          const preCell_type&,
                          const postCell_type&,
                          const preComponent_type&,
                          const postComponent_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ContinuousConnection (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ContinuousConnection (const ContinuousConnection& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ContinuousConnection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ContinuousConnection&
    operator= (const ContinuousConnection& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ContinuousConnection ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< preComponent_type > preComponent_;
    ::xsd::cxx::tree::one< postComponent_type > postComponent_;

    //@endcond
  };

  bool
  operator== (const ContinuousConnection&, const ContinuousConnection&);

  bool
  operator!= (const ContinuousConnection&, const ContinuousConnection&);


  /**
   * @brief Class corresponding to the %ContinuousConnectionInstance schema type.
   *
   * An instance of a connection in a  **continuousProjection**  between
   * **presynapticPopulation**  to another **postsynapticPopulation** 
   * through a **preComponent**  at the start and **postComponent**  at the
   * end. Populations need to be of type  **populationList**  and contain 
   * **instance**  and  **location**  elements. Can be used for analog
   * synapses.
   *
   * @nosubgrouping
   */
  class ContinuousConnectionInstance: public ::neuroml2::ContinuousConnection
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ContinuousConnectionInstance (const id_type&,
                                  const preCell_type&,
                                  const postCell_type&,
                                  const preComponent_type&,
                                  const postComponent_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ContinuousConnectionInstance (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ContinuousConnectionInstance (const ContinuousConnectionInstance& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ContinuousConnectionInstance*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ContinuousConnectionInstance ();
  };

  /**
   * @brief Class corresponding to the %ContinuousConnectionInstanceW schema type.
   *
   * An instance of a connection in a  **continuousProjection**  between
   * **presynapticPopulation**  to another **postsynapticPopulation** 
   * through a **preComponent**  at the start and **postComponent**  at the
   * end. Populations need to be of type  **populationList**  and contain 
   * **instance**  and  **location**  elements. Can be used for analog
   * synapses. Includes setting of **weight**  for the connection
   * @param weight 
   *
   * @nosubgrouping
   */
  class ContinuousConnectionInstanceW: public ::neuroml2::ContinuousConnectionInstance
  {
    public:
    /**
     * @name weight
     *
     * @brief Accessor and modifier functions for the %weight
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ weight_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< weight_type, char > weight_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const weight_type&
    weight () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    weight_type&
    weight ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    weight (const weight_type& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ContinuousConnectionInstanceW (const id_type&,
                                   const preCell_type&,
                                   const postCell_type&,
                                   const preComponent_type&,
                                   const postComponent_type&,
                                   const weight_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ContinuousConnectionInstanceW (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ContinuousConnectionInstanceW (const ContinuousConnectionInstanceW& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ContinuousConnectionInstanceW*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ContinuousConnectionInstanceW&
    operator= (const ContinuousConnectionInstanceW& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ContinuousConnectionInstanceW ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< weight_type > weight_;

    //@endcond
  };

  bool
  operator== (const ContinuousConnectionInstanceW&, const ContinuousConnectionInstanceW&);

  bool
  operator!= (const ContinuousConnectionInstanceW&, const ContinuousConnectionInstanceW&);


  /**
   * @brief Class corresponding to the %ExplicitInput schema type.
   *
   * An explicit input ( anything which extends  **basePointCurrent**  ) to
   * a target cell in a population
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name target
     *
     * @brief Accessor and modifier functions for the %target
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string target_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< target_type, char > target_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const target_type&
    target () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    target_type&
    target ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    target (const target_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    target (::std::unique_ptr< target_type > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string input_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< input_type, char > input_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const input_type&
    input () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    input_type&
    input ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    input (const input_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    input (::std::unique_ptr< input_type > p);

    //@}

    /**
     * @name destination
     *
     * @brief Accessor and modifier functions for the %destination
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string destination_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< destination_type > destination_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< destination_type, char > destination_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const destination_optional&
    destination () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    destination_optional&
    destination ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    destination (const destination_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    destination (const destination_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    destination (::std::unique_ptr< destination_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ExplicitInput (const target_type&,
                   const input_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ExplicitInput (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ExplicitInput (const ExplicitInput& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ExplicitInput*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ExplicitInput&
    operator= (const ExplicitInput& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ExplicitInput ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< target_type > target_;
    ::xsd::cxx::tree::one< input_type > input_;
    destination_optional destination_;

    //@endcond
  };

  bool
  operator== (const ExplicitInput&, const ExplicitInput&);

  bool
  operator!= (const ExplicitInput&, const ExplicitInput&);


  /**
   * @brief Class corresponding to the %InputList schema type.
   *
   * An explicit list of  **input** s to a **population.**
   *
   * @nosubgrouping
   */
  class InputList: public ::neuroml2::Base
  {
    public:
    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::Input input_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< input_type > input_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef input_sequence::iterator input_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef input_sequence::const_iterator input_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< input_type, char > input_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const input_sequence&
    input () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    input_sequence&
    input ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    input (const input_sequence& s);

    //@}

    /**
     * @name inputW
     *
     * @brief Accessor and modifier functions for the %inputW
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::neuroml2::InputW inputW_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< inputW_type > inputW_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef inputW_sequence::iterator inputW_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef inputW_sequence::const_iterator inputW_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< inputW_type, char > inputW_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const inputW_sequence&
    inputW () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    inputW_sequence&
    inputW ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    inputW (const inputW_sequence& s);

    //@}

    /**
     * @name population
     *
     * @brief Accessor and modifier functions for the %population
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId population_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< population_type, char > population_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const population_type&
    population () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    population_type&
    population ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    population (const population_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    population (::std::unique_ptr< population_type > p);

    //@}

    /**
     * @name component
     *
     * @brief Accessor and modifier functions for the %component
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId component_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< component_type, char > component_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const component_type&
    component () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    component_type&
    component ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    component (const component_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    component (::std::unique_ptr< component_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InputList (const id_type&,
               const population_type&,
               const component_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InputList (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InputList (const InputList& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InputList*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InputList&
    operator= (const InputList& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InputList ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    input_sequence input_;
    inputW_sequence inputW_;
    ::xsd::cxx::tree::one< population_type > population_;
    ::xsd::cxx::tree::one< component_type > component_;

    //@endcond
  };

  bool
  operator== (const InputList&, const InputList&);

  bool
  operator!= (const InputList&, const InputList&);


  /**
   * @brief Class corresponding to the %Input schema type.
   *
   * Specifies a single input to a **target,**  optionally giving the
   * **segmentId**  ( default 0 ) and **fractionAlong**  the segment (
   * default 0. 5 ).
   *
   * @nosubgrouping
   */
  {
    public:
    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NonNegativeInteger id_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const id_type&
    id () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    id_type&
    id ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    id (const id_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    id (::std::unique_ptr< id_type > p);

    //@}

    /**
     * @name target
     *
     * @brief Accessor and modifier functions for the %target
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::string target_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< target_type, char > target_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const target_type&
    target () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    target_type&
    target ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    target (const target_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    target (::std::unique_ptr< target_type > p);

    //@}

    /**
     * @name destination
     *
     * @brief Accessor and modifier functions for the %destination
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NmlId destination_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< destination_type, char > destination_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const destination_type&
    destination () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    destination_type&
    destination ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    destination (const destination_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    destination (::std::unique_ptr< destination_type > p);

    //@}

    /**
     * @name segmentId
     *
     * @brief Accessor and modifier functions for the %segmentId
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::NonNegativeInteger segmentId_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< segmentId_type > segmentId_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< segmentId_type, char > segmentId_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const segmentId_optional&
    segmentId () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    segmentId_optional&
    segmentId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    segmentId (const segmentId_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    segmentId (const segmentId_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    segmentId (::std::unique_ptr< segmentId_type > p);

    //@}

    /**
     * @name fractionAlong
     *
     * @brief Accessor and modifier functions for the %fractionAlong
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::ZeroToOne fractionAlong_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< fractionAlong_type > fractionAlong_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< fractionAlong_type, char > fractionAlong_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const fractionAlong_optional&
    fractionAlong () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    fractionAlong_optional&
    fractionAlong ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    fractionAlong (const fractionAlong_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    fractionAlong (const fractionAlong_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    fractionAlong (::std::unique_ptr< fractionAlong_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Input (const id_type&,
           const target_type&,
           const destination_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Input (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Input (const Input& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Input*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Input&
    operator= (const Input& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Input ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< id_type > id_;
    ::xsd::cxx::tree::one< target_type > target_;
    ::xsd::cxx::tree::one< destination_type > destination_;
    segmentId_optional segmentId_;
    fractionAlong_optional fractionAlong_;

    //@endcond
  };

  bool
  operator== (const Input&, const Input&);

  bool
  operator!= (const Input&, const Input&);


  /**
   * @brief Class corresponding to the %InputW schema type.
   *
   * Specifies input lists. Can set **weight**  to scale individual inputs.
   * @param weight 
   *
   * @nosubgrouping
   */
  class InputW: public ::neuroml2::Input
  {
    public:
    /**
     * @name weight
     *
     * @brief Accessor and modifier functions for the %weight
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ weight_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< weight_type, char > weight_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const weight_type&
    weight () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    weight_type&
    weight ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    weight (const weight_type& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InputW (const id_type&,
            const target_type&,
            const destination_type&,
            const weight_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InputW (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InputW (const InputW& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InputW*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InputW&
    operator= (const InputW& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InputW ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< weight_type > weight_;

    //@endcond
  };

  bool
  operator== (const InputW&, const InputW&);

  bool
  operator!= (const InputW&, const InputW&);


  /**
   * @brief Class corresponding to the %basePyNNCell schema type.
   *
   * Base type of any PyNN standard cell model. Note: membrane potential
   * **v**  has dimensions voltage, but all other parameters are
   * dimensionless. This is to facilitate translation to and from PyNN
   * scripts in Python, where these parameters have implicit units, see
   * http://neuralensemble.org/trac/PyNN/wiki/StandardModels
   * @param cm 
   * @param i_offset 
   * @param tau_syn_E This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param tau_syn_I This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param v_init 
   *
   * @nosubgrouping
   */
  class basePyNNCell: public ::neuroml2::BaseCell
  {
    public:
    /**
     * @name cm
     *
     * @brief Accessor and modifier functions for the %cm
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ cm_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< cm_type, char > cm_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const cm_type&
    cm () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    cm_type&
    cm ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    cm (const cm_type& x);

    //@}

    /**
     * @name i_offset
     *
     * @brief Accessor and modifier functions for the %i_offset
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ i_offset_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< i_offset_type, char > i_offset_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const i_offset_type&
    i_offset () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    i_offset_type&
    i_offset ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    i_offset (const i_offset_type& x);

    //@}

    /**
     * @name tau_syn_E
     *
     * @brief Accessor and modifier functions for the %tau_syn_E
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ tau_syn_E_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< tau_syn_E_type, char > tau_syn_E_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const tau_syn_E_type&
    tau_syn_E () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    tau_syn_E_type&
    tau_syn_E ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    tau_syn_E (const tau_syn_E_type& x);

    //@}

    /**
     * @name tau_syn_I
     *
     * @brief Accessor and modifier functions for the %tau_syn_I
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ tau_syn_I_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< tau_syn_I_type, char > tau_syn_I_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const tau_syn_I_type&
    tau_syn_I () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    tau_syn_I_type&
    tau_syn_I ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    tau_syn_I (const tau_syn_I_type& x);

    //@}

    /**
     * @name v_init
     *
     * @brief Accessor and modifier functions for the %v_init
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ v_init_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< v_init_type, char > v_init_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const v_init_type&
    v_init () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    v_init_type&
    v_init ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    v_init (const v_init_type& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    basePyNNCell (const id_type&,
                  const cm_type&,
                  const i_offset_type&,
                  const tau_syn_E_type&,
                  const tau_syn_I_type&,
                  const v_init_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    basePyNNCell (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    basePyNNCell (const basePyNNCell& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual basePyNNCell*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    basePyNNCell&
    operator= (const basePyNNCell& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~basePyNNCell ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< cm_type > cm_;
    ::xsd::cxx::tree::one< i_offset_type > i_offset_;
    ::xsd::cxx::tree::one< tau_syn_E_type > tau_syn_E_;
    ::xsd::cxx::tree::one< tau_syn_I_type > tau_syn_I_;
    ::xsd::cxx::tree::one< v_init_type > v_init_;

    //@endcond
  };

  bool
  operator== (const basePyNNCell&, const basePyNNCell&);

  bool
  operator!= (const basePyNNCell&, const basePyNNCell&);


  /**
   * @brief Class corresponding to the %basePyNNIaFCell schema type.
   *
   * Base type of any PyNN standard integrate and fire model
   * @param tau_refrac 
   * @param v_thresh 
   * @param tau_m 
   * @param v_rest 
   * @param v_reset 
   * @param cm 
   * @param i_offset 
   * @param tau_syn_E This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param tau_syn_I This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param v_init 
   *
   * @nosubgrouping
   */
  class basePyNNIaFCell: public ::neuroml2::basePyNNCell
  {
    public:
    /**
     * @name tau_m
     *
     * @brief Accessor and modifier functions for the %tau_m
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ tau_m_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< tau_m_type, char > tau_m_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const tau_m_type&
    tau_m () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    tau_m_type&
    tau_m ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    tau_m (const tau_m_type& x);

    //@}

    /**
     * @name tau_refrac
     *
     * @brief Accessor and modifier functions for the %tau_refrac
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ tau_refrac_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< tau_refrac_type, char > tau_refrac_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const tau_refrac_type&
    tau_refrac () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    tau_refrac_type&
    tau_refrac ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    tau_refrac (const tau_refrac_type& x);

    //@}

    /**
     * @name v_reset
     *
     * @brief Accessor and modifier functions for the %v_reset
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ v_reset_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< v_reset_type, char > v_reset_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const v_reset_type&
    v_reset () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    v_reset_type&
    v_reset ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    v_reset (const v_reset_type& x);

    //@}

    /**
     * @name v_rest
     *
     * @brief Accessor and modifier functions for the %v_rest
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ v_rest_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< v_rest_type, char > v_rest_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const v_rest_type&
    v_rest () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    v_rest_type&
    v_rest ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    v_rest (const v_rest_type& x);

    //@}

    /**
     * @name v_thresh
     *
     * @brief Accessor and modifier functions for the %v_thresh
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ v_thresh_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< v_thresh_type, char > v_thresh_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const v_thresh_type&
    v_thresh () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    v_thresh_type&
    v_thresh ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    v_thresh (const v_thresh_type& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    basePyNNIaFCell (const id_type&,
                     const cm_type&,
                     const i_offset_type&,
                     const tau_syn_E_type&,
                     const tau_syn_I_type&,
                     const v_init_type&,
                     const tau_m_type&,
                     const tau_refrac_type&,
                     const v_reset_type&,
                     const v_rest_type&,
                     const v_thresh_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    basePyNNIaFCell (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    basePyNNIaFCell (const basePyNNIaFCell& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual basePyNNIaFCell*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    basePyNNIaFCell&
    operator= (const basePyNNIaFCell& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~basePyNNIaFCell ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< tau_m_type > tau_m_;
    ::xsd::cxx::tree::one< tau_refrac_type > tau_refrac_;
    ::xsd::cxx::tree::one< v_reset_type > v_reset_;
    ::xsd::cxx::tree::one< v_rest_type > v_rest_;
    ::xsd::cxx::tree::one< v_thresh_type > v_thresh_;

    //@endcond
  };

  bool
  operator== (const basePyNNIaFCell&, const basePyNNIaFCell&);

  bool
  operator!= (const basePyNNIaFCell&, const basePyNNIaFCell&);


  /**
   * @brief Class corresponding to the %basePyNNIaFCondCell schema type.
   *
   * Base type of conductance based PyNN IaF cell models
   * @param e_rev_E This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param e_rev_I This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param tau_refrac 
   * @param v_thresh 
   * @param tau_m 
   * @param v_rest 
   * @param v_reset 
   * @param cm 
   * @param i_offset 
   * @param tau_syn_E This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param tau_syn_I This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param v_init 
   *
   * @nosubgrouping
   */
  class basePyNNIaFCondCell: public ::neuroml2::basePyNNIaFCell
  {
    public:
    /**
     * @name e_rev_E
     *
     * @brief Accessor and modifier functions for the %e_rev_E
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ e_rev_E_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< e_rev_E_type, char > e_rev_E_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const e_rev_E_type&
    e_rev_E () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    e_rev_E_type&
    e_rev_E ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    e_rev_E (const e_rev_E_type& x);

    //@}

    /**
     * @name e_rev_I
     *
     * @brief Accessor and modifier functions for the %e_rev_I
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ e_rev_I_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< e_rev_I_type, char > e_rev_I_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const e_rev_I_type&
    e_rev_I () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    e_rev_I_type&
    e_rev_I ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    e_rev_I (const e_rev_I_type& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    basePyNNIaFCondCell (const id_type&,
                         const cm_type&,
                         const i_offset_type&,
                         const tau_syn_E_type&,
                         const tau_syn_I_type&,
                         const v_init_type&,
                         const tau_m_type&,
                         const tau_refrac_type&,
                         const v_reset_type&,
                         const v_rest_type&,
                         const v_thresh_type&,
                         const e_rev_E_type&,
                         const e_rev_I_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    basePyNNIaFCondCell (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    basePyNNIaFCondCell (const basePyNNIaFCondCell& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual basePyNNIaFCondCell*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    basePyNNIaFCondCell&
    operator= (const basePyNNIaFCondCell& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~basePyNNIaFCondCell ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< e_rev_E_type > e_rev_E_;
    ::xsd::cxx::tree::one< e_rev_I_type > e_rev_I_;

    //@endcond
  };

  bool
  operator== (const basePyNNIaFCondCell&, const basePyNNIaFCondCell&);

  bool
  operator!= (const basePyNNIaFCondCell&, const basePyNNIaFCondCell&);


  /**
   * @brief Class corresponding to the %IF_curr_alpha schema type.
   *
   * Leaky integrate and fire model with fixed threshold and
   * alpha-function-shaped post-synaptic current
   * @param tau_refrac 
   * @param v_thresh 
   * @param tau_m 
   * @param v_rest 
   * @param v_reset 
   * @param cm 
   * @param i_offset 
   * @param tau_syn_E This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param tau_syn_I This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param v_init 
   *
   * @nosubgrouping
   */
  class IF_curr_alpha: public ::neuroml2::basePyNNIaFCell
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IF_curr_alpha (const id_type&,
                   const cm_type&,
                   const i_offset_type&,
                   const tau_syn_E_type&,
                   const tau_syn_I_type&,
                   const v_init_type&,
                   const tau_m_type&,
                   const tau_refrac_type&,
                   const v_reset_type&,
                   const v_rest_type&,
                   const v_thresh_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IF_curr_alpha (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IF_curr_alpha (const IF_curr_alpha& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IF_curr_alpha*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IF_curr_alpha ();
  };

  /**
   * @brief Class corresponding to the %IF_curr_exp schema type.
   *
   * Leaky integrate and fire model with fixed threshold and
   * decaying-exponential post-synaptic current
   * @param tau_refrac 
   * @param v_thresh 
   * @param tau_m 
   * @param v_rest 
   * @param v_reset 
   * @param cm 
   * @param i_offset 
   * @param tau_syn_E This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param tau_syn_I This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param v_init 
   *
   * @nosubgrouping
   */
  class IF_curr_exp: public ::neuroml2::basePyNNIaFCell
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IF_curr_exp (const id_type&,
                 const cm_type&,
                 const i_offset_type&,
                 const tau_syn_E_type&,
                 const tau_syn_I_type&,
                 const v_init_type&,
                 const tau_m_type&,
                 const tau_refrac_type&,
                 const v_reset_type&,
                 const v_rest_type&,
                 const v_thresh_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IF_curr_exp (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IF_curr_exp (const IF_curr_exp& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IF_curr_exp*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IF_curr_exp ();
  };

  /**
   * @brief Class corresponding to the %IF_cond_alpha schema type.
   *
   * Leaky integrate and fire model with fixed threshold and
   * alpha-function-shaped post-synaptic conductance
   * @param e_rev_E This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param e_rev_I This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param tau_refrac 
   * @param v_thresh 
   * @param tau_m 
   * @param v_rest 
   * @param v_reset 
   * @param cm 
   * @param i_offset 
   * @param tau_syn_E This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param tau_syn_I This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param v_init 
   *
   * @nosubgrouping
   */
  class IF_cond_alpha: public ::neuroml2::basePyNNIaFCondCell
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IF_cond_alpha (const id_type&,
                   const cm_type&,
                   const i_offset_type&,
                   const tau_syn_E_type&,
                   const tau_syn_I_type&,
                   const v_init_type&,
                   const tau_m_type&,
                   const tau_refrac_type&,
                   const v_reset_type&,
                   const v_rest_type&,
                   const v_thresh_type&,
                   const e_rev_E_type&,
                   const e_rev_I_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IF_cond_alpha (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IF_cond_alpha (const IF_cond_alpha& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IF_cond_alpha*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IF_cond_alpha ();
  };

  /**
   * @brief Class corresponding to the %IF_cond_exp schema type.
   *
   * Leaky integrate and fire model with fixed threshold and
   * exponentially-decaying post-synaptic conductance
   * @param e_rev_E This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param e_rev_I This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param tau_refrac 
   * @param v_thresh 
   * @param tau_m 
   * @param v_rest 
   * @param v_reset 
   * @param cm 
   * @param i_offset 
   * @param tau_syn_E This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param tau_syn_I This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param v_init 
   *
   * @nosubgrouping
   */
  class IF_cond_exp: public ::neuroml2::basePyNNIaFCondCell
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IF_cond_exp (const id_type&,
                 const cm_type&,
                 const i_offset_type&,
                 const tau_syn_E_type&,
                 const tau_syn_I_type&,
                 const v_init_type&,
                 const tau_m_type&,
                 const tau_refrac_type&,
                 const v_reset_type&,
                 const v_rest_type&,
                 const v_thresh_type&,
                 const e_rev_E_type&,
                 const e_rev_I_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IF_cond_exp (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IF_cond_exp (const IF_cond_exp& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IF_cond_exp*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IF_cond_exp ();
  };

  /**
   * @brief Class corresponding to the %EIF_cond_exp_isfa_ista schema type.
   *
   * Adaptive exponential integrate and fire neuron according to Brette R
   * and Gerstner W ( 2005 ) with exponentially-decaying post-synaptic
   * conductance
   * @param v_spike 
   * @param delta_T 
   * @param tau_w 
   * @param a 
   * @param b 
   * @param e_rev_E This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param e_rev_I This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param tau_refrac 
   * @param v_thresh 
   * @param tau_m 
   * @param v_rest 
   * @param v_reset 
   * @param cm 
   * @param i_offset 
   * @param tau_syn_E This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param tau_syn_I This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param v_init 
   *
   * @nosubgrouping
   */
  class EIF_cond_exp_isfa_ista: public ::neuroml2::basePyNNIaFCondCell
  {
    public:
    /**
     * @name a
     *
     * @brief Accessor and modifier functions for the %a
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ a_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< a_type, char > a_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const a_type&
    a () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    a_type&
    a ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    a (const a_type& x);

    //@}

    /**
     * @name b
     *
     * @brief Accessor and modifier functions for the %b
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ b_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< b_type, char > b_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const b_type&
    b () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    b_type&
    b ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    b (const b_type& x);

    //@}

    /**
     * @name delta_T
     *
     * @brief Accessor and modifier functions for the %delta_T
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ delta_T_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< delta_T_type, char > delta_T_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const delta_T_type&
    delta_T () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    delta_T_type&
    delta_T ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    delta_T (const delta_T_type& x);

    //@}

    /**
     * @name tau_w
     *
     * @brief Accessor and modifier functions for the %tau_w
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ tau_w_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< tau_w_type, char > tau_w_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const tau_w_type&
    tau_w () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    tau_w_type&
    tau_w ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    tau_w (const tau_w_type& x);

    //@}

    /**
     * @name v_spike
     *
     * @brief Accessor and modifier functions for the %v_spike
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ v_spike_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< v_spike_type, char > v_spike_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const v_spike_type&
    v_spike () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    v_spike_type&
    v_spike ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    v_spike (const v_spike_type& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    EIF_cond_exp_isfa_ista (const id_type&,
                            const cm_type&,
                            const i_offset_type&,
                            const tau_syn_E_type&,
                            const tau_syn_I_type&,
                            const v_init_type&,
                            const tau_m_type&,
                            const tau_refrac_type&,
                            const v_reset_type&,
                            const v_rest_type&,
                            const v_thresh_type&,
                            const e_rev_E_type&,
                            const e_rev_I_type&,
                            const a_type&,
                            const b_type&,
                            const delta_T_type&,
                            const tau_w_type&,
                            const v_spike_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    EIF_cond_exp_isfa_ista (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    EIF_cond_exp_isfa_ista (const EIF_cond_exp_isfa_ista& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual EIF_cond_exp_isfa_ista*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    EIF_cond_exp_isfa_ista&
    operator= (const EIF_cond_exp_isfa_ista& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~EIF_cond_exp_isfa_ista ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< a_type > a_;
    ::xsd::cxx::tree::one< b_type > b_;
    ::xsd::cxx::tree::one< delta_T_type > delta_T_;
    ::xsd::cxx::tree::one< tau_w_type > tau_w_;
    ::xsd::cxx::tree::one< v_spike_type > v_spike_;

    //@endcond
  };

  bool
  operator== (const EIF_cond_exp_isfa_ista&, const EIF_cond_exp_isfa_ista&);

  bool
  operator!= (const EIF_cond_exp_isfa_ista&, const EIF_cond_exp_isfa_ista&);


  /**
   * @brief Class corresponding to the %EIF_cond_alpha_isfa_ista schema type.
   *
   * Adaptive exponential integrate and fire neuron according to Brette R
   * and Gerstner W ( 2005 ) with alpha-function-shaped post-synaptic
   * conductance
   * @param v_spike 
   * @param delta_T 
   * @param tau_w 
   * @param a 
   * @param b 
   * @param e_rev_E This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param e_rev_I This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param tau_refrac 
   * @param v_thresh 
   * @param tau_m 
   * @param v_rest 
   * @param v_reset 
   * @param cm 
   * @param i_offset 
   * @param tau_syn_E This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param tau_syn_I This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param v_init 
   *
   * @nosubgrouping
   */
  class EIF_cond_alpha_isfa_ista: public ::neuroml2::EIF_cond_exp_isfa_ista
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    EIF_cond_alpha_isfa_ista (const id_type&,
                              const cm_type&,
                              const i_offset_type&,
                              const tau_syn_E_type&,
                              const tau_syn_I_type&,
                              const v_init_type&,
                              const tau_m_type&,
                              const tau_refrac_type&,
                              const v_reset_type&,
                              const v_rest_type&,
                              const v_thresh_type&,
                              const e_rev_E_type&,
                              const e_rev_I_type&,
                              const a_type&,
                              const b_type&,
                              const delta_T_type&,
                              const tau_w_type&,
                              const v_spike_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    EIF_cond_alpha_isfa_ista (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    EIF_cond_alpha_isfa_ista (const EIF_cond_alpha_isfa_ista& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual EIF_cond_alpha_isfa_ista*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~EIF_cond_alpha_isfa_ista ();
  };

  /**
   * @brief Class corresponding to the %HH_cond_exp schema type.
   *
   * Single-compartment Hodgkin-Huxley-type neuron with transient sodium
   * and delayed-rectifier potassium currents using the ion channel models
   * from Traub.
   * @param gbar_K 
   * @param gbar_Na 
   * @param g_leak 
   * @param e_rev_K 
   * @param e_rev_Na 
   * @param e_rev_leak 
   * @param v_offset 
   * @param e_rev_E 
   * @param e_rev_I 
   * @param cm 
   * @param i_offset 
   * @param tau_syn_E This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param tau_syn_I This parameter is never used in the NeuroML2
   * description of this cell! Any synapse producing a current can be
   * placed on this cell
   * @param v_init 
   *
   * @nosubgrouping
   */
  class HH_cond_exp: public ::neuroml2::basePyNNCell
  {
    public:
    /**
     * @name v_offset
     *
     * @brief Accessor and modifier functions for the %v_offset
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ v_offset_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< v_offset_type, char > v_offset_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const v_offset_type&
    v_offset () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    v_offset_type&
    v_offset ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    v_offset (const v_offset_type& x);

    //@}

    /**
     * @name e_rev_E
     *
     * @brief Accessor and modifier functions for the %e_rev_E
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ e_rev_E_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< e_rev_E_type, char > e_rev_E_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const e_rev_E_type&
    e_rev_E () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    e_rev_E_type&
    e_rev_E ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    e_rev_E (const e_rev_E_type& x);

    //@}

    /**
     * @name e_rev_I
     *
     * @brief Accessor and modifier functions for the %e_rev_I
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ e_rev_I_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< e_rev_I_type, char > e_rev_I_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const e_rev_I_type&
    e_rev_I () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    e_rev_I_type&
    e_rev_I ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    e_rev_I (const e_rev_I_type& x);

    //@}

    /**
     * @name e_rev_K
     *
     * @brief Accessor and modifier functions for the %e_rev_K
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ e_rev_K_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< e_rev_K_type, char > e_rev_K_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const e_rev_K_type&
    e_rev_K () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    e_rev_K_type&
    e_rev_K ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    e_rev_K (const e_rev_K_type& x);

    //@}

    /**
     * @name e_rev_Na
     *
     * @brief Accessor and modifier functions for the %e_rev_Na
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ e_rev_Na_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< e_rev_Na_type, char > e_rev_Na_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const e_rev_Na_type&
    e_rev_Na () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    e_rev_Na_type&
    e_rev_Na ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    e_rev_Na (const e_rev_Na_type& x);

    //@}

    /**
     * @name e_rev_leak
     *
     * @brief Accessor and modifier functions for the %e_rev_leak
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ e_rev_leak_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< e_rev_leak_type, char > e_rev_leak_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const e_rev_leak_type&
    e_rev_leak () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    e_rev_leak_type&
    e_rev_leak ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    e_rev_leak (const e_rev_leak_type& x);

    //@}

    /**
     * @name g_leak
     *
     * @brief Accessor and modifier functions for the %g_leak
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ g_leak_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< g_leak_type, char > g_leak_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const g_leak_type&
    g_leak () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    g_leak_type&
    g_leak ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    g_leak (const g_leak_type& x);

    //@}

    /**
     * @name gbar_K
     *
     * @brief Accessor and modifier functions for the %gbar_K
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ gbar_K_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< gbar_K_type, char > gbar_K_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const gbar_K_type&
    gbar_K () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    gbar_K_type&
    gbar_K ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    gbar_K (const gbar_K_type& x);

    //@}

    /**
     * @name gbar_Na
     *
     * @brief Accessor and modifier functions for the %gbar_Na
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ gbar_Na_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< gbar_Na_type, char > gbar_Na_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const gbar_Na_type&
    gbar_Na () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    gbar_Na_type&
    gbar_Na ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    gbar_Na (const gbar_Na_type& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HH_cond_exp (const id_type&,
                 const cm_type&,
                 const i_offset_type&,
                 const tau_syn_E_type&,
                 const tau_syn_I_type&,
                 const v_init_type&,
                 const v_offset_type&,
                 const e_rev_E_type&,
                 const e_rev_I_type&,
                 const e_rev_K_type&,
                 const e_rev_Na_type&,
                 const e_rev_leak_type&,
                 const g_leak_type&,
                 const gbar_K_type&,
                 const gbar_Na_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HH_cond_exp (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HH_cond_exp (const HH_cond_exp& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HH_cond_exp*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HH_cond_exp&
    operator= (const HH_cond_exp& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HH_cond_exp ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< v_offset_type > v_offset_;
    ::xsd::cxx::tree::one< e_rev_E_type > e_rev_E_;
    ::xsd::cxx::tree::one< e_rev_I_type > e_rev_I_;
    ::xsd::cxx::tree::one< e_rev_K_type > e_rev_K_;
    ::xsd::cxx::tree::one< e_rev_Na_type > e_rev_Na_;
    ::xsd::cxx::tree::one< e_rev_leak_type > e_rev_leak_;
    ::xsd::cxx::tree::one< g_leak_type > g_leak_;
    ::xsd::cxx::tree::one< gbar_K_type > gbar_K_;
    ::xsd::cxx::tree::one< gbar_Na_type > gbar_Na_;

    //@endcond
  };

  bool
  operator== (const HH_cond_exp&, const HH_cond_exp&);

  bool
  operator!= (const HH_cond_exp&, const HH_cond_exp&);


  /**
   * @brief Class corresponding to the %BasePynnSynapse schema type.
   *
   * Base type for all PyNN synapses. Note, the current **I**  produced is
   * dimensionless, but it requires a membrane potential **v**  with
   * dimension voltage
   * @param tau_syn 
   *
   * @nosubgrouping
   */
  class BasePynnSynapse: public ::neuroml2::BaseSynapse
  {
    public:
    /**
     * @name tau_syn
     *
     * @brief Accessor and modifier functions for the %tau_syn
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ tau_syn_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< tau_syn_type, char > tau_syn_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const tau_syn_type&
    tau_syn () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    tau_syn_type&
    tau_syn ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    tau_syn (const tau_syn_type& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BasePynnSynapse (const id_type&,
                     const tau_syn_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BasePynnSynapse (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BasePynnSynapse (const BasePynnSynapse& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BasePynnSynapse*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BasePynnSynapse&
    operator= (const BasePynnSynapse& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BasePynnSynapse ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< tau_syn_type > tau_syn_;

    //@endcond
  };

  bool
  operator== (const BasePynnSynapse&, const BasePynnSynapse&);

  bool
  operator!= (const BasePynnSynapse&, const BasePynnSynapse&);


  /**
   * @brief Class corresponding to the %ExpCondSynapse schema type.
   *
   * Conductance based synapse with instantaneous rise and single
   * exponential decay ( with time constant tau_syn )
   * @param e_rev 
   * @param tau_syn 
   *
   * @nosubgrouping
   */
  class ExpCondSynapse: public ::neuroml2::BasePynnSynapse
  {
    public:
    /**
     * @name e_rev
     *
     * @brief Accessor and modifier functions for the %e_rev
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ e_rev_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< e_rev_type, char > e_rev_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const e_rev_type&
    e_rev () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    e_rev_type&
    e_rev ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    e_rev (const e_rev_type& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ExpCondSynapse (const id_type&,
                    const tau_syn_type&,
                    const e_rev_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ExpCondSynapse (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ExpCondSynapse (const ExpCondSynapse& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ExpCondSynapse*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ExpCondSynapse&
    operator= (const ExpCondSynapse& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ExpCondSynapse ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< e_rev_type > e_rev_;

    //@endcond
  };

  bool
  operator== (const ExpCondSynapse&, const ExpCondSynapse&);

  bool
  operator!= (const ExpCondSynapse&, const ExpCondSynapse&);


  /**
   * @brief Class corresponding to the %AlphaCondSynapse schema type.
   *
   * Alpha synapse: rise time and decay time are both tau_syn. Conductance
   * based synapse.
   * @param e_rev 
   * @param tau_syn 
   *
   * @nosubgrouping
   */
  class AlphaCondSynapse: public ::neuroml2::BasePynnSynapse
  {
    public:
    /**
     * @name e_rev
     *
     * @brief Accessor and modifier functions for the %e_rev
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::float_ e_rev_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< e_rev_type, char > e_rev_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const e_rev_type&
    e_rev () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    e_rev_type&
    e_rev ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    e_rev (const e_rev_type& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AlphaCondSynapse (const id_type&,
                      const tau_syn_type&,
                      const e_rev_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlphaCondSynapse (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlphaCondSynapse (const AlphaCondSynapse& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AlphaCondSynapse*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlphaCondSynapse&
    operator= (const AlphaCondSynapse& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AlphaCondSynapse ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< e_rev_type > e_rev_;

    //@endcond
  };

  bool
  operator== (const AlphaCondSynapse&, const AlphaCondSynapse&);

  bool
  operator!= (const AlphaCondSynapse&, const AlphaCondSynapse&);


  /**
   * @brief Class corresponding to the %ExpCurrSynapse schema type.
   *
   * Current based synapse with instantaneous rise and single exponential
   * decay ( with time constant tau_syn )
   * @param tau_syn 
   *
   * @nosubgrouping
   */
  class ExpCurrSynapse: public ::neuroml2::BasePynnSynapse
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ExpCurrSynapse (const id_type&,
                    const tau_syn_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ExpCurrSynapse (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ExpCurrSynapse (const ExpCurrSynapse& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ExpCurrSynapse*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ExpCurrSynapse ();
  };

  /**
   * @brief Class corresponding to the %AlphaCurrSynapse schema type.
   *
   * Alpha synapse: rise time and decay time are both tau_syn. Current
   * based synapse.
   * @param tau_syn 
   *
   * @nosubgrouping
   */
  class AlphaCurrSynapse: public ::neuroml2::BasePynnSynapse
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AlphaCurrSynapse (const id_type&,
                      const tau_syn_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlphaCurrSynapse (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlphaCurrSynapse (const AlphaCurrSynapse& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AlphaCurrSynapse*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AlphaCurrSynapse ();
  };

  /**
   * @brief Class corresponding to the %SpikeSourcePoisson schema type.
   *
   * Spike source, generating spikes according to a Poisson process.
   * @param start 
   * @param duration 
   * @param rate 
   *
   * @nosubgrouping
   */
  class SpikeSourcePoisson: public ::neuroml2::Standalone
  {
    public:
    /**
     * @name start
     *
     * @brief Accessor and modifier functions for the %start
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time start_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< start_type, char > start_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const start_type&
    start () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    start_type&
    start ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    start (const start_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    start (::std::unique_ptr< start_type > p);

    //@}

    /**
     * @name duration
     *
     * @brief Accessor and modifier functions for the %duration
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_time duration_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< duration_type, char > duration_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const duration_type&
    duration () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    duration_type&
    duration ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    duration (const duration_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    duration (::std::unique_ptr< duration_type > p);

    //@}

    /**
     * @name rate
     *
     * @brief Accessor and modifier functions for the %rate
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::neuroml2::Nml2Quantity_pertime rate_type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< rate_type, char > rate_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const rate_type&
    rate () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    rate_type&
    rate ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    rate (const rate_type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    rate (::std::unique_ptr< rate_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SpikeSourcePoisson (const id_type&,
                        const start_type&,
                        const duration_type&,
                        const rate_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SpikeSourcePoisson (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SpikeSourcePoisson (const SpikeSourcePoisson& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SpikeSourcePoisson*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SpikeSourcePoisson&
    operator= (const SpikeSourcePoisson& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SpikeSourcePoisson ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< start_type > start_;
    ::xsd::cxx::tree::one< duration_type > duration_;
    ::xsd::cxx::tree::one< rate_type > rate_;

    //@endcond
  };

  bool
  operator== (const SpikeSourcePoisson&, const SpikeSourcePoisson&);

  bool
  operator!= (const SpikeSourcePoisson&, const SpikeSourcePoisson&);
}

#include <iosfwd>

namespace neuroml2
{
  ::std::ostream&
  operator<< (::std::ostream&, const NmlId&);

  ::std::ostream&
  operator<< (::std::ostream&, const Nml2Quantity&);

  ::std::ostream&
  operator<< (::std::ostream&, const Nml2Quantity_none&);

  ::std::ostream&
  operator<< (::std::ostream&, const Nml2Quantity_voltage&);

  ::std::ostream&
  operator<< (::std::ostream&, const Nml2Quantity_length&);

  ::std::ostream&
  operator<< (::std::ostream&, const Nml2Quantity_resistance&);

  ::std::ostream&
  operator<< (::std::ostream&, const Nml2Quantity_resistivity&);

  ::std::ostream&
  operator<< (::std::ostream&, const Nml2Quantity_conductance&);

  ::std::ostream&
  operator<< (::std::ostream&, const Nml2Quantity_conductanceDensity&);

  ::std::ostream&
  operator<< (::std::ostream&, const Nml2Quantity_permeability&);

  ::std::ostream&
  operator<< (::std::ostream&, const Nml2Quantity_time&);

  ::std::ostream&
  operator<< (::std::ostream&, const Nml2Quantity_pertime&);

  ::std::ostream&
  operator<< (::std::ostream&, const Nml2Quantity_capacitance&);

  ::std::ostream&
  operator<< (::std::ostream&, const Nml2Quantity_specificCapacitance&);

  ::std::ostream&
  operator<< (::std::ostream&, const Nml2Quantity_concentration&);

  ::std::ostream&
  operator<< (::std::ostream&, const Nml2Quantity_current&);

  ::std::ostream&
  operator<< (::std::ostream&, const Nml2Quantity_currentDensity&);

  ::std::ostream&
  operator<< (::std::ostream&, const Nml2Quantity_temperature&);

  ::std::ostream&
  operator<< (::std::ostream&, const Nml2Quantity_rhoFactor&);

  ::std::ostream&
  operator<< (::std::ostream&, const Nml2Quantity_conductancePerVoltage&);

  ::std::ostream&
  operator<< (::std::ostream&, const MetaId&);

  ::std::ostream&
  operator<< (::std::ostream&, const NeuroLexId&);

  ::std::ostream&
  operator<< (::std::ostream&, const NonNegativeInteger&);

  ::std::ostream&
  operator<< (::std::ostream&, const PositiveInteger&);

  ::std::ostream&
  operator<< (::std::ostream&, const DoubleGreaterThanZero&);

  ::std::ostream&
  operator<< (::std::ostream&, const ZeroOrOne&);

  ::std::ostream&
  operator<< (::std::ostream&, const Notes&);

  ::std::ostream&
  operator<< (::std::ostream&, const Property&);

  ::std::ostream&
  operator<< (::std::ostream&, const Annotation&);

  ::std::ostream&
  operator<< (::std::ostream&, const ComponentType&);

  ::std::ostream&
  operator<< (::std::ostream&, const Constant&);

  ::std::ostream&
  operator<< (::std::ostream&, const Exposure&);

  ::std::ostream&
  operator<< (::std::ostream&, const NamedDimensionalType&);

  ::std::ostream&
  operator<< (::std::ostream&, const NamedDimensionalVariable&);

  ::std::ostream&
  operator<< (::std::ostream&, const Parameter&);

  ::std::ostream&
  operator<< (::std::ostream&, const LEMS_Property&);

  ::std::ostream&
  operator<< (::std::ostream&, const Requirement&);

  ::std::ostream&
  operator<< (::std::ostream&, const InstanceRequirement&);

  ::std::ostream&
  operator<< (::std::ostream&, const Dynamics&);

  ::std::ostream&
  operator<< (::std::ostream&, const DerivedVariable&);

  ::std::ostream&
  operator<< (::std::ostream&, const StateVariable&);

  ::std::ostream&
  operator<< (::std::ostream&, const ConditionalDerivedVariable&);

  ::std::ostream&
  operator<< (::std::ostream&, const Case&);

  ::std::ostream&
  operator<< (::std::ostream&, const TimeDerivative&);

  ::std::ostream&
  operator<< (::std::ostream&, const ZeroToOne&);

  ::std::ostream&
  operator<< (::std::ostream&, const BaseWithoutId&);

  ::std::ostream&
  operator<< (::std::ostream&, const Base&);

  ::std::ostream&
  operator<< (::std::ostream&, const Standalone&);

  ::std::ostream&
  operator<< (::std::ostream&, const NeuroMLDocument_base&);

  ::std::ostream&
  operator<< (::std::ostream&, const IncludeType&);

  ::std::ostream&
  operator<< (::std::ostream&, const IonChannelScalable&);

  ::std::ostream&
  operator<< (::std::ostream&, const IonChannelKS&);

  ::std::ostream&
  operator<< (::std::ostream&, const IonChannel&);

  ::std::ostream&
  operator<< (::std::ostream&, const IonChannelHH&);

  ::std::ostream&
  operator<< (::std::ostream&, const IonChannelVShift&);

  ::std::ostream&
  operator<< (::std::ostream&, channelTypes::value);

  ::std::ostream&
  operator<< (::std::ostream&, const channelTypes&);

  ::std::ostream&
  operator<< (::std::ostream&, const Q10ConductanceScaling&);

  ::std::ostream&
  operator<< (::std::ostream&, gateTypes::value);

  ::std::ostream&
  operator<< (::std::ostream&, const gateTypes&);

  ::std::ostream&
  operator<< (::std::ostream&, const ClosedState&);

  ::std::ostream&
  operator<< (::std::ostream&, const OpenState&);

  ::std::ostream&
  operator<< (::std::ostream&, const ForwardTransition&);

  ::std::ostream&
  operator<< (::std::ostream&, const ReverseTransition&);

  ::std::ostream&
  operator<< (::std::ostream&, const TauInfTransition&);

  ::std::ostream&
  operator<< (::std::ostream&, const GateKS&);

  ::std::ostream&
  operator<< (::std::ostream&, const GateHHUndetermined&);

  ::std::ostream&
  operator<< (::std::ostream&, const GateHHRates&);

  ::std::ostream&
  operator<< (::std::ostream&, const GateHHTauInf&);

  ::std::ostream&
  operator<< (::std::ostream&, const GateHHRatesTauInf&);

  ::std::ostream&
  operator<< (::std::ostream&, const GateHHRatesTau&);

  ::std::ostream&
  operator<< (::std::ostream&, const GateHHRatesInf&);

  ::std::ostream&
  operator<< (::std::ostream&, const GateHHInstantaneous&);

  ::std::ostream&
  operator<< (::std::ostream&, const GateFractional&);

  ::std::ostream&
  operator<< (::std::ostream&, const GateFractionalSubgate&);

  ::std::ostream&
  operator<< (::std::ostream&, const Q10Settings&);

  ::std::ostream&
  operator<< (::std::ostream&, const HHRate&);

  ::std::ostream&
  operator<< (::std::ostream&, const HHVariable&);

  ::std::ostream&
  operator<< (::std::ostream&, const HHTime&);

  ::std::ostream&
  operator<< (::std::ostream&, const DecayingPoolConcentrationModel&);

  ::std::ostream&
  operator<< (::std::ostream&, const FixedFactorConcentrationModel&);

  ::std::ostream&
  operator<< (::std::ostream&, const BaseSynapse&);

  ::std::ostream&
  operator<< (::std::ostream&, const BaseVoltageDepSynapse&);

  ::std::ostream&
  operator<< (::std::ostream&, const BaseCurrentBasedSynapse&);

  ::std::ostream&
  operator<< (::std::ostream&, const BaseConductanceBasedSynapse&);

  ::std::ostream&
  operator<< (::std::ostream&, const BaseConductanceBasedSynapseTwo&);

  ::std::ostream&
  operator<< (::std::ostream&, const GapJunction&);

  ::std::ostream&
  operator<< (::std::ostream&, const SilentSynapse&);

  ::std::ostream&
  operator<< (::std::ostream&, const LinearGradedSynapse&);

  ::std::ostream&
  operator<< (::std::ostream&, const GradedSynapse&);

  ::std::ostream&
  operator<< (::std::ostream&, const AlphaCurrentSynapse&);

  ::std::ostream&
  operator<< (::std::ostream&, const AlphaSynapse&);

  ::std::ostream&
  operator<< (::std::ostream&, const ExpOneSynapse&);

  ::std::ostream&
  operator<< (::std::ostream&, const ExpTwoSynapse&);

  ::std::ostream&
  operator<< (::std::ostream&, const ExpThreeSynapse&);

  ::std::ostream&
  operator<< (::std::ostream&, const DoubleSynapse&);

  ::std::ostream&
  operator<< (::std::ostream&, const BlockingPlasticSynapse&);

  ::std::ostream&
  operator<< (::std::ostream&, BlockTypes::value);

  ::std::ostream&
  operator<< (::std::ostream&, const BlockTypes&);

  ::std::ostream&
  operator<< (::std::ostream&, const BlockMechanism&);

  ::std::ostream&
  operator<< (::std::ostream&, PlasticityTypes::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PlasticityTypes&);

  ::std::ostream&
  operator<< (::std::ostream&, const PlasticityMechanism&);

  ::std::ostream&
  operator<< (::std::ostream&, const BaseCell&);

  ::std::ostream&
  operator<< (::std::ostream&, const IafTauCell&);

  ::std::ostream&
  operator<< (::std::ostream&, const IafTauRefCell&);

  ::std::ostream&
  operator<< (::std::ostream&, const IafCell&);

  ::std::ostream&
  operator<< (::std::ostream&, const IafRefCell&);

  ::std::ostream&
  operator<< (::std::ostream&, const IzhikevichCell&);

  ::std::ostream&
  operator<< (::std::ostream&, const BaseCellMembPotCap&);

  ::std::ostream&
  operator<< (::std::ostream&, const Izhikevich2007Cell&);

  ::std::ostream&
  operator<< (::std::ostream&, const AdExIaFCell&);

  ::std::ostream&
  operator<< (::std::ostream&, const FitzHughNagumoCell&);

  ::std::ostream&
  operator<< (::std::ostream&, const FitzHughNagumo1969Cell&);

  ::std::ostream&
  operator<< (::std::ostream&, const PinskyRinzelCA3Cell&);

  ::std::ostream&
  operator<< (::std::ostream&, const Cell&);

  ::std::ostream&
  operator<< (::std::ostream&, const Cell2CaPools&);

  ::std::ostream&
  operator<< (::std::ostream&, const Morphology_base&);

  ::std::ostream&
  operator<< (::std::ostream&, const BaseNonNegativeIntegerId&);

  ::std::ostream&
  operator<< (::std::ostream&, const Segment_base&);

  ::std::ostream&
  operator<< (::std::ostream&, const SegmentParent&);

  ::std::ostream&
  operator<< (::std::ostream&, const Point3DWithDiam&);

  ::std::ostream&
  operator<< (::std::ostream&, const SegmentGroup&);

  ::std::ostream&
  operator<< (::std::ostream&, const InhomogeneousParameter&);

  ::std::ostream&
  operator<< (::std::ostream&, Metric::value);

  ::std::ostream&
  operator<< (::std::ostream&, const Metric&);

  ::std::ostream&
  operator<< (::std::ostream&, const ProximalDetails&);

  ::std::ostream&
  operator<< (::std::ostream&, const DistalDetails&);

  ::std::ostream&
  operator<< (::std::ostream&, const Member&);

  ::std::ostream&
  operator<< (::std::ostream&, const Include&);

  ::std::ostream&
  operator<< (::std::ostream&, const Path&);

  ::std::ostream&
  operator<< (::std::ostream&, const SubTree&);

  ::std::ostream&
  operator<< (::std::ostream&, const SegmentEndPoint&);

  ::std::ostream&
  operator<< (::std::ostream&, const BiophysicalProperties&);

  ::std::ostream&
  operator<< (::std::ostream&, const BiophysicalProperties2CaPools&);

  ::std::ostream&
  operator<< (::std::ostream&, const MembraneProperties&);

  ::std::ostream&
  operator<< (::std::ostream&, const MembraneProperties2CaPools&);

  ::std::ostream&
  operator<< (::std::ostream&, const SpikeThresh&);

  ::std::ostream&
  operator<< (::std::ostream&, const SpecificCapacitance&);

  ::std::ostream&
  operator<< (::std::ostream&, const InitMembPotential&);

  ::std::ostream&
  operator<< (::std::ostream&, const Resistivity&);

  ::std::ostream&
  operator<< (::std::ostream&, const ChannelPopulation&);

  ::std::ostream&
  operator<< (::std::ostream&, const ChannelDensityNonUniform&);

  ::std::ostream&
  operator<< (::std::ostream&, const ChannelDensityNonUniformNernst&);

  ::std::ostream&
  operator<< (::std::ostream&, const ChannelDensityNonUniformGHK&);

  ::std::ostream&
  operator<< (::std::ostream&, const ChannelDensity&);

  ::std::ostream&
  operator<< (::std::ostream&, const ChannelDensityVShift&);

  ::std::ostream&
  operator<< (::std::ostream&, const ChannelDensityNernst&);

  ::std::ostream&
  operator<< (::std::ostream&, const ChannelDensityNernstCa2&);

  ::std::ostream&
  operator<< (::std::ostream&, const ChannelDensityGHK&);

  ::std::ostream&
  operator<< (::std::ostream&, const ChannelDensityGHK2&);

  ::std::ostream&
  operator<< (::std::ostream&, const VariableParameter&);

  ::std::ostream&
  operator<< (::std::ostream&, const InhomogeneousValue&);

  ::std::ostream&
  operator<< (::std::ostream&, const Species&);

  ::std::ostream&
  operator<< (::std::ostream&, const ConcentrationModel_D&);

  ::std::ostream&
  operator<< (::std::ostream&, const IntracellularProperties&);

  ::std::ostream&
  operator<< (::std::ostream&, const IntracellularProperties2CaPools&);

  ::std::ostream&
  operator<< (::std::ostream&, const ExtracellularProperties&);

  ::std::ostream&
  operator<< (::std::ostream&, const ExtracellularPropertiesLocal&);

  ::std::ostream&
  operator<< (::std::ostream&, const ReactionScheme&);

  ::std::ostream&
  operator<< (::std::ostream&, const PulseGenerator&);

  ::std::ostream&
  operator<< (::std::ostream&, const PulseGeneratorDL&);

  ::std::ostream&
  operator<< (::std::ostream&, const SineGenerator&);

  ::std::ostream&
  operator<< (::std::ostream&, const SineGeneratorDL&);

  ::std::ostream&
  operator<< (::std::ostream&, const RampGenerator&);

  ::std::ostream&
  operator<< (::std::ostream&, const RampGeneratorDL&);

  ::std::ostream&
  operator<< (::std::ostream&, const CompoundInput&);

  ::std::ostream&
  operator<< (::std::ostream&, const CompoundInputDL&);

  ::std::ostream&
  operator<< (::std::ostream&, const VoltageClamp&);

  ::std::ostream&
  operator<< (::std::ostream&, const VoltageClampTriple&);

  ::std::ostream&
  operator<< (::std::ostream&, const Spike&);

  ::std::ostream&
  operator<< (::std::ostream&, const SpikeArray&);

  ::std::ostream&
  operator<< (::std::ostream&, const TimedSynapticInput&);

  ::std::ostream&
  operator<< (::std::ostream&, const SpikeGenerator&);

  ::std::ostream&
  operator<< (::std::ostream&, const SpikeGeneratorRandom&);

  ::std::ostream&
  operator<< (::std::ostream&, const SpikeGeneratorPoisson&);

  ::std::ostream&
  operator<< (::std::ostream&, const SpikeGeneratorRefPoisson&);

  ::std::ostream&
  operator<< (::std::ostream&, const PoissonFiringSynapse&);

  ::std::ostream&
  operator<< (::std::ostream&, const TransientPoissonFiringSynapse&);

  ::std::ostream&
  operator<< (::std::ostream&, const Network&);

  ::std::ostream&
  operator<< (::std::ostream&, networkTypes::value);

  ::std::ostream&
  operator<< (::std::ostream&, const networkTypes&);

  ::std::ostream&
  operator<< (::std::ostream&, const Space&);

  ::std::ostream&
  operator<< (::std::ostream&, const SpaceStructure&);

  ::std::ostream&
  operator<< (::std::ostream&, allowedSpaces::value);

  ::std::ostream&
  operator<< (::std::ostream&, const allowedSpaces&);

  ::std::ostream&
  operator<< (::std::ostream&, const Region&);

  ::std::ostream&
  operator<< (::std::ostream&, const Population&);

  ::std::ostream&
  operator<< (::std::ostream&, populationTypes::value);

  ::std::ostream&
  operator<< (::std::ostream&, const populationTypes&);

  ::std::ostream&
  operator<< (::std::ostream&, const Layout&);

  ::std::ostream&
  operator<< (::std::ostream&, const UnstructuredLayout&);

  ::std::ostream&
  operator<< (::std::ostream&, const RandomLayout&);

  ::std::ostream&
  operator<< (::std::ostream&, const GridLayout&);

  ::std::ostream&
  operator<< (::std::ostream&, const Instance&);

  ::std::ostream&
  operator<< (::std::ostream&, const Location&);

  ::std::ostream&
  operator<< (::std::ostream&, const CellSet&);

  ::std::ostream&
  operator<< (::std::ostream&, const SynapticConnection&);

  ::std::ostream&
  operator<< (::std::ostream&, const BaseProjection&);

  ::std::ostream&
  operator<< (::std::ostream&, const Projection&);

  ::std::ostream&
  operator<< (::std::ostream&, const BaseConnection&);

  ::std::ostream&
  operator<< (::std::ostream&, const BaseConnectionOldFormat&);

  ::std::ostream&
  operator<< (::std::ostream&, const BaseConnectionNewFormat&);

  ::std::ostream&
  operator<< (::std::ostream&, const Connection_base&);

  ::std::ostream&
  operator<< (::std::ostream&, const ConnectionWD&);

  ::std::ostream&
  operator<< (::std::ostream&, const ElectricalProjection&);

  ::std::ostream&
  operator<< (::std::ostream&, const ElectricalConnection&);

  ::std::ostream&
  operator<< (::std::ostream&, const ElectricalConnectionInstance&);

  ::std::ostream&
  operator<< (::std::ostream&, const ElectricalConnectionInstanceW&);

  ::std::ostream&
  operator<< (::std::ostream&, const ContinuousProjection&);

  ::std::ostream&
  operator<< (::std::ostream&, const ContinuousConnection&);

  ::std::ostream&
  operator<< (::std::ostream&, const ContinuousConnectionInstance&);

  ::std::ostream&
  operator<< (::std::ostream&, const ContinuousConnectionInstanceW&);

  ::std::ostream&
  operator<< (::std::ostream&, const ExplicitInput&);

  ::std::ostream&
  operator<< (::std::ostream&, const InputList&);

  ::std::ostream&
  operator<< (::std::ostream&, const Input&);

  ::std::ostream&
  operator<< (::std::ostream&, const InputW&);

  ::std::ostream&
  operator<< (::std::ostream&, const basePyNNCell&);

  ::std::ostream&
  operator<< (::std::ostream&, const basePyNNIaFCell&);

  ::std::ostream&
  operator<< (::std::ostream&, const basePyNNIaFCondCell&);

  ::std::ostream&
  operator<< (::std::ostream&, const IF_curr_alpha&);

  ::std::ostream&
  operator<< (::std::ostream&, const IF_curr_exp&);

  ::std::ostream&
  operator<< (::std::ostream&, const IF_cond_alpha&);

  ::std::ostream&
  operator<< (::std::ostream&, const IF_cond_exp&);

  ::std::ostream&
  operator<< (::std::ostream&, const EIF_cond_exp_isfa_ista&);

  ::std::ostream&
  operator<< (::std::ostream&, const EIF_cond_alpha_isfa_ista&);

  ::std::ostream&
  operator<< (::std::ostream&, const HH_cond_exp&);

  ::std::ostream&
  operator<< (::std::ostream&, const BasePynnSynapse&);

  ::std::ostream&
  operator<< (::std::ostream&, const ExpCondSynapse&);

  ::std::ostream&
  operator<< (::std::ostream&, const AlphaCondSynapse&);

  ::std::ostream&
  operator<< (::std::ostream&, const ExpCurrSynapse&);

  ::std::ostream&
  operator<< (::std::ostream&, const AlphaCurrSynapse&);

  ::std::ostream&
  operator<< (::std::ostream&, const SpikeSourcePoisson&);
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace neuroml2
{
  /**
   * @name Parsing functions for the %neuroml document root.
   *
   * The root NeuroML element.
   */
  //@{

  /**
   * @brief Parse a URI or a local file.
   *
   * @param uri A URI or a local file name.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (const ::std::string& uri,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a URI or a local file with an error handler.
   *
   * @param uri A URI or a local file name.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (const ::std::string& uri,
           ::xml_schema::error_handler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a URI or a local file with a Xerces-C++ DOM error
   * handler.
   *
   * @param uri A URI or a local file name.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (const ::std::string& uri,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream.
   *
   * @param is A standrad input stream.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (::std::istream& is,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with an error handler.
   *
   * @param is A standrad input stream.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (::std::istream& is,
           ::xml_schema::error_handler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a Xerces-C++ DOM error
   * handler.
   *
   * @param is A standrad input stream.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (::std::istream& is,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (::std::istream& is,
           const ::std::string& id,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id and an
   * error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (::std::istream& is,
           const ::std::string& id,
           ::xml_schema::error_handler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id and a
   * Xerces-C++ DOM error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (::std::istream& is,
           const ::std::string& id,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source.
   *
   * @param is A Xerces-C++ input source.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (::xercesc::InputSource& is,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source with an error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (::xercesc::InputSource& is,
           ::xml_schema::error_handler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
   * error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (::xercesc::InputSource& is,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   */
  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A pointer to the Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function is normally used together with the keep_dom and
   * own_dom parsing flags to assign ownership of the DOM document
   * to the object model.
   */
  ::std::unique_ptr< ::neuroml2::NeuroMLDocument >
  neuroml (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

  //@}
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace neuroml2
{
  void
  operator<< (::xercesc::DOMElement&, const NmlId&);

  void
  operator<< (::xercesc::DOMAttr&, const NmlId&);

  void
  operator<< (::xml_schema::list_stream&,
              const NmlId&);

  void
  operator<< (::xercesc::DOMElement&, const Nml2Quantity&);

  void
  operator<< (::xercesc::DOMAttr&, const Nml2Quantity&);

  void
  operator<< (::xml_schema::list_stream&,
              const Nml2Quantity&);

  void
  operator<< (::xercesc::DOMElement&, const Nml2Quantity_none&);

  void
  operator<< (::xercesc::DOMAttr&, const Nml2Quantity_none&);

  void
  operator<< (::xml_schema::list_stream&,
              const Nml2Quantity_none&);

  void
  operator<< (::xercesc::DOMElement&, const Nml2Quantity_voltage&);

  void
  operator<< (::xercesc::DOMAttr&, const Nml2Quantity_voltage&);

  void
  operator<< (::xml_schema::list_stream&,
              const Nml2Quantity_voltage&);

  void
  operator<< (::xercesc::DOMElement&, const Nml2Quantity_length&);

  void
  operator<< (::xercesc::DOMAttr&, const Nml2Quantity_length&);

  void
  operator<< (::xml_schema::list_stream&,
              const Nml2Quantity_length&);

  void
  operator<< (::xercesc::DOMElement&, const Nml2Quantity_resistance&);

  void
  operator<< (::xercesc::DOMAttr&, const Nml2Quantity_resistance&);

  void
  operator<< (::xml_schema::list_stream&,
              const Nml2Quantity_resistance&);

  void
  operator<< (::xercesc::DOMElement&, const Nml2Quantity_resistivity&);

  void
  operator<< (::xercesc::DOMAttr&, const Nml2Quantity_resistivity&);

  void
  operator<< (::xml_schema::list_stream&,
              const Nml2Quantity_resistivity&);

  void
  operator<< (::xercesc::DOMElement&, const Nml2Quantity_conductance&);

  void
  operator<< (::xercesc::DOMAttr&, const Nml2Quantity_conductance&);

  void
  operator<< (::xml_schema::list_stream&,
              const Nml2Quantity_conductance&);

  void
  operator<< (::xercesc::DOMElement&, const Nml2Quantity_conductanceDensity&);

  void
  operator<< (::xercesc::DOMAttr&, const Nml2Quantity_conductanceDensity&);

  void
  operator<< (::xml_schema::list_stream&,
              const Nml2Quantity_conductanceDensity&);

  void
  operator<< (::xercesc::DOMElement&, const Nml2Quantity_permeability&);

  void
  operator<< (::xercesc::DOMAttr&, const Nml2Quantity_permeability&);

  void
  operator<< (::xml_schema::list_stream&,
              const Nml2Quantity_permeability&);

  void
  operator<< (::xercesc::DOMElement&, const Nml2Quantity_time&);

  void
  operator<< (::xercesc::DOMAttr&, const Nml2Quantity_time&);

  void
  operator<< (::xml_schema::list_stream&,
              const Nml2Quantity_time&);

  void
  operator<< (::xercesc::DOMElement&, const Nml2Quantity_pertime&);

  void
  operator<< (::xercesc::DOMAttr&, const Nml2Quantity_pertime&);

  void
  operator<< (::xml_schema::list_stream&,
              const Nml2Quantity_pertime&);

  void
  operator<< (::xercesc::DOMElement&, const Nml2Quantity_capacitance&);

  void
  operator<< (::xercesc::DOMAttr&, const Nml2Quantity_capacitance&);

  void
  operator<< (::xml_schema::list_stream&,
              const Nml2Quantity_capacitance&);

  void
  operator<< (::xercesc::DOMElement&, const Nml2Quantity_specificCapacitance&);

  void
  operator<< (::xercesc::DOMAttr&, const Nml2Quantity_specificCapacitance&);

  void
  operator<< (::xml_schema::list_stream&,
              const Nml2Quantity_specificCapacitance&);

  void
  operator<< (::xercesc::DOMElement&, const Nml2Quantity_concentration&);

  void
  operator<< (::xercesc::DOMAttr&, const Nml2Quantity_concentration&);

  void
  operator<< (::xml_schema::list_stream&,
              const Nml2Quantity_concentration&);

  void
  operator<< (::xercesc::DOMElement&, const Nml2Quantity_current&);

  void
  operator<< (::xercesc::DOMAttr&, const Nml2Quantity_current&);

  void
  operator<< (::xml_schema::list_stream&,
              const Nml2Quantity_current&);

  void
  operator<< (::xercesc::DOMElement&, const Nml2Quantity_currentDensity&);

  void
  operator<< (::xercesc::DOMAttr&, const Nml2Quantity_currentDensity&);

  void
  operator<< (::xml_schema::list_stream&,
              const Nml2Quantity_currentDensity&);

  void
  operator<< (::xercesc::DOMElement&, const Nml2Quantity_temperature&);

  void
  operator<< (::xercesc::DOMAttr&, const Nml2Quantity_temperature&);

  void
  operator<< (::xml_schema::list_stream&,
              const Nml2Quantity_temperature&);

  void
  operator<< (::xercesc::DOMElement&, const Nml2Quantity_rhoFactor&);

  void
  operator<< (::xercesc::DOMAttr&, const Nml2Quantity_rhoFactor&);

  void
  operator<< (::xml_schema::list_stream&,
              const Nml2Quantity_rhoFactor&);

  void
  operator<< (::xercesc::DOMElement&, const Nml2Quantity_conductancePerVoltage&);

  void
  operator<< (::xercesc::DOMAttr&, const Nml2Quantity_conductancePerVoltage&);

  void
  operator<< (::xml_schema::list_stream&,
              const Nml2Quantity_conductancePerVoltage&);

  void
  operator<< (::xercesc::DOMElement&, const MetaId&);

  void
  operator<< (::xercesc::DOMAttr&, const MetaId&);

  void
  operator<< (::xml_schema::list_stream&,
              const MetaId&);

  void
  operator<< (::xercesc::DOMElement&, const NeuroLexId&);

  void
  operator<< (::xercesc::DOMAttr&, const NeuroLexId&);

  void
  operator<< (::xml_schema::list_stream&,
              const NeuroLexId&);

  void
  operator<< (::xercesc::DOMElement&, const NonNegativeInteger&);

  void
  operator<< (::xercesc::DOMAttr&, const NonNegativeInteger&);

  void
  operator<< (::xml_schema::list_stream&,
              const NonNegativeInteger&);

  void
  operator<< (::xercesc::DOMElement&, const PositiveInteger&);

  void
  operator<< (::xercesc::DOMAttr&, const PositiveInteger&);

  void
  operator<< (::xml_schema::list_stream&,
              const PositiveInteger&);

  void
  operator<< (::xercesc::DOMElement&, const DoubleGreaterThanZero&);

  void
  operator<< (::xercesc::DOMAttr&, const DoubleGreaterThanZero&);

  void
  operator<< (::xml_schema::list_stream&,
              const DoubleGreaterThanZero&);

  void
  operator<< (::xercesc::DOMElement&, const ZeroOrOne&);

  void
  operator<< (::xercesc::DOMAttr&, const ZeroOrOne&);

  void
  operator<< (::xml_schema::list_stream&,
              const ZeroOrOne&);

  void
  operator<< (::xercesc::DOMElement&, const Notes&);

  void
  operator<< (::xercesc::DOMAttr&, const Notes&);

  void
  operator<< (::xml_schema::list_stream&,
              const Notes&);

  void
  operator<< (::xercesc::DOMElement&, const Property&);

  void
  operator<< (::xercesc::DOMElement&, const Annotation&);

  void
  operator<< (::xercesc::DOMElement&, const ComponentType&);

  void
  operator<< (::xercesc::DOMElement&, const Constant&);

  void
  operator<< (::xercesc::DOMElement&, const Exposure&);

  void
  operator<< (::xercesc::DOMElement&, const NamedDimensionalType&);

  void
  operator<< (::xercesc::DOMElement&, const NamedDimensionalVariable&);

  void
  operator<< (::xercesc::DOMElement&, const Parameter&);

  void
  operator<< (::xercesc::DOMElement&, const LEMS_Property&);

  void
  operator<< (::xercesc::DOMElement&, const Requirement&);

  void
  operator<< (::xercesc::DOMElement&, const InstanceRequirement&);

  void
  operator<< (::xercesc::DOMElement&, const Dynamics&);

  void
  operator<< (::xercesc::DOMElement&, const DerivedVariable&);

  void
  operator<< (::xercesc::DOMElement&, const StateVariable&);

  void
  operator<< (::xercesc::DOMElement&, const ConditionalDerivedVariable&);

  void
  operator<< (::xercesc::DOMElement&, const Case&);

  void
  operator<< (::xercesc::DOMElement&, const TimeDerivative&);

  void
  operator<< (::xercesc::DOMElement&, const ZeroToOne&);

  void
  operator<< (::xercesc::DOMAttr&, const ZeroToOne&);

  void
  operator<< (::xml_schema::list_stream&,
              const ZeroToOne&);

  /**
   * @name Serialization functions for the %neuroml document root.
   *
   * The root NeuroML element.
   */
  //@{

  /**
   * @brief Serialize to a standard output stream.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  neuroml (::std::ostream& os,
           const ::neuroml2::NeuroMLDocument& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::string& e = "UTF-8",
           ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a standard output stream with an error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  neuroml (::std::ostream& os,
           const ::neuroml2::NeuroMLDocument& x, 
           ::xml_schema::error_handler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::string& e = "UTF-8",
           ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a standard output stream with a Xerces-C++ DOM
   * error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  neuroml (::std::ostream& os,
           const ::neuroml2::NeuroMLDocument& x, 
           ::xercesc::DOMErrorHandler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::string& e = "UTF-8",
           ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  neuroml (::xercesc::XMLFormatTarget& ft,
           const ::neuroml2::NeuroMLDocument& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::string& e = "UTF-8",
           ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with an error
   * handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  neuroml (::xercesc::XMLFormatTarget& ft,
           const ::neuroml2::NeuroMLDocument& x, 
           ::xml_schema::error_handler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::string& e = "UTF-8",
           ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with a
   * Xerces-C++ DOM error handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  neuroml (::xercesc::XMLFormatTarget& ft,
           const ::neuroml2::NeuroMLDocument& x, 
           ::xercesc::DOMErrorHandler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::string& e = "UTF-8",
           ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to an existing Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param x An object model to serialize.
   * @param f Serialization flags.
   *
   * Note that it is your responsibility to create the DOM document
   * with the correct root element as well as set the necessary
   * namespace mapping attributes.
   */
  void
  neuroml (::xercesc::DOMDocument& d,
           const ::neuroml2::NeuroMLDocument& x,
           ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a new Xerces-C++ DOM document.
   *
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param f Serialization flags.
   * @return A pointer to the new Xerces-C++ DOM document.
   */
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  neuroml (const ::neuroml2::NeuroMLDocument& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           ::xml_schema::flags f = 0);

  //@}

  void
  operator<< (::xercesc::DOMElement&, const BaseWithoutId&);

  void
  operator<< (::xercesc::DOMElement&, const Base&);

  void
  operator<< (::xercesc::DOMElement&, const Standalone&);

  void
  operator<< (::xercesc::DOMElement&, const NeuroMLDocument_base&);

  void
  operator<< (::xercesc::DOMElement&, const IncludeType&);

  void
  operator<< (::xercesc::DOMElement&, const IonChannelScalable&);

  void
  operator<< (::xercesc::DOMElement&, const IonChannelKS&);

  void
  operator<< (::xercesc::DOMElement&, const IonChannel&);

  void
  operator<< (::xercesc::DOMElement&, const IonChannelHH&);

  void
  operator<< (::xercesc::DOMElement&, const IonChannelVShift&);

  void
  operator<< (::xercesc::DOMElement&, const channelTypes&);

  void
  operator<< (::xercesc::DOMAttr&, const channelTypes&);

  void
  operator<< (::xml_schema::list_stream&,
              const channelTypes&);

  void
  operator<< (::xercesc::DOMElement&, const Q10ConductanceScaling&);

  void
  operator<< (::xercesc::DOMElement&, const gateTypes&);

  void
  operator<< (::xercesc::DOMAttr&, const gateTypes&);

  void
  operator<< (::xml_schema::list_stream&,
              const gateTypes&);

  void
  operator<< (::xercesc::DOMElement&, const ClosedState&);

  void
  operator<< (::xercesc::DOMElement&, const OpenState&);

  void
  operator<< (::xercesc::DOMElement&, const ForwardTransition&);

  void
  operator<< (::xercesc::DOMElement&, const ReverseTransition&);

  void
  operator<< (::xercesc::DOMElement&, const TauInfTransition&);

  void
  operator<< (::xercesc::DOMElement&, const GateKS&);

  void
  operator<< (::xercesc::DOMElement&, const GateHHUndetermined&);

  void
  operator<< (::xercesc::DOMElement&, const GateHHRates&);

  void
  operator<< (::xercesc::DOMElement&, const GateHHTauInf&);

  void
  operator<< (::xercesc::DOMElement&, const GateHHRatesTauInf&);

  void
  operator<< (::xercesc::DOMElement&, const GateHHRatesTau&);

  void
  operator<< (::xercesc::DOMElement&, const GateHHRatesInf&);

  void
  operator<< (::xercesc::DOMElement&, const GateHHInstantaneous&);

  void
  operator<< (::xercesc::DOMElement&, const GateFractional&);

  void
  operator<< (::xercesc::DOMElement&, const GateFractionalSubgate&);

  void
  operator<< (::xercesc::DOMElement&, const Q10Settings&);

  void
  operator<< (::xercesc::DOMElement&, const HHRate&);

  void
  operator<< (::xercesc::DOMElement&, const HHVariable&);

  void
  operator<< (::xercesc::DOMElement&, const HHTime&);

  void
  operator<< (::xercesc::DOMElement&, const DecayingPoolConcentrationModel&);

  void
  operator<< (::xercesc::DOMElement&, const FixedFactorConcentrationModel&);

  void
  operator<< (::xercesc::DOMElement&, const BaseSynapse&);

  void
  operator<< (::xercesc::DOMElement&, const BaseVoltageDepSynapse&);

  void
  operator<< (::xercesc::DOMElement&, const BaseCurrentBasedSynapse&);

  void
  operator<< (::xercesc::DOMElement&, const BaseConductanceBasedSynapse&);

  void
  operator<< (::xercesc::DOMElement&, const BaseConductanceBasedSynapseTwo&);

  void
  operator<< (::xercesc::DOMElement&, const GapJunction&);

  void
  operator<< (::xercesc::DOMElement&, const SilentSynapse&);

  void
  operator<< (::xercesc::DOMElement&, const LinearGradedSynapse&);

  void
  operator<< (::xercesc::DOMElement&, const GradedSynapse&);

  void
  operator<< (::xercesc::DOMElement&, const AlphaCurrentSynapse&);

  void
  operator<< (::xercesc::DOMElement&, const AlphaSynapse&);

  void
  operator<< (::xercesc::DOMElement&, const ExpOneSynapse&);

  void
  operator<< (::xercesc::DOMElement&, const ExpTwoSynapse&);

  void
  operator<< (::xercesc::DOMElement&, const ExpThreeSynapse&);

  void
  operator<< (::xercesc::DOMElement&, const DoubleSynapse&);

  void
  operator<< (::xercesc::DOMElement&, const BlockingPlasticSynapse&);

  void
  operator<< (::xercesc::DOMElement&, const BlockTypes&);

  void
  operator<< (::xercesc::DOMAttr&, const BlockTypes&);

  void
  operator<< (::xml_schema::list_stream&,
              const BlockTypes&);

  void
  operator<< (::xercesc::DOMElement&, const BlockMechanism&);

  void
  operator<< (::xercesc::DOMElement&, const PlasticityTypes&);

  void
  operator<< (::xercesc::DOMAttr&, const PlasticityTypes&);

  void
  operator<< (::xml_schema::list_stream&,
              const PlasticityTypes&);

  void
  operator<< (::xercesc::DOMElement&, const PlasticityMechanism&);

  void
  operator<< (::xercesc::DOMElement&, const BaseCell&);

  void
  operator<< (::xercesc::DOMElement&, const IafTauCell&);

  void
  operator<< (::xercesc::DOMElement&, const IafTauRefCell&);

  void
  operator<< (::xercesc::DOMElement&, const IafCell&);

  void
  operator<< (::xercesc::DOMElement&, const IafRefCell&);

  void
  operator<< (::xercesc::DOMElement&, const IzhikevichCell&);

  void
  operator<< (::xercesc::DOMElement&, const BaseCellMembPotCap&);

  void
  operator<< (::xercesc::DOMElement&, const Izhikevich2007Cell&);

  void
  operator<< (::xercesc::DOMElement&, const AdExIaFCell&);

  void
  operator<< (::xercesc::DOMElement&, const FitzHughNagumoCell&);

  void
  operator<< (::xercesc::DOMElement&, const FitzHughNagumo1969Cell&);

  void
  operator<< (::xercesc::DOMElement&, const PinskyRinzelCA3Cell&);

  void
  operator<< (::xercesc::DOMElement&, const Cell&);

  void
  operator<< (::xercesc::DOMElement&, const Cell2CaPools&);

  void
  operator<< (::xercesc::DOMElement&, const Morphology_base&);

  void
  operator<< (::xercesc::DOMElement&, const BaseNonNegativeIntegerId&);

  void
  operator<< (::xercesc::DOMElement&, const Segment_base&);

  void
  operator<< (::xercesc::DOMElement&, const SegmentParent&);

  void
  operator<< (::xercesc::DOMElement&, const Point3DWithDiam&);

  void
  operator<< (::xercesc::DOMElement&, const SegmentGroup&);

  void
  operator<< (::xercesc::DOMElement&, const InhomogeneousParameter&);

  void
  operator<< (::xercesc::DOMElement&, const Metric&);

  void
  operator<< (::xercesc::DOMAttr&, const Metric&);

  void
  operator<< (::xml_schema::list_stream&,
              const Metric&);

  void
  operator<< (::xercesc::DOMElement&, const ProximalDetails&);

  void
  operator<< (::xercesc::DOMElement&, const DistalDetails&);

  void
  operator<< (::xercesc::DOMElement&, const Member&);

  void
  operator<< (::xercesc::DOMElement&, const Include&);

  void
  operator<< (::xercesc::DOMElement&, const Path&);

  void
  operator<< (::xercesc::DOMElement&, const SubTree&);

  void
  operator<< (::xercesc::DOMElement&, const SegmentEndPoint&);

  void
  operator<< (::xercesc::DOMElement&, const BiophysicalProperties&);

  void
  operator<< (::xercesc::DOMElement&, const BiophysicalProperties2CaPools&);

  void
  operator<< (::xercesc::DOMElement&, const MembraneProperties&);

  void
  operator<< (::xercesc::DOMElement&, const MembraneProperties2CaPools&);

  void
  operator<< (::xercesc::DOMElement&, const SpikeThresh&);

  void
  operator<< (::xercesc::DOMElement&, const SpecificCapacitance&);

  void
  operator<< (::xercesc::DOMElement&, const InitMembPotential&);

  void
  operator<< (::xercesc::DOMElement&, const Resistivity&);

  void
  operator<< (::xercesc::DOMElement&, const ChannelPopulation&);

  void
  operator<< (::xercesc::DOMElement&, const ChannelDensityNonUniform&);

  void
  operator<< (::xercesc::DOMElement&, const ChannelDensityNonUniformNernst&);

  void
  operator<< (::xercesc::DOMElement&, const ChannelDensityNonUniformGHK&);

  void
  operator<< (::xercesc::DOMElement&, const ChannelDensity&);

  void
  operator<< (::xercesc::DOMElement&, const ChannelDensityVShift&);

  void
  operator<< (::xercesc::DOMElement&, const ChannelDensityNernst&);

  void
  operator<< (::xercesc::DOMElement&, const ChannelDensityNernstCa2&);

  void
  operator<< (::xercesc::DOMElement&, const ChannelDensityGHK&);

  void
  operator<< (::xercesc::DOMElement&, const ChannelDensityGHK2&);

  void
  operator<< (::xercesc::DOMElement&, const VariableParameter&);

  void
  operator<< (::xercesc::DOMElement&, const InhomogeneousValue&);

  void
  operator<< (::xercesc::DOMElement&, const Species&);

  void
  operator<< (::xercesc::DOMElement&, const ConcentrationModel_D&);

  void
  operator<< (::xercesc::DOMElement&, const IntracellularProperties&);

  void
  operator<< (::xercesc::DOMElement&, const IntracellularProperties2CaPools&);

  void
  operator<< (::xercesc::DOMElement&, const ExtracellularProperties&);

  void
  operator<< (::xercesc::DOMElement&, const ExtracellularPropertiesLocal&);

  void
  operator<< (::xercesc::DOMElement&, const ReactionScheme&);

  void
  operator<< (::xercesc::DOMElement&, const PulseGenerator&);

  void
  operator<< (::xercesc::DOMElement&, const PulseGeneratorDL&);

  void
  operator<< (::xercesc::DOMElement&, const SineGenerator&);

  void
  operator<< (::xercesc::DOMElement&, const SineGeneratorDL&);

  void
  operator<< (::xercesc::DOMElement&, const RampGenerator&);

  void
  operator<< (::xercesc::DOMElement&, const RampGeneratorDL&);

  void
  operator<< (::xercesc::DOMElement&, const CompoundInput&);

  void
  operator<< (::xercesc::DOMElement&, const CompoundInputDL&);

  void
  operator<< (::xercesc::DOMElement&, const VoltageClamp&);

  void
  operator<< (::xercesc::DOMElement&, const VoltageClampTriple&);

  void
  operator<< (::xercesc::DOMElement&, const Spike&);

  void
  operator<< (::xercesc::DOMElement&, const SpikeArray&);

  void
  operator<< (::xercesc::DOMElement&, const TimedSynapticInput&);

  void
  operator<< (::xercesc::DOMElement&, const SpikeGenerator&);

  void
  operator<< (::xercesc::DOMElement&, const SpikeGeneratorRandom&);

  void
  operator<< (::xercesc::DOMElement&, const SpikeGeneratorPoisson&);

  void
  operator<< (::xercesc::DOMElement&, const SpikeGeneratorRefPoisson&);

  void
  operator<< (::xercesc::DOMElement&, const PoissonFiringSynapse&);

  void
  operator<< (::xercesc::DOMElement&, const TransientPoissonFiringSynapse&);

  void
  operator<< (::xercesc::DOMElement&, const Network&);

  void
  operator<< (::xercesc::DOMElement&, const networkTypes&);

  void
  operator<< (::xercesc::DOMAttr&, const networkTypes&);

  void
  operator<< (::xml_schema::list_stream&,
              const networkTypes&);

  void
  operator<< (::xercesc::DOMElement&, const Space&);

  void
  operator<< (::xercesc::DOMElement&, const SpaceStructure&);

  void
  operator<< (::xercesc::DOMElement&, const allowedSpaces&);

  void
  operator<< (::xercesc::DOMAttr&, const allowedSpaces&);

  void
  operator<< (::xml_schema::list_stream&,
              const allowedSpaces&);

  void
  operator<< (::xercesc::DOMElement&, const Region&);

  void
  operator<< (::xercesc::DOMElement&, const Population&);

  void
  operator<< (::xercesc::DOMElement&, const populationTypes&);

  void
  operator<< (::xercesc::DOMAttr&, const populationTypes&);

  void
  operator<< (::xml_schema::list_stream&,
              const populationTypes&);

  void
  operator<< (::xercesc::DOMElement&, const Layout&);

  void
  operator<< (::xercesc::DOMElement&, const UnstructuredLayout&);

  void
  operator<< (::xercesc::DOMElement&, const RandomLayout&);

  void
  operator<< (::xercesc::DOMElement&, const GridLayout&);

  void
  operator<< (::xercesc::DOMElement&, const Instance&);

  void
  operator<< (::xercesc::DOMElement&, const Location&);

  void
  operator<< (::xercesc::DOMElement&, const CellSet&);

  void
  operator<< (::xercesc::DOMElement&, const SynapticConnection&);

  void
  operator<< (::xercesc::DOMElement&, const BaseProjection&);

  void
  operator<< (::xercesc::DOMElement&, const Projection&);

  void
  operator<< (::xercesc::DOMElement&, const BaseConnection&);

  void
  operator<< (::xercesc::DOMElement&, const BaseConnectionOldFormat&);

  void
  operator<< (::xercesc::DOMElement&, const BaseConnectionNewFormat&);

  void
  operator<< (::xercesc::DOMElement&, const Connection_base&);

  void
  operator<< (::xercesc::DOMElement&, const ConnectionWD&);

  void
  operator<< (::xercesc::DOMElement&, const ElectricalProjection&);

  void
  operator<< (::xercesc::DOMElement&, const ElectricalConnection&);

  void
  operator<< (::xercesc::DOMElement&, const ElectricalConnectionInstance&);

  void
  operator<< (::xercesc::DOMElement&, const ElectricalConnectionInstanceW&);

  void
  operator<< (::xercesc::DOMElement&, const ContinuousProjection&);

  void
  operator<< (::xercesc::DOMElement&, const ContinuousConnection&);

  void
  operator<< (::xercesc::DOMElement&, const ContinuousConnectionInstance&);

  void
  operator<< (::xercesc::DOMElement&, const ContinuousConnectionInstanceW&);

  void
  operator<< (::xercesc::DOMElement&, const ExplicitInput&);

  void
  operator<< (::xercesc::DOMElement&, const InputList&);

  void
  operator<< (::xercesc::DOMElement&, const Input&);

  void
  operator<< (::xercesc::DOMElement&, const InputW&);

  void
  operator<< (::xercesc::DOMElement&, const basePyNNCell&);

  void
  operator<< (::xercesc::DOMElement&, const basePyNNIaFCell&);

  void
  operator<< (::xercesc::DOMElement&, const basePyNNIaFCondCell&);

  void
  operator<< (::xercesc::DOMElement&, const IF_curr_alpha&);

  void
  operator<< (::xercesc::DOMElement&, const IF_curr_exp&);

  void
  operator<< (::xercesc::DOMElement&, const IF_cond_alpha&);

  void
  operator<< (::xercesc::DOMElement&, const IF_cond_exp&);

  void
  operator<< (::xercesc::DOMElement&, const EIF_cond_exp_isfa_ista&);

  void
  operator<< (::xercesc::DOMElement&, const EIF_cond_alpha_isfa_ista&);

  void
  operator<< (::xercesc::DOMElement&, const HH_cond_exp&);

  void
  operator<< (::xercesc::DOMElement&, const BasePynnSynapse&);

  void
  operator<< (::xercesc::DOMElement&, const ExpCondSynapse&);

  void
  operator<< (::xercesc::DOMElement&, const AlphaCondSynapse&);

  void
  operator<< (::xercesc::DOMElement&, const ExpCurrSynapse&);

  void
  operator<< (::xercesc::DOMElement&, const AlphaCurrSynapse&);

  void
  operator<< (::xercesc::DOMElement&, const SpikeSourcePoisson&);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
// LCOV_EXCL_STOP
#include "NeuroML_custom.hxx"
//
// End epilogue.

#endif // NEUROML_API_SCHEMA_NEURO_ML_V2_2_HXX
